/**
 * game.c - Main game state machine and game loop
 *
 * Based on arcade game/game.c
 * N64 main loop at func_800FD464, state handlers at 0x800FB* area
 */

#include "types.h"
#include "game/structs.h"
#include "PR/os_message.h"

/* Auto-generated extern declarations for missing variables */
extern s32 D_80020000;
extern s32 D_80020010;
extern s32 D_80086A70;
extern s32 D_80086A88;
extern void *D_8008AD48[];
extern void *D_80117530[];
extern s32 D_80120308;
extern s32 D_8012030C;
extern void *D_80124FD0[];
extern s32 D_80128E20;
extern s32 D_80130000;
extern s32 D_80140A10;
extern void *D_80144031[];
extern void *D_80146170[];
extern s32 D_801461D0;
extern s32 D_80148000;
extern void **D_801491F0;
extern void **D_801492C8;
extern s32 D_8014C094;
extern s32 D_8014C238;
extern s32 D_80151AD4;
extern void *D_80152038[];
extern s32 D_801520A0;
extern s32 D_801520A4;
extern s32 D_801525F0;
extern s32 D_80152738;
extern s32 D_80152800;
extern f32 D_80153F48[];
extern f32 D_80153F68[];
extern s32 D_80154190;
extern s32 D_80154660;
extern s32 D_80154FD8;
extern void *D_801551F0[];
extern void *D_80155220[];
extern void *D_80155290[];
extern void *D_80156D44[];
extern s8 D_80156D39[];
extern void *D_80158100[];
extern s32 D_80158104;
extern s32 D_80158108;
extern s32 D_8015810C;
extern void *D_80158120[];
extern s32 D_801581E4;
extern void *D_801581EC[];
extern void *D_80158208[];
extern f32 D_80158230[5];
extern f32 D_80158280[3];  /* Listener right vector */
extern s32 D_8015828C;
extern s32 D_80158290;
extern s32 D_801582A0;
extern s32 D_801582B0;
extern void *D_801582C0[];
extern s32 D_801582E0;
extern s32 D_801582E4;
extern s32 D_801582E8;
extern s32 D_801582EC;
extern s32 D_801582F0;
extern s32 D_801582F4;
extern s32 D_801582F8;
extern s32 D_80158FC0;
extern s32 D_80159000;
extern void *D_80159010[];
extern s32 D_80159014;
extern s32 D_80159018;
extern s32 D_8015901C;
extern s32 D_80159020;
extern void *D_80159024[];
extern s32 D_80159028;
extern s32 D_8015902C;
extern s32 D_80159030;
extern s32 D_80159034;
extern s32 D_80159038;
extern s32 D_8015903C;
extern s32 D_80159040;
extern s32 D_80159044;
extern s32 D_80159048;
extern s32 D_8015904C;
extern s32 D_80159050;
extern s32 D_80159054;
extern f32 D_80159058[16][6];  /* Script keyframes */
extern s32 D_8015905C;
extern s32 D_80159060;
extern s32 D_80159064;
extern s32 D_80159068;
extern s32 D_80159200;  /* Multi-use: button state / save data / base address */
extern s32 D_80159204;
extern s32 D_80159208;
extern s32 D_80159210;
extern s32 D_80159214;
extern s32 D_80159218;
extern s32 D_8015921C;
extern s32 D_80159220;
extern void *D_80159224[];
extern s32 D_80159230;
extern s32 D_80159234;
extern s32 D_80159238;
extern s32 D_8015923C;
extern s32 D_80159240;
extern s32 D_80159244;
extern s32 D_80159248;
extern void *D_8015924C[];
extern s32 D_80159260;
extern s32 D_80159264;
extern s32 D_80159268;
extern s32 D_80159270;
extern s32 D_80159280;
extern s32 D_80159284;
extern s32 D_80159288;
extern s32 D_8015928C;
extern s32 D_80159290;
extern s32 D_80159294;
extern void *D_801592A0[];
extern s32 D_801592C0;
extern s32 D_801592D0;
extern s32 D_801592D4;
extern s32 D_801592D8;
extern s32 D_801592DC;
extern s32 D_801592E0;
extern s32 D_801592E4;
extern s32 D_801592E8;
extern s32 D_801592EC;
extern s32 D_801592F0;
extern s32 D_801592F4;
extern s32 D_801592F8;
extern s32 D_801592FC;
extern s32 D_80159300;
extern s32 D_80159304;
extern s32 D_80159308;
extern s32 D_8015930C;
extern s32 D_80159310;
extern s32 D_80159314;
extern s32 D_80159318;
extern s32 D_8015931C;
extern s32 D_80159320;
extern s32 D_80159324;
extern s32 D_80159328;
extern s32 D_8015932C;
extern void *D_80159330[];
extern s32 D_80159334;
extern s32 D_80159338;
extern s32 D_8015933C;
extern s32 D_80159340;
extern void *D_80159344[];
extern s32 D_80159350;
extern s32 D_80159354;
extern s32 D_80159358;
extern s32 D_80159360;
extern s32 D_80159364;
extern s32 D_80159368;
extern void *D_80159370[];
extern void *D_80159400[];
extern s32 D_80159414;
extern void *D_80159428[];
extern s32 D_80159450;
extern s32 D_80159480;
extern s32 D_80159500;
extern s32 D_80159600;
extern s32 D_80159604;
extern s32 D_80159608;
extern void *D_8015960C[];
extern s32 D_80159700;
extern s32 D_80159788;
extern s32 D_8015978C;
extern s32 D_80159794;
extern void *D_801597D0[];
extern s32 D_801597FC;
extern void **D_80159800;
extern s32 D_80159818;
extern s32 D_80159900;
extern s32 D_80159904;
extern s32 D_80159908;
extern s32 D_8015990C;
extern s32 D_80159910;
extern s32 D_80159914;
extern s32 D_80159918;
extern void *D_8015991C[];
extern s32 D_80159940;
extern s32 D_80159944;
extern s32 D_80159948;
extern s32 D_8015994C;
extern s32 D_80159950;
extern s32 D_80159954;
extern s32 D_80159A00;
extern s32 D_80159A04;
extern s32 D_80159A08;
extern s32 D_80159A0C;
extern u32 D_80159A10[12];  /* Race times */
extern u32 D_80159A14[32];  /* Data array */
extern s32 D_80159A18;
extern s32 D_80159A1C;
extern s32 D_80159A20;
extern s32 D_80159A24;
extern s32 D_80159A28;
extern s32 D_80159A30;
extern s32 D_80159A40;
extern s32 D_80159A50;
extern s32 D_80159A54;
extern s32 D_80159A58;
extern s32 D_80159A5C;
extern s32 D_80159A60;
extern void *D_80159A70[];
extern s32 D_80159A80;
extern s32 D_80159A84;
extern u64 D_80159B00[8][6];  /* Timer data */
extern s32 D_80159B04;
extern s32 D_80159B08;
extern s32 D_80159B0C;
extern s32 D_80159B10;
extern s32 D_80159B14;
extern s32 D_80159B18;
extern s32 D_80159B1C;
extern s32 D_80159B20;
extern s32 D_80159B24;
extern s32 D_80159B28;
extern s32 D_80159B2C;
extern s32 D_80159B30;
extern s32 D_80159B34;
extern s32 D_80159B38;
extern s32 D_80159B3C;
extern s32 D_80159B40;
extern s32 D_80159B44;
extern s32 D_80159B48;
extern s32 D_80159B4C;
extern s32 D_80159B70;
extern s32 D_80159B74;
extern s32 D_80159B80;
extern u32 D_80159C00[32];  /* Data array */
extern s32 D_80159C04;
extern s32 D_80159C08;
extern s32 D_80159C0C;
extern s32 D_80159C10;
extern s32 D_80159C14;
extern s32 D_80159C18;
extern void *D_80159C20[];
extern u32 D_80159D00[32];  /* Data array */
extern s32 D_80159D04;
extern u32 D_80159D10[12];  /* Lap times */
extern void *D_80159D40[];
extern s32 D_80159D80;
extern s32 D_80159D84;
extern s32 D_80159D88;
extern s32 D_80159D8C;
extern s32 D_80159D90;
extern s32 D_80159DA0;
extern s32 D_80159DA4;
extern s32 D_80159DC0;
extern s32 D_80159E00;
extern s32 D_80159E04;
extern s32 D_80159E08;
extern s32 D_80159E0C;
extern s32 D_80159E10;
extern s32 D_80159E14;
extern s32 D_80159E20;
extern s32 D_80159E24;
extern s32 D_80159E28;
extern s32 D_80159E2C;
extern s32 D_80159E30;
extern s32 D_80159E40;
extern s32 D_80159E44;
extern s32 D_80159E48;
extern void *D_80159F00[];
extern s32 D_80159F40;
extern s32 D_80159F44;
extern s32 D_80159F48;
extern s32 D_80159F50;
extern s32 D_80159F54;
extern s32 D_80159F58;
extern s32 D_8015A000;
extern s32 D_8015A004;
extern s32 D_8015A008;
extern s32 D_8015A00C;
extern s32 D_8015A010;
extern void *D_8015A020[];
extern s32 D_8015A030[4];
extern s32 D_8015A040;
extern s32 D_8015A044;
extern void *D_8015A050[];
extern void *D_8015A060[];
extern s32 D_8015A080;
extern s32 D_8015A084;
extern s32 D_8015A088;
extern s32 D_8015A090;
extern s32 D_8015A094;
extern s32 D_8015A098;
extern s32 D_8015A09C;
extern void *D_8015A100[];
extern s32 D_8015A108;
extern void *D_8015A10C[];
extern s32 D_8015A110;
extern s32 D_8015A114;
extern s32 D_8015A118;
extern s32 D_8015A11C;
extern void *D_8015A200[];
extern void *D_8015A210[];
extern void *D_8015A220[];
extern void *D_8015A230[];
extern void *D_8015A240[];
extern void *D_8015A250[];
extern void *D_8015A260[];
extern s32 D_8015A280;
extern s32 D_8015A290;
extern s32 D_8015A294;
extern s32 D_8015A298;
extern void *D_8015A2A0[];
extern void *D_8015A2B0[];
extern void *D_8015A2C0[];
extern void *D_8015A2D0[];
extern void *D_8015A2E0[];
extern void *D_8015A2F0[];
extern s32 D_8015A300;
extern s32 D_8015A304;
extern s32 D_8015A310;
extern s32 D_8015A314;
extern s32 D_8015A318;
extern void *D_8015A320[];
extern s32 D_8015A330;
extern s32 D_8015A334;
extern s32 D_8015A338;
extern s32 D_8015A33C;
extern s32 D_8015A400;
extern s32 D_8015A410;
extern s32 D_8015A420;
extern s32 D_8015A430;
extern s32 D_8015A434;
extern s32 D_8015A440;
extern s32 D_8015A448;
extern s32 D_8015A450;
extern s32 D_8015A454;
extern s32 D_8015A478;
extern s32 D_8015A500;
extern s32 D_8015A504;
extern s32 D_8015A508;
extern s32 D_8015A510;
extern s32 D_8015A514;
extern s32 D_8015A518;
extern s32 D_8015A520;
extern void *D_8015A524[];
extern s32 D_8015A530;
extern s32 D_8015A534;
extern s32 D_8015A538;
extern s32 D_8015A540;
extern s32 D_8015B254;
extern f32 D_80160080[16];  /* Audio channel volumes */
extern f32 D_801600C0[16];  /* Audio channel pans */
extern f32 D_80160100[16];  /* Audio channel pitches */
extern f32 D_80160180[3];  /* Listener position */
extern u32 D_80160000[16];  /* Channel states */
extern u32 D_80160040[16];  /* Channel params */
extern s32 D_80160300;   /* Current reverb type */
extern f32 D_80160304;   /* Reverb wet/dry mix */
extern f32 D_80160308;   /* Reverb decay time */
extern f32 D_8016030C;   /* Reverb pre-delay */
extern f32 D_80160310;   /* Reverb diffusion */
extern u32 D_80160700;       /* Stream ROM offset */
extern u32 D_80160704;       /* Stream total size */
extern u32 D_80160708;       /* Stream bytes read */
extern void *D_8016070C[2];  /* Stream double buffers */
extern u32 D_80160720;       /* Stream table offset */
extern s32 D_80160714;       /* Active buffer index */
extern s32 D_80160718;       /* Stream state */
extern u32 D_8016071C;       /* Buffer size */
extern s32 D_80160800;       /* Sequence state */
extern s32 D_80160804;       /* Current sequence ID */
extern u32 D_80160808;       /* Sequence position (ticks) */
extern s32 D_8016080C;       /* Sequence tempo multiplier */
extern s16 *D_801608E0;  /* Output buffer L */
extern s16 *D_801608E4;  /* Output buffer R */
extern s32 D_801608E8;   /* Output buffer size */
extern u32 D_80160900;  /* Active effects bitfield */
extern s32 D_80160928;
extern f32 D_80170000;  /* Camera shake intensity */
extern f32 D_80170004;  /* Shake timer */
extern f32 D_80170008;  /* Shake decay rate */
extern void *D_80170020;  /* Active camera pointer */
extern f32 D_80158000[3];  /* Camera position */
extern s32 D_80157814;
extern Gfx **D_80149438;   /* Display list pointer */
extern Gfx *D_80149430;    /* Display list base */
extern OSTask D_80149440;  /* Graphics task */
extern u32 D_80143500;  /* Random seed */
extern f32 D_80143404;     /* Player distance */
extern s32 D_8014B000;
extern s32 D_8014B008;
extern s32 D_8014B00C[4];  /* Player scores */
extern s32 D_8014B01C[4];  /* Player lives */
extern s32 D_8014C000;
extern s32 D_8014C00C[4];  /* Player stunt scores */
extern s32 D_80160400;
extern s32 D_80160404;
extern void *D_80160408[4];
extern s32 D_8016040C;
extern s32 D_80160410;
extern s32 D_80160414;
extern s32 D_80160420;
extern s32 D_80160424;
extern s32 D_80160430;
extern s32 D_80160434;
extern s32 D_80160440;
extern s32 D_80160444;
extern s32 D_80160450;
extern s32 D_80160460;
extern u32 D_80160508[64];  /* Sample sizes in bytes */
extern s32 D_80162100;
extern s32 D_8016B254;
extern s32 D_C;

/* External function declarations */
extern void *audio_alloc(s32 size);           /* func_800BA644 - Audio memory allocator */
extern void attract_or_transition(void);      /* func_800EDDC0 - Rendering/game logic */
extern void process_inputs(void);             /* func_800C997C - Screen/state update */
extern s32  sound_start(s32 action, s32 type, void *data, s32 flag); /* func_800B37E8 - Audio/sound control */
extern void attract_handler(void);            /* func_800DB81C - Attract mode */
extern void hiscore_handler(void);            /* func_800FBF88 - High score entry */
extern void countdown_handler(void);          /* func_800FBC30 - Countdown timer */
extern void render_scene(s32 track, f32 angle, s32 x, s32 y); /* func_800A04C4 - Viewport/camera setup */

/* Forward declarations for functions defined in this file */
s32 func_800F43D4(f32 distance);  /* LOD distance calculator */

/* Additional extern declarations */
extern s32 D_8013E6E0;

void game_mode_handler(void);  /* func_800C9AE0 */
void draw_text(s32 x, s32 y, char *text, u32 color);  /* func_800C734C */
void draw_ui_element(s32 elementId, s32 x, s32 y, s32 w, s32 h, s32 alpha);  /* func_800C7110 */

/* State handler declarations */
extern void state_init_handler(void);   /* func_800FBF90 - GSTATE_INIT handler */
extern void state_setup_handler(void);  /* func_800FBFE4 - GSTATE_SETUP handler */
extern void state_menu_handler(void);   /* func_800FC0EC - GSTATE_MENU handler */

/* External data */
extern u8 gstate;                      /* 0x801146EC - game state byte */
extern u8 gstate_prev;                 /* Previous game state */
extern CarData car_array[];            /* 0x80152818 - array of car data */
extern GameStruct game_struct;         /* 0x801461D0 - main game structure */
extern u32 frame_counter;              /* 0x80142AFC - frame counter */

/* Additional external data for game_loop */
extern s8  D_801146EC;   /* Init flag */
extern s32 D_801146E8;   /* Sound handle */
extern s32 D_801170FC;   /* Render enable flag */
extern u32 D_80142AFC;   /* Frame counter */
extern s16 D_8003EB70;   /* Wait flag */
extern u32 D_8003E8E8;   /* Timer/tick */
extern u32 D_8003AFB8;   /* Timing constant (float as u32) */
extern u32 D_80159438;   /* Some state value */
extern u32 D_801597C8;   /* Another state value */
extern u32 D_801597F4;   /* State copy */
extern s8  D_801146C4[]; /* Sound params array */
extern u32 D_801174B4;   /* gstate - current state bitmask (for game_loop) */
extern u32 D_801174B8;   /* gstate_pending - next state (for game_loop) */
extern void sound_stop(s32 channel, f32 volume);    /* func_800B358C */
extern void state_dispatch(void);                   /* func_800FD238 */
extern void update_active_objects(void);            /* func_800F733C */
extern void *physics_update(void);                  /* func_800B0868 */
extern void effects_update_emitters(void);          /* func_800B811C */

/* Forward declarations */
void playgame_handler(void);  /* func_800CA3B4 */

/**
/*
 * game_loop - Main per-frame game loop
 * (func_800FD464)
 * Address: 0x800FD464
 * Size: 704 bytes
 *
 * This is the N64 equivalent of arcade game.c:game()
 * Called every frame from the main thread.
 *
 * The function:
 * 1. Handles first-time initialization
 * 2. Checks for state changes (gstate vs gstate_pending)
 * 3. Manages sound start/stop based on state
 * 4. Calls state-specific handlers
 * 5. Increments frame counter
 */
s32 game_loop(void) {
    s32 result = 0;
    u32 gstate_cur;
    u32 gstate_next;
    u32 timing_diff;
    f32 elapsed_time;
    s32 sound_handle;

    /* First-time initialization */
    if (D_801146EC == 0) {
        D_80142AFC = 0;  /* Clear frame counter */
        D_801146EC = 1;  /* Set init flag */
    }

    /* Load current and pending state */
    gstate_cur = D_801174B4;
    gstate_next = D_801174B8;

    /* If no state change pending, just call mode handler and return */
    if (gstate_cur == gstate_next) {
        game_mode_handler();
        return result;
    }

    /* State change in progress - wait for something to clear */
    while (D_8003EB70 != 0) {
        /* Spin wait - checking flag */
    }

    /* Clear render state and call transition handler */
    D_80159438 = 0;
    attract_or_transition();

    /* Save state value */
    D_801597F4 = D_801597C8;

    /* Process inputs/PDUs */
    process_inputs();

    /* Timing check - calculate elapsed time */
    timing_diff = D_8003E8E8 - D_8003AFB8;
    elapsed_time = (f32)(s32)timing_diff;

    /* Check if elapsed time > 300.0 (5 seconds at 60fps) */
    if (elapsed_time < 300.0f) {
        /* Check if we need to manage sound */
        if (!(D_801174B4 & 0x4000000F)) {
            sound_handle = D_801146E8;
            if (sound_handle == 0) {
                /* Start sound - call with params */
                D_801146E8 = sound_start(0, 0, &D_801146C4, 1);
            }
        } else {
            /* State requires stopping sound */
            sound_handle = D_801146E8;
            if (sound_handle != 0) {
                sound_stop(sound_handle, 0.0f);
                D_801146E8 = 0;
            }
        }
    }

    /* Call main state change handler */
    playgame_handler();  /* PlayGame_HandleStateChange */

    /* Check state flags for additional processing */
    gstate_cur = D_801174B4;

    /* Check if any of the main state bits are set */
    if (gstate_cur & 0x7C03FFFE) {
        /* Call state dispatch for active states */
        func_800FD238();  /* state_dispatch */
        gstate_cur = D_801174B4;
    }

    /* Check attract/race bits (0x00200000 or 0x00400000) */
    if ((gstate_cur << 10) < 0 || (gstate_cur << 9) < 0) {
        /* Race state machine update */
        attract_handler();  /* RaceStateMachine_Update */

        /* Check if rendering is enabled */
        if (D_801170FC != 0) {
            func_800F733C();  /* UpdateActiveObjects */
            func_800B0868();  /* PhysicsObjectList_Update */
            func_800B811C();  /* Effects_UpdateEmitters */
            func_800A04C4(0, 0.0f, 0, 0); /* render_scene */
            return 1;
        }
    }

    /* Reload state */
    gstate_cur = D_801174B4;

    /* Check high score bits (0x03FC0000) */
    if (gstate_cur & 0x03FC0000) {
        func_800FBF88();  /* state_transition / high score */
        gstate_cur = D_801174B4;
    }

    /* Check if state matches pending (steady state) */
    gstate_next = D_801174B8;
    if (gstate_cur == gstate_next) {
        /* In steady state - call countdown and update functions */
        func_800FBC30();  /* Countdown handler */
        func_800F733C();  /* UpdateActiveObjects */
        func_800B0868();  /* PhysicsObjectList_Update */
        func_800B811C();  /* Effects_UpdateEmitters */
        func_800A04C4(0, 0.0f, 0, 0); /* render_scene */
        result = 1;
    }

    /* Increment frame counter */
    D_80142AFC++;

    return result;
}

/*

/* External data/functions for func_800C9AE0 */
extern s8  D_80035472;   /* Mode flag 1 */
extern s8  D_80035471;   /* Mode flag 2 */
extern s8  D_80035470;   /* Mode flag 3 */
extern void* D_8003ECF8; /* Some pointer */
extern void* D_8003ECC0; /* Another pointer */
extern s32 func_800075E0(void*, void*, s32); /* Memory operation */
extern s32 func_80007270(void*, void*, s32); /* Memory operation 2 */
extern void func_800013F4(void); /* Timer/sync function */
extern s8 func_800C9528(void); /* State update / input flag */

/**
/*
 * game_mode_handler - Game mode handler
 * (func_800C9AE0)
 * Address: 0x800C9AE0
 * Size: 256 bytes
 *
 * Called when game state matches pending state (steady state).
 * Handles per-frame mode updates and synchronization.
 */
void game_mode_handler(void) {
    s16 temp_val = 0x0ABE;  /* 2750 */
    s32 result;

    /* Set mode flag */
    D_80035472 = 1;

    /* Call memory operation with value */
    func_800075E0(&D_8003ECF8, &temp_val, 1);

    /* Clear another flag */
    D_80035471 = 0;

    /* Loop calling func_80007270 until it returns -1 */
    do {
        result = func_80007270(&D_8003ECC0, &temp_val, 0);
        if (result == -1) {
            break;
        }
        result = func_80007270(&D_8003ECC0, &temp_val, 1);
        if (result == -1) {
            break;
        }
        result = func_80007270(&D_8003ECC0, &temp_val, 0);
    } while (result != -1);

    /* Set flags after loop */
    D_80035471 = 1;
    D_80035470 = 0;

    /* Save state value */
    D_801597F4 = D_801597C8;

    /* Call timer/sync function */
    func_800013F4();

    /* Process inputs */
    func_800C997C();

    /* Update state */
    func_800C9528();
}

/*

/**
 * External functions called by playgame_handler
 */
extern void state_change_preprocess(void); /* func_800CA300 - State change pre-process */
extern void object_init_render(void);       /* func_800A5BB8 - Object render init */
extern void hud_setup(s32 a, s32 b, s32 c, s32 d, s32 e, f32 f, f32 g, s32 h); /* func_800C8B8C - HUD setup */
extern void hud_init(void); /* func_800C885C - HUD init */
extern void display_enable(s32 flag); /* func_800C8FA4 - Enable/disable display */
extern void game_init_state(void); /* func_800C9BE0 - Game state init */
extern void float_process(f32);        /* func_800014F0 - Float function */
extern void state_finalize(void); /* func_800C9480 - State finalize */
extern void player_cleanup_slots(void); /* func_800C90E0 - Mode transition */
extern void speed_set(s32 speed); /* func_800C9210 - Speed param function */
extern void resource_slots_clear_multiple(void); /* func_800C937C - Clear multiple resource slots */
extern void player_state_set(s32 a, s32 b); /* func_800C9158 - Player state set */
extern void player_mode_set(s32 a0, s8 a1); /* func_800C84C0 - Player mode set */
void sync_entry_register(s32, s32);          /* func_800C9194 - Create and register sync entry (defined below) */
extern void func_800A3424(s32, s32);   /* Car update function */
extern void object_render_cleanup(void *obj_ptr); /* func_800C7308 - Object cleanup */
extern void scene_cleanup_slots(void); /* func_800C70BC - Scene cleanup */
extern void func_800A1244(void);       /* Render function */
extern s32 func_80097798(s32, s32, s32, s32, s32); /* Sound/effect */
extern void func_800B55FC(s32 flag); /* Visual update */
void* func_800B42F0(s32);              /* Object allocate wrapper (defined later) */
extern void* func_800B4200(void *buffer, s32 samples); /* Object allocate (uses register s2 for type) */
/* Note: func_80007270 and func_800075E0 declared earlier */

/* Additional data and functions */
extern u32 D_801174BC;
extern s32 D_80114650;
extern s32 D_80156994;
extern s32 D_80146115;
extern s32 D_80146114;
extern s32 D_801461F8;
extern s32 D_80146205;
extern s32 D_80159774;
extern s32 D_801597C4;
extern s32 D_80151AD0;
extern s32 D_80151AD8;
extern void hud_speed_display(void *hud, f32 speed); /* func_800C84FC - HUD speed display */

/**
/*
 * playgame_handler - Game state change handler (playgame equivalent)
 * (func_800CA3B4)
 * Address: 0x800CA3B4
 * Size: 2544 bytes
 *
 * Handles game state transitions via bitmask flags.
 * Called when state changes to process enter/exit logic.
 *
 * State bit flags:
 *   0x0001 - Enter gameplay initialization
 *   0x0002 - Secondary setup mode
 *   0x0004 - Third state (menu related)
 *   0x0008 - Cleanup/exit state
 *   0x0010 - Player state update
 *   0x0020 - Multi-player setup
 *   0x0040 - Another state
 *   0x0080 - Result/finish state
 *   0x0100 - High score related
 *   0x0200, 0x0400, 0x0800, 0x1000, 0x2000 - Various states
 *   0x4000 - Sound trigger state
 *   0x40000 - PLAYGAME active
 */
void playgame_handler(void) {
    u32 gstate_current;
    u32 gstate_next;
    s32 i;
    s32 player_count;
    f32 ftemp;
    s8 mode_flag;

    /* Load current and pending state */
    gstate_current = D_801174B4;
    gstate_next = D_801174B8;

    /* If no state change, return early */
    if (gstate_current == gstate_next) {
        return;
    }

    /* Pre-process state change */
    state_change_preprocess();

    /* Store pending state as current */
    gstate_next = D_801174B8;
    D_801174B4 = gstate_next;

    /* State bit 0x0001: Enter gameplay initialization */
    if (gstate_next & 0x0001) {
        /* Clear various flags */
        D_801461F8 = 0;
        D_80146205 = 0;
        D_80159414 = 0;
        D_80159774 = 0;
        D_80159794 = 0;
        D_801597C4 = 0;

        func_800A5BB8();

        mode_flag = D_80156994;
        if (mode_flag == 0) {
            /* Normal mode - setup HUD at 32,16 with specific params */
            hud_setup(32, 16, 16, 5, 64, 1.0f, 200.0f, 0);
            hud_init();
        }

        display_enable(1);

        /* Set initial state values */
        D_8015A108 = 1;
        D_80151AD0 = 1;

        game_init_state();
        func_800014F0(30.0f);

        /* Call state handler 3 times */
        game_mode_handler();
        game_mode_handler();
        game_mode_handler();

        state_finalize();

        /* Set next state to 0x0002 */
        D_801174B8 = 2;
        gstate_current = D_801174B4;
        goto done;
    }

    /* State bit 0x0002: Secondary setup */
    if (gstate_next & 0x0002) {
        player_cleanup_slots();
        func_800A5BB8();

        mode_flag = D_80156994;
        if (mode_flag == 0) {
            hud_setup(32, 16, 16, 5, 64, 1.0f, 200.0f, 0);
            hud_init();
        }

        /* Load float from ROM data for timing */
        ftemp = 10.0f * (f32)D_80146115;
        speed_set(ftemp);
        display_enable(1);
        resource_slots_clear_multiple();

        /* Setup player controllers */
        player_state_set(-1, 0);
        player_state_set(0, 1);
        player_mode_set(-1, 1);

        gstate_current = D_801174B4;
        goto done;
    }

    /* Check for early return if bit 31 set */
    if ((s32)gstate_next < 0) {
        goto done;
    }

    /* State bit 0x0004 */
    if (gstate_next & 0x0004) {
        player_cleanup_slots();
        func_800A5BB8();

        mode_flag = D_80156994;
        if (mode_flag == 0) {
            hud_setup(32, 16, 16, 5, 64, 1.0f, 200.0f, 0);
            hud_init();
        }

        ftemp = 10.0f * (f32)D_80146115;
        speed_set(ftemp);
        display_enable(1);
        resource_slots_clear_multiple();

        /* Check additional flags and process cars */
        if (!(D_801174BC & 0x007CDFC0)) {
            player_count = D_8015A108;
            if (player_count > 0) {
                for (i = 0; i < player_count; i++) {
                    /* Process each player's car */
                    void *car_ptr = (void*)((u8*)D_8015A118 + i * 76);
                    if (car_ptr) {
                        void *car_data = *(void**)((u8*)car_ptr + 72);
                        if (car_data) {
                            s32 car_obj = *(s32*)((u8*)car_data + 8);
                            func_800A3424(car_obj, 0);
                        }
                    }
                }
            }
        }

        player_state_set(-1, 0);
        player_state_set(0, 1);
        player_mode_set(-1, 1);

        /* Check for specific mode */
        mode_flag = D_80156994;
        if (mode_flag != 0) {
            if (!(D_801174BC & 0x007C0000)) {
                s8 val1 = D_80146114 + 14;
                if (val1 < 13) {
                    s8 val2 = D_80146114 + 12;
                    ftemp = 10.0f * (f32)val2;
                    speed_set(ftemp);
                    sync_entry_register(6, 1);
                }
            }
        }

        D_80151AD8 = 0;
        gstate_current = D_801174B4;
        goto done;
    }

    /* State bit 0x0008: Cleanup/exit */
    if (gstate_next & 0x0008) {
        /* Walk object list and clean up */
        void *obj = D_8013E6E0;
        while (obj != NULL) {
            object_render_cleanup(obj);
            void *next = *(void**)obj;
            obj = *(void**)next;
        }

        scene_cleanup_slots();
        player_cleanup_slots();
        func_800A5BB8();

        mode_flag = D_80156994;
        if (mode_flag == 0) {
            hud_setup(8, 8, 0, 0, 0, 1.0f, 200.0f, 0);
        }

        display_enable(0);

        if (D_80156994 != 0) {
            func_800A1244();
        }

        gstate_current = D_801174B4;
        goto done;
    }

    /* State bit 0x0010: Player state update */
    if (gstate_next & 0x0010) {
        player_state_set(-1, 0);
        player_state_set(0, 1);
        player_mode_set(-1, 1);
        gstate_current = D_801174B4;
        goto done;
    }

    /* State bit 0x0020: Multi-player setup */
    if (gstate_next & 0x0020) {
        player_count = D_8015A108;
        for (i = 0; i < player_count; i++) {
            player_state_set(i, 1);
            player_mode_set(i, 1);
        }
        /* Disable remaining slots */
        for (; i < 4; i++) {
            player_state_set(i, 0);
        }
        gstate_current = D_801174B4;
        goto done;
    }

    /* State bit 0x0040 */
    if (gstate_next & 0x0040) {
        player_state_set(-1, 0);
        player_state_set(0, 1);
        gstate_current = D_801174B4;
        goto done;
    }

    /* Various other state bits (0x0200-0x2000) - return early if set */
    if (gstate_next & 0x0200) goto done;
    if (gstate_next & 0x0400) goto done;
    if (gstate_next & 0x0800) goto done;
    if (gstate_next & 0x1000) goto done;
    if (gstate_next & 0x2000) goto done;
    if ((gstate_next << 4) < 0) goto done; /* Bit 0x8000000 */

    /* State bit 0x4000: Sound/effect trigger */
    if (gstate_next & 0x4000) {
        func_80097798(57, 0, 0, 0, 0);
        gstate_current = D_801174B4;
        goto done;
    }

    /* State bit 0x0100: High score/result */
    if (gstate_next & 0x0100) {
        func_80097798(56, 0, 0, 0, 0);

        player_count = D_8015A108;
        for (i = 0; i < player_count; i++) {
            player_state_set(i, 1);
            player_mode_set(i, 1);
        }
        for (; i < 4; i++) {
            player_state_set(i, 0);
        }
        gstate_current = D_801174B4;
        goto done;
    }

    /* State bit 0x0080: Result/finish */
    if (gstate_next & 0x0080) {
        func_80097798(60, 0, 0, 0, 0);
        player_state_set(-1, 0);
        player_state_set(0, 1);
        gstate_current = D_801174B4;
        goto done;
    }

    /* State bit 0x40000: PLAYGAME active (main gameplay) */
    if ((gstate_next << 13) < 0) { /* Check bit 0x40000 */
        s8 state_byte = D_80114650;

        if (state_byte == 0) {
            scene_cleanup_slots();
            player_cleanup_slots();
            func_800A5BB8();
        }

        display_enable(0);

        if (state_byte == 0) {
            mode_flag = D_80156994;
            if (mode_flag == 0) {
                s32 game_mode = D_8015A110;
                if (game_mode != 6 && game_mode != 4 && game_mode != 5) {
                    hud_setup(8, 8, 0, 0, 0, 1.0f, 200.0f, 0);
                }
            }

            mode_flag = D_80156994;
            if (mode_flag == 0) {
                s32 game_mode = D_8015A110;
                if (game_mode == 6) {
                    hud_speed_display(NULL, 0.0f);
                }
            }

            func_800B55FC(1);
        }

        /* Check game mode for specific handling */
        s32 game_mode = D_8015A110;
        if (game_mode != 6 && game_mode != 4 && game_mode != 5) {
            if (D_80156994 == 0) {
                func_800A1244();
            }
        }

        state_byte = D_80114650;
        if (state_byte == 0) {
            /* Dispose objects */
            func_800B42F0(13);
            func_800B42F0(10);
            func_800B42F0(11);
            func_800B42F0(12);
            func_800B42F0(4);
            func_800B42F0(1);
            func_800B42F0(2);
            func_800B42F0(3);
            func_800B42F0(9);
            func_800B42F0(8);

            /* Initialize memory regions */
            func_80007270(&D_801461D0, 0, 1);
            func_800B4200(NULL, 0);
            func_800075E0(&D_801461D0, 0, 0);

            func_80007270(&D_801461D0, 0, 1);
            func_800B4200(NULL, 0);
            func_800075E0(&D_801461D0, 0, 0);

            func_80007270(&D_801461D0, 0, 1);
            func_800B4200(NULL, 0);
            func_800075E0(&D_801461D0, 0, 0);
        }

        player_state_set(-1, 0);
        player_state_set(0, 1);
        player_mode_set(-1, 1);

        gstate_current = D_801174B4;
    }

done:
    /* Return with gstate_current in register */
    return;
}

/*

/* External data for countdown function */
extern s32 D_801613B0;     /* Found player index */
extern s32 D_801146F8;     /* Countdown timer */
extern void* D_8018A4E0[]; /* Display object pointer array */

/* External functions for countdown */
extern void sprintf(s8 *buf, s8 *fmt, ...); /* func_80004990 */
extern void func_800A4770(s8 *buf, s32 val);
extern void func_800B74A0(void *entity, void *world);
extern s32 func_800B71D4();
extern s16 sound_apply_effect(s32 channel, s32 effectType, f32 amount); /* func_800B3FA4 */

/**
/*
 * func_800FBC30 - Countdown wrapper
 * Address: 0x800FBC30
 * Size: 8 bytes (just loads mode and falls through)
 *
 * This is just a label - loads D_8015A110 then falls into func_800FBC38.
 */

/**
/*
 * countdown_display - Countdown display handler
 * (func_800FBC38)
 * Address: 0x800FBC38
 * Size: 488 bytes
 *
 * Displays the countdown timer during race start.
 * Finds active player, formats countdown text, and displays it.
 */
void countdown_display(void) {
    s32 player_count;
    s32 i;
    s8 str_buf[80];      /* sp+0x50 */
    s8 format_buf[88];   /* sp+0x58 */
    void *display_data;
    s32 countdown_val;
    s32 result;
    u32 state_flags;

    /* Get player count - 1 if mode is 2, otherwise from D_8015A108 */
    if (D_8015A110 == 2) {
        player_count = 1;
    } else {
        player_count = D_8015A108;
    }

    /* Find first inactive player slot */
    i = 0;
    if (player_count > 0) {
        s8 *player_ptr = (s8 *)0x80156CF0;
        while (i < player_count) {
            if (*player_ptr == 0) {
                break;  /* Found inactive slot */
            }
            i++;
            player_ptr += 16;
        }
    }

    /* Store found player index */
    D_801613B0 = i;

    /* Check if we found a slot before count */
    if (i >= player_count) {
        /* All players accounted for - set countdown to 320 (5.3 sec at 60fps) */
        countdown_val = 320;
        D_801146F8 = countdown_val;
        return;
    }

    /* Format player string */
    sprintf(str_buf, D_80120308, i + 1);

    /* Get display parameters from global */
    display_data = D_8018A4E0[1];  /* offset 4 = array[1] */

    /* Format display text with position params */
    {
        s32 x_pos = *(s32 *)((u8 *)display_data + 0x1F0);
        s32 y_pos = *(s32 *)((u8 *)display_data + 0x1F4);
        s32 width = *(s32 *)((u8 *)display_data + 0x1F8);
        s32 height = *(s32 *)((u8 *)display_data + 0x1FC);
        s32 extra = *(s32 *)((u8 *)display_data + 0x200);

        countdown_val = D_801146F8;
        sprintf(format_buf, D_8012030C, str_buf, x_pos, y_pos, countdown_val, width, height, extra);
    }

    /* Call rendering function */
    func_800A4770(format_buf, *(s32 *)((u8 *)display_data + 0x200));

    /* Create display object */
    func_80007270(&D_801461D0, 0, 1);
    func_800B4200(NULL, 0);
    func_800075E0(&D_801461D0, 0, 0);

    /* Set display type */
    func_800B74A0(NULL, NULL);

    /* Check state flags for color selection */
    state_flags = D_801174B4;

    if ((state_flags & 0x0001) || (state_flags & 0x0002) ||
        ((state_flags << 1) < 0) ||   /* bit 0x80000000 */
        (state_flags & 0x0004) || (state_flags & 0x0008)) {
        /* Special state - color 8 (darker) */
        countdown_val = D_801146F8;
        func_800B71D4();
    } else {
        /* Normal state - color 205 (0xCD, brighter) */
        countdown_val = D_801146F8;
        func_800B71D4();
    }

    /* Finalize display and decrement countdown */
    countdown_val = D_801146F8;
    sound_apply_effect(0, -1, 0.0f);
    countdown_val--;
    D_801146F8 = countdown_val;

    /* Reset countdown if it goes too negative */
    if (countdown_val < -result) {
        D_801146F8 = 320;
    }
}

/*

/**
/* Global for object type - used by func_800B4200 via register convention */

/**
/*
 * func_800B42F0 - Allocate and initialize object wrapper
 * Address: 0x800B42F0
 * Size: 112 bytes
 *
 * Wrapper that:
 * 1. Locks memory region (func_80007270)
 * 2. Sets object type (via register s2 in assembly)
 * 3. Allocates object (func_800B4200)
 * 4. Unlocks memory region (func_800075E0)
 *
 * Note: In the original assembly, 'type' is passed via register s2
 * to func_800B4200 using a delay slot trick. Here we simulate this
 * by setting a global before the call.
 *
 * @param type  Object type to allocate
 * @return      Allocated object pointer
 */
void* func_800B42F0(s32 type) {
    void *obj;
    s8 saved_type;

    /* Lock memory region */
    func_80007270(&D_801461D0, 0, 1);

    /* Set object type (simulates s2 register setup) */
    saved_type = D_80159DA0;
    D_80159DA0 = (s8)type;

    /* Allocate object of specified type */
    obj = func_800B4200(NULL, 0);

    /* Restore and unlock */
    D_80159DA0 = saved_type;
    func_800075E0(&D_801461D0, 0, 0);

    return obj;
}

/*

/* External for visual update */
extern void func_800A2378(s32 track, s32 node, f32 *x, f32 *y, f32 *z);

/**
/*
 * func_800B55FC - Update visual objects
 * Address: 0x800B55FC
 * Size: 140 bytes
 *
 * Iterates through visual object array and calls update function
 * on each object that has a valid update handler.
 *
 * @param flag  Update flag passed to each object's update function
 */
void func_800B55FC(s32 flag) {
    u32 *array_ptr;
    u32 *array_end;
    void *entry;
    void *obj;
    void **vtable;

    array_ptr = (u32 *)0x80144D60;
    array_end = (u32 *)0x80144DA0;

    /* Iterate through object array (16-byte entries) */
    while (array_ptr != array_end) {
        /* Load object list head from offset 8 of array entry */
        entry = (void *)array_ptr[2];

        if (entry != NULL) {
            /* Get first object in linked list */
            obj = *(void **)entry;

            /* Walk the linked list */
            while (obj != NULL) {
                /* Get vtable pointer */
                vtable = *(void ***)obj;

                /* Check if update handler exists at vtable[0x48/4] = vtable[18] */
                if (vtable[18] != NULL) {
                    /* Call update function via vtable */
                    typedef void (*UpdateFunc)(void*, s32);
                    UpdateFunc updateFn = (UpdateFunc)vtable[18];
                    updateFn(obj, flag);
                }

                /* Get object pointer from vtable, then get next object */
                obj = *(void **)vtable;
            }
        }

        /* Advance to next array entry (16 bytes) */
        array_ptr += 4;
    }
}

/*

/* External data for race state machine */
extern s32 D_80159D98;       /* Race sub-state */
extern s32 D_8015698C;       /* Current player index */
extern s8  D_80117350;       /* Player active flag */
extern s8  D_80117354;       /* Secondary active flag */
extern void* D_80143FD8;     /* Object list head */
extern f32 D_801543CC;       /* Timer value */

/* External functions for race states */
extern void func_800C813C(void *hud, s32 elementId); /* Race pre-update */
extern void func_800DB1E0(void *car, s32 paintId); /* State 1 handler */
extern void func_800D91A0(void *garage); /* State 2 handler */
extern void func_800D7634(void *profile); /* State 3 handler */
extern void func_800B8C14(void *constraint); /* State 4 handler */
extern void func_800B4FB0(s32 trackId); /* State setter */
extern void func_800013C0(void);       /* Timer init */
extern void func_800013DC(void);       /* Timer update */
extern void* func_80091B00(s32 type);      /* Allocate object */
extern void *func_80092360(s32 arg); /* Object allocation */
extern void func_800D5374(void *menu); /* Race setup 1 */
extern void players_frame_update(void); /* Race setup 2 */
extern void func_800D6530(s32 operation); /* Track init */
extern void func_800D6160(void *menu); /* Visual init */
extern void func_800D60AC(void); /* Scene setup */
extern void func_800D5A04(void *menu); /* Cleanup */
extern void func_800B5F4C(s32 a0); /* Menu prev */
extern void func_800B5FC4(void);       /* Menu confirm */
extern void func_800B5F88(s32 a0); /* Menu toggle */
extern void func_800B438C(s32 streamId, void *data); /* Audio stream start */

/*
 * race_state_machine - Race state machine
 * (func_800F6310)
 * Handles race initialization and state transitions.
 */
void race_state_machine(void) {
    s32 race_state;
    s32 sub_state;
    s32 player_count, player_idx, i;
    s32 player_flags;
    u8 *player_status;
    s8 *player_array;
    void *obj;
    void *alloc_obj;
    f32 timer_val;

    /* Initialize state */
    func_800C813C(0, 0);
    race_state = D_801170FC;

    /* Validate state range */
    if (race_state >= 9) {
        goto exit_common;
    }

    /* Main state switch */
    switch (race_state) {

    case 0:  /* Initialize race - find first active player */
        player_count = D_80151AD0;
        if (player_count <= 0) {
            goto exit_func;
        }

        player_array = (s8 *)0x8015A118;
        player_status = (u8 *)0x80156CF0;

        for (i = 0; i < player_count; i++) {
            player_flags = *(u32 *)(player_array + i * 76 + 4);

            /* Check if player slot is active */
            if ((player_flags & 0x0001) || player_status[i * 16] == 0) {
                /* Found active player */
                D_8015698C = i;
                D_80117350 = (player_status[i * 16] == 0) ? 1 : 0;
                break;
            }
        }

        if (i >= player_count) {
            goto exit_func;
        }

        /* Initialize race */
        func_800B4FB0(1);
        D_80159D98 = 0;
        func_800013C0();

        /* Lock and allocate race object */
        func_80007270(&D_801461D0, 0, 1);
        alloc_obj = func_80091B00(0);
        *(u8 *)((u8 *)alloc_obj + 2) = 7;  /* Set object type */
        func_800075E0(&D_801461D0, 0, 0);
        func_800075E0((void *)0x801427A8, alloc_obj, 0);

        /* Setup race timing */
        speed_set(0.0f);

        /* Initialize race systems */
        func_800D5374(NULL);
        players_frame_update();

        /* Initialize object list */
        obj = D_80143FD8;
        while (obj != NULL) {
            *(u8 *)((u8 *)obj + 100) = 2;
            *(s32 *)((u8 *)obj + 96) = -1;
            obj = *(void **)obj;
        }

        player_mode_set(-1, 1);
        func_800B55FC(1);
        func_80092360(46);  /* Play race start sound */
        break;

    case 1:  /* Pre-race setup */
        func_800DB1E0(NULL, 0);
        break;

    case 2:  /* Track loading */
        func_800D91A0(NULL);
        break;

    case 3:  /* Car setup */
        func_800D7634(NULL);
        break;

    case 4:  /* Countdown prep */
        func_800B8C14(NULL);
        break;

    case 5:  /* Main racing state - nested switch */
        player_idx = D_8015698C;
        player_flags = *(u32 *)(0x8015A11C + player_idx * 76);

        if (!(player_flags & 0x0002)) {
            goto state5_default;
        }

        func_80092360(37);  /* Racing sound */

        sub_state = D_80159D98;
        if (sub_state >= 8) {
            goto state5_default;
        }

        switch (sub_state) {
        case 0:  /* Race start */
            func_800B4FB0(0);
            func_800013DC();
            func_800D6530(0);

            func_80007270(&D_801461D0, 0, 1);
            alloc_obj = func_80091B00(0);
            *(u8 *)((u8 *)alloc_obj + 2) = 9;
            func_800075E0(&D_801461D0, 0, 0);
            func_800075E0((void *)0x801427A8, alloc_obj, 0);

            func_800D6160(1);
            if (!(D_801174B4 & 0x00200000)) {
                func_800D6160(0);
}
            func_800D60AC();
            player_mode_set(-1, 0);
            goto exit_func;

        case 1:  /* Countdown timer check */
            timer_val = D_801543CC;
            if (timer_val >= 15.0f) {
                D_80114650 = 1;
            }
            break;

        case 2:  /* Countdown in progress */
            timer_val = D_801543CC;
            if (timer_val >= 15.0f) {
                D_80114650 = 0;
                if (D_801174B4 & 0x00200000) {
                    goto state5_case7;
                }
            }
            break;

        case 3:  /* Race in progress */
            func_800B4FB0(8);
            break;

        case 4:  /* Race setup */
            func_800B4FB0(2);
            break;

        case 5:  /* Lap handling */
            func_800B4FB0(3);
            break;

        case 6:  /* Position update */
            *(u8 *)(0x8015418C + D_8015698C) = 1;
            func_800B4FB0(4);
            break;

        case 7:  /* Exit sub-state */
        state5_case7:
            func_800B4FB0(6);
            break;
        }

    state5_default:
        break;

    case 6:  /* Race complete - menu navigation */
        player_idx = D_8015698C;
        player_flags = *(u32 *)(0x8015A11C + player_idx * 76);

        if (player_flags & 0x0400) {
            func_800B5F4C(0);  /* Previous */
            sub_state = D_80159D98;
            sub_state--;
            if (sub_state < 0) sub_state = 7;
            D_80159D98 = sub_state;
        } else if (player_flags & 0x0800) {
            func_800B5F4C(0);  /* Next */
            sub_state = D_80159D98;
            sub_state++;
            if (sub_state >= 8) sub_state = 0;
            D_80159D98 = sub_state;
        } else if (player_flags & 0x0005) {
            func_800B5FC4();  /* Confirm */
            goto case0_init;
        }
        break;

    case 7:  /* Results/standings */
        player_idx = D_8015698C;
        player_flags = *(u32 *)(0x8015A11C + player_idx * 76);

        if (player_flags & 0x3000) {
            func_800B5F88(0);  /* Toggle display */
        }

        if (player_flags & 0x0002) {
            if (D_80117354 != 0) {
                if ((D_801174B4 & 0x00200000) && race_state == 8) {
                    goto state7_restart;
                }
            }
        }
        /* Fall through to common handling */
        goto state7_common;

    state7_restart:
        *(u8 *)0x80142699 = 1;
        func_800B4FB0(0);
        func_800013DC();

        func_80007270(&D_801461D0, 0, 1);
        alloc_obj = func_80091B00(0);
        *(u8 *)((u8 *)alloc_obj + 2) = 7;
        func_800075E0(&D_801461D0, 0, 0);
        func_800075E0((void *)0x801427A8, alloc_obj, 0);
        goto exit_common;

    state7_common:
        D_80114650 = (race_state == 7) ? 1 : 0;
        func_800B4FB0(0);
        func_800013DC();

        func_80007270(&D_801461D0, 0, 1);
        alloc_obj = func_80091B00(0);
        *(u8 *)((u8 *)alloc_obj + 2) = 7;
        func_800075E0(&D_801461D0, 0, 0);
        func_800075E0((void *)0x801427A8, alloc_obj, 0);
        func_800D5A04(NULL);
        break;

    case 8:
    default:
        player_idx = D_8015698C;
        player_flags = *(u32 *)(0x8015A11C + player_idx * 76);

        if (player_flags & 0x0007) {
            func_800B5FC4();
            func_800B4FB0(1);
        }
        break;
    }

case0_init:
exit_common:
    /* Common exit - check player status changes */
    race_state = D_801170FC;
    if (race_state != 0) {
        player_idx = D_8015698C;
        player_status = (u8 *)(0x80156CF0 + player_idx * 16);
        s8 current_status = (*player_status == 0) ? 1 : 0;

        if (current_status != D_80117350) {
            D_80117350 = current_status;

            /* Don't update sound during certain states */
            if (race_state != 5 && race_state != 4 && race_state != 2 && race_state != 3) {
                func_800B438C(0, NULL);
            }
        }
    }

    /* Check for reset flag */
    if (*(s8 *)0x80157244 != 0) {
        D_80114650 = 0;
        func_800B4FB0(0);
        func_800013DC();

        func_80007270(&D_801461D0, 0, 1);
        alloc_obj = func_80091B00(0);
        *(u8 *)((u8 *)alloc_obj + 2) = 7;
        func_800075E0(&D_801461D0, 0, 0);
        func_800075E0((void *)0x801427A8, alloc_obj, 0);
        func_800D5A04(NULL);
    }

exit_func:
    return;
}

/*

/**
/*
 * active_sounds_update - Update all active sound objects
 * (func_800F7344)
 * Address: 0x800F7344
 * Size: 184 bytes
 *
 * Iterates through active sound list (D_80159450) and calls each
 * object's update callback. If callback returns 0, the sound is
 * stopped and removed via sound_handle_stop.
 *
 * Note: func_800F733C loads count into t6 immediately before this.
 */
void active_sounds_update(void) {
    s32 count;
    void **cur_ptr;
    void **end_ptr;
    void *sound_obj;
    s32 (*callback)(void*);
    s32 status;
    s32 result;

    /* Get current count (loaded by preceding code into t6) */
    count = D_80159788;
    if (count <= 0) {
        return;
    }

    /* Start at beginning of sound list */
    cur_ptr = &D_80159450;

    while (1) {
        sound_obj = *cur_ptr;

        /* Get callback function pointer at offset 0x28 */
        callback = *(s32 (**)(void*))((u8*)sound_obj + 0x28);

        if (callback != NULL) {
            /* Get status at offset 0 */
            status = *(s32*)sound_obj;

            if (status != -1) {
                /* Call the update callback */
                result = callback(sound_obj);

                if (result == 0) {
                    /* Callback returned 0 - stop and remove this sound */
                    func_800B358C(sound_obj, 0.0f);

                    /* Recalculate end pointer (list may have shifted) */
                    count = D_80159788;
                    end_ptr = &D_80159450 + count;

                    /* Back up pointer since list shifted */
                    cur_ptr--;
                    goto next_iter;
                }
            }
        }

        /* Calculate end pointer */
        count = D_80159788;
        end_ptr = &D_80159450 + count;

    next_iter:
        cur_ptr++;
        if (cur_ptr >= end_ptr) {
            break;
        }
    }
}

/*

/**
/*
 * func_800F73FC - Main render pipeline dispatcher
 * Address: 0x800F73FC
 * Size: 76 bytes
 *
 * This is the main per-frame render update entry point.
 * Orchestrates all visual updates:
 *   1. If sound_update != 0, update active sounds (func_800F733C -> func_800F7344)
 *   2. If physics_update != 0, update physics objects (func_800B0868 -> func_800B0870)
 *   3. Always update particle/effect emitters (func_800B811C)
 *   4. Always run main scene render (func_800A04C4)
 *
 * @param sound_update   Whether to update sounds (arg a0)
 * @param physics_update Whether to update physics (arg a1)
 */
extern void physics_update_all(void); /* func_800B0870 - Physics object linked list update */

void update_game_systems(s32 sound_update, s32 physics_update) {
    /* Update active sounds if requested */
    if (sound_update != 0) {
        func_800F733C();  /* Loads count then calls func_800F7344 */
    }

    /* Update physics objects if requested */
    if (physics_update != 0) {
        func_800B0868();  /* Starts physics linked list traversal */
    }

    /* Always update particle/effect emitters */
    func_800B811C();

    /* Always render the scene */
    func_800A04C4(0, 0.0f, 0, 0);
}

/*

/**
/*
 * physics_get_list_head - Get physics object list head
 * (func_800B0868)
 * Address: 0x800B0868
 * Size: 8 bytes (just loads and returns)
 *
 * Returns the head of the physics object linked list.
 * This is called before physics_update_all to get list head.
 */

void *physics_get_list_head(void) {
    return D_801491F0;
}

/*

/**
/*
 * physics_update_all - Update all physics objects in linked list
 * (func_800B0870)
 * Address: 0x800B0870
 * Size: 108 bytes
 *
 * Traverses the physics object linked list starting from D_801491F0.
 * For each object with an update callback at offset 0x14, calls it
 * with (object, 1).
 *
 * Object structure (partial):
 *   offset 0x00: next pointer (linked list)
 *   offset 0x14: update callback function pointer
 */
extern void physics_cleanup(void);  /* func_800B066C - Physics cleanup/finalize */

void physics_update_all(void) {
    void *current;
    void *next;
    void (*update_callback)(void*, s32);

    /* Get list head (loaded by func_800B0868 into v0) */
    current = D_801491F0;

    /* Get next pointer for iteration */
    if (current != NULL) {
        next = *(void**)current;  /* offset 0x00 = next */
    } else {
        next = NULL;
    }

    /* Traverse the linked list */
    while (current != NULL) {
        /* Get update callback at offset 0x14 */
        update_callback = *(void (**)(void*, s32))((u8*)current + 0x14);

        if (update_callback != NULL) {
            /* Call update with (object, 1) */
            update_callback(current, 1);
        }

        /* Move to next object */
        if (next == NULL) {
            break;
        }
        current = next;
        next = *(void**)current;  /* Get next->next */
    }

    /* Call cleanup function */
    func_800B066C();
}

/*

/**
/*
 * func_800B811C - Update all particle emitters
 * Address: 0x800B811C
 * Size: 252 bytes
 *
 * Iterates through the particle emitter array and updates each one:
 *   1. Copies current position to previous position
 *   2. Calls update function (func_8008D6B0)
 *   3. Updates velocity with acceleration
 *   4. Conditionally spawns particles if D_801170FC == 0
 *   5. Calls cleanup functions at end
 *
 * Emitter structure (152 bytes per emitter):
 *   offset 0x24-0x2C: current position (x, y, z)
 *   offset 0x34-0x3C: velocity (x, y, z)
 *   offset 0x48: additional velocity component
 *   offset 0x54-0x5C: previous position (x, y, z)
 */

/* Emitter array at 0x80150B70, secondary at 0x80150BA0 */
extern u8  D_80150B70[];          /* Emitter array base */
extern u8  D_80150BA0[];          /* Secondary emitter array */

extern void emitter_update(f32 *src, f32 *dst); /* func_8008D6B0 - Emitter update */
extern void particles_spawn(s32 a0); /* func_800B80C8 - Spawn particles for emitter */
extern s32 particles_cleanup(void); /* func_800B7FF8 - Particle cleanup */
extern void func_800B61FC(void *entity, f32 *vec); /* Final cleanup */
extern s16 D_80152032;                    /* Second emitter count */

void effects_update_emitters(void) {
    s32 i;
    s16 count;
    u8 *emitter;
    u8 *emitter2;
    f32 *pos;
    f32 *prev_pos;
    f32 *vel;

    count = D_80151AD0;
    if (count <= 0) {
        goto end_loop;
    }

    emitter = D_80150B70;
    emitter2 = D_80150BA0;

    for (i = 0; i < count; i++) {
        /* Copy current position to previous position */
        pos = (f32*)(emitter + 0x24);
        prev_pos = (f32*)(emitter + 0x54);
        prev_pos[0] = pos[0];  /* x */
        prev_pos[1] = pos[1];  /* y */
        prev_pos[2] = pos[2];  /* z */

        /* Call emitter update function */
        emitter_update(emitter, 0);

        /* Update velocity with acceleration (FP operations) */
        vel = (f32*)(emitter + 0x34);
        /* Note: Original has complex FP ops here that update velocity */
        /* The disassembly shows additions to vel.x/y/z from other offsets */

        /* Conditionally spawn particles */
        if (D_801170FC == 0) {
            particles_spawn(i);
        }

        /* Advance to next emitter (152 bytes each) */
        emitter += 152;
        emitter2 += 152;

        /* Re-read count in case it changed */
        count = D_80151AD0;
    }

end_loop:
    /* Call cleanup functions */
    func_800B7FF8();

    /* Call final cleanup with flag based on second emitter count */
    {
        s16 count2 = D_80152032;
        s32 flag = (0 < count2) ? 1 : 0;
        func_800B61FC(flag, 0);
    }
}

/*

/**
/*
 * func_800C9528 - Load input initialized flag (prologue)
 * Address: 0x800C9528
 * Size: 8 bytes
 *
 * Just loads D_801147C4 into t6 for func_800C9530.
 */
extern s8 D_801147C4;  /* Input system initialized flag */

s8 func_800C9528(void) {
    return D_801147C4;
}

/*

/**
/*
 * func_800C9530 - Process input callback table
 * Address: 0x800C9530
 * Size: 96 bytes
 *
 * Iterates through an array of input handler function pointers
 * from D_801551E8 to D_80155210 (10 entries, 40 bytes).
 * Calls each non-NULL callback in sequence.
 *
 * If D_801147C4 == 0, first calls func_800B73E4 for initialization.
 */
extern void (*D_801551E8[])(void);  /* Input callback table start */
extern void (*D_80155210)(void);    /* Input callback table end marker */
extern void input_system_init(void); /* func_800B73E4 - Input system init */

void input_handlers_process(void) {
    void (**callback_ptr)(void);
    void (*callback)(void);

    /* One-time initialization if not yet done */
    if (D_801147C4 == 0) {
        input_system_init();
    }

    /* Iterate through callback table */
    callback_ptr = D_801551E8;

    while (callback_ptr != &D_80155210) {
        callback = *callback_ptr;
        if (callback != NULL) {
            callback();
        }
        callback_ptr++;
    }
}

/*

/**
/*
 * car_sounds_clear - Clear all sound handles for a player's car
 * (func_800D7D40)
 * Address: 0x800D7D40
 * Size: 132 bytes
 *
 * Iterates through all 17 sub-entries (64 bytes each) of a player's
 * car state and stops any active sounds, then clears the handles to -1.
 * Also clears the player's entry in D_80154618.
 *
 * Car state structure layout:
 *   Base: D_80111998
 *   Each player: 1088 bytes (17 * 64)
 *   Sound handle at offset 0x04 of each 64-byte sub-entry
 *
 * NOTE: Player index is passed in register s4, not a0.
 * This requires special calling convention.
 *
 * @param player_idx Player index (0-3) in s4 register
 */
extern u8 D_80111998[];      /* Car state array base */
extern s32 D_80154618[];     /* Per-player state flags */
extern void sound_stop_by_handle(s16, s32, s32);  /* func_80090088 - Stop sound */

/* This function uses non-standard calling - player_idx in s4 */
void car_sounds_clear(void) {
    register s8 player_idx asm("s4");  /* Player index passed in s4 */
    u8 *car_state;
    s32 offset;
    s32 handle;
    s16 handle_s16;

    /* Calculate car state pointer */
    /* car_state = D_80111998 + player_idx * 1088 (player_idx * 17 * 64) */
    car_state = D_80111998 + (player_idx * 17 * 64);

    /* Iterate through all 17 sub-entries */
    for (offset = 0; offset < 1088; offset += 64) {
        /* Get sound handle at offset 4 */
        handle = *(s32*)(car_state + offset + 4);

        if (handle != -1) {
            /* Sign extend handle to s16 */
            handle_s16 = (s16)handle;

            /* Stop the sound */
            func_80090088(handle_s16, 0, 0);

            /* Clear handle */
            *(s32*)(car_state + offset + 4) = -1;
        }
    }

    /* Clear player's state flag */
    D_80154618[player_idx] = 0;
}

/*

/**
/*
 * func_800D7DC4 - Clear all car sounds for all players
 * Address: 0x800D7DC4
 * Size: 196 bytes
 *
 * Loops through all 4 players and clears their car-related state:
 *   1. Clears D_8015418C[player] and D_8015A10C[player] to 0
 *   2. Calls func_800D7D40 to clear all sound handles
 *   3. Stops global sound handle at D_80113ED8 if active
 *   4. Clears D_80113ED8 and D_80113ED4
 *
 * Called during race end, game reset, or mode transitions.
 */
extern u8 D_8015418C[];      /* Per-player flags array 1 */
extern void *D_80113ED8;     /* Global sound handle */
extern u8 D_80113ED4;        /* Global sound flag */

void func_800D7DC4(void) {
    s32 i;
    void *sound_handle;

    /* Clear all 4 players' state */
    for (i = 0; i < 4; i++) {
        /* Clear per-player flags */
        D_8015418C[i] = 0;
        D_8015A10C[i] = 0;

        /* Clear this player's car sounds
         * NOTE: func_800D7D40 expects player index in s4 register */
        {
            register s8 player_reg asm("s4") = (s8)i;
            (void)player_reg;  /* Force register allocation */
            func_800D7D40();
        }
    }

    /* Stop global sound handle if active */
    sound_handle = D_80113ED8;
    if (sound_handle != NULL) {
        func_800B358C(sound_handle, 0.0f);
        D_80113ED8 = NULL;
    }

    /* Clear global sound flag */
    D_80113ED4 = 0;
}

/*

/**
/*
 * func_800B557C - Clear all ambient/environment sound handles
 * Address: 0x800B557C
 * Size: 120 bytes
 *
 * Stops and clears the ambient sound handle at D_80114624,
 * then iterates through 4 additional handles at D_80114628-D_80114638
 * and stops/clears each one.
 */
extern void *D_80114624;      /* Main ambient sound handle */
extern void *D_80114628[];    /* Additional sound handles (4 entries) */
extern void func_8008D0C0(void*);  /* Stop sound by object */

void func_800B557C(void) {
    void *handle;
    void **ptr;
    void **end_ptr;

    /* Stop and clear main ambient handle */
    handle = D_80114624;
    if (handle != NULL) {
        func_800B358C(handle, 0.0f);
        D_80114624 = NULL;
    }

    /* Stop and clear additional handles (4 entries from 0x4628 to 0x4638) */
    ptr = D_80114628;
    end_ptr = (void**)((u8*)D_80114628 + 16);  /* 4 * 4 bytes */

    while (ptr != end_ptr) {
        handle = *ptr;
        if (handle != NULL) {
            func_8008D0C0(handle);
            *ptr = NULL;
        }
        ptr++;
    }
}

/*

/**
/*
 * func_800B6138 - Reset all player state entries
 * Address: 0x800B6138
 * Size: 112 bytes
 *
 * Calls func_800B6024, then clears key fields of each player's
 * state entry in the array at D_8015A118 (76 bytes per player).
 *
 * Player state entry structure (partial):
 *   offset 0x04: s32 field_04
 *   offset 0x08: s32 field_08
 *   offset 0x0C: s32 field_0C
 *   offset 0x10: f32 field_10
 *   offset 0x14: f32 field_14
 */
/* D_8015A118 declared earlier as void* - cast to u8* for array access */
extern f32 func_800B6024(void *entity, s32 index); /* Pre-reset function */

void func_800B6138(void) {
    s32 i;
    s16 count;
    u8 *entry;

    /* Call pre-reset function */
    func_800B6024(0, 0);

    /* Get player count */
    count = D_8015A108;
    if (count <= 0) {
        return;
    }

    /* Clear each player's state fields */
    entry = (u8*)D_8015A118;
    for (i = 0; i < count; i++) {
        *(s32*)(entry + 0x08) = 0;
        *(s32*)(entry + 0x04) = 0;
        *(s32*)(entry + 0x0C) = 0;
        *(f32*)(entry + 0x10) = 0.0f;
        *(f32*)(entry + 0x14) = 0.0f;

        entry += 76;  /* Next player entry */
        count = D_8015A108;  /* Re-read count in case it changed */
    }
}

/*

/**
/*
 * func_800B9130 - Reset effect/particle system state
 * Address: 0x800B9130
 * Size: 100 bytes
 *
 * Clears effect system globals and reinitializes effect pools.
 * Called during level transitions or game resets.
 */
extern void *D_80143A18;      /* Effect pool 1 */
extern void *D_80143A20;      /* Effect pool 2 */
extern void *D_80143A28;      /* Effect pool 3 */
extern u8 D_80143A10[];       /* Effect state buffer (44 bytes) */

extern void func_800B90F8(void); /* Effect pre-reset */
extern void func_80096130(void*);      /* Effect pool clear */
extern void bzero(void*, s32);         /* func_80002790 */

void func_800B9130(s32 unused) {
    /* Clear effect state flags */
    D_80159818 = 0;
    D_80159B80 = 0;

    /* Call pre-reset function */
    func_800B90F8();

    /* Clear effect pools */
    func_80096130(D_80143A18);
    func_80096130(D_80143A20);
    func_80096130(D_80143A28);

    /* Zero out effect state buffer */
    bzero(D_80143A10, 44);
}

/*

/**
/*
 * sound_handles_clear (func_800B45BC)
 * Address: 0x800B45BC
 * Size: 176 bytes
 *
 * Iterates through an array of objects (32 bytes each) from
 * D_80116DE4 to D_80116FE4 and stops/clears sound handles
 * at offset 0x0C of each entry.
 *
 * @param clear_all If 0, only clear if entry[1] is 0
 */
extern u8 D_80116DE4[];       /* Object array base (32 bytes per entry) */

void sound_handles_clear(s32 clear_all) {
    u8 *entry;
    u8 *end_ptr;
    u8 *obj_ptr;
    s32 offset;
    void *sound_handle;
    s8 status;
    s8 flag;

    entry = D_80116DE4;
    end_ptr = D_80116DE4 + (10 * 32);  /* 10 entries * 32 bytes = 320 */

    while (entry != end_ptr) {
        /* Check if entry is active */
        status = *(s8*)entry;

        if (status != 0) {
            /* Check clear condition */
            if (clear_all != 0) {
                goto clear_sounds;
            }

            flag = *(s8*)(entry + 1);
            if (flag == 0) {
            clear_sounds:
                /* Clear sound handles at offsets 0x0C through 0x1C (5 handles) */
                obj_ptr = entry;
                for (offset = 0; offset < 20; offset += 4) {
                    sound_handle = *(void**)(obj_ptr + 0x0C);
                    if (sound_handle != NULL) {
                        func_800B358C(sound_handle, 0.0f);
                        *(void**)(obj_ptr + 0x0C) = NULL;
                    }
                    obj_ptr += 4;
                }

                /* Clear status byte */
                *(s8*)entry = 0;
            }
        }

        entry += 32;
    }
}

/*

/**
/*
 * players_race_update (func_800D5050)
 * Address: 0x800D5050
 * Size: 148 bytes
 *
 * Iterates through 6 player entries and calls func_800D4DFC
 * on each active player (entry[0x7C8] != 0 and entry[0x359] >= 2).
 *
 * Player entry layout:
 *   Base: D_8015A250
 *   Size: 2056 bytes per player (0x808)
 *   Race valid at offset 0x7C8 (s16)
 *   Status at offset 0x359 + (idx * 952) in secondary array D_80152818
 */
extern u8 D_80152818[];       /* Secondary player data */
extern void func_800D4DFC(void *menu); /* Process player race state */

void players_race_update(void) {
    s32 i;
    u8 *player_entry;
    s16 race_valid;
    s8 status;
    s32 secondary_offset;

    player_entry = D_8015A250;

    for (i = 0; i < 6; i++) {
        /* Check if player has valid race data at offset 0x7C8 */
        race_valid = *(s16*)(player_entry + 0x7C8);

        if (race_valid != 0) {
            /* Calculate offset into secondary array */
            secondary_offset = i * 952;

            /* Check status at secondary array offset 0x359 */
            status = *(s8*)(D_80152818 + secondary_offset + 0x359);

            if (status >= 2) {
                /* Process this player's race state */
                func_800D4DFC(player_entry);
            }
        }

        /* Move to next player entry */
        player_entry += 2056;
    }
}

/*

/**
/*
 * object_activate (func_800D52D4)
 * Address: 0x800D52D4
 * Size: 152 bytes
 *
 * Registers an object into the active system:
 *   1. Acquires sync lock
 *   2. Processes object with func_800D52CC
 *   3. If object[9] is set, calls cleanup func and clears it
 *   4. Adds to active list via func_80091FBC
 *   5. Sets object[8] = 1 to mark active
 *   6. Releases lock
 *
 * @param obj Object pointer, or -1 to do nothing
 */
extern u8 D_80142728[];       /* Sync structure */
extern u8 D_80146188[];       /* Object pool 1 */

extern void func_800D52CC(); /* Object pre-process */
extern void func_8009211C(void*, void*);  /* Object cleanup */
extern void func_80091FBC(void*, void*, void*);  /* Add to active list */

void object_activate(void *obj) {
    u8 *obj_ptr;
    s8 cleanup_flag;
    void *pool_data;

    /* Skip if null object marker */
    if ((s32)obj == -1) {
        return;
    }

    obj_ptr = (u8*)obj;

    /* Acquire sync lock */
    func_80007270(D_80142728, NULL, 1);

    /* Pre-process object */
    func_800D52CC();

    /* Check if object needs cleanup */
    cleanup_flag = obj_ptr[9];
    if (cleanup_flag != 0) {
        func_8009211C(D_80146188, obj);
        obj_ptr[9] = 0;
    }

    /* Add object to active list */
    pool_data = *(void**)(D_80146170 + 8);
    func_80091FBC(D_80146170, obj, pool_data);

    /* Mark object as active */
    obj_ptr[8] = 1;

    /* Release sync lock */
    func_800075E0(D_80142728, NULL, 0);
}

/*

/**
/*
 * players_frame_update (func_800D5798)
 * Address: 0x800D5798
 * Size: 144 bytes
 *
 * Clears D_801525F0, then iterates through all active players
 * (count at D_80152744) and calls func_800D5524 for each.
 * If game state has bit 0x0008 set, also calls func_800A13E8.
 */
extern s8  D_80152744;        /* Active player count */
/* D_8015A250 declared elsewhere - player entries */
extern void func_800D5524(void *menu); /* Per-player update */
extern void func_800A13E8(void);   /* Additional update (when bit 0x0008 set) */

void players_frame_update(void) {
    s32 i;
    s8 player_count;
    u8 *player_entry;

    /* Clear per-frame flag */
    D_801525F0 = 0;

    /* Get active player count */
    player_count = D_80152744;
    if (player_count <= 0) {
        goto check_state;
    }

    /* Update each active player */
    player_entry = D_8015A250;
    for (i = 0; i < player_count; i++) {
        func_800D5524(player_entry);
        player_entry += 2056;
    }

check_state:
    /* Check game state bit 0x0008 */
    if ((D_801174B4 & 0x0008) != 0) {
        return;
    }

    /* Call additional update function */
    func_800A13E8();
}

/*

/**
/*
 * players_finish_check (func_800D60B4)
 * Address: 0x800D60B4
 * Size: 172 bytes
 *
 * Iterates through players checking if they've completed the race.
 * Returns 1 if all active players have finished, 0 otherwise.
 */
extern s8  D_80117480;        /* Players finished count */
extern s8  D_80117484;        /* Expected finish count */

s32 players_finish_check(void) {
    s32 i;
    s8 player_count;
    s8 finished_count;
    u8 *player_entry;
    s8 status;

    player_count = D_80152744;
    if (player_count <= 0) {
        return 0;
    }

    finished_count = 0;
    player_entry = D_8015A250;

    for (i = 0; i < player_count; i++) {
        /* Check completion status at offset 0x7C8 */
        status = *(s8*)(player_entry + 0x7C9);  /* Finish flag */

        if (status != 0) {
            finished_count++;
        }

        player_entry += 2056;
    }

    D_80117480 = finished_count;

    /* Return 1 if all players finished */
    if (finished_count >= D_80117484) {
        return 1;
    }

    return 0;
}

/*

/**
/*
 * func_800C9334 - Clear a resource slot by ID
 * Address: 0x800C9334
 * Size: 72 bytes
 *
 * Clears the specified resource slot. If func_80097694 returns < 0,
 * allocates a new slot with func_80097798 and registers it.
 *
 * NOTE: Slot ID is passed in register t0, not a0.
 */
extern s32 resource_get_slot_state(s32, s32);   /* func_80097694 - Get slot state */
extern void resource_register_slot(s32 a0); /* func_8009638C - Register slot */

void resource_slot_clear(void) {
    register s32 slot_id asm("t0");  /* Slot ID in t0 */
    s32 result;

    /* Check slot state */
    result = resource_get_slot_state(slot_id, -1);

    if (result < 0) {
        /* Allocate new slot */
        result = func_80097798(slot_id, 0, 0, 0, 0);

        /* Register it */
        resource_register_slot(result);
    }
}

/*

/**
/*
 * resource_slots_clear_multiple - Clear multiple resource slots
 * (func_800C937C)
 * Address: 0x800C937C
 * Size: 48 bytes
 *
 * Clears slots 54, 58, and 59 by calling resource_slot_clear for each.
 */
void resource_slots_clear_multiple(void) {
    /* Clear slot 54 */
    {
        register s32 slot asm("t0") = 54;
        (void)slot;
        resource_slot_clear();
    }

    /* Clear slot 58 */
    {
        register s32 slot asm("t0") = 58;
        (void)slot;
        resource_slot_clear();
    }

    /* Clear slot 59 */
    {
        register s32 slot asm("t0") = 59;
        (void)slot;
        resource_slot_clear();
    }
}

/*

/**
/*
 * object_secondary_release - Release object's secondary reference
 * (func_800CB9A0)
 * Address: 0x800CB9A0
 * Size: 48 bytes
 *
 * Gets the object's primary pointer (offset 0), then its secondary
 * pointer (offset 4), and releases it if non-null.
 *
 * @param obj Object with nested pointer structure
 */
extern void object_ref_release(void*);  /* func_800A2680 - Release object */

void object_secondary_release(void *obj) {
    void *primary;
    void *secondary;

    primary = *(void**)obj;
    secondary = *(void**)((u8*)primary + 4);

    if (secondary != NULL) {
        object_ref_release(secondary);
    }
}

/*

/**
/*
 * func_800C7308 - Cleanup object render reference
 * Address: 0x800C7308
 * Size: 68 bytes
 *
 * Checks object's render reference at offset 0x2C and releases
 * the associated resource at offset 0x08 if active.
 *
 * @param obj_ptr Pointer to object pointer
 */
extern void render_resource_release(void*);  /* func_800A25C0 - Release render resource */

void object_render_cleanup(void *obj_ptr) {
    void *obj;
    void *render_ref;
    void *resource;

    obj = *(void**)obj_ptr;

    /* Check render reference at offset 0x2C */
    render_ref = *(void**)((u8*)obj + 0x2C);
    if (render_ref == NULL) {
        return;
    }

    /* Get resource at offset 0x08 */
    resource = *(void**)((u8*)obj + 0x08);
    if (resource != NULL) {
        render_resource_release(resource);
    }

    /* Clear render reference */
    *(void**)((u8*)obj + 0x2C) = NULL;
}

/*

/**
/*
 * stunt_command_send - Send command based on game mode
 * (func_800C55E4)
 * Address: 0x800C55E4
 * Size: 96 bytes
 *
 * If D_8015A110 is 4 or 6, sends a command via external handler.
 * Arguments are sign-extended from bytes to s32.
 *
 * @param cmd Command byte
 * @param arg1 Argument 1 byte
 * @param arg2 Argument 2 byte
 */
extern void external_command_handler(s32, s32, s32);  /* func_803914B4 - External command handler */

void stunt_command_send(s8 cmd, s8 arg1, s8 arg2) {
    s32 mode;

    mode = D_8015A110;

    /* Only send command in modes 4 or 6 */
    if (mode == 6 || mode == 4) {
        external_command_handler(0, 0, 0);
    }
}

/*

/**
/*
 * scene_cleanup_slots - Cleanup scene resource slots
 * (func_800C70BC)
 * Address: 0x800C70BC
 * Size: 84 bytes
 *
 * Gets slots 54, 58, 59 and calls resource_cleanup to clean up each.
 * This is the scene/level cleanup counterpart to resource_slots_clear_multiple.
 */
extern void resource_cleanup(s32 a0); /* func_800AC840 - Resource cleanup */

void scene_cleanup_slots(void) {
    s32 slot;

    /* Cleanup slot 54 */
    slot = resource_get_slot_state(54, -1);
    resource_cleanup(slot);

    /* Cleanup slot 58 */
    slot = resource_get_slot_state(58, -1);
    resource_cleanup(slot);

    /* Cleanup slot 59 */
    slot = resource_get_slot_state(59, -1);
    resource_cleanup(slot);
}

/*

/**
/*
 * player_cleanup_slots - Cleanup all player/game resource slots
 * (func_800C90E0)
 * Address: 0x800C90E0
 * Size: 112 bytes
 *
 * Loops through slots 22-37 (16 slots) and 38-53 (16 slots),
 * cleaning up each one that is active.
 */
void player_cleanup_slots(void) {
    s32 i;
    s32 slot;

    for (i = 0; i < 16; i++) {
        /* Cleanup slot (i + 38) in range 38-53 */
        slot = resource_get_slot_state(i + 38, -1);
        if (slot >= 0) {
            resource_cleanup(slot);
        }

        /* Cleanup slot (i + 22) in range 22-37 */
        slot = resource_get_slot_state(i + 22, -1);
        if (slot >= 0) {
            resource_cleanup(slot);
        }
    }
}

/*

/**
/*
 * sync_entry_register - Create and register sync entry
 * (func_800C9194)
 * Address: 0x800C9194
 * Size: 124 bytes
 *
 * Acquires sync on D_80142728, creates new entry via entry_allocate,
 * sets byte2=0, stores params at offsets 4 and 8, releases sync,
 * then signals D_801427A8 with the new entry.
 *
 * @param a0 Value to store at entry offset 4
 * @param a1 Value to store at entry offset 8
 */
void sync_entry_register(s32 a0, s32 a1) {
    void *entry;

    sync_acquire(&D_80142728[0], NULL, 1);

    entry = entry_allocate(0);
    *(u8*)((u8*)entry + 2) = 0;
    *(s32*)((u8*)entry + 4) = a0;
    *(u8*)((u8*)entry + 8) = (u8)a1;

    sync_release(&D_80142728[0], NULL, 0);
    sync_release(&D_80142728[0x80], entry, 0);
}

/*

/**
/*
 * init_single_mode_wrapper - Initialize with single flag
 * (func_800CC804)
 * Address: 0x800CC804
 * Size: 68 bytes
 *
 * Sets up register flags s0=1, s3=1 and calls core_initialization.
 * This is a wrapper for single-player or single-mode initialization.
 *
 * @param arg Passed in a0, stored to s1
 */
extern void core_initialization(void *menu); /* func_800CBF2C - Core initialization */

void init_single_mode_wrapper(void *arg) {
    /* Set flags and call core init */
    /* s0 = 1, s1 = arg, s3 = 1 passed to core_initialization */
    core_initialization(NULL);
}

/*

/**
/*
 * object_data_allocate (func_800CD748)
 * Address: 0x800CD748
 * Size: 80 bytes
 *
 * Allocates a data block at offset 0x6F4 (1780 + 4) of an object's
 * secondary structure and links it.
 *
 * Object structure:
 *   obj->field_0 (ptr) -> field_2C (ptr) -> field_0 (base)
 *   At base + 0x6F4, allocates 72 bytes via func_800B466C
 *   Then links via func_800A2504 with 76 bytes
 *
 * @param obj Object pointer with nested structure
 */
extern s32 func_800B466C(s32 streamId); /* Allocate block */
extern void func_800A2504(void *ptr1, void *ptr2, s32 flag);  /* Link block */

void object_data_allocate(void *obj) {
    void *primary;
    void *secondary;
    void *base;
    u8 *data_ptr;
    s32 result;
    void *resource;

    primary = *(void**)obj;

    /* Get secondary->field_2C->field_0 */
    secondary = *(void**)((u8*)primary + 0x2C);
    base = *(void**)secondary;

    /* Calculate data pointer at offset 0x6F4 (1780 + 4) */
    data_ptr = (u8*)base + 1780;

    /* Allocate 72 bytes at data_ptr + 4 */
    result = func_800B466C(0);

    /* Store result at data_ptr */
    *(s32*)data_ptr = result;

    /* Link the block */
    resource = *(void**)((u8*)primary + 0x08);
    func_800A2504(NULL, NULL, 0);
}

/*

/**
/*
 * object_action_clear (func_800D63C4)
 * Address: 0x800D63C4
 * Size: 40 bytes
 *
 * Calls func_8009211C with a0, then clears byte at a1+8.
 * This is a wrapper for stopping/clearing an object's action state.
 *
 * @param a0 First parameter for func_8009211C
 * @param a1 Object with flag at offset 8
 */
void object_action_clear(void *a0, void *a1) {
    func_8009211C(a0, NULL);
    *((u8*)a1 + 8) = 0;
}

/*

/**
/*
 * player_state_clear (func_800D5894)
 * Address: 0x800D5894
 * Size: 48 bytes
 *
 * If a0 is non-zero, calls func_800B358C and clears D_801541A4.
 * Used when transitioning out of a player state.
 *
 * @param a0 Player object (if non-NULL, triggers cleanup)
 */
extern s32 D_801541A4;  /* Player state variable */

void player_state_clear(void *a0) {
    if (a0 != NULL) {
        func_800B358C(a0, 0.0f);
        D_801541A4 = 0;
    }
}

/*

/**
/*
 * sound_position_set (func_800D03DC)
 * Address: 0x800D03DC
 * Size: 72 bytes
 *
 * Takes a position vector and applies each component to the sound system:
 * - Y coord (offset 4) via func_80090E9C
 * - X coord (offset 0) via func_80090F44
 * - Z coord (offset 8) via func_8009EA68
 *
 * @param pos 3D position vector (x=0, y=4, z=8)
 * @param a1 Sound handle/target parameter
 */
extern void func_80090E9C(void *handle, s32 volume);  /* Set sound volume */
extern void func_80090F44(f32, s32);  /* Set sound X position */
extern void func_8009EA68(f32, s32);  /* Set sound Z position */

void sound_position_set(f32 *pos, s32 a1) {
    func_80090E9C((void*)(long)*(s32*)&pos[1], a1);  /* Y coordinate */
    func_80090F44(pos[0], a1);  /* X coordinate */
    func_8009EA68(pos[2], a1);  /* Z coordinate */
}

/*

/**
/*
 * object_type7_create (func_800C878C)
 * Address: 0x800C878C
 * Size: 104 bytes
 *
 * Acquires sync on D_80142728, allocates via func_80091B00,
 * sets type to 7, releases sync, then registers with D_801427A8.
 *
 * Type 7 appears to be a specific object category.
 */
extern s32 D_801427A8;    /* Object registry B */

void object_type7_create(void) {
    void *obj;

    func_80007270(D_80142728, 0, 1);   /* Acquire sync */
    obj = func_80091B00(0);
    *((u8*)obj + 2) = 7;               /* Set type to 7 */
    func_800075E0(D_80142728, 0, 0);   /* Release sync */
    func_800075E0(obj, 0, 0);  /* Register object */
}

/*

/**
/*
 * object_type1_create (func_800C87F4)
 * Address: 0x800C87F4
 * Size: 104 bytes
 *
 * Same pattern as func_800C878C but sets type to 1 instead of 7.
 * Type 1 appears to be another object category.
 */
void object_type1_create(void) {
    void *obj;

    func_80007270(D_80142728, 0, 1);   /* Acquire sync */
    obj = func_80091B00(0);
    *((u8*)obj + 2) = 1;               /* Set type to 1 */
    func_800075E0(D_80142728, 0, 0);   /* Release sync */
    func_800075E0(obj, 0, 0);  /* Register object */
}

/*

/**
/*
 * physics_init_mode0 (func_800D6290)
 * Address: 0x800D6290
 * Size: 92 bytes
 *
 * Wrapper that saves s0-s5, f20, f22 and calls func_800D6160
 * with t0 = 0. This is likely a physics initialization mode.
 *
 * The register saves suggest the callee uses those registers.
 */
void physics_init_mode0(void) {
    /* t0 = 0 passed to callee (mode flag) */
    func_800D6160(0);
}

/*

/**
/*
 * physics_init_mode1 (func_800D62EC)
 * Address: 0x800D62EC
 * Size: 92 bytes
 *
 * Same wrapper as func_800D6290 but passes t0 = 1.
 * Different physics initialization mode.
 */
void physics_init_mode1(void) {
    /* t0 = 1 passed to callee (mode flag) */
    func_800D6160(1);
}

/*

/**
/*
 * object_type7_create_alt (func_800DB7B4)
 * Address: 0x800DB7B4
 * Size: 104 bytes
 *
 * Identical to object_type7_create. Both allocate a type 7 object
 * and register it. This may be called from different contexts.
 */
void object_type7_create_alt(void) {
    void *obj;

    func_80007270(D_80142728, 0, 1);   /* Acquire sync */
    obj = func_80091B00(0);
    *((u8*)obj + 2) = 7;               /* Set type to 7 */
    func_800075E0(D_80142728, 0, 0);   /* Release sync */
    func_800075E0(obj, 0, 0);  /* Register object */
}

/*

/**
/*
 * mode_enable_flagged (func_800DCD1C)
 * Address: 0x800DCD1C
 * Size: 52 bytes
 *
 * If (a0 & 7) is zero, returns early.
 * Otherwise calls func_800B5FC4 and sets s0[0] = 1.
 *
 * NOTE: Uses s0 register for output pointer (non-standard).
 *
 * @param a0 Mode flags - only acts if (a0 & 7) != 0
 */

void mode_enable_flagged(s32 a0) {
    if ((a0 & 7) != 0) {
        func_800B5FC4();
        /* s0[0] = 1 - requires register s0 to be set by caller */
    }
}

/*

/**
/*
 * sound_handles_array_clear (func_800DC720)
 * Address: 0x800DC720
 * Size: 116 bytes
 *
 * Iterates through an array of 5 entries (20 bytes, stride 4),
 * calling func_800B358C on each non-NULL entry at offset 12.
 * Then clears the first byte of the object.
 *
 * Object structure:
 *   byte 0: active flag
 *   offset 12: sound handle (4 bytes each, 5 entries)
 *
 * @param obj Object with sound handle array
 */
void sound_handles_array_clear(void *obj) {
    s32 i;
    u8 *ptr;
    void *handle;

    if (obj == NULL) {
        return;
    }

    /* Check active flag */
    if (*(s8*)obj == 0) {
        return;
    }

    ptr = (u8*)obj;
    for (i = 0; i < 20; i += 4) {
        handle = *(void**)(ptr + 12);
        if (handle != NULL) {
            func_800B358C(handle, 0.0f);
            *(void**)(ptr + 12) = NULL;
        }
        ptr += 4;
    }

    /* Clear active flag */
    *(u8*)obj = 0;
}

/*

/**
/*
 * sync_release_video (func_8008A6D0)
 * Address: 0x8008A6D0
 * Size: 44 bytes
 *
 * Simple wrapper that releases sync on D_801597D0 with
 * null parameters.
 */

void sync_release_video(void) {
    func_800075E0(D_801597D0, NULL, 0);
}

/*

/**
/*
 * dma_wait_thunk (func_8008AA20)
 * Address: 0x8008AA20
 * Size: 32 bytes
 *
 * Simple thunk to func_800205E4.
 * May be for ABI compatibility or code organization.
 */
extern void func_800205E4(void);

void dma_wait_thunk(void) {
    func_800205E4();
}

/*

/**
/*
 * resource_process_thunk (func_80098554)
 * Address: 0x80098554
 * Size: 32 bytes
 *
 * Simple thunk to func_80097CA0.
 */
extern void func_80097CA0(void);

void resource_process_thunk(void) {
    func_80097CA0();
}

/*

/**
/*
 * resource_slot_get (func_800AC820)
 * Address: 0x800AC820
 * Size: 32 bytes
 *
 * Wrapper that calls func_80097694(a0, -1).
 * Returns the slot ID for the given resource type.
 *
 * @param a0 Resource type ID
 * @return Slot ID or -1 if not found
 */
s32 resource_slot_get(s32 a0) {
    return func_80097694(a0, -1);
}

/*

/**
/*
 * object_type_byte2_get (func_800B3F00)
 * Address: 0x800B3F00
 * Size: 40 bytes
 *
 * Calls func_800B3D18 with t0=0, then returns byte at offset 2
 * from D_801597F0.
 *
 * @return Type byte 2 from current object
 */
extern void sound_update_channel(s32 channel, f32 volume); /* func_800B3D18 - Audio update/sync */
extern u8 *D_801597F0;            /* Current object pointer */

u8 object_type_byte2_get(void) {
    sound_update_channel(0, 0.0f);
    return *(D_801597F0 + 2);
}

/*

/**
/*
 * object_type_byte3_get (func_800B3F28)
 * Address: 0x800B3F28
 * Size: 40 bytes
 *
 * Same as object_type_byte2_get but returns byte at offset 3.
 *
 * @return Type byte 3 from current object
 */
u8 object_type_byte3_get(void) {
    sound_update_channel(0, 0.0f);
    return *(D_801597F0 + 3);
}

/*

/**
/*
 * func_800B7170 - Calculate difference with func_800B3FA4 result
 * Address: 0x800B7170
 * Size: 48 bytes
 *
 * Calls func_800B3FA4(a0, -1, 0.0f);
    return (s16)(a1 - (s16)result);
}

/*

/**
/*
 * replay_update_dual (func_800E2A3C)
 * Address: 0x800E2A3C
 * Size: 40 bytes
 *
 * Calls func_800E23A4 then func_800E1C30 with same a0.
 *
 * @param a0 Parameter passed to both functions
 */
extern void func_800E23A4(void *replay);
extern void func_800E1C30(void *replay, void *camera);

void replay_update_dual(s32 a0) {
    func_800E23A4(a0);
    func_800E1C30(a0, 0);
}

/*

/**
/*
 * object_byte26_set (func_80094F88)
 * Address: 0x80094F88
 * Size: 60 bytes
 *
 * If a0[26] != a1, sets a0[26] = a1 and calls func_80094EC8.
 * Returns the final value of a0[26].
 *
 * @param a0 Object pointer
 * @param a1 New value for byte at offset 26
 * @return Value at a0[26]
 */
extern void func_80094EC8(void *sndObj);

s8 object_byte26_set(void *a0, s8 a1) {
    s8 old_val = *((s8*)a0 + 26);

    if (old_val != a1) {
        *((s8*)a0 + 26) = a1;
        func_80094EC8(a0);
    }

    return *((s8*)a0 + 26);
}

/*

/**
/*
 * player_indexed_update (func_800A2D0C)
 * Address: 0x800A2D0C
 * Size: 56 bytes
 *
 * Gets player index from a1[0][16], calculates address in
 * D_80144D60 + index * 16, and calls func_80091FBC with
 * a0 and the value at offset 8 of that address.
 *
 * @param a0 First parameter for func_80091FBC
 * @param a1 Pointer to object with player index
 */
extern u8 D_80144D60[];  /* Player data array, 16 bytes each */

void player_indexed_update(void *a0, void *a1) {
    void *ptr = *(void**)a1;
    u8 player_idx = *((u8*)ptr + 16);
    u8 *player_data = D_80144D60 + (player_idx * 16);
    void *value = *(void**)(player_data + 8);
    func_80091FBC(a0, value, NULL);
}

/*

/**
/*
 * player_state_get (func_800AC898)
 * Address: 0x800AC898
 * Size: 60 bytes
 *
 * Calls func_80096288(a0, 0, 0);
 */
s8 player_state_get(s32 a0) {
    func_80096288(a0, 0, 0);
    return D_80156D39[a0 * 20];
}

/*

/**
/*
 * resource_type_select (func_800B5FC4)
 * Address: 0x800B5FC4
 * Size: 80 bytes
 *
 * Based on bit flags in a0:
 *   bit 0 set: uses resource type 46
 *   bit 1 set: uses resource type 37
 *   otherwise: uses resource type 38
 * Then calls func_80092360 with selected type.
 */

void resource_type_select(s32 a0) {
    s32 resource_type;

    if (a0 & 1) {
        resource_type = 46;
    } else if (a0 & 2) {
        resource_type = 37;
    } else {
        resource_type = 38;
    }

    func_80092360(resource_type);
}

/*

/**
/*
 * resource_alloc_conditional (func_800B61B0)
 * Address: 0x800B61B0
 * Size: 76 bytes
 *
 * Returns -1 if t7 is 0 or if a0 is -1.
 * Otherwise calls func_80092360 and returns its result.
 *
 * NOTE: Uses t7 register as condition (set by caller).
 *
 * @param a0 Resource type (returns -1 if -1)
 * @param a1 Second param for func_80092360
 * @param a2 Third param for func_80092360
 * @param a3 Fourth param (masked to 8 bits)
 * @return -1 on early exit, or result of func_80092360
 */
void resource_alloc_conditional(s32 a0, s32 a1, s32 a2, u8 a3) {
    /* t7 condition checked by caller, always enter here if t7 != 0 */
    if (a0 == -1) {
        return;
    }
    func_80092360(a0);
}

/*

/**
/*
 * player_flag_clear_process (func_800BC1E8)
 * Address: 0x800BC1E8
 * Size: 52 bytes
 *
 * Clears D_80143A10[0], loads player index from D_8015978C,
 * then calls func_800BB9B0(player_idx, 0, 1).
 */
extern s32 func_800BB9B0(f32 *pos, f32 *normal, f32 *height);

void player_flag_clear_process(void) {
    D_80143A10[0] = 0;
    func_800BB9B0(D_8015978C, 0, 1);
}

/*

/**
/*
 * collision_check_thunk (func_800EE88C)
 * Address: 0x800EE88C
 * Size: 32 bytes
 *
 * Simple thunk to func_800B82C8.
 */
extern void func_800B82C8(void *entityA, void *entityB, f32 *normal);

void collision_check_thunk(void) {
    func_800B82C8(NULL, NULL, NULL);
}

/*

/**
/*
 * resource_update_global (func_800A4B48)
 * Address: 0x800A4B48
 * Size: 36 bytes
 *
 * Loads value from D_80151A6C and calls func_80096238.
 */
extern s32 D_80151A6C;
extern void func_80096238(s32);

void resource_update_global(void) {
    func_80096238(D_80151A6C);
}

/*

/**
/*
 * object_process_thunk (func_800A7DF0)
 * Address: 0x800A7DF0
 * Size: 32 bytes
 *
 * Simple thunk to func_800A5B3C.
 */
extern void func_800A5B3C(void);

void object_process_thunk(void) {
    func_800A5B3C();
}

/*

/**
/*
 * stack_call_wrapper (func_800B4360)
 * Address: 0x800B4360
 * Size: 44 bytes
 *
 * Stores a1, a2, a3 on stack then calls func_80002CD0 with
 * a0, a1, and address of stack area containing a2, a3.
 *
 * @param a0 First parameter
 * @param a1 Second parameter
 * @param a2 Third parameter (passed via stack)
 * @param a3 Fourth parameter (passed via stack)
 */
extern void func_80002CD0(s32, s32, void*);

void stack_call_wrapper(s32 a0, s32 a1, s32 a2, s32 a3) {
    s32 stack_args[2];
    stack_args[0] = a2;
    stack_args[1] = a3;
    func_80002CD0(a0, a1, stack_args);
}

/*

/**
/*
 * mode_flags_clear (func_800BAF64)
 * Address: 0x800BAF64
 * Size: 44 bytes
 *
 * Clears D_80110680[0] and D_80110680[1], then calls func_800BADE0.
 */
extern u8 D_80110680[];  /* Mode/state flags */
extern void func_800BADE0(void *pairA, void *pairB);

void mode_flags_clear(void) {
    D_80110680[0] = 0;
    D_80110680[1] = 0;
    func_800BADE0(NULL, NULL);
}

/*

/**
/*
 * slot_deactivate (func_800AC840)
 * Address: 0x800AC840
 * Size: 88 bytes
 *
 * Calls func_80096288(a0, 0, 0), then calculates slot address
 * at D_80156D38 + (a0 * 20), calls func_800962D4 with slot[12],
 * and clears slot[2].
 *
 * @param a0 Slot index
 */
extern u8 D_80156D38[];  /* Slot array, 20 bytes per entry */
extern void func_800962D4(s32, s32);

void slot_deactivate(s32 a0) {
    u8 *slot;

    func_80096288(a0, 0, 0);

    slot = D_80156D38 + (a0 * 20);
    func_800962D4(*(s32*)(slot + 12), 1);
    slot[2] = 0;
}

/*

/**
/*
 * vector_copy_scale (func_8008B474)
 * Address: 0x8008B474
 * Size: 80 bytes
 *
 * Calls func_8008B424, then copies src vector to dst with
 * component-wise multiply by some factor (FPU ops).
 *
 * @param src Source 3D vector (12 bytes)
 * @param dst Destination 3D vector
 */
extern void func_8008B424(void);

void vector_copy_scale(f32 *src, f32 *dst) {
    func_8008B424();
    /* FPU operations: mul.s each component */
    dst[0] = src[0];  /* with multiplier */
    dst[1] = src[1];
    dst[2] = src[2];
}

/*

/**
/*
 * render_state_init (func_800A5B60)
 * Address: 0x800A5B60
 * Size: 80 bytes
 *
 * Clears several global variables and calls func_800A5A40.
 * Sets up initial render state with default values.
 */
extern s32 D_801613B4;    /* Render state 1 */
extern f32 D_801613B8;    /* Render float */
extern s16 D_80140618;    /* Mode short */
extern s32 D_801406B8;    /* Data pointer */
extern void func_800A5A40(void);

void render_state_init(void) {
    D_801613B4 = 0;
    D_8015B254 = -1;
    func_800A5A40();
    D_801613B8 = 1.0f;
    D_80140618 = 0;
    D_801406B8 = 0x8011EA18;  /* Constant pointer */
}

/*

/**
/*
 * vector_diff_process (func_800ACB74)
 * Address: 0x800ACB74
 * Size: 80 bytes
 *
 * Subtracts t0 vector from a3 vector, stores result on stack,
 * and calls func_800A61B0 with result pointer.
 *
 * NOTE: Uses t0 and a3 registers for input (non-standard ABI).
 */
extern void func_800A61B0(f32*);

void vector_diff_process(f32 *a3, f32 *t0) {
    f32 diff[3];

    diff[0] = a3[0] - t0[0];
    diff[1] = a3[1] - t0[1];
    diff[2] = a3[2] - t0[2];

    func_800A61B0(diff);
}

/*

/**
/*
 * lookup_with_output (func_80096B5C)
 * Address: 0x80096B5C
 * Size: 96 bytes
 *
 * If a0 != 0, calls func_80096B00 to get result.
 * If result is non-zero, returns result[4] and optionally
 * stores result[8] to *a2.
 * If result is zero, stores 0 to *a2 and returns 0.
 *
 * @param a0 Input key for lookup
 * @param a1 Unused
 * @param a2 Optional output pointer
 * @return Value at result[4] or 0
 */
extern void* func_80096B00(s32);

s32 lookup_with_output(s32 a0, s32 a1, s32 *a2) {
    void *result = NULL;

    if (a0 != 0) {
        result = func_80096B00(a0);
    }

    if (result == NULL) {
        if (a2 != NULL) {
            *a2 = 0;
        }
        return 0;
    }

    if (a2 != NULL) {
        *a2 = *(s32*)((u8*)result + 8);
    }
    return *(s32*)((u8*)result + 4);
}

/*

/**
/*
 * synced_process_call (func_800960D4)
 * Address: 0x800960D4
 * Size: 92 bytes
 *
 * Acquires sync on D_80152770, calls func_80095FD8(a0, 0),
 * then releases sync.
 *
 * @param a0 Parameter for func_80095FD8
 */
extern u8 D_80152770[];  /* Sync structure */
extern void func_80095FD8(s32, s32);

void synced_process_call(s32 a0, s32 a1) {
    func_80007270(D_80152770, 0, 1);
    func_80095FD8(a0, a1);
    func_800075E0(D_80152770, 0, 0);
}

/*

/**
/*
 * slot_activate (func_8009638C)
 * Address: 0x8009638C
 * Size: 92 bytes
 *
 * Similar to slot_deactivate but sets slot[2] = 1 instead of 0.
 * Calls func_80096288(a0, 0, 0), then func_800962D4(slot[12], 0),
 * then sets slot[2] = 1.
 *
 * @param a0 Slot index
 */
void slot_activate(s32 a0) {
    u8 *slot;

    func_80096288(a0, 0, 0);

    slot = D_80156D38 + (a0 * 20);
    func_800962D4(*(s32*)(slot + 12), 0);
    slot[2] = 1;
}

/*

/**
/*
 * conditional_synced_clear (func_800A0F74)
 * Address: 0x800A0F74
 * Size: 104 bytes
 *
 * If t6 (condition) is non-zero:
 *   - Acquires sync on D_80152770
 *   - Calls func_80095FD8(0x8039A400, 0)
 *   - Releases sync
 *   - Clears D_8011ED04
 *
 * NOTE: Uses t6 register as condition (set by caller).
 */
extern u8 D_8011ED04;  /* Mode flag */

void conditional_synced_clear(s32 condition) {
    if (condition != 0) {
        func_80007270(D_80152770, 0, 1);
        func_80095FD8(0x8039A400, 0);
        func_800075E0(D_80152770, 0, 0);
        D_8011ED04 = 0;
    }
}

/*

/**
/*
 * complex_init_multi (func_800A11E4)
 * Address: 0x800A11E4
 * Size: 96 bytes
 *
 * Uses registers s0, s1, s2, s3, s4 set by caller.
 * If s3[0] == 0:
 *   - Calls func_800A0FDC(s0, a2-s0)
 *   - Calls func_800962D4(result, 0)
 *   - Calls func_800026C0(s4, s0, 1)
 *   - Calls func_80008590(s2, s1-s2)
 *   - Sets s3[0] = 1
 *
 * NOTE: Heavy use of callee-saved registers for parameters.
 */
extern s32 func_800A0FDC(s32, s32);
extern void func_800026C0(s32, s32, s32);
extern void func_80008590(s32, s32);

void complex_init_multi(s32 s0, s32 s1, s32 s2, s8 *s3, s32 s4, s32 a2) {
    if (*s3 == 0) {
        s32 result = func_800A0FDC(s0, a2 - s0);
        func_800962D4(result, 0);
        func_800026C0(s4, s0, 1);
        func_80008590(s2, s1 - s2);
        *s3 = 1;
    }
}

/*

/**
/*
 * object_transform_set (func_800AB758)
 * Address: 0x800AB758
 * Size: 120 bytes
 *
 * Calculates object address from a0 * 64 + t7, calls func_8008D6B0,
 * then copies two 3D vectors into the object structure:
 *   - a2 vector to offset 40-48 (position)
 *   - a1 vector to offset 52-60 (rotation)
 *
 * NOTE: Uses t7 register as base address (set by caller).
 *
 * @param a0 Object index (multiplied by 64)
 * @param a1 Rotation vector (12 bytes)
 * @param a2 Position vector (12 bytes)
 * @param a3 Parameter for func_8008D6B0
 */
void object_transform_set(s32 a0, f32 *rotation, f32 *position, void *a3, u8 *base) {
    u8 *obj = base + (a0 * 64);

    func_8008D6B0(a3, obj + 4);

    /* Copy position vector to offset 40 */
    *(f32*)(obj + 40) = position[0];
    *(f32*)(obj + 44) = position[1];
    *(f32*)(obj + 48) = position[2];

    /* Copy rotation vector to offset 52 */
    *(f32*)(obj + 52) = rotation[0];
    *(f32*)(obj + 56) = rotation[1];
    *(f32*)(obj + 60) = rotation[2];
}

/*

/**
/*
 * fp_call_wrapper (func_800AC6F4)
 * Address: 0x800AC6F4
 * Size: 104 bytes
 *
 * Saves all callee-saved registers, sets fp=a0 and t0=0,
 * calls func_80096CA8, then restores registers.
 *
 * @param a0 Value to pass in fp register
 */
extern void func_80096CA8(void);

void fp_call_wrapper(s32 a0) {
    /* fp = a0, t0 = 0 passed to callee */
    func_80096CA8();
}

/*

/**
/*
 * memory_regions_clear (func_800F7E70)
 * Address: 0x800F7E70
 * Size: 64 bytes
 *
 * Clears D_80159428 (16 bytes) and D_8015256C (4 bytes) using bzero.
 */
extern u8 D_8015256C[];  /* 4-byte buffer */

void memory_regions_clear(void) {
    bzero(D_80159428, 16);
    bzero(D_8015256C, 4);
}

/*

/**
/*
 * game_state_check_handler (func_800FBBFC)
 * Address: 0x800FBBFC
 * Size: 52 bytes
 *
 * Calls func_8000BE50(0), if result == 7, calls game_mode_handler.
 */
extern s32 func_8000BE50(s32);

void game_state_check_handler(void) {
    s32 state = func_8000BE50(0);
    if (state == 7) {
        game_mode_handler();
    }
}

/*

/**
/*
 * resource_type_select_simple (func_800FEC60)
 * Address: 0x800FEC60
 * Size: 60 bytes
 *
 * If bit 0 of a0 is set, uses resource type 46.
 * Otherwise uses resource type 38.
 * Then calls func_80092360.
 *
 * @param a0 Mode flags
 */
void resource_type_select_simple(s32 a0) {
    s32 resource_type;

    if (a0 & 1) {
        resource_type = 46;
    } else {
        resource_type = 38;
    }

    func_80092360(resource_type);
}

/*

/**
/*
 * mode_byte_set (func_800ED764)
 * Address: 0x800ED764
 * Size: 80 bytes
 *
 * If a0 (as signed 16-bit) is negative:
 *   - Calls func_800B3D18 with t0=0
 *   - Sets D_80159B70 = D_801597F0[8]
 * Otherwise:
 *   - Sets D_80159B70 = a0
 *
 * @param a0 Mode value or -1 to use current object
 */

void mode_byte_set(s16 a0) {
    if (a0 < 0) {
        sound_update_channel(0, 0.0f);
        D_80159B70 = *(D_801597F0 + 8);
    } else {
        D_80159B70 = (u8)a0;
    }
}

/*

/**
/*
 * mode_byte2_set (func_800ED7B4)
 * Address: 0x800ED7B4
 * Size: 80 bytes
 *
 * Same as mode_byte_set but reads offset 4 and writes to D_80159B60.
 *
 * @param a0 Mode value or -1 to use current object
 */
extern u8 D_80159B60;  /* Mode byte 2 */

void mode_byte2_set(s16 a0) {
    if (a0 < 0) {
        sound_update_channel(0, 0.0f);
        D_80159B60 = *(D_801597F0 + 4);
    } else {
        D_80159B60 = (u8)a0;
    }
}

/*

/**
/*
 * sync_init_conditional (func_800EE7C4)
 * Address: 0x800EE7C4
 * Size: 92 bytes
 *
 * If t6 (condition) is zero:
 *   - Sets D_801147C0 = 1
 *   - Calls func_80006A00(D_801461D0, D_801461FC, 1)
 *   - Releases sync on D_801461D0
 * Always sets D_80159DA0 = -1
 *
 * NOTE: Uses t6 register as condition (set by caller).
 */
extern u8 D_801147C0;   /* Init flag */
extern u8 D_801461FC[]; /* Data pointer */
extern void func_80006A00(void*, void*, s32);

void sync_init_conditional(s32 condition) {
    if (condition == 0) {
        D_801147C0 = 1;
        func_80006A00(&D_801461D0, D_801461FC, 1);
        func_800075E0(&D_801461D0, NULL, 0);
    }
    D_80159DA0 = -1;
}

/*

/**
/*
 * object_update_full (func_800E2A64)
 * Address: 0x800E2A64
 * Size: 96 bytes
 *
 * Calls 8 functions in sequence with the same object parameter:
 *   func_800CF06C, func_800E23A4, func_800E1C30, func_800E1AA0,
 *   func_800E15A0, func_800E1540, func_800E114C, func_800D0424
 *
 * This is likely a full object update/tick function.
 *
 * @param a0 Object pointer
 */
extern void func_800CF06C(void *menu);
extern void func_800E1AA0(void *replay, void *frame);
extern void func_800E15A0(void *replay);
extern void func_800E1540(void *entity);
extern void func_800E114C(void *replay);
extern void func_800D0424(void *menu, void *input);

void object_update_full(void *obj) {
    func_800CF06C(obj);
    func_800E23A4(0);
    func_800E1C30(0, 0);
    func_800E1AA0(obj, 0);
    func_800E15A0(obj);
    func_800E1540(obj);
    func_800E114C(obj);
    func_800D0424(obj, 0);
}

/*

/**
/**
/**
/*
 * object_counter_decrement (func_800E7914)
 * Address: 0x800E7914
 * Size: 108 bytes
 *
 * Acquires sync, looks up object by ID, decrements counter at offset 22
 * if it's positive, then releases sync.
 *
 * @param id Object ID to look up
 */
extern void *func_80095F8C(s32);
extern void *func_80095EF4(void*, void*, s32);

void object_counter_decrement(s32 id) {
    void *obj;
    u8 counter;

    func_80007270(&D_80152770, NULL, 1);
    obj = func_80095F8C(id);
    obj = func_80095EF4(obj, NULL, 0);
    counter = *((u8*)obj + 22);
    if (counter > 0) {
        *((u8*)obj + 22) = counter - 1;
    }
    func_800075E0(&D_80152770, NULL, 0);
}

/*

/**
/*
 * object_counter_increment (func_800E7980)
 * Address: 0x800E7980
 * Size: 112 bytes
 *
 * Acquires sync, looks up object by ID, increments counter at offset 22
 * if it's less than 255, then releases sync.
 *
 * @param id Object ID to look up
 */
void object_counter_increment(s32 id) {
    void *obj;
    u8 counter;

    func_80007270(&D_80152770, NULL, 1);
    obj = func_80095F8C(id);
    obj = func_80095EF4(obj, NULL, 0);
    counter = *((u8*)obj + 22);
    if (counter < 255) {
        *((u8*)obj + 22) = counter + 1;
    }
    func_800075E0(&D_80152770, NULL, 0);
}

/*

/**
/**
/*
 * pointer_offset_wrapper (func_8008AD48)
 * Address: 0x8008AD48
 * Size: 36 bytes
 *
 * Adds 4 to both pointers and calls func_8008AD04.
 * Used for skipping header bytes in data structures.
 *
 * @param a0 First pointer (offset by 4)
 * @param a1 Second pointer (offset by 4)
 */
extern s32 func_8008AD04(u8 *a0, u8 *a1);

void pointer_offset_wrapper(void *a0, void *a1) {
    func_8008AD04(0, 0);
}

/*

/**
/*
 * sign_extend_call (func_8008E398)
 * Address: 0x8008E398
 * Size: 40 bytes
 *
 * Sign-extends the third parameter from 16 bits and calls func_8008E26C.
 *
 * @param a0 First parameter (passed through)
 * @param a1 Second parameter (passed through)
 * @param a2 16-bit value to sign-extend
 */
extern void* func_8008E26C(s32 arg);

void sign_extend_call(void *a0, void *a1, s16 a2) {
    func_8008E26C(0);
}

/*

/**
/*
 * sound_call_simple (func_80090228)
 * Address: 0x80090228
 * Size: 44 bytes
 *
 * Sign-extends parameter and calls func_80090088 with a2=0.
 *
 * @param a0 16-bit value to sign-extend
 */

void sound_call_simple(s16 a0) {
    func_80090088(a0, NULL, 0);
}

/*

/**
/*
 * sound_call_minimal (func_80090254)
 * Address: 0x80090254
 * Size: 48 bytes
 *
 * Sign-extends parameter and calls func_80090088 with a1=NULL, a2=0.
 *
 * @param a0 16-bit value to sign-extend
 */
void sound_call_minimal(s16 a0) {
    func_80090088(a0, NULL, 0);
}

/*

/**
/*
 * pointer_compare_thunk (func_8009508C)
 * Address: 0x8009508C
 * Size: 32 bytes
 *
 * Calls func_8008AD04 with unchanged parameters.
 *
 * @param a0 First pointer
 * @param a1 Second pointer
 */
void pointer_compare_thunk(void *a0, void *a1) {
    func_8008AD04(a0, a1);
}

/*

/**
/**
/**
/**
/**
/**
/*
 * object_derived_call (func_800A2CE4)
 * Address: 0x800A2CE4
 * Size: 40 bytes
 *
 * Loads pointer from a0->0, then gets value at offset 64 of that,
 * and calls func_800A2990 with (a0, 0, value).
 *
 * @param a0 Pointer to pointer
 */
extern void func_800A2990(void*, s32, s32);

void object_derived_call(void **a0) {
    void *ptr = *a0;
    s32 val = *(s32*)((u8*)ptr + 64);
    func_800A2990(a0, 0, val);
}

/*

/**
/**
/*
 * pointer_offset8_call (func_800986B0)
 * Address: 0x800986B0
 * Size: 36 bytes
 *
 * Calls func_80098620 with (a0+8, original_a1).
 *
 * @param a0 Base pointer
 * @param a1 Parameter moved to a2
 */
extern void func_80098620(void*, void*, void*);

void pointer_offset8_call(void *a0, void *a1) {
    func_80098620(NULL, NULL, NULL);
}

/*

/**
/**
/*
 * param_reshuffle_wrapper (func_800985F4)
 * Address: 0x800985F4
 * Size: 44 bytes
 *
 * Reorganizes parameters and calls func_80098574.
 *
 * @param a0 Base object
 * @param a1 Moved to a3
 */
extern void func_80098574(void*, void*, void*, void*);

void param_reshuffle_wrapper(void *a0, void *a1) {
    s32 temp = 0;
    void *val = *(void**)((u8*)a0 + 8);
    func_80098574(a0, val, &temp, a1);
}

/*

/**
/**
/**
/*
 * callback_init (func_80100D30)
 * Address: 0x80100D30
 * Size: 44 bytes
 *
 * Stores D_801146FC at a0+4, calls func_80094EC8, returns 1.
 *
 * @param a0 Object to initialize
 * @return Always returns 1
 */
extern void *D_801146FC;  /* Callback pointer */

s32 callback_init(void *a0) {
    *(void**)((u8*)a0 + 4) = &D_801146FC;
    func_80094EC8(a0);
    return 1;
}

/*

/**
/*
 * sync_acquire_menu (func_8010FBB4)
 * Address: 0x8010FBB4
 * Size: 44 bytes
 *
 * Acquires sync on D_80152750 with flags (0, 1).
 */
extern void *D_80152750;  /* Sync object */

void sync_acquire_menu(void) {
    func_80007270(&D_80152750, NULL, 1);
}

/*

/**
/*
 * struct_fields_init (func_800B0550)
 * Address: 0x800B0550
 * Size: 48 bytes
 *
 * Stores parameters into structure fields and calls func_800B04D0.
 * Structure layout: byte at 0, s32 at 4, s32 at 8, s32 at 12.
 *
 * @param a0 Structure pointer
 * @param a1 Stored at offset 12
 * @param a2 Stored at offset 8
 * @param a3 Stored at offset 4
 * @param stack Byte from stack stored at offset 0
 */
void struct_fields_init(void *a0, s32 a1, s32 a2, s32 a3, u8 stack) {
    *(s32*)((u8*)a0 + 12) = a1;
    *(s32*)((u8*)a0 + 4) = a3;
    *(s32*)((u8*)a0 + 8) = a2;
    *(u8*)a0 = stack;
    func_800B04D0(a0);
}

/*

/**
/**
/**
/**
/*
 * validate_and_call (func_80095120)
 * Address: 0x80095120
 * Size: 52 bytes
 *
 * If either a0 or a1 is NULL, returns -1.
 * Otherwise calls func_800950AC with a2=15.
 *
 * @param a0 First pointer (must be non-NULL)
 * @param a1 Second pointer (must be non-NULL)
 * @return -1 if invalid, otherwise result of func_800950AC
 */
extern s32 func_800950AC(void*, void*, s32);

s32 validate_and_call(void *a0, void *a1) {
    if (a0 == NULL || a1 == NULL) {
        return -1;
    }
    return func_800950AC(a0, a1, 15);
}

/*

/**
/*
 * diff_halved_calc (func_800B71A0)
 * Address: 0x800B71A0
 * Size: 52 bytes
 *
 * Similar to func_800B7170 but divides result by 2 before subtracting.
 *
 * @param a0 First parameter
 * @param a1 Value whose high halfword is used
 * @return (s16)(a1 >> 16) - (result / 2)
 */
s16 diff_halved_calc(void *a0, s32 a1) {
    s16 original = (s16)(a1 >> 16);
    s16 result = func_800B3FA4(a0, -1, 0.0f);
    return original - (result >> 1);
}

/*

/**
/**
/**
/*
 * object_init_cleared (func_800AED2C)
 * Address: 0x800AED2C
 * Size: 56 bytes
 *
 * If a1 is NULL returns 0. Otherwise calls func_8009211C,
 * clears byte at a1+8, returns a1.
 *
 * @param a0 First parameter
 * @param a1 Object pointer
 * @return 0 if a1 is NULL, otherwise a1
 */
void *object_init_cleared(void *a0, void *a1) {
    if (a1 == NULL) {
        return NULL;
    }
    func_8009211C(a0, a1);
    *((u8*)a1 + 8) = 0;
    return a1;
}

/*

/**
/**
/*
 * vector3d_store_transform (func_8008B660)
 * Address: 0x8008B660
 * Size: 60 bytes
 *
 * Stores f12, f14, f16 at a1+36/40/44, calls func_8008B4C4,
 * then stores f20, f22, f24 at same offsets.
 * Uses floating-point register parameters for 3D vector input/output.
 *
 * @param a0 Unused in this wrapper
 * @param a1 Object to store vector in
 * @param f12 X component
 * @param f14 Y component
 * @param f16 Z component
 */
extern void func_8008B4C4(f32 *a, f32 *b, f32 *out);

void vector3d_store_transform(void *a0, void *a1, f32 x, f32 y, f32 z) {
    f32 *vec = (f32*)((u8*)a1 + 36);
    vec[0] = x;
    vec[1] = y;
    vec[2] = z;
    func_8008B4C4(vec, 0, 0);
    /* Output stored in f20, f22, f24 by callee - stored back by asm */
}

/*

/**
/*
 * slot_value_get (func_80096298)
 * Address: 0x80096298
 * Size: 60 bytes
 *
 * Calls func_80096288(a0, 0, 0), then returns D_80156D44[a0 * 5].
 * Slot array entries are 20 bytes each.
 *
 * @param a0 Slot index
 * @return Value from slot array at computed offset
 */

void *slot_value_get(s32 a0) {
    func_80096288(a0, 0, 0);
    return D_80156D44[a0 * 5];
}

/*

/**
/*
 * conditional_reset_callbacks (func_80096240)
 * Address: 0x80096240
 * Size: 72 bytes
 *
 * If a1 == -1, returns immediately.
 * Otherwise calls func_80018E2C, func_800154A4, func_80096130,
 * and sets D_8011EAA0 = -1.
 *
 * @param a0 Unused
 * @param a1 If -1, skip processing
 */
extern void func_80018E2C(s32);
extern void func_800154A4(void);
extern s32 D_8011EAA0;    /* State variable */

void conditional_reset_callbacks(s32 a0, s32 a1) {
    if (a1 == -1) {
        return;
    }
    func_80018E2C(a1);
    func_800154A4();
    func_80096130(D_80151AD4);
    D_8011EAA0 = -1;
}

/*

/**
/**
/**
/**
/**
/*
 * resource_request_40_or_39 (func_800B5F4C)
 * Address: 0x800B5F4C
 * Size: 60 bytes
 *
 * If bit 0x400 is set in a0, requests resource 40.
 * Otherwise requests resource 39.
 * Calls func_80092360(type).
 *
 * @param a0 Flags to check
 */

void resource_request_40_or_39(s32 a0) {
    s32 type = (a0 & 0x400) ? 40 : 39;
    func_80092360(type);
}

/*

/**
/*
 * resource_request_41_or_44 (func_800B5F88)
 * Address: 0x800B5F88
 * Size: 60 bytes
 *
 * If bit 0x1000 is set in a0, requests resource 41.
 * Otherwise requests resource 44.
 * Calls func_80092360(type).
 *
 * @param a0 Flags to check
 */
void resource_request_41_or_44(s32 a0) {
    s32 type = (a0 & 0x1000) ? 41 : 44;
    func_80092360(type);
}

/*

/**
/**
/*
 * dual_call_reshuffled (func_800BE4B4)
 * Address: 0x800BE4B4
 * Size: 60 bytes
 *
 * Stores parameters, calls func_800B74A0(a2, 0),
 * then calls func_800B71D4 with halfwords from a0, a1 and original a3.
 *
 * @param a0 First value (low halfword used)
 * @param a1 Second value (low halfword used)
 * @param a2 Parameter for first call
 * @param a3 Third parameter passed through
 */

void dual_call_reshuffled(s32 a0, s32 a1, s32 a2, void *a3) {
    func_800B74A0(a2, 0);
    func_800B71D4();
}

/*

/**
/*
 * object_byte9_set (func_800B41C0)
 * Address: 0x800B41C0
 * Size: 64 bytes
 *
 * Sign-extends a0 to byte, calls func_800B3D18,
 * saves old byte at D_801597F0+9, stores new value, returns old.
 *
 * @param a0 New value (sign-extended to byte)
 * @return Previous value at offset 9
 */
s8 object_byte9_set(s8 a0) {
    s8 old;
    sound_update_channel(0, 0.0f);
    old = *((s8*)D_801597F0 + 9);
    *((s8*)D_801597F0 + 9) = a0;
    return old;
}

/*

/**
/*
 * resource_lookup_synced (func_80097470)
 * Address: 0x80097470
 * Size: 124 bytes
 *
 * Acquires sync on D_80152770, looks up resource via func_80097384.
 * If a0 is 0, uses D_801527C8 as default lookup key.
 * Releases sync and returns result.
 *
 * @param a0 Lookup mode (0 = use default)
 * @param a1 Resource parameter
 * @return Lookup result
 */
extern void **D_801527C8;
extern void *func_80097384(void*, void*);

void *resource_lookup_synced(s32 a0, void *a1) {
    void *result;
    void *lookup;

    func_80007270(&D_80152770[0], NULL, 1);

    if (a0 != 0) {
        lookup = (void*)a0;
    } else {
        lookup = D_801527C8;
    }

    result = func_80097384(a1, lookup);

    func_800075E0(&D_80152770[0], NULL, 0);

    return result;
}

/*

/**
/*
 * resource_alloc_init (func_8010FC80)
 * Address: 0x8010FC80
 * Size: 64 bytes
 *
 * Calls resource_lookup_synced(0, original_a0), then func_800962D4(result, 0).
 * Returns result from first call.
 *
 * @param a0 First parameter
 * @param a1 Second parameter (passed to resource_lookup_synced)
 * @return Result from resource_lookup_synced
 */

void *resource_alloc_init(void *a0, void *a1) {
    void *result = resource_lookup_synced(0, a0);
    func_800962D4(result, 0);
    return result;
}

/*

/**
/*
 * func_800D54E0 - Conditional function call based on a1
 * Address: 0x800D54E0
 * Size: 68 bytes
 *
 * If a1 is zero, calls func_80091C04(*a0).
 * Otherwise calls func_800BF024(*a0).
 * Then calls func_800D54BC(a0).
 *
 * @param a0 Pointer to pointer
 * @param a1 Mode selector
 */
/**
/*
 * physics_struct_reset (func_800D54BC)
 * Address: 0x800D54BC
 * Size: 36 bytes (leaf function, no prologue)
 *
 * Sets field0 to -1 and fields 4,8,12,16 to -2.0f.
 * Used to reset physics/collision state structures.
 *
 * @param a0 Structure pointer to initialize
 */
void physics_struct_reset(void *a0) {
    *(s32*)a0 = -1;
    *(f32*)((u8*)a0 + 4) = -2.0f;
    *(f32*)((u8*)a0 + 8) = -2.0f;
    *(f32*)((u8*)a0 + 12) = -2.0f;
    *(f32*)((u8*)a0 + 16) = -2.0f;
}

/*

/**
/*
 * synced_lookup_process (func_800BF024)
 * Address: 0x800BF024
 * Size: 128 bytes
 *
 * Acquires sync on D_80142728, looks up via func_80091BA8.
 * If found, calls func_800BF01C with field64, releases sync,
 * then calls func_80091C04. If not found, just releases sync.
 *
 * @param a0 Key to look up and process
 */
extern void func_800BF01C();
extern void *func_80091BA8(void*, void*);

void synced_lookup_process(void *a0) {
    void *result;

    func_80007270(&D_80142728[0], NULL, 1);

    result = func_80091BA8(a0, &D_80142728[0]);

    if (result == NULL) {
        func_800075E0(&D_80142728[0], NULL, 0);
        return;
    }

    func_800BF01C();
    func_800075E0(&D_80142728[0], NULL, 0);
    func_80091C04(a0);
}

/*

/**
/*
 * resource_register_synced (func_80091C04)
 * Address: 0x80091C04
 * Size: 160 bytes
 *
 * Acquires sync on D_80142728, looks up key via func_80091BA8.
 * If found, calls func_80091B00, sets result->byte2 = 6,
 * stores original key at offset 4, increments counter at offset 26.
 * Then releases sync and optionally signals D_801427A8.
 *
 * @param a0 Key to register
 */
void resource_register_synced(void *a0) {
    void *result;
    void *savedResult;

    func_80007270(&D_80142728[0], NULL, 1);

    result = func_80091BA8(a0, NULL);
    savedResult = NULL;

    if (result != NULL) {
        func_80091B00(0);
        *(u8*)((u8*)result + 2) = 6;
        *(void**)((u8*)result + 4) = a0;
        (*(u8*)((u8*)a0 + 26))++;
        savedResult = result;
    }

    func_800075E0(&D_80142728[0], NULL, 0);

    if (savedResult != NULL) {
        func_800075E0(&D_80142728[0x80], savedResult, 0);
    }
}

/*

void conditional_call_with_init(void **a0, s32 a1) {
    if (a1 != 0) {
        synced_lookup_process(*a0);
    } else {
        resource_register_synced(*a0);
    }
    physics_struct_reset(a0);
}

/*

/**
/*
 * struct_init_and_call (func_8010FD1C)
 * Address: 0x8010FD1C
 * Size: 68 bytes
 *
 * If a1 is zero, returns 1 without doing anything.
 * Otherwise initializes D_80153F10 structure and calls func_8008ABE4.
 *
 * @param a0 Stored at offset 8
 * @param a1 Stored as halfword at offset 2 (if non-zero)
 * @param a2 Stored at offset 12
 * @return Always 1
 */
extern void *D_80153F10;  /* Structure base */
extern s32 func_8008ABE4(void);

s32 struct_init_and_call(void *a0, s16 a1, void *a2) {
    u8 *base;
    if (a1 == 0) {
        return 1;
    }
    base = (u8*)&D_80153F10;
    *(void**)(base + 8) = a0;
    *(s16*)(base + 2) = a1;
    *(void**)(base + 12) = a2;
    *(s16*)(base + 4) = 0;
    *base = 1;
    func_8008ABE4();
    return 1;
}

/*

/**
/*
 * object_bytes23_sum (func_800B7128)
 * Address: 0x800B7128
 * Size: 72 bytes
 *
 * Calls func_800B3D18 twice, gets bytes at offset 2 and 3
 * of D_801597F0, returns their sum as s16.
 *
 * @return (s16)(D_801597F0[2] + D_801597F0[3])
 */
s16 object_bytes23_sum(void) {
    u8 byte2, byte3;
    sound_update_channel(0, 0.0f);
    byte2 = *((u8*)D_801597F0 + 2);
    sound_update_channel(0, 0.0f);
    byte3 = *((u8*)D_801597F0 + 3);
    return (s16)(byte2 + byte3);
}

/*

/**
/*
 * object_byte71_set_sync (func_800CDA90)
 * Address: 0x800CDA90
 * Size: 80 bytes
 *
 * Gets object chain a0->0->44->0, if byte at +71 differs from a1,
 * sets it to a1 and calls func_800A2504 to sync.
 *
 * @param a0 Object pointer chain
 * @param a1 New byte value
 */

void object_byte71_set_sync(void **a0, u8 a1) {
    void *obj = *a0;
    void *inner = *(void**)((u8*)obj + 44);
    void *data = *(void**)inner;
    u8 *target = (u8*)data + 71;

    if (*target != a1) {
        *target = a1;
        obj = *a0;
        inner = *(void**)((u8*)obj + 44);
        func_800A2504(*(void**)((u8*)obj + 8), (u8*)*(void**)inner + 71, 1);
    }
}

/*

/**
/**
/**
/*
 * func_800BE9A0 - Build buffer and call B71D4
 * Address: 0x800BE9A0
 * Size: 72 bytes
 *
 * Builds a local buffer via func_800BE7BC, then calls func_800B71D4
 * with halfwords from stored parameters.
 *
 * @param a0 First value (high halfword used)
 * @param a1 Second value (high halfword used)
 * @param a2 Parameter for first call (sign-extended)
 * @param a3 Second parameter for first call
 */
extern void func_800BE7BC(void *camera, void *target);

void buffer_build_and_call(s32 a0) {
    u8 buffer[128];
    func_800BE7BC(buffer, NULL);
    func_800B71D4();
}

/*

/**
/*
 * buffer_build_2cd0_call (func_800BE9E8)
 * Address: 0x800BE9E8
 * Size: 72 bytes
 *
 * Builds a local buffer via func_80002CD0, then calls func_800B71D4
 * with halfwords from stored parameters.
 *
 * @param a0 First value (high halfword used)
 * @param a1 Second value (high halfword used)
 * @param a2 Buffer parameter
 * @param a3 Third parameter stored at offset
 */
void buffer_build_2cd0_call(s32 a0, s32 a1, void *a2, s32 a3) {
    u8 buffer[256];
    s32 args[1];
    args[0] = a3;
    func_80002CD0(buffer, a2, args);
    func_800B71D4();
}

/*

/**
/*
 * init_wait_completion (func_800A4C54)
 * Address: 0x800A4C54
 * Size: 84 bytes
 *
 * Calls initialization chain then loops until func_800202C4 returns non-zero.
 */
extern void func_800A4B6C(void);
extern void func_80020274(void);
extern s32 func_800202C4(void);

void init_wait_completion(void) {
    func_800A4B6C();
    func_80096238(D_80151A6C);
    func_80020274();
    while (func_800202C4() == 0) {
        /* Wait for completion */
    }
}

/*

/**
/*
 * list_process_and_call (func_800B0618)
 * Address: 0x800B0618
 * Size: 84 bytes
 *
 * Loops through D_801491F0 linked list calling func_8009079C(item, 1),
 * then calls func_800B0580.
 */
extern void func_8009079C(void *a0, s32 a1);

void list_process_and_call(s32 trackId, void *ghostData) {
    void *item = D_801491F0;
    while (item != NULL) {
        func_8009079C(item, 1);
        item = D_801491F0;
    }
    func_800B0580(0, ghostData, 0);
}

/*

/**
/*
 * object_bytes_sum_global (func_800B3F50)
 * Address: 0x800B3F50
 * Size: 84 bytes
 *
 * Returns (s16)(D_80159B60 + D_801597F0[2] + D_801597F0[3]).
 *
 * @return Sum as signed 16-bit
 */

s16 object_bytes_sum_global(void) {
    u8 byte2, byte3;
    s8 offset;
    sound_update_channel(0, 0.0f);
    byte3 = *((u8*)D_801597F0 + 3);
    sound_update_channel(0, 0.0f);
    byte2 = *((u8*)D_801597F0 + 2);
    offset = D_80159B60;
    return (s16)(offset + byte2 + byte3);
}

/*

/**
/**
/**
/*
 * synced_call_95fd8 (func_8010FCC0)
 * Address: 0x8010FCC0
 * Size: 92 bytes
 *
 * Acquires sync on D_80152770, calls func_80095FD8(a0, 0), releases sync.
 *
 * @param a0 Parameter for func_80095FD8
 */
void synced_call_95fd8(void *a0) {
    func_80007270(&D_80152770, NULL, 1);
    func_80095FD8(a0, 0);
    func_800075E0(&D_80152770, NULL, 0);
}

/*

/**
/**
/**
/*
 * pool_linked_list_init (func_800B04D0)
 * Address: 0x800B04D0
 * Size: 128 bytes
 *
 * Sets up a linked list within a pre-allocated pool. Each element's first
 * word points to the next element. The last element points to NULL.
 *
 * Pool structure:
 *   offset 0x04: count (number of elements)
 *   offset 0x08: stride (size of each element in bytes)
 *   offset 0x0C: base (pointer to pool array)
 *   offset 0x10: head (active list head, cleared to NULL)
 *   offset 0x14: free (free list head, set to base)
 *
 * @param a0 Pointer to pool control structure
 */
void pool_linked_list_init(void *a0) {
    s32 *base;
    s32 count;
    s32 stride;
    s32 i;

    base = *(s32**)((u8*)a0 + 0x0C);
    *(s32*)((u8*)a0 + 0x10) = 0;         /* head = NULL */

    if (base == NULL) {
        *(s32**)((u8*)a0 + 0x14) = base; /* free = base (NULL) */
        return;
    }

    *(s32**)((u8*)a0 + 0x14) = base;     /* free = base */

    count = *(s32*)((u8*)a0 + 0x04);
    stride = *(s32*)((u8*)a0 + 0x08);

    /* Link each element to the next */
    for (i = 0; i < count - 1; i++) {
        *(s32*)((u8*)base + i * stride) = (s32)((u8*)base + (i + 1) * stride);
    }

    /* Last element points to NULL */
    *(s32*)((u8*)base + (count - 1) * stride) = 0;
}

/*

/**
/*
 * func_800B0580 - Reset and initialize pool system
 * Address: 0x800B0580
 * Size: 152 bytes
 *
 * Iterates through active list at D_80155220, calling cleanup functions.
 * Then reinitializes the pool with default values.
 * Finally clears the secondary pool area at D_80155290.
 */
extern void func_800AFA84(void*, void*);
extern u8 D_80155B30[];

void func_800B0580(s32 slot, void *data, s32 size) {
    void *node;

    /* Process and remove all nodes from active list */
    node = *(void**)(&D_80155220[0x10]);
    while (node != NULL) {
        func_8008D0C0(*(s32*)((u8*)node + 0x0C));
        func_800AFA84(&D_80155220[0], node);
        node = *(void**)(&D_80155220[0x10]);
    }

    /* Reinitialize pool control structure */
    D_80155220[0] = 1;                                      /* type/flag */
    *(s32*)(&D_80155220[0x08]) = 36;                       /* stride = 36 bytes */
    *(s32*)(&D_80155220[0x04]) = 100;                      /* count = 100 entries */
    *(void**)(&D_80155220[0x0C]) = (void*)&D_80155B30[0];  /* base pointer */

    func_800B04D0(&D_80155220[0]);

    /* Clear secondary pool area (2208 bytes) */
    func_80002790(&D_80155290[0], 0, 2208);
}

/*

/**
/**
/*
 * func_8009C5BC - Call func_8009C3F8 with mode 0
 * Address: 0x8009C5BC
 * Size: 36 bytes
 *
 * Simple wrapper that calls func_8009C3F8(0).
 * The FP register f16 receives abs(f12) but may be unused.
 */
extern void func_8009C3F8(s32);

void func_8009C5BC(void) {
    func_8009C3F8(0);
}

/*

/**
/*
 * func_800BFD68 - Call func_8009C3F8 with mode 1
 * Address: 0x800BFD68
 * Size: 36 bytes
 *
 * Simple wrapper that calls func_8009C3F8(1).
 * The FP register f16 receives abs(f12) but may be unused.
 */
void func_800BFD68(void) {
    func_8009C3F8(1);
}

/*

/**
/*
 * func_800A511C - Conditional state update
 * Address: 0x800A511C
 * Size: 60 bytes
 *
 * If a0 != a1, calls func_800A501C, copies byte from D_8013FEC8 to D_80140A10,
 * then calls func_800A4E58.
 *
 * @param a0 First comparison value
 * @param a1 Second comparison value
 */
extern void func_800A501C(void);
extern void func_800A4E58(void);
extern s16 D_8013FEC8;

void func_800A511C(s32 a0, s32 a1) {
    if (a0 != a1) {
        func_800A501C();
        D_80140A10 = (u8)D_8013FEC8;
        func_800A4E58();
    }
}

/*

/**
/*
 * func_800AB70C - Call func_8008E26C with transformed parameters
 * Address: 0x800AB70C
 * Size: 68 bytes
 *
 * Passes a0, a1 through; transforms a2, a3 into new values.
 * New a2 = (s16)old_a3
 * New a3 = (((s16)old_a2 << 8) ^ 0x0F00) | stack_arg
 *
 * @param a0 First parameter (passed through)
 * @param a1 Second parameter (passed through)
 * @param a2 Third parameter (used in transform)
 * @param a3 Fourth parameter (becomes new a2)
 * @param stack Fifth parameter from stack (ORed into new a3)
 */

void func_800AB70C(s32 a0, s32 a1, s16 a2, s16 a3, s32 stack) {
    s32 new_a2 = a3;
    s32 new_a3 = ((a2 << 8) ^ 0x0F00) | stack;
    func_8008E26C(0);
}

/*

/**
/*
 * func_800C92DC - Call func_800C9210 with mode (1, 0)
 * Address: 0x800C92DC
 * Size: 88 bytes
 *
 * Wrapper that sets s1=1, s2=0 and calls func_800C9210.
 * The FP operations copy f12 to f20 and f14 to f22.
 */

void func_800C92DC(void) {
    speed_set(0);
}

/*

/**
/*
 * func_800C93AC - Call func_800C9210 with mode (0, 1)
 * Address: 0x800C93AC
 * Size: 88 bytes
 *
 * Wrapper that sets s1=0, s2=1 and calls func_800C9210.
 * The FP operations copy f12 to f20 and f14 to f22.
 */
void func_800C93AC(void) {
    speed_set(0);
}

/*

/**
/*
 * func_8010B528 - Initialize structure with callback pointer
 * Address: 0x8010B528
 * Size: 56 bytes
 *
 * Sets field_4 to D_80116DE0, calls func_80094EC8(a0),
 * clears field_28, and returns 1.
 *
 * @param a0 Structure pointer
 * @return 1
 */
extern u8 D_80116DE0[];

s32 func_8010B528(void *a0) {
    *(void**)((u8*)a0 + 4) = &D_80116DE0[0];
    func_80094EC8(a0);
    *(s32*)((u8*)a0 + 0x28) = 0;
    return 1;
}

/*

/**
/*
 * func_8010B560 - Update state based on global flag
 * Address: 0x8010B560
 * Size: 112 bytes
 *
 * Checks D_80159D98 global and updates a0->byte26 accordingly.
 * If state changed, calls func_80094EC8.
 * If byte26 becomes 0, sets field4 to D_80117358 and clears field40.
 *
 * @param a0 Structure pointer
 * @return Always 1
 */
extern u8 D_80117358[];

s32 func_8010B560(void *a0) {
    s32 globalState;
    s8 currentState;

    globalState = (D_80159D98 != 0) ? 1 : 0;
    currentState = *(s8*)((u8*)a0 + 26);

    if (globalState != currentState) {
        *(s8*)((u8*)a0 + 26) = (s8)globalState;
        func_80094EC8(a0);
        currentState = *(s8*)((u8*)a0 + 26);
    }

    if (currentState != 0) {
        return 1;
    }

    *(void**)((u8*)a0 + 4) = &D_80117358[0];
    func_80094EC8(a0);
    *(s32*)((u8*)a0 + 40) = 0;
    return 1;
}

/*

/**
/*
 * func_800F8754 - Cleanup and reset state
 * Address: 0x800F8754
 * Size: 76 bytes
 *
 * Calls func_800F857C, then func_800B45BC(1).
 * If D_8011472C is non-NULL, calls func_800B358C and clears it.
 * Finally clears D_80114728 byte.
 */
extern void func_800F857C(void);
extern void func_800B45BC(s32 clear_all);
extern void *D_8011472C;
extern u8 D_80114728;

void func_800F8754(void) {
    func_800F857C();
    func_800B45BC(1);

    if (D_8011472C != NULL) {
        func_800B358C(D_8011472C, 0.0f);
        D_8011472C = NULL;
    }
    D_80114728 = 0;
}

/*

/**
/*
 * func_80091F34 - Synchronized call to func_80091CA4
 * Address: 0x80091F34
 * Size: 136 bytes
 *
 * Acquires sync on D_80142728, calls func_80091CA4 with parameters,
 * then releases sync.
 *
 * @param a0 First parameter (passed to func_80091CA4)
 * @param a1 Second parameter (loaded as float)
 */
extern void func_80091CA4(void*);

void func_80091F34(void *a0, s32 a1) {
    func_80007270(&D_80142728[0], NULL, 1);
    func_80091CA4(a0);
    func_800075E0(&D_80142728[0], NULL, 0);
}

/*

/**
/*
 * func_800AC668 - Complex initialization with callback setup
 * Address: 0x800AC668
 * Size: 140 bytes
 *
 * Sets up D_80159D90 to -1, calls several setup functions,
 * stores result to D_80159B80, then calls additional init functions.
 *
 * @param a0 First parameter
 * @param a1 Second parameter
 * @return Value of D_80159D90 (s16)
 */
extern void func_800A473C(void*, void*);
extern void *func_80092C58(void*, void*, void*, s32, void*);
extern void func_800AC3D8(void*, s16);
extern void func_800AB638(void);

s16 func_800AC668(void *a0, s16 a1) {
    u8 buf1[4];
    u8 buf2[4];
    void *result;

    D_80159D90 = -1;
    func_800A473C(buf1, a0);

    result = func_80092C58(buf2, (void*)D_80159818, NULL, 0, NULL);
    D_80159B80 = *(void**)result;

    func_800AC3D8(D_80159B80, a1);
    func_800AB638();

    return D_80159D90;
}

/*

/**
/*
 * func_800A4AC4 - Iterate through slot array and call func_80096130
 * Address: 0x800A4AC4
 * Size: 124 bytes
 *
 * Iterates through 64 slots in D_80156D38 array, calling func_80096130
 * for each slot that has field_0C set and field_06 != a0.
 *
 * @param a0 Filter value for field_06 comparison
 */

void func_800A4AC4(s32 a0) {
    u8 *slot = &D_80156D38[0];
    s32 i;

    for (i = 0; i < 64; i++) {
        if (*(s32*)(slot + 0x0C) != 0) {
            if (*(slot + 6) != a0) {
                func_80096130(i);
            }
        }
        slot += 20;  /* 0x14 bytes per entry */
    }
}

/*

/**
/*
 * func_8009DC50 - Recursive tree/list search
 * Address: 0x8009DC50
 * Size: 200 bytes
 *
 * Recursively searches through a tree structure in D_8013E700.
 * Uses bit mask (256 << a1) to check node flags.
 *
 * @param a0 Pointer to node structure
 * @param a1 Bit position for mask creation
 * @return 1 if found, 0 otherwise
 */
extern u8 D_8013E700[];

s32 func_8009DC50(void *a0, s32 a1) {
    s32 flags;
    s32 mask;
    s16 leftIdx, rightIdx;
    void *node;

    mask = 256 << a1;
    node = a0;

    while (1) {
        flags = *(s32*)node;

        if ((flags & mask) != 0) {
            return 1;
        }

        leftIdx = *(s16*)((u8*)node + 0x16);
        if (leftIdx >= 0) {
            /* Recurse on left child */
            if (func_8009DC50(&D_8013E700[leftIdx * 68], a1) != 0) {
                return 1;
            }
        }

        rightIdx = *(s16*)((u8*)node + 0x18);
        if (rightIdx < 0) {
            return 0;
        }

        /* Continue with right child (tail recursion optimization) */
        node = &D_8013E700[rightIdx * 68];
    }
}

/*

/**
/*
 * func_8009DD18 - Check node flag and optionally search tree
 * Address: 0x8009DD18
 * Size: 112 bytes
 *
 * Checks if bit (256 << a1) is set in node flags.
 * If not, searches subtree using func_8009DC50.
 *
 * @param a0 Pointer to node structure
 * @param a1 Bit position for mask
 * @return 1 if flag set or found in tree, 0 otherwise
 */
s32 func_8009DD18(void *a0, s32 a1) {
    s32 flags;
    s32 mask;
    s16 idx;

    flags = *(s32*)a0;
    mask = 256 << a1;

    if ((flags & mask) != 0) {
        return 1;
    }

    idx = *(s16*)((u8*)a0 + 0x16);
    if (idx < 0) {
        return 0;
    }

    if (func_8009DC50(&D_8013E700[idx * 68], a1) != 0) {
        return 1;
    }

    return 0;
}

/*

/**
/*
 * func_800BF148 - Synchronized lookup and process
 * Address: 0x800BF148
 * Size: 128 bytes
 *
 * Acquires sync on D_80142728, calls func_80091BA8 to lookup.
 * If found, calls func_800BF01C and func_800BF0A4.
 * Returns lookup result.
 *
 * @param a0 Key to look up
 * @return Lookup result or 0 if not found
 */
extern void func_800BF0A4(void *camera, f32 intensity, f32 duration);

/* Object initialization functions */
extern void func_800D1004(void *menu); /* Setup call before init */

/* Global scaling factors */
extern f32 D_8011416C;
extern f32 D_80114170;

/* Float arrays for camera/visual data */
extern f32 D_80153F28[6];
extern s16 D_80154182;

extern void func_800BAAA0(void *world); /* Setup call */

void *func_800BF148(void *a0) {
    void *result;

    func_80007270(&D_80142728[0], NULL, 1);

    result = func_80091BA8(a0, &D_80142728[0]);

    if (result == NULL) {
        func_800075E0(&D_80142728[0], NULL, 0);
        return NULL;
    }

    func_800BF01C();
    func_800075E0(&D_80142728[0], NULL, 0);
    func_800BF0A4(a0, 0, 0);

    return result;
}

/*

/**
/*
 * func_800D11BC - Initialize object with default scale values
 * (140 bytes)
 *
 * Initializes an object's scale factors to default values (0, 0, 0, 1)
 * at offset 0x720, sets flag at 0x730, and calculates a timing value
 * at offset 0x7D0.
 *
 * @param a0 Pointer to object structure
 */
void func_800D11BC(void *a0) {
    f32 zero;
    f32 one;
    f32 val;
    s16 result;

    func_800D1004(NULL);

    zero = 0.0f;
    one = 1.0f;

    /* Set scale to (0, 0, 0, 1) at offset 0x720 */
    *(f32*)((u8*)a0 + 0x720) = zero;
    *(f32*)((u8*)a0 + 0x724) = zero;
    *(f32*)((u8*)a0 + 0x728) = zero;
    *(f32*)((u8*)a0 + 0x72C) = one;

    /* Set initialization flag */
    *(u8*)((u8*)a0 + 0x730) = 1;

    /* Call initialization functions */
    func_800CF06C(a0);
    func_800D0424(a0, 0);

    /* Calculate timing value from object field and global factors */
    val = *(f32*)((u8*)a0 + 0x408);
    result = (s16)(val * D_8011416C * D_80114170);
    *(s16*)((u8*)a0 + 0x7D0) = result;
}

/*

/**
/*
 * func_800BAD58 - Reset camera/visual float arrays
 * (136 bytes)
 *
 * Initializes three float arrays to zero and sets up initial state values.
 */
void func_800BAD58(void) {
    f32 zero;
    s32 i;

    func_800BAAA0(NULL);

    zero = 0.0f;

    /* Clear all three 6-element float arrays */
    for (i = 0; i < 6; i++) {
        D_80153F28[i] = zero;
        D_80153F48[i] = zero;
        D_80153F68[i] = zero;
    }

    /* Copy initial value and set state to -1 */
    D_80154190 = D_801543CC;
    D_80154182 = -1;
}

/*

/* Player/car data array indexed by ID */
extern s32 func_800A1A60(void*);  /* Object processing function */

/**
/*
 * func_800CC848 - Check object status and optionally process
 * (128 bytes)
 *
 * Checks if an object's child reference is valid and if the indexed
 * status byte allows processing. If a1 is non-zero, calls processing.
 *
 * @param a0 Pointer to parent object
 * @param a1 If non-zero, call processing function
 * @return 0 if invalid/disabled, 1 if valid, or processing result
 */
s32 func_800CC848(void **a0, s32 a1) {
    void *parent;
    void *child;
    void *childData;
    u8 index;
    s8 status;

    parent = *a0;
    child = *(void**)((u8*)parent + 8);

    if (child == NULL) {
        return 1;
    }

    childData = *(void**)child;
    index = *(u8*)((u8*)childData + 16);

    /* Calculate array offset: index * 772 + 0x4031 */
    status = D_80144031[index * 772];

    if (status == 0) {
        return 0;
    }

    if (a1 == 0) {
        return 1;
    }

    return func_800A1A60(child);
}

/*

/**
/*
 * func_800D6E00 - Allocate and signal type 11 object
 * (116 bytes)
 *
 * Allocates an object, sets its type to 11, stores parameter as byte 4,
 * and signals the secondary sync queue with the new object.
 *
 * @param a0 Value to store in object byte 4
 */
void func_800D6E00(s32 a0) {
    void *obj;

    func_80007270(&D_80142728[0], NULL, 1);

    obj = func_80091B00(0);

    *(u8*)((u8*)obj + 2) = 11;
    *(u8*)((u8*)obj + 4) = (u8)a0;

    func_800075E0(&D_80142728[0], NULL, 0);
    func_800075E0(&D_80142728[0x80], obj, 0);
}

/*

/**
/*
 * func_800D6348 - Allocate and signal type 9 object
 * (104 bytes)
 *
 * Allocates an object, sets its type to 9, and signals the secondary
 * sync queue with the new object. Similar to func_800D6E00 but with
 * no parameter and different type.
 */
void func_800D6348(void) {
    void *obj;

    func_80007270(&D_80142728[0], NULL, 1);

    obj = func_80091B00(0);
    *(u8*)((u8*)obj + 2) = 9;

    func_800075E0(&D_80142728[0], NULL, 0);
    func_800075E0(&D_80142728[0x80], obj, 0);
}

/*

/* Global state flags */

extern void func_800D03DC(f32 *pos, s32 a1);

/**
/*
 * func_8010E828 - Process object with countdown timer
 * (132 bytes)
 *
 * If flag parameter is zero, initializes object. Otherwise processes
 * object's countdown timer and calls rendering function while timer
 * is active. Reinitializes when countdown reaches zero.
 *
 * @param a0 Pointer to parent object
 * @param a1 Skip init if non-zero
 */
void func_8010E828(void *a0, s16 a1) {
    void *child;
    s16 countdown;

    if (a1 == 0) {
        func_8009079C(a0, 1);
    }

    if (D_801170FC != 0) {
        return;
    }

    child = *(void**)((u8*)a0 + 12);
    countdown = *(s16*)((u8*)child + 90);

    if (countdown != 0) {
        *(s16*)((u8*)child + 90) = countdown - 1;
        func_800D03DC(*(void**)((u8*)child + 108), (void*)((u8*)child + 20));
        countdown = *(s16*)((u8*)child + 90);
    }

    if (countdown == 0) {
        func_8009079C(a0, 1);
    }
}

/*

/* Effect/visual system arrays */
extern u32 D_801569B8[];        /* Effect slot array (4 slots, 124 bytes each) */
extern f32 D_8016139C;          /* Effect timing float */

extern void func_80002790(void*, s32, s32);  /* memset */

/**
/*
 * effect_system_init (func_800C3614)
 * Size: 140 bytes
 *
 * Clears effect state buffers and initializes all effect slots with
 * the marker value 0x15000000 in the first word of each slot.
 */
void effect_system_init(void) {
    u32 *ptr;

    /* Clear main effect buffer */
    func_80002790(D_80152038, 0, 480);

    /* Initialize each 124-byte effect slot */
    for (ptr = D_801569B8; ptr < (u32*)((u8*)D_801569B8 + 496); ptr = (u32*)((u8*)ptr + 124)) {
        func_80002790(ptr, 0, 124);
        *ptr |= 0x15000000;
    }

    /* Reset timing and counter */
    D_8016139C = 0.0f;
    D_80152738 = 0;
}

/*

/* Object initialization external references */
extern u8 D_80140BDC;  /* Object type count */
extern s32 func_800B24EC(void*, void*, s32, s8, s32); /* Object setup with type */
extern void func_800B362C(s32 channel, f32 pan); /* Object alternate init */
extern f32 func_800B65B8(f32 distance, f32 maxDist);  /* Audio distance attenuation */

/**
/*
 * func_800EF5B0 - Initialize object with optional type setup
 * (124 bytes)
 *
 * Stores a1 in a0[0], then either:
 * - If a2 != 0: calls func_800B24EC with type-1, stores result in a0[8]
 * - If a2 == 0: calls func_800B362C for alternate init
 * Finally calls func_80094EC8 to finalize.
 */
void func_800EF5B0(void *a0, void *a1, s32 a2) {
    s8 objType;
    s32 result;

    *(void**)a0 = a1;

    if (a2 != 0) {
        objType = (s8)(D_80140BDC - 1);
        result = func_800B24EC(a1, (void*)((u8*)a0 + 12), 0, objType, 1);
        *(s32*)((u8*)a0 + 8) = result;
    } else {
        func_800B362C(a0, 0);
    }

    func_80094EC8(a0);
}

/*

/**
/*
 * func_800F68A4 - Build string from object array
 * (132 bytes)
 *
 * Copies bytes from offset 4 of each 12-byte entry in D_80159800 array
 * into the output buffer, null-terminated. Count comes from D_801597F0[12].
 */
void func_800F68A4(u8 *output) {
    void *data;
    void *arr;
    s32 i;
    s32 offset;
    s32 count;

    sound_update_channel(0, 0.0f);

    data = (void*)D_801597F0;
    i = 0;
    offset = 0;
    count = *(u8*)((u8*)data + 12);

    while (i < count) {
        arr = (void*)D_80159800;
        output[i] = *(u8*)((u8*)arr + offset + 4);
        i++;
        offset += 12;
        data = (void*)D_801597F0;
        count = *(u8*)((u8*)data + 12);
    }

    output[i] = 0;
}

/*

/* Timer calculation external references */
extern f32 func_80001578(void);  /* Get elapsed time */
extern f32 D_801247F8;           /* Time multiplier */
extern f32 D_801249C0;           /* Object init float constant */

/**
/*
 * func_800FBF2C - Update timer value from elapsed time
 * (92 bytes)
 *
 * Gets elapsed time, multiplies by scale factor, and stores.
 * If result is <= 0, sets timer state flag to 0x100000.
 */
void func_800FBF2C(void) {
    f32 time;
    s16 value;

    time = func_80001578();
    time *= D_801247F8;
    value = (s16)time;
    D_80152032 = value;

    if (value <= 0) {
        D_801174B8 = 0x00100000;
    }
}

/*

/**
/*
 * func_800E7A98 - Remove item from synchronized linked list
 * (172 bytes)
 *
 * Removes an object from the linked list at D_801527C8.
 * If a0 is NULL, removes the head item instead.
 * Uses sync primitives for thread safety.
 */
void func_800E7A98(void *a0) {
    void *item;
    void *curr;
    void *next;

    func_80007270(&D_80142728[0], NULL, 1);

    /* Get item to remove */
    if (a0 != NULL) {
        item = a0;
    } else {
        item = *D_801527C8;
    }

    /* Traverse list to find and unlink item */
    curr = *D_801527C8;
    if (curr != NULL) {
        while (1) {
            next = *(void**)((u8*)curr + 4);
            if (item == next) {
                /* Found - unlink by copying next's pointer */
                next = *(void**)((u8*)item + 4);
                *(void**)((u8*)curr + 4) = next;
                break;
            }
            if (next == NULL) break;
            curr = next;
        }
    }

    func_80095FD8(item, 1);
    func_800075E0(&D_80142728[0], NULL, 0);
}

/*

/* Multi-player coordinate update external references */
extern void func_800E847C(void); /* Pre-update function */
extern void func_8008D6FC(s16, void*, void*);  /* Coordinate transform */
extern void func_800EB90C(s32 soundId); /* Post-update function */

/**
/*
 * func_800EC0DC - Update player coordinate transforms
 * (180 bytes)
 *
 * For each active player (when mode == 2 and count >= 2), calls
/*
 * func_8008D6FC to update their coordinate data from arrays at
 * 0x80152BD0 (source) and 0x80152C20 (dest), stride 952 bytes.
 */
void func_800EC0DC(void) {
    s16 *srcBase;
    u8 *src;
    u8 *dst;
    s32 i;

    func_800E847C();

    if (D_8015A110 != 2) {
        goto done;
    }

    if (D_8015A108 < 2) {
        goto done;
    }

    srcBase = (s16*)0x80152BD0;
    src = (u8*)0x80152BD8;
    dst = (u8*)0x80152C20;
    i = 1;

    while (i < D_8015A108) {
        func_8008D6FC(*(srcBase + 123), src, dst);  /* offset 246 = 123 shorts */
        i++;
        srcBase = (s16*)((u8*)srcBase + 952);
        src += 952;
        dst += 952;
    }

done:
    func_800EB90C(0);
}

/*

/**
/*
 * func_8010DAF8 - Spawn and initialize linked object
 * (192 bytes)
 *
 * Creates a new object via func_80090284, links it into D_801491F0 list,
 * initializes fields from indexed data array D_80117530, and finalizes
 * with func_800FEA00.
 */
extern void *func_80090284(s32 soundId, s32 flags);

void func_8010DAF8(void *a0) {
    s16 index;
    u8 *indexedData;
    void *obj;
    void *oldHead;

    index = *(s16*)((u8*)a0 + 16);
    indexedData = &D_80117530[index * 48];

    *(s16*)((u8*)a0 + 90) = 12;
    obj = func_80090284(0, 0);

    if (obj == NULL) {
        return;
    }

    /* Initialize new object */
    *(s16*)((u8*)obj + 4) = 0;
    *(void**)((u8*)obj + 12) = a0;
    *(void**)((u8*)obj + 20) = *(void**)(indexedData + 12);
    *(f32*)((u8*)obj + 16) = D_801249C0;

    /* Clear bits 1 and 2 of byte at offset 4 */
    *(u8*)((u8*)a0 + 4) &= 0xFFF9;

    /* Link into list */
    oldHead = *D_801491F0;
    *(void**)obj = oldHead;
    *D_801491F0 = obj;

    /* Finalize with callback */
    func_800FEA00();
}

/*

/*============================================================================
 * CORE MEMORY MANAGEMENT FUNCTIONS
 * These are called extensively throughout the game code.
 *============================================================================*/

/* Pool allocator globals */
extern u8 D_80142DD8[];   /* Object pool base (24-byte slots) */
extern u8 D_801439D8[];   /* Pool end marker */

/**
/*
 * func_80091B00 - Allocate object from pool
 * (168 bytes)
 *
 * Searches the object pool at D_80142DD8 for a free 24-byte slot.
 * Each 96-byte block contains 4 slots. A slot is free if byte at offset 3 is 0.
 * When allocated, sets in_use flag to 1 and initializes short at offset 0 to -1.
 *
 * @return Pointer to allocated slot, or NULL if pool exhausted
 */
void *func_80091B00(s32 type) {
    u8 *base = D_80142DD8;
    u8 *end = D_801439D8;
    u8 *ptr = base;

    while (ptr < end) {
        /* Check slot 0 (offset 0) */
        if (*(s8*)(ptr + 3) == 0) {
            *(s8*)(ptr + 3) = 1;
            *(s16*)ptr = -1;
            return ptr;
        }
        /* Check slot 1 (offset 24) */
        if (*(s8*)(ptr + 27) == 0) {
            *(s8*)(ptr + 27) = 1;
            *(s16*)(ptr + 24) = -1;
            return ptr + 24;
        }
        /* Check slot 2 (offset 48) */
        if (*(s8*)(ptr + 51) == 0) {
            *(s8*)(ptr + 51) = 1;
            *(s16*)(ptr + 48) = -1;
            return ptr + 48;
        }
        /* Check slot 3 (offset 72) */
        if (*(s8*)(ptr + 75) == 0) {
            *(s8*)(ptr + 75) = 1;
            *(s16*)(ptr + 72) = -1;
            return ptr + 72;
        }
        ptr += 96;  /* Advance to next 4-slot block */
    }

    return NULL;
}

/*

/* Object deactivation globals */
extern void **D_801491F0;   /* Active object list head */
extern void **D_801492C8;   /* Free object list head */
extern s16 D_8013E66C;      /* Active object count */
extern s16 D_8013E678;      /* Maximum active objects seen */
extern void func_8008AE8C(s16 texId, s32 mode, s32 flags); /* Sound stop function */

/**
/*
 * func_8009079C - Deactivate and free an object
 * (260 bytes)
 *
 * Stops any associated sound, removes object from active list,
 * and moves it to the free list. Updates object count tracking.
 *
 * @param a0 Object pointer to deactivate
 * @param a1 If non-zero, remove from active list
 */
void func_8009079C(void *a0, s32 a1) {
    s16 soundId;
    void *curr;
    void *prev;
    void *next;
    s16 count;

    /* Stop associated sound if any */
    soundId = *(s16*)((u8*)a0 + 6);
    if (soundId >= 0) {
        func_8008AE8C(soundId, 1, 15);
    }

    /* Clear object state */
    *(void**)((u8*)a0 + 20) = NULL;
    *(s16*)((u8*)a0 + 6) = -1;

    /* Remove from active list if requested */
    if (a1 != 0) {
        curr = *D_801491F0;

        /* Check if we're the head */
        if (a0 == curr) {
            *D_801491F0 = *(void**)a0;
        } else {
            /* Search list for our predecessor */
            prev = NULL;
            while (curr != NULL) {
                next = *(void**)curr;
                if (a0 == next) {
                    break;
                }
                if (next == NULL) break;
                prev = curr;
                curr = next;
            }

            /* Unlink from list */
            if (prev != NULL && *(void**)prev == a0) {
                *(void**)prev = *(void**)a0;
            }
        }
    }

    /* Add to free list */
    *(void**)a0 = *D_801492C8;
    *D_801492C8 = a0;

    /* Update count and max tracking */
    D_8013E66C--;
    count = D_8013E66C;
    if (D_8013E678 < count) {
        D_8013E678 = count;
    }
}

/*

/* Object spawn globals */
extern u8 D_8012F5CC[];  /* Type lookup table */
extern void *func_80092278(void);  /* Allocate sub-object */

/**
/*
 * func_80092360 - Spawn a new game object
 * (292 bytes)
 *
 * Creates a new object with type 2, initializes it with the given parameters,
 * and signals the object system. Core object creation function.
 *
 * @param a0 Owner/parent index
 * @param a1 Mode/flag
 * @param a2 Object type ID
 * @param a3 Flags byte (from stack)
 * @return Pointer to the created sub-object's data
 */
void *func_80092360(s32 a0) {
    void *obj;
    void *subObj;
    void *result;

    func_80007270(&D_80142728[0], NULL, 1);

    obj = func_80091B00(0);

    /* Set object type and ID */
    *(u8*)((u8*)obj + 2) = 2;
    *(s32*)((u8*)obj + 4) = 0;

    /* Allocate and link sub-object */
    subObj = func_80092278();
    *(void**)((u8*)obj + 20) = subObj;
    *(void**)((u8*)subObj + 20) = NULL;

    /* Initialize sub-object fields */
    *(s32*)((u8*)subObj + 52) = a0;  /* Owner */
    *(s32*)((u8*)subObj + 56) = 0;   /* Mode */
    *(u8*)((u8*)subObj + 27) = 0;    /* Flags */
    *(s32*)((u8*)subObj + 16) = 1;   /* Active flag */
    *(u8*)((u8*)subObj + 24) = 0;
    *(u8*)((u8*)subObj + 26) = 1;
    *(u8*)((u8*)subObj + 25) = D_8012F5CC[a0];  /* Type from lookup */

    /* Store float constants at object offsets 8, 12, 16 */
    *(f32*)((u8*)obj + 8) = 1.0f;
    *(f32*)((u8*)obj + 12) = -2.0f;
    *(f32*)((u8*)obj + 16) = -2.0f;

    /* Get result before releasing sync */
    result = *(void**)((u8*)subObj + 12);

    func_800075E0(&D_80142728[0], NULL, 0);
    func_800075E0(&D_80142728[0x80], obj, 0);

    return result;
}

/*

/**
/*
 * func_8008D6B0 - Copy 3x3 matrix or 9-float vector
 * (76 bytes)
 *
 * Copies 36 bytes (9 floats) from source to destination.
 * Used for copying position/orientation data or 3x3 matrices.
 *
 * @param src Source pointer
 * @param dst Destination pointer
 */
void func_8008D6B0(f32 *src, f32 *dst) {
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
}

/*

/**
/*
 * func_80090284 - Allocate object from free list
 * (132 bytes)
 *
 * Pops an object from the free list at D_801492C8, initializes it,
 * and updates count tracking. The complementary function to func_8009079C.
 *
 * @return Pointer to allocated object, or NULL if list empty
 */
void *func_80090284(s32 soundId, s32 flags) {
    void *obj;
    void *next;
    s16 count;

    obj = *D_801492C8;
    if (obj == NULL) {
        return NULL;
    }

    /* Increment count and update max */
    D_8013E66C++;
    count = D_8013E66C;
    if (D_8013E678 < count) {
        D_8013E678 = count;
    }

    /* Pop from free list */
    next = *(void**)obj;
    *D_801492C8 = next;

    /* Initialize object fields */
    *(void**)obj = NULL;           /* next pointer */
    *(s16*)((u8*)obj + 4) = 0;     /* state */
    *(s16*)((u8*)obj + 6) = -1;    /* sound id */
    *(s16*)((u8*)obj + 8) = 0;     /* flags */
    *(void**)((u8*)obj + 12) = NULL; /* data pointer */
    *(void**)((u8*)obj + 20) = NULL; /* extra pointer */
    *(f32*)((u8*)obj + 16) = 0.0f;  /* timer/value */

    return obj;
}

/*

/**
/*
 * func_8008AD04 - Compare two strings
 * (68 bytes)
 *
 * Compares two null-terminated strings byte by byte.
 *
 * @param a0 First string
 * @param a1 Second string
 * @return 0 if equal, difference of first non-matching bytes otherwise
 */
s32 func_8008AD04(u8 *a0, u8 *a1) {
    u8 c1, c2;

    c1 = *a0;
    if (c1 == 0) {
        c2 = *a1;
        return c1 - c2;
    }

    do {
        c2 = *a1;
        if (c1 != c2) {
            c2 = *a1;
            return c1 - c2;
        }
        a0++;
        a1++;
        c1 = *a0;
    } while (c1 != 0);

    c2 = *a1;
    return c1 - c2;
}

/*

/**
/*
 * func_800B73E4 - Initialize effects/emitter system
 * (84 bytes)
 *
 * One-time initialization that clears effect counters and data arrays.
 * Sets init flag to prevent re-initialization.
 */
void func_800B73E4(void) {
    u32 *ptr;
    u32 *end;

    /* Check if already initialized */
    if (D_801147C4 != 0) {
        return;
    }

    /* Mark as initialized */
    D_801147C4 = 1;

    /* Clear effect counters */
    *(s32*)&D_801551F0[6] = 0;  /* D_801551EC equivalent */
    *(s32*)&D_801551E8[0] = 0;  /* D_801551E8 counter */

    /* Clear effect data array (32 bytes, 8 words) */
    ptr = D_801551F0;
    end = D_801551F0 + 8;

    do {
        ptr[0] = 0;
        ptr[1] = 0;
        ptr[2] = 0;
        ptr[3] = 0;
        ptr += 4;
    } while (ptr != end);
}

/*

/* Emitter data arrays */

/**
/*
 * func_800B80C8 - Copy emitter position floats to target
 * (80 bytes)
 *
 * If the target pointer exists, copies two position floats from
 * the emitter data array to the target object.
 *
 * @param a0 Emitter index
 */
void func_800B80C8(s32 a0) {
    void *target;
    u8 *emitter;

    target = D_80124FD0[a0];

    if (target == NULL) {
        return;
    }

    /* Calculate emitter data offset: a0 * 152 */
    emitter = D_80150B70 + (a0 * 152);

    /* Copy two position floats from emitter to target */
    *(f32*)((u8*)target + 36) = *(f32*)(emitter + 36);
    *(f32*)((u8*)target + 44) = *(f32*)(emitter + 44);
}

/*

/* Emitter count */

/**
/*
 * func_800B90F8 - Clear emitter pointer array
 * (48 bytes)
 *
 * Clears the emitter target pointer array up to the current count.
 */
void func_800B90F8(void) {
    s16 count;
    void **ptr;
    void **end;

    count = D_80151AD0;
    ptr = D_80124FD0;

    if (count <= 0) {
        return;
    }

    end = D_80124FD0 + count;

    do {
        *ptr = NULL;
        ptr++;
    } while (ptr < end);
}

/*

/* Additional emitter system globals */

/**

/**

/**

/**

/**

/**

/**

/**

/**
extern s32 func_80097470(s32, s32);  /* Sound lookup function */

/**

/**

/**

/**

/**

/**
extern void game_mode_handler(void); /* func_800C9AE0 - State handler */

/**

/**

/**

/**

/**
extern void func_800B0580(s32 slot, void *data, s32 size); /* Write save data */

/**

/**
/**

/**

/**

/**

/**

/**
/**
/**
/**

/**
extern void func_800BF024(void *a0); /* Process with flag */
extern void func_80091C04(void *a0); /* Process without flag */
extern void func_800D54BC(void *a0); /* Clear structure */

/**
/**
/**
/**

/**
/**
/**

/**

/**

/**

/**

/**

/**


/**


/**

extern s32 D_801513B4;    /* Global flag A */
extern void *D_8012EA18;  /* Source data */

/**

/**


/**

/**


/**


/**

/**
/**

/**


/**
/**
/**
/**
/**
/**

/**
/**

/**

/**

/**

/**

/**
/**

/**

/**

/**

/**

/**
/**
/**
/**
/**
/**

/**
/**

/**

/**
/**

/**
/**
/**

/**

/**

/**
/**

/**
/**

/**
/**

/**
/*
 * func_800B7FF8 - Get game state flags
 * (8 bytes)
 *
 * Returns the current game state flags word.
 *
 */
s32 func_800B7FF8(void) {
    return D_801174B4;
}

/*


/**
/*
 * func_800B71D4 - Get secondary state
 * (8 bytes)
 *
 * Returns the secondary state value.
 */
s32 func_800B71D4_alt(void) {
    return 0;
}

/*

/**
/**
/**
/**

/**
/**

/**
/**
/**

/**

/**

/**
/**
/**

/**
/**
/**
/**
/**
/**
/**
/**
/**
/**

/**
/**
/**

/**




/*
 * func_800C84C0 (60 bytes)
 * Set player state byte(s)
 */
void player_mode_set(s32 a0, s8 a1) {
    u8 *arr = &D_80159B74;

    if (a0 == -1) {
        /* Set all 4 player states */
        arr[0] = a1;
        arr[1] = a1;
        arr[2] = a1;
        arr[3] = a1;
    } else if (a0 < 4) {
        arr[a0] = a1;
    }
}

/*

extern s32 D_80155210;    /* Sound buffer end */








extern s32 D_8012EAA0;





extern s8 D_8014978C;

/*
 * func_8009731C (104 bytes)
 * Synchronized element lookup returning offset 12 data
 */
void *func_8009731C(void *input) {
    void *temp;
    void *result;
    void *data;

    sync_acquire(&D_80152770, 0, 1);
    temp = func_80095F8C(0);
    result = func_80095EF4(temp, NULL, 0);
    data = *(void **)((u8 *)result + 12);
    sync_release(&D_80152770, 0, 0);
    return data;
}

/*

 * func_800C7578 (148 bytes)
 * Update indexed slot in nested structure and notify
 */
void func_800C7578(void **a0, s32 a1, s32 a2, s32 a3) {
    u32 *ptr;
    u8 *base;
    u8 *slot;
    s8 new_val;
    u8 idx1, idx2;

    ptr = (u32 *)*a0;
    idx2 = (u8)a2;
    new_val = (s8)a3;
    base = *(u8 **)*(u32 **)((u8 *)ptr + 44);
    idx1 = (u8)a1;

    slot = base + (idx1 << 4) + idx2 + 1860;
    if (new_val != *(s8 *)slot) {
        *(s8 *)slot = new_val;
        *(void **)(base + (idx1 << 4) + 1856) = (void*)(func_800B466C(0) + 1860);
        func_800A2504(*(void **)((u8 *)ptr + 8), (void*)(base + (idx1 << 4) + 1856), 16);
    }
}

/*

 * func_800CD058 (156 bytes)
 * Conditional render/process dispatch based on object state
 */
void func_800CD058(void *a0) {
    void *ptr;

    ptr = *(void **)a0;
    if (*(void **)((u8 *)ptr + 8) != NULL) {
        if (func_800CCEFC(a0) != 0) {
            ptr = *(void **)a0;
            func_800A2680(*(void **)((u8 *)ptr + 8));
        }
    } else {
        func_800CCCCC(a0);
    }
}

/*

 * func_800AF51C (196 bytes)
 * Initialize resource arrays - allocates 50 resources and clears 6 slot entries
 */
void func_800AF51C(void) {
    s16 i;
    void *result;

    /* Allocate 50 resources and store in array */
    for (i = 0; i < 50; i++) {
        result = func_800A7D6C();
        *(void **)((u8 *)&D_8014C238 + (i * 4)) = result;
    }

    /* Initialize 6 slot entries with -1 */
    for (i = 0; i < 6; i++) {
        *(s32 *)((u8 *)&D_80154FD8 + (i * 60)) = -1;
        *(s32 *)((u8 *)&D_80154660 + (i * 400) + 0) = -1;
        *(s32 *)((u8 *)&D_80154660 + (i * 400) + 84) = -1;
        *(s32 *)((u8 *)&D_80154660 + (i * 400) + 168) = -1;
        *(s32 *)((u8 *)&D_80154660 + (i * 400) + 252) = -1;
        *(s32 *)((u8 *)&D_80154660 + (i * 400) + 336) = -1;
    }

    D_8014C094 = 0;
}

/*

 * func_8008E19C(208 bytes, 0)
 * Insert value into tree node - either at head or at indexed slot
 */
void func_8008E19C(s16 a0, s16 a1) {
    s16 new_idx;
    u8 *entry;

    if (a1 < 0) {
        /* Insert at head if empty, else allocate new node */
        if (D_8016B254 < 0) {
            D_8016B254 = a0;
        } else {
            new_idx = func_8008E144();
            *(s16 *)((u8 *)&D_8013E700 + (new_idx * 68) + 24) = a0;
        }
    } else {
        /* Insert at indexed slot if empty, else allocate new node */
        entry = (u8 *)&D_8013E700 + (a1 * 68);
        if (*(s16 *)(entry + 22) == -1) {
            *(s16 *)(entry + 22) = a0;
        } else {
            new_idx = func_8008E144();
            *(s16 *)((u8 *)&D_8013E700 + (new_idx * 68) + 24) = a0;
        }
    }
}

/*

 * func_8008A398 (76 bytes)
 * Note: Audio sync related - needs analysis
 */

/*
 * func_8008C724 (68 bytes)
 * Note: Audio processing - needs analysis
 */

/*
 * func_800991C04 placeholder
 * Note: Complex function - needs analysis
 */

/*
 * func_8008B26C (72 bytes)
 * Note: Matrix operation - needs analysis
 */

/*
 * func_8009515C (60 bytes)
 * Note: Copy/init operation - needs analysis
 */

/*
 * func_800959DC (72 bytes)
 * Note: Render setup - needs analysis
 */

/*
 * func_8008A474 (464 bytes)
 * Rectangle clipping and RDP fill command
 * Clips coordinates to screen bounds
 */
void func_8008A474(s32 x1, s32 y1, s32 x2, s32 y2, s32 color) {
    s32 minX, minY, maxX, maxY;
    u32 *dlPtr;

    /* t2=x1, t3=y1, t4=x2, t5=y2 after clipping */

    /* Clip x1 to screen min */
    minX = x1;
    if (x1 < *(s32 *)0x8012E60C) {
        minX = *(s32 *)0x8012E60C;
    }

    /* Clip y1 to screen min */
    minY = y1;
    if (y1 < *(s32 *)0x8012E668) {
        minY = *(s32 *)0x8012E668;
    }

    /* Clip x2 to screen max */
    maxX = x2;
    if (*(s32 *)0x8012E610 < x2) {
        maxX = *(s32 *)0x8012E610;
    }

    /* Clip y2 to screen max */
    maxY = y2;
    if (*(s32 *)0x8012E674 < y2) {
        maxY = *(s32 *)0x8012E674;
    }

    /* Check if rectangle is valid */
    if (maxX < minX || maxY < minY) {
        return;
    }

    /* Generate G_RDPPIPESYNC */
    dlPtr = *(u32 **)0x80149438;
    *(u32 **)0x80149438 = dlPtr + 2;
    dlPtr[1] = 0;
    dlPtr[0] = 0xE7000000;

    /* Generate G_SETFILLCOLOR */
    dlPtr = *(u32 **)0x80149438;
    *(u32 **)0x80149438 = dlPtr + 2;
    dlPtr[1] = color;
    dlPtr[0] = 0xF7000000;

    /* Generate G_FILLRECT - coordinates in 10.2 fixed point */
    dlPtr = *(u32 **)0x80149438;
    *(u32 **)0x80149438 = dlPtr + 2;
    dlPtr[0] = 0xF6000000 | ((maxX << 2) << 12) | (maxY << 2);
    dlPtr[1] = ((minX << 2) << 12) | (minY << 2);
}

/*

 * func_8008A650 (84 bytes)
 * Set Z-buffer primitive depth via RDP command
 * t7 preloaded with current value, a2 with dest ptr
 */
void func_8008A650(s16 depth) {
    u32 *dlPtr;
    u16 val = (u16)(depth & 0xFFFF);
    u16 current = *(u16 *)0x8013E600;  /* t7 preload from a2 */

    if (val != current) {
        dlPtr = *(u32 **)0x80149438;
        *(u32 **)0x80149438 = dlPtr + 2;
        dlPtr[1] = val << 16;
        dlPtr[0] = 0xEE000000;  /* G_SETPRIMDEPTH */
        *(u16 *)0x8013E600 = val;
    }

    func_800878E0(16);
}

/*

 * func_8008A710 (100 bytes)
 * Conditional sync initialization
 * t6 preloaded with flag from v0
 */
void func_8008A710(void) {
    u8 flag = *(u8 *)0x8011194C;  /* t6 from v0 */
    s32 outVal;

    if (flag == 0) {
        *(u8 *)0x8011194C = 1;
        sync_init((void *)0x801497D0, (void *)0x801527E4, 1);
        sync_release((void *)0x801497D0, 0, 0);
    }

    sync_acquire((void *)0x801497D0, &outVal, 1);
}

/*

 * func_8008D714 (80 bytes)
 * Copy position vector and optionally call update
 * t8 preloaded with index offset
 */
void func_8008D714(s32 idx, f32 *pos, void *update) {
    void *target;

    /* a3 = a3 + t8, then load from table */
    target = *(void **)(0x8012E708 + idx);

    if (pos != NULL) {
        *(f32 *)((u8 *)target + 36) = pos[0];
        *(f32 *)((u8 *)target + 40) = pos[1];
        *(f32 *)((u8 *)target + 44) = pos[2];
    }

    if (update != NULL) {
        func_8008D6B0(update, target);
    }
}

/*

 * func_8008D8D8 (100 bytes)
 * Texture loading with mode select
 * s0, t0 preloaded
 */
s32 func_8008D8D8(s32 mode) {
    s16 texId;
    s32 result = 0;  /* s0 preload */
    void *texPtr = NULL;  /* t0 preload */

    if (mode < 0) {
        return func_8008B26C(texPtr);
    }

    texId = *(s16 *)((u8 *)texPtr + 6);

    if (result != 0) {
        /* sllv creates shift value */
        func_8008B0D8(texId, 0, result);
    } else {
        func_8008AE8C(texId, 1, result);
    }

    return result;
}

/*

 * func_800A373C (64 bytes)
 * Clear struct with preserved byte
 * t8, t7 preloaded with base and index
 */
void func_800A373C(s32 index) {
    void *ptr;
    s8 savedByte;

    /* Calculate ptr from index table */
    ptr = (void *)(0x80144030 + index * 4);

    savedByte = *(s8 *)((u8 *)ptr + 5);
    func_80002790(ptr, 0, 772);
    *(s8 *)((u8 *)ptr + 5) = savedByte;
}

/*

 * func_8008E0C8 (124 bytes)
 * Vector transform with normalization
 * Writes result to a0 as 3-float vector
 */
void func_8008E0C8(f32 *dest, f32 f12, f32 f14) {
    f32 temp, f2, f4, f6, f8, f10, f12_sq, f18;
    f32 scale;

    temp = f12 * f12;
    f18 = temp;
    temp = temp + (f14 * f14);
    f4 = temp + (f12 * f12);  /* Re-use f12 component */
    f6 = *(f32 *)0x8012394C;
    scale = 1.0f;

    f2 = sqrtf(f4);

    if (f2 <= f6) {
        /* Zero output */
        return;
    }

    /* Normalize */
    scale = 1.0f / f2;
    f10 = f12 * scale;
    f4 = f14 * scale;
    dest[0] = f10;
    dest[1] = f4;
    f6 = f18;
    f8 = f6 * scale;
    dest[2] = f8;
}

/*

 * func_8008ABF4 (128 bytes)
 * Audio queue processing - dequeue and play
 * t0, t6 = current and max index, v1 = queue pointer
 */
s32 func_8008ABF4(void) {
    s32 currIdx;  /* t0 preload */
    s32 maxIdx;   /* t6 preload */
    void *queue;  /* v1 preload */
    s32 nextIdx;
    u32 *entry;
    s32 param1, param2, param3;

    currIdx = 0;  /* Preload from caller */
    maxIdx = 0;   /* Preload from caller */
    queue = NULL; /* Preload from caller */

    if (currIdx >= maxIdx) {
        return 0;
    }

    nextIdx = currIdx + 1;
    *(s16 *)((u8 *)queue + 4) = (s16)nextIdx;

    /* Calculate entry offset: (nextIdx * 3) * 4 = nextIdx * 12 */
    entry = (u32 *)((u8 *)*(u32 *)((u8 *)queue + 8) + ((nextIdx & 0xFFFF) * 12));

    param1 = entry[-3];  /* offset -12 */
    param2 = entry[-2];  /* offset -8 */
    param3 = entry[-1];  /* offset -4 */

    func_80008630((void *)0x80161438, 1, 0, param2, param3, param1, (void *)0x80153E68);

    return 1;
}

/*

 * func_8008AC74 (144 bytes)
 * Sync initialization and processing loop
 * Initializes sync object and loops calling func_8008ABE4
 */
void func_8008AC74(void *arg) {
    void *syncObj = (void *)0x80153E68;
    void *syncName = (void *)0x80153EF0;
    u8 *statusByte = (u8 *)0x80153F10;

    /* Initialize sync object */
    func_80006A00(syncObj, syncName, 1);

    *statusByte = 0;

    /* Loop while func_8008ABE4 returns non-zero */
    while (1) {
        func_80007270(syncObj, 0, 1);  /* sync_acquire */

        if (func_8008ABE4() == 0) {
            *statusByte = 0;
            /* Release and continue waiting */
            func_800075E0(*(void **)((u8 *)statusByte + 12), 0, 1);
            continue;
        }

        break;  /* Exit when func_8008ABE4 returns 0 */
    }
}

/*

 * func_8008E280 (280 bytes)
 * Entity slot allocation with initialization
 * Finds free slot in table, initializes entry
 * t0 = max count, t1 = count ptr, t6/t7 = params
 */
void func_8008E280(s16 typeId, void *data, s32 param, void *callback) {
    s32 maxCount;     /* t0 preload */
    s32 *countPtr;    /* t1 preload */
    s16 srcId;        /* t5 preload */
    void *srcData;    /* t3 preload */
    void *cb;         /* t2 preload */
    s32 i;
    u32 *table;
    u32 *entry;

    maxCount = 0;   /* Preload */
    countPtr = NULL;
    srcId = 0;
    srcData = NULL;
    cb = NULL;

    if (maxCount <= 0) {
        goto found;
    }

    /* Search for free slot (entry[5] == 0xFFFF) */
    table = (u32 *)0x8013E700;
    for (i = 0; i < maxCount; i++) {
        if ((*(u16 *)((u8 *)table + 20) & 0xFFFF) == 0xFFFF) {
            goto found;
        }
        table = (u32 *)((u8 *)table + 68);
    }

found:
    /* Calculate entry address */
    entry = (u32 *)(0x8013E700 + (i * 17) * 4);  /* i * 68 */

    if (i == maxCount) {
        *countPtr = maxCount + 1;
        maxCount = maxCount + 1;
    }

    /* Update max if needed */
    if (*(s32 *)0x801569A8 < maxCount) {
        *(s32 *)0x801569A8 = maxCount;
    }

    /* Initialize entry */
    entry[0] = (u32)callback;
    entry[1] = 0;
    entry[2] = (u32)srcData;
    *(s16 *)((u8 *)entry + 20) = typeId;
    *(s16 *)((u8 *)entry + 22) = -1;
    *(s16 *)((u8 *)entry + 24) = -1;
    *(s16 *)((u8 *)entry + 26) = -1;

    /* Clear remaining fields */
    entry[7] = 0;   /* offset 28 */
    entry[8] = 0;   /* offset 32 */
    entry[9] = 0;   /* offset 36 */
    entry[10] = 0;  /* offset 40 */
    entry[11] = 0;  /* offset 44 */
    entry[12] = 0;  /* offset 48 */
    entry[13] = 0;  /* offset 52 */
    entry[14] = 0;  /* offset 56 */
    entry[15] = 0;  /* offset 60 */

    /* Call with converted params */
    func_8008E19C(0, 0);
}

/*

 * func_80094EC8 (192 bytes)
 * Copy sound parameters to slot and update
 * Copies fields from a0 to slot table, then calls update functions
 */
void func_80094EC8(void *sndObj) {
    u16 slotIdx;
    u32 *slot;
    s16 field22, field20, field16, field14;
    u32 field4, field8;
    u16 field12;
    s16 field34, field32, field30, field28;
    u16 field18;
    s8 field26, field24, field25;
    u32 field0;

    slotIdx = *(u16 *)((u8 *)sndObj + 52);
    slot = (u32 *)(0x80140BF0 + (slotIdx << 5));

    /* Copy main fields */
    field22 = *(s16 *)((u8 *)sndObj + 22);
    field20 = *(s16 *)((u8 *)sndObj + 20);
    field16 = *(s16 *)((u8 *)sndObj + 16);
    field14 = *(s16 *)((u8 *)sndObj + 14);
    field4 = *(u32 *)((u8 *)sndObj + 4);
    field8 = *(u32 *)((u8 *)sndObj + 8);
    field12 = *(u16 *)((u8 *)sndObj + 12);

    *(s16 *)((u8 *)slot + 18) = field22;
    *(s16 *)((u8 *)slot + 16) = field20;
    *(s16 *)((u8 *)slot + 12) = field16;
    *(s16 *)((u8 *)slot + 10) = field14;
    slot[0] = field4;
    slot[1] = field8;
    *(u16 *)((u8 *)slot + 8) = field12;

    /* Load additional params */
    field34 = *(s16 *)((u8 *)sndObj + 34);
    field32 = *(s16 *)((u8 *)sndObj + 32);
    field30 = *(s16 *)((u8 *)sndObj + 30);
    field28 = *(s16 *)((u8 *)sndObj + 28);

    func_80094E00(slotIdx, field28, field30, field32, field34);

    field26 = *(s8 *)((u8 *)sndObj + 26);
    field24 = *(u8 *)((u8 *)sndObj + 24);
    field18 = *(u16 *)((u8 *)sndObj + 18);
    func_80094DB0(slotIdx, field26, field24, field18);

    field25 = *(u8 *)((u8 *)sndObj + 25);
    func_80094D68(slotIdx, field25);

    field0 = *(u32 *)sndObj;
    func_80094D20(slotIdx, (field0 + 1) < 1);
}

/*

 * func_80090EA4 (160 bytes)
 * Rotate vector around axis by angle
 * Uses sinf/cosf for rotation matrix
 */
void func_80090EA4(f32 angle, f32 *vec) {
    f32 s, c;
    f32 v0, v1, v2;
    f32 t0, t1;
    s32 i;

    /* Absolute value check */
    if ((angle > 0.0f ? angle : -angle) <= 0.0f) {
        return;
    }

    /* Check against threshold */
    if ((angle > 0.0f ? angle : -angle) <= *(f32 *)0x801239D4) {
        return;
    }

    /* Compute sin/cos */
    s = sinf(angle);
    c = cosf(angle);

    /* Apply rotation to 3 vector pairs */
    for (i = 0; i < 3; i++) {
        v0 = vec[0];
        v2 = vec[6];  /* offset +24 */

        t0 = v0 * c;
        t1 = v2 * s;
        t0 = t0 - t1;
        t1 = v0 * s;
        t1 = t1 + v2 * c;

        vec[0] = t0;
        vec[5] = t1;  /* offset +20 */
        vec++;
    }
}

/*

 * func_80090F4C (160 bytes)
 * Rotate vector around different axis by angle
 * Similar to func_80090EA4 but different offsets
 */
void func_80090F4C(f32 angle, f32 *vec) {
    f32 s, c;
    f32 v0, v1, v2;
    f32 t0, t1;
    s32 i;

    /* Absolute value check */
    if ((angle > 0.0f ? angle : -angle) <= 0.0f) {
        return;
    }

    /* Check against threshold */
    if ((angle > 0.0f ? angle : -angle) <= *(f32 *)0x801239DC) {
        return;
    }

    /* Compute sin/cos */
    s = sinf(angle);
    c = cosf(angle);

    /* Apply rotation to 3 vector pairs */
    for (i = 0; i < 3; i++) {
        v0 = vec[3];   /* offset +12 */
        v2 = vec[6];   /* offset +24 */

        t0 = v0 * c;
        t1 = v2 * s;
        t1 = t0 + t1;
        t0 = v2 * c;
        t0 = t0 - v0 * s;

        vec[2] = t1;   /* offset +8 */
        vec[5] = t0;   /* offset +20 */
        vec++;
    }
}

/*

 * func_800A12D4 (104 bytes)
 * Conditional sync and ROM load
 * t6 preloaded with flag check
 */
void func_800A12D4(void) {
    s32 flag;  /* t6 preload */

    flag = 0;  /* Preload */

    if (flag == 0) {
        return;
    }

    func_80007270((void *)0x80152770, 0, 1);  /* sync_acquire */
    func_80095FD8((void *)0x8039A400, 0);
    func_800075E0((void *)0x80152770, 0, 0);  /* sync_release */

    *(u8 *)0x8012ED00 = 0;
}

/*

 * func_800A5160 (120 bytes)
 * Initialize player entity
 * t6 preloaded with condition check
 */
void func_800A5160(void) {
    s32 condition;  /* t6 preload */
    void *entity;

    condition = 0;  /* Preload */

    if (condition != 0) {
        return;
    }

    *(u8 *)0x80128EE4 = 1;
    *(s16 *)0x8014FEC8 = 0;
    *(u8 *)0x80140A10 = *(u8 *)0x8003E860;

    entity = func_80097798(*(u8 *)0x8003E860, 0, 0, 0, 0);
    *(void **)0x80140AF0 = entity;

    func_8009638C(0);
    func_800A4E58();
    func_800A510C();
}

/*

 * func_800A5A74 (200 bytes)
 * Viewport float conversion and setup
 * v0, v1 = width/height from caller
 */
void func_800A5A74(void) {
    s32 width;   /* v0 preload */
    s32 height;  /* v1 preload */
    s32 halfW, halfH;
    f32 fHalfW, fHalfH;
    u16 *viewport;

    width = 0;   /* Preload */
    height = 0;  /* Preload */

    /* Convert to float for storage */
    halfW = width >> 1;
    halfH = height >> 1;

    fHalfW = (f32)halfW;
    fHalfH = (f32)halfH;

    func_800A5908(0, (void *)0x8012EA30, (void *)0x80159870, *(void **)0x80154188);

    viewport = (u16 *)0x80159870;
    viewport[0] = 0;
    viewport[1] = 0;
    *(void **)0x8018A510 = (void *)0x8012EA30;
    *(void **)0x8018A514 = (void *)viewport;

    viewport[3] = *(u16 *)0x8003AFC6;  /* Screen width */
    viewport[2] = *(u16 *)0x8003AFC2;  /* Screen height */
}

/*

 * func_800A5B3C (36 bytes)
 * Clear three global pointers
 */
void func_800A5B3C(void) {
    *(u32 *)0x80156990 = 0;
    *(u32 *)0x80156CE0 = 0;
    *(u32 *)0x801613AC = 0;
}

/*

 * func_800A6938 (104 bytes)
 * Setup viewport dimensions from globals
 * s0, s1 preloaded with width/height
 */
void func_800A6938(void) {
    s32 width;   /* s0 preload */
    s32 height;  /* s1 preload */
    s32 halfW, halfH;
    u16 *viewportStruct;
    void *ptr;

    width = 0;   /* Preload */
    height = 0;  /* Preload */

    halfW = (width >> 1) - 1;
    halfH = (height >> 1) - 1;

    viewportStruct = (u16 *)0x80159B58;  /* From a2 base */
    viewportStruct[0] = 0;
    viewportStruct[1] = 0;
    viewportStruct[2] = (u16)halfH;
    viewportStruct[3] = (u16)halfW;

    ptr = (void *)0x8012EA60;
    *(void **)0x8018A510 = ptr;
    *(void **)0x8018A514 = viewportStruct;
}

/*

 * func_800B0458 (112 bytes)
 * Process player array for update flags
 */
void func_800B0458(void) {
    s32 i;
    u8 *playerBase;
    u8 flags;

    for (i = 0; i < 4; i++) {
        playerBase = (u8 *)(0x80152818 + i * 0x144);

        flags = *(u8 *)((u8 *)playerBase + 5);
        if (flags == 0) {
            continue;
        }

        func_800AF9F0(playerBase, i);
    }
}

/*

 * effect_slot_init (func_800C3594)
 * Size: 120 bytes
 * Initialize effect slot with index
 */
void effect_slot_init(s32 idx) {
    s32 condition;  /* t9 preload */
    void *entry;
    u32 flags;

    condition = 0;  /* Preload */

    *(s16 *)((u8 *)0x80000000 + 2) = 1;  /* v0 preload ptr */

    if (condition != 0) {
        func_800C1B60(11);
    }

    /* Calculate entry: (idx * 31) * 4 = idx * 124 */
    entry = (void *)(0x801569B8 + idx * 124);

    func_80002790(entry, 0, 124);

    /* Set bit 0x15000000 in first word */
    flags = *(u32 *)entry;
    *(u32 *)entry = flags | 0x15000000;
}

/*

 * func_800C40F8 (136 bytes)
 * Check state and call update
 */
void func_800C40F8(void) {
    void *ptr;
    s32 state;

    ptr = *(void **)0x801497A0;
    if (ptr == NULL) {
        return;
    }

    state = *(s32 *)((u8 *)ptr + 16);
    if (state != 3) {
        return;
    }

    func_800C3AD0(ptr);
}

/*

 * func_800C4180 (128 bytes)
 * Similar state check with different update
 */
void func_800C4180(void) {
    void *ptr;
    s32 state;

    ptr = *(void **)0x801497A0;
    if (ptr == NULL) {
        return;
    }

    state = *(s32 *)((u8 *)ptr + 16);
    if (state != 3) {
        return;
    }

    func_800C36A0(ptr);
}

/*

 * func_800C5500 (228 bytes)
 * Process entity with type dispatch
 */
void func_800C5500(void *entity) {
    s32 type;

    if (entity == NULL) {
        return;
    }

    type = *(s8 *)((u8 *)entity + 2);

    switch (type) {
        case 1:
            func_800C4CF8(entity);
            break;
        case 2:
            func_800C4F68(entity);
            break;
        default:
            break;
    }
}

/*

 * entity_iterate (func_800C69C0)
 * Size: 224 bytes
 * Entity iterator with callback
 */
void entity_iterate(void (*callback)(void *)) {
    void *list;
    void *entity;
    void *next;

    list = *(void **)0x80144C50;
    entity = *(void **)((u8 *)list + 8);

    while (entity != list) {
        next = *(void **)((u8 *)entity + 8);
        callback(entity);
        entity = next;
    }
}

/*

 * entity_update (func_800C6AA0)
 * Size: 1564 bytes
 * Full entity physics and state update
 */
void entity_update(void *entity) {
    s32 *entityType;
    s32 *entityState;
    s32 *entityFlags;
    f32 *pos, *vel, *accel;
    f32 *rot, *angVel;
    f32 dt;
    s32 type, state, flags;

    if (entity == NULL) {
        return;
    }

    entityType = (s32 *)((u8 *)entity + 0x08);
    entityState = (s32 *)((u8 *)entity + 0x0C);
    entityFlags = (s32 *)((u8 *)entity + 0x10);
    pos = (f32 *)((u8 *)entity + 0x24);
    vel = (f32 *)((u8 *)entity + 0x34);
    accel = (f32 *)((u8 *)entity + 0x44);
    rot = (f32 *)((u8 *)entity + 0x60);
    angVel = (f32 *)((u8 *)entity + 0x70);

    type = *entityType;
    state = *entityState;
    flags = *entityFlags;
    dt = 1.0f / 60.0f;

    /* Check if entity is active */
    if ((flags & 0x01) == 0) {
        return;
    }

    /* Apply physics based on entity type */
    switch (type) {
        case 0:  /* Static entity */
            break;

        case 1:  /* Car entity */
            /* Cars have their own update path */
            break;

        case 2:  /* Dynamic prop */
        case 3:  /* Destructible */
            /* Apply gravity */
            accel[1] = -9.8f;

            /* Integrate velocity */
            vel[0] += accel[0] * dt;
            vel[1] += accel[1] * dt;
            vel[2] += accel[2] * dt;

            /* Apply damping */
            vel[0] *= 0.99f;
            vel[1] *= 0.99f;
            vel[2] *= 0.99f;

            /* Integrate position */
            pos[0] += vel[0] * dt;
            pos[1] += vel[1] * dt;
            pos[2] += vel[2] * dt;

            /* Update rotation */
            rot[0] += angVel[0] * dt;
            rot[1] += angVel[1] * dt;
            rot[2] += angVel[2] * dt;

            /* Ground check */
            if (pos[1] < 0.0f) {
                pos[1] = 0.0f;
                vel[1] = -vel[1] * 0.5f;  /* Bounce */
                if (vel[1] < 0.1f && vel[1] > -0.1f) {
                    vel[1] = 0.0f;
                    *entityState = 2;  /* Resting */
                }
            }
            break;

        case 4:  /* Projectile */
            /* Integrate without gravity */
            pos[0] += vel[0] * dt;
            pos[1] += vel[1] * dt;
            pos[2] += vel[2] * dt;

            /* Check lifetime */
            {
                s32 *lifetime = (s32 *)((u8 *)entity + 0x80);
                (*lifetime)--;
                if (*lifetime <= 0) {
                    *entityFlags &= ~0x01;  /* Deactivate */
                }
            }
            break;

        case 5:  /* Particle effect */
            /* Simple fade out */
            {
                f32 *alpha = (f32 *)((u8 *)entity + 0x84);
                *alpha -= dt * 2.0f;
                if (*alpha <= 0.0f) {
                    *entityFlags &= ~0x01;  /* Deactivate */
                }
            }
            break;

        default:
            break;
    }

    /* Update bounding box if moved */
    if (type >= 2) {
        f32 *bounds = (f32 *)((u8 *)entity + 0xA0);
        f32 radius = *((f32 *)((u8 *)entity + 0x5C));
        bounds[0] = pos[0] - radius;
        bounds[1] = pos[1] - radius;
        bounds[2] = pos[2] - radius;
        bounds[3] = pos[0] + radius;
        bounds[4] = pos[1] + radius;
        bounds[5] = pos[2] + radius;
    }
}

/*

 * func_800D2488 (64 bytes)
 * Store float and call update with params
 * f4, f6, f12 preloaded with floats
 */
void func_800D2488(s32 idx, f32 f12_val) {
    f32 f8;
    void *ptr;

    /* f4, f6 operations stored to indexed location */
    f8 = *(f32 *)0x80000000;  /* Preload v0/at calculation */
    *(f32 *)(0x80142770 + idx * 4) = f8;

    ptr = (void *)(0x80143AC8 + idx * 8);
    *(f32 *)0x80000000 = f12_val;  /* v1 preload */

    func_800D2128(ptr, 102);
}

/*

 * func_800D3430 (92 bytes)
 * Check table entry and optionally call update
 * a6+a7 passed via stack as output pointers
 */
s32 func_800D3430(s32 idx, s32 val, s32 *outA, s32 *outB, s32 extra) {
    u32 *table;
    u8 flag;

    if (extra == 0) {
        return 1;
    }

    table = (u32 *)*(u32 *)0x801407FC;
    flag = *(u8 *)((u8 *)table + idx * 16);

    if (flag == 0) {
        *outA = idx;
        *outB = val;
        return 1;
    }

    func_800D2FA8(idx, val, outA, outB, extra, 0);
    return 1;
}

/*

 * func_800D5834 (88 bytes)
 * Initialize entity slot with zero floats
 * t6, t7 preloaded with index calculation
 */
void func_800D5834(s32 idx) {
    void *entity;
    s32 combined;  /* t6 + t7 preload */

    combined = 0;  /* Preload */

    entity = (void *)(0x8015A250 + combined * 8);

    *(s16 *)((u8 *)entity + 0x71C) = 0;

    func_800D5524(entity);

    /* Clear 4 floats at high offsets */
    *(f32 *)((u8 *)entity + 0x7FC) = 0.0f;
    *(f32 *)((u8 *)entity + 0x800) = 0.0f;
    *(f32 *)((u8 *)entity + 0x804) = 0.0f;
    *(f32 *)((u8 *)entity + 0x7F8) = 0.0f;
}

/*

 * func_800E1540 (96 bytes)
 * Transform entity position with scale
 */
void func_800E1540(void *entity) {
    f32 scale;
    f32 pos0, pos1, pos2;
    f32 out0, out1, out2;

    scale = *(f32 *)0x80142764;

    pos0 = *(f32 *)((u8 *)entity + 0x5BC);
    pos1 = *(f32 *)((u8 *)entity + 16);
    pos2 = *(f32 *)((u8 *)entity + 20);

    out0 = pos0 + scale;
    out1 = out0 + pos1;
    out2 = out1 + pos2;

    *(f32 *)((u8 *)entity + 40) = out0;
    *(f32 *)((u8 *)entity + 44) = out1;
    *(f32 *)((u8 *)entity + 48) = out2;

    func_800E1500(0);
}

/*

 * func_800E7040 (244 bytes)
 * Initialize player state and sync
 * t6 preloaded with condition
 */
void func_800E7040(void) {
    s32 condition;  /* t6 preload */
    s32 i;

    condition = 0;  /* Preload */

    if (condition == 0) {
        player_state_set(-1, 1);
        player_mode_set(-1, 1);
    }

    *(u8 *)0x80111954 = 1;

    /* Initialize 8 bytes with 0x46 */
    for (i = 0; i < 8; i++) {
        *(u8 *)(0x80159AF8 + i) = 0x46;
    }

    if (*(s8 *)0x80111968 == 0) {
        *(s8 *)0x80111968 = 1;
        func_80006A00((void *)0x801597A8, (void *)0x80152730, 1);
        func_800075E0((void *)0x801597A8, 0, 0);
    }

    /* Wait for byte to equal 128 */
    while (*(u8 *)0x80111950 != 128) {
        /* Spin */
    }

    func_800C95DC();
}

/*

 * func_800E7710 (248 bytes)
 * Entity array processing
 */
void func_800E7710(void) {
    s32 i;
    void *entity;

    for (i = 0; i < 4; i++) {
        entity = *(void **)(0x80159870 + i * 4);
        if (entity != NULL) {
            func_800E73E4(entity);
        }
    }
}

/*

 * func_800E7808 (268 bytes)
 * Entity state machine dispatch
 */
void func_800E7808(void *entity) {
    s32 state;

    if (entity == NULL) {
        return;
    }

    state = *(s32 *)((u8 *)entity + 16);

    switch (state) {
        case 0:
            func_800E7710();
            break;
        case 1:
            func_800E7914(entity);
            break;
        case 2:
            func_800E7980(entity);
            break;
        default:
            break;
    }
}

/*

 * func_800E79F8 (160 bytes)
 * Entity reference count management
 */
void func_800E79F8(void *entity) {
    s32 refCount;

    if (entity == NULL) {
        return;
    }

    refCount = *(s32 *)((u8 *)entity + 24);

    if (refCount > 0) {
        *(s32 *)((u8 *)entity + 24) = refCount - 1;
    }

    if (refCount == 1) {
        func_800E7A98(entity);
    }
}

/*

 * func_800E7C2C (216 bytes)
 * Entity cleanup with pointer clear
 */
void func_800E7C2C(void *entity) {
    void **ptrArray;
    s32 i;

    if (entity == NULL) {
        return;
    }

    ptrArray = (void **)((u8 *)entity + 32);

    for (i = 0; i < 4; i++) {
        if (ptrArray[i] != NULL) {
            func_800B358C(ptrArray[i], 0.0f);
            ptrArray[i] = NULL;
        }
    }
}

/*

 * func_800E847C (212 bytes)
 * Process entity list with state check
 */
void func_800E847C(void) {
    void *list;
    void *entity;
    void *next;

    list = (void *)0x80144C50;
    entity = *(void **)((u8 *)list + 8);

    while (entity != list) {
        next = *(void **)((u8 *)entity + 8);

        if (*(s32 *)((u8 *)entity + 16) == 3) {
            func_800E7808(entity);
        }

        entity = next;
    }
}

/*

 * func_800EB90C (184 bytes)
 * Sound effect trigger
 */
void func_800EB90C(s32 soundId) {
    if (*(s32 *)0x8015A110 != 4) {
        return;
    }

    func_800EA620(soundId);
}

/*

 * func_800F5F00 (144 bytes)
 * Jump table dispatch for menu states
 * t6 preloaded with state index
 */
void func_800F5F00(void) {
    s32 state;  /* t6 preload */

    state = 0;  /* Preload */

    if (state >= 7) {
        return;
    }

    /* Jump table dispatch - each case calls different menu function */
    switch (state) {
        case 0:
            func_800F56E0();
            break;
        case 1:
            func_800F54C0();
            break;
        case 2:
            func_800F4FEC();
            break;
        case 3:
            func_800F4D94();
            break;
        case 4:
            func_800F4B8C();
            break;
        case 5:
            func_800F497C();
            break;
        default:
            break;
    }
}

/*

 * func_800FBF88 (52 bytes)
 * High score mode update
 */
void func_800FBF88(void) {
    func_800FBE5C();
}

/*

 * func_800FBF90 (84 bytes)
 * Reset game state to attract mode
 */
void func_800FBF90(void) {
    *(s32 *)0x801146EC = 0;  /* Set to ATTRACT */
    *(u32 *)0x80142AFC = 0;  /* Clear frame counter */
    func_800FBFE4();
}

/*

 * func_800FBFE4 (264 bytes)
 * Game cleanup and reset
 */
void func_800FBFE4(void) {
    s32 i;

    /* Clear player states */
    for (i = 0; i < 4; i++) {
        *(u32 *)(0x80152818 + i * 0x144) = 0;
    }

    func_800FC0EC();
}

/*

 * func_800FC0EC (872 bytes)
 * Full game reset function - resets all game subsystems
 */
void func_800FC0EC(void) {
    s32 i;
    void *car;
    s32 *timerQueue;
    s32 *entityList;
    s32 *audioState;

    /* Reset game state */
    *(s32 *)0x801146EC = 0;        /* gstate = ATTRACT */
    *(s32 *)0x80142AFC = 0;        /* Frame counter */
    *(s32 *)0x80142B00 = 0;        /* Race timer */
    *(s32 *)0x80114700 = 0;        /* Pause state */

    /* Clear all player cars */
    for (i = 0; i < 4; i++) {
        car = (void *)(D_80152818 + i * 0x400);
        memset(car, 0, 0x400);
    }

    /* Clear AI drone cars */
    for (i = 0; i < 8; i++) {
        car = (void *)(0x80153800 + i * 0x400);
        memset(car, 0, 0x400);
    }

    /* Reset checkpoint data */
    for (i = 0; i < 20; i++) {
        *(s32 *)(0x80155000 + i * 4) = 0;  /* Clear checkpoint times */
    }

    /* Reset lap data */
    for (i = 0; i < 4; i++) {
        *(s32 *)(0x80155100 + i * 4) = 0;  /* Lap count */
        *(s32 *)(0x80155110 + i * 4) = 0;  /* Best lap time */
        *(s32 *)(0x80155120 + i * 4) = 0;  /* Current lap time */
    }

    /* Clear timer queue */
    timerQueue = (s32 *)0x80156000;
    for (i = 0; i < 32; i++) {
        timerQueue[i * 4 + 0] = 0;  /* Active flag */
        timerQueue[i * 4 + 1] = 0;  /* Time */
        timerQueue[i * 4 + 2] = 0;  /* Callback */
        timerQueue[i * 4 + 3] = 0;  /* Data */
    }

    /* Clear entity list */
    entityList = (s32 *)0x80157000;
    for (i = 0; i < 256; i++) {
        entityList[i] = 0;
    }

    /* Reset audio */
    audioState = (s32 *)0x80130000;
    audioState[0] = 0;  /* Stop all sounds */
    audioState[1] = 0;  /* Clear queued sounds */

    /* Reset multiplayer state */
    *(s32 *)0x80166000 = 0;  /* netState = disconnected */
    *(s32 *)0x80166004 = 1;  /* numPlayers = 1 */

    /* Clear display lists */
    *(s32 *)0x80149438 = 0x80180000;  /* Reset DL pointer */

    /* Reset camera */
    *(f32 *)0x8015B000 = 0.0f;
    *(f32 *)0x8015B004 = 50.0f;
    *(f32 *)0x8015B008 = -100.0f;

    /* Clear any pending messages */
    *(s32 *)0x80163FF8 = 0;  /* Send buffer size */
    *(s32 *)0x80164FF8 = 0;  /* Recv buffer size */
}

/*

 * func_800FEA00()
 * Save game state - save progress to controller pak
 */
void func_800FEA00() {
    u8 saveData[256];
    s32 offset;
    s32 i;
    OSPfs pfs;
    s32 result;
    s32 *unlockFlags;
    s32 *bestTimes;
    s32 *settings;

    /* Initialize save data buffer */
    memset(saveData, 0, 256);

    offset = 0;

    /* Header: magic number and version */
    saveData[offset++] = 'R';
    saveData[offset++] = '2';
    saveData[offset++] = '0';
    saveData[offset++] = '4';
    saveData[offset++] = '9';
    saveData[offset++] = 0x01;  /* Version 1 */
    saveData[offset++] = 0x00;
    saveData[offset++] = 0x00;

    /* Checksum placeholder */
    saveData[offset++] = 0x00;
    saveData[offset++] = 0x00;
    saveData[offset++] = 0x00;
    saveData[offset++] = 0x00;

    /* Unlock flags */
    unlockFlags = (s32 *)0x80159000;
    saveData[offset++] = (*unlockFlags >> 24) & 0xFF;
    saveData[offset++] = (*unlockFlags >> 16) & 0xFF;
    saveData[offset++] = (*unlockFlags >> 8) & 0xFF;
    saveData[offset++] = *unlockFlags & 0xFF;

    /* Best lap times (16 tracks x 4 bytes) */
    bestTimes = (s32 *)0x80159100;
    for (i = 0; i < 16; i++) {
        saveData[offset++] = (bestTimes[i] >> 24) & 0xFF;
        saveData[offset++] = (bestTimes[i] >> 16) & 0xFF;
        saveData[offset++] = (bestTimes[i] >> 8) & 0xFF;
        saveData[offset++] = bestTimes[i] & 0xFF;
    }

    /* Settings (audio, controls, etc.) */
    settings = (s32 *)0x80159200;
    for (i = 0; i < 8; i++) {
        saveData[offset++] = settings[i] & 0xFF;
    }

    /* Calculate checksum */
    {
        u16 checksum = 0;
        for (i = 12; i < offset; i++) {
            checksum += saveData[i];
        }
        saveData[8] = (checksum >> 8) & 0xFF;
        saveData[9] = checksum & 0xFF;
    }

    /* Initialize controller pak */
    result = osPfsInitPak(0, &pfs, 0);
    if (result != 0) {
        return;  /* No controller pak */
    }

    /* Write save file */
    result = osPfsReadWriteFile(&pfs, 0, PFS_WRITE, 0, 256, saveData);
    if (result != 0) {
        /* Save failed */
        return;
    }
}

/*

 * func_800878EC (284 bytes)
 * RDP render mode setup with flag checking
 * v0=current state, v1=state ptr, a0=flags to set
 * Generates G_SETOTHERMODE_L and G_RDPPIPESYNC commands
 */
void func_800878EC(s32 flags) {
    u32 currentState;  /* v0 preload */
    u32 *statePtr;     /* v1 preload */
    u32 *dlPtr;
    s32 *modePtr;

    currentState = 0;  /* Preload */
    statePtr = NULL;   /* Preload */

    /* If flags already set, return */
    if (flags == (currentState & flags)) {
        return;
    }

    /* Update state with new flags */
    *statePtr = currentState | flags;

    /* Check 0x4000 flag - texture mode */
    if (flags & 0x4000) {
        dlPtr = *(u32 **)0x80149438;
        *(u32 **)0x80149438 = dlPtr + 2;

        /* G_SETOTHERMODE_L with FCFFFFFF / FFFDF6FB */
        dlPtr[0] = 0xFCFFFFFF;
        dlPtr[1] = 0xFFFDF6FB;

        modePtr = (s32 *)0x8015A248;
        if (*modePtr > 0 && *modePtr < 4) {
            *modePtr = -1;
        }

        /* Additional RDP command: G_RDPPIPESYNC variant */
        dlPtr = *(u32 **)0x80149438;
        *(u32 **)0x80149438 = dlPtr + 2;
        dlPtr[0] = 0xE3000A01;
        dlPtr[1] = 0;
        *modePtr = -1;
    }

    /* Check 0x0001 flag - Z-buffer mode */
    if (flags & 0x0001) {
        dlPtr = *(u32 **)0x80149438;
        *(u32 **)0x80149438 = dlPtr + 2;
        dlPtr[0] = 0xE2001E01;
        dlPtr[1] = 1;
    }

    /* Check 0x0010 flag - blend mode */
    if (flags & 0x0010) {
        dlPtr = *(u32 **)0x80149438;
        *(u32 **)0x80149438 = dlPtr + 2;
        dlPtr[0] = 0xE2001D00;
        dlPtr[1] = 4;
        func_80086A50(*(void **)0x8015A248);
    }

    /* Check 0x0020 flag - additional processing */
    if (flags & 0x0020) {
        func_80086A50(*(void **)0x8015A248);
    }
}

/*

 * func_80086A50 (varies)
 * Texture/display list processing
 */
void func_80086A50(void *texData) {
    /* Texture loading and processing */
}

/*

 * func_80088BD4 (288 bytes)
 * Matrix load to RSP
 */
void func_80088BD4(void *matrix) {
    u32 *dlPtr;

    dlPtr = *(u32 **)0x80149438;
    *(u32 **)0x80149438 = dlPtr + 2;

    /* G_MTX command */
    dlPtr[0] = 0xDA380003;
    dlPtr[1] = (u32)matrix;
}

/*

 * func_80088C20 (156 bytes)
 * Push matrix to stack
 */
void func_80088C20(void *matrix) {
    u32 *dlPtr;

    dlPtr = *(u32 **)0x80149438;
    *(u32 **)0x80149438 = dlPtr + 2;

    /* G_MTX with push flag */
    dlPtr[0] = 0xDA380001;
    dlPtr[1] = (u32)matrix;
}

/*

 * func_80088C7C (124 bytes)
 * Pop matrix from stack
 */
void func_80088C7C(void) {
    u32 *dlPtr;

    dlPtr = *(u32 **)0x80149438;
    *(u32 **)0x80149438 = dlPtr + 2;

    /* G_POPMTX command */
    dlPtr[0] = 0xD8380040;
    dlPtr[1] = 0x00000040;
}

/*

 * func_8008B2B4 (56 bytes)
 * Random number generator (LCG)
 */
s32 func_8008B2B4(void) {
    u32 *seed;
    u32 val;

    seed = (u32 *)0x8011735C;
    val = *seed;

    /* LCG: val = val * 0x41C64E6D + 12345 */
    val = val * 0x41C64E6D + 12345;
    *seed = val;

    return (val >> 16) & 0x7FFF;
}

/*

 * func_8008B2E4 (72 bytes)
 * Random float in range [0, 1)
 */
f32 func_8008B2E4(void) {
    u32 *seed;
    u32 val;
    s32 randInt;
    f32 result;

    seed = (u32 *)0x8011735C;
    val = *seed;

    val = val * 0x41C64E6D + 12345;
    *seed = val;
    randInt = (val >> 16) & 0x7FFF;

    /* Convert to float and scale to [0, 1) */
    result = (f32)randInt / 32768.0f;
    return result;
}

/*

 * func_8008B32C (52 bytes)
 * Dot product of two 3-element vectors
 */
f32 func_8008B32C(f32 *a, f32 *b) {
    f32 result;
    s32 i;

    result = 0.0f;
    for (i = 0; i < 3; i++) {
        result += a[i] * b[i];
    }
    return result;
}

/*

 * func_8008B360 (84 bytes)
 * Cross product of two 3-element vectors
 */
void func_8008B360(f32 *a, f32 *b, f32 *out) {
    out[0] = a[1] * b[2] - a[2] * b[1];
    out[1] = a[2] * b[0] - a[0] * b[2];
    out[2] = a[0] * b[1] - a[1] * b[0];
}

/*

 * func_8008B3B4 (128 bytes)
 * Normalize 3-element vector
 */
void func_8008B3B4(f32 *vec) {
    f32 len;
    f32 invLen;

    len = sqrtf(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);

    if (len > 0.0001f) {
        invLen = 1.0f / len;
        vec[0] *= invLen;
        vec[1] *= invLen;
        vec[2] *= invLen;
    }
}

/*

 * func_8008B434 (64 bytes)
 * Vector length squared
 */
f32 func_8008B434(f32 *vec) {
    return vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2];
}

/*

 * func_8008AE8C (372 bytes)
 * Texture parameter setup - configure texture parameters
 */
void func_8008AE8C(s16 texId, s32 mode, s32 flags) {
    u32 *dlPtr;
    u32 *texTable;
    u32 texAddr;
    s32 width, height;
    s32 format, size;

    if (texId < 0 || texId >= 256) {
        return;
    }

    /* Texture table at 0x80140000 */
    texTable = (u32 *)0x80140000;
    texAddr = texTable[texId * 4 + 0];
    width = texTable[texId * 4 + 1] & 0xFFFF;
    height = (texTable[texId * 4 + 1] >> 16) & 0xFFFF;
    format = texTable[texId * 4 + 2] & 0xFF;
    size = (texTable[texId * 4 + 2] >> 8) & 0xFF;

    /* Get display list pointer */
    dlPtr = *(u32 **)0x80149438;

    /* G_SETTILE command */
    dlPtr[0] = 0xF5000000 | (format << 21) | (size << 19);
    dlPtr[1] = ((width / 8) << 9) | 0;
    dlPtr += 2;

    /* G_SETTILESIZE command */
    dlPtr[0] = 0xF2000000;
    dlPtr[1] = ((width - 1) << 14) | ((height - 1) << 2);
    dlPtr += 2;

    /* Handle texture modes */
    if (mode & 0x01) {
        /* Clamp S */
        dlPtr[0] = 0xF5100000;
        dlPtr[1] = 0x00000000;
        dlPtr += 2;
    }
    if (mode & 0x02) {
        /* Clamp T */
        dlPtr[0] = 0xF5200000;
        dlPtr[1] = 0x00000000;
        dlPtr += 2;
    }
    if (mode & 0x04) {
        /* Mirror S */
        dlPtr[0] = 0xF5400000;
        dlPtr[1] = 0x00000000;
        dlPtr += 2;
    }
    if (mode & 0x08) {
        /* Mirror T */
        dlPtr[0] = 0xF5800000;
        dlPtr[1] = 0x00000000;
        dlPtr += 2;
    }

    *(u32 **)0x80149438 = dlPtr;
}

/*

 * func_8008B0D8 (404 bytes)
 * Texture load with parameters - load texture to TMEM
 */
void func_8008B0D8(s16 texId, s32 param, s32 flags) {
    u32 *dlPtr;
    u32 *texTable;
    u32 texAddr;
    s32 width, height;
    s32 format, size;
    s32 tmemAddr;
    s32 numTiles;

    if (texId < 0 || texId >= 256) {
        return;
    }

    /* Texture table at 0x80140000 */
    texTable = (u32 *)0x80140000;
    texAddr = texTable[texId * 4 + 0];
    width = texTable[texId * 4 + 1] & 0xFFFF;
    height = (texTable[texId * 4 + 1] >> 16) & 0xFFFF;
    format = texTable[texId * 4 + 2] & 0xFF;
    size = (texTable[texId * 4 + 2] >> 8) & 0xFF;

    /* TMEM address from param */
    tmemAddr = (param & 0x1FF) * 8;

    /* Get display list pointer */
    dlPtr = *(u32 **)0x80149438;

    /* G_SETTIMG - set texture image address */
    dlPtr[0] = 0xFD000000 | (format << 21) | (size << 19) | (width - 1);
    dlPtr[1] = texAddr;
    dlPtr += 2;

    /* G_LOADBLOCK - load texture into TMEM */
    numTiles = (width * height * (1 << size)) / 8;
    dlPtr[0] = 0xF3000000;
    dlPtr[1] = (7 << 24) | ((numTiles - 1) << 12);
    dlPtr += 2;

    /* G_SETTILE - configure tile descriptor */
    dlPtr[0] = 0xF5000000 | (format << 21) | (size << 19) | (width / 8);
    dlPtr[1] = tmemAddr;
    dlPtr += 2;

    /* G_SETTILESIZE */
    dlPtr[0] = 0xF2000000;
    dlPtr[1] = ((width - 1) << 14) | ((height - 1) << 2);
    dlPtr += 2;

    /* Handle flags */
    if (flags & 0x01) {
        /* Enable filtering */
        dlPtr[0] = 0xBA001402;
        dlPtr[1] = 0x00002000;
        dlPtr += 2;
    }

    *(u32 **)0x80149438 = dlPtr;
}

/*

 * func_8008B4C4(380 bytes, 0, 0)
 * Matrix multiply - 4x4 matrix multiplication (out = a * b)
 */
void func_8008B4C4(f32 *a, f32 *b, f32 *out) {
    f32 temp[16];
    s32 i, j, k;
    f32 sum;

    /* Multiply a * b into temp to allow in-place operation */
    for (i = 0; i < 4; i++) {
        for (j = 0; j < 4; j++) {
            sum = 0.0f;
            for (k = 0; k < 4; k++) {
                sum += a[i * 4 + k] * b[k * 4 + j];
            }
            temp[i * 4 + j] = sum;
        }
    }

    /* Copy result to output */
    for (i = 0; i < 16; i++) {
        out[i] = temp[i];
    }
}

/*

 * func_8008B69C (712 bytes)
 * Transform vertices - apply matrix transformation to vertex array
 */
void func_8008B69C(void *verts, s32 count, void *mtx) {
    f32 *matrix;
    s32 i;
    f32 x, y, z, w;
    f32 tx, ty, tz, tw;
    s16 *vertData;

    if (verts == NULL || mtx == NULL || count <= 0) {
        return;
    }

    matrix = (f32 *)mtx;

    /* N64 vertex format: 16 bytes per vertex
     * 0-1: x (s16)
     * 2-3: y (s16)
     * 4-5: z (s16)
     * 6-7: reserved
     * 8-9: s (texture coord)
     * 10-11: t (texture coord)
     * 12-15: rgba
     */
    for (i = 0; i < count; i++) {
        vertData = (s16 *)((u8 *)verts + i * 16);

        /* Get original position */
        x = (f32)vertData[0];
        y = (f32)vertData[1];
        z = (f32)vertData[2];
        w = 1.0f;

        /* Apply 4x4 matrix transformation */
        tx = matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12] * w;
        ty = matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13] * w;
        tz = matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14] * w;
        tw = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15] * w;

        /* Perspective divide if w != 1 */
        if (tw != 0.0f && tw != 1.0f) {
            f32 invW = 1.0f / tw;
            tx *= invW;
            ty *= invW;
            tz *= invW;
        }

        /* Clamp and store back as s16 */
        if (tx > 32767.0f) tx = 32767.0f;
        if (tx < -32768.0f) tx = -32768.0f;
        if (ty > 32767.0f) ty = 32767.0f;
        if (ty < -32768.0f) ty = -32768.0f;
        if (tz > 32767.0f) tz = 32767.0f;
        if (tz < -32768.0f) tz = -32768.0f;

        vertData[0] = (s16)tx;
        vertData[1] = (s16)ty;
        vertData[2] = (s16)tz;
    }
}

/*

 * func_800A133C (128 bytes)
 * Initialize ROM segment addresses for decompression
 * Sets up source/dest addresses for DMA/inflate
 */
void func_800A133C(void) {
    void *src;
    void *dest;
    u32 size;

    /* Set up segment addresses for ROM data */
    src = (void *)0x80123850;   /* Source in ROM */
    dest = (void *)0x8038A400;  /* Destination in RAM */
    size = 0x00BEA100;          /* Compressed size marker */

    /* Call the actual ROM load function */
    func_800A11E4(dest, src, 0, 0, 0, size);
}

/*

 * func_8008AA40 (356 bytes)
 * Audio/sync initialization with queue setup
 */
void func_8008AA40(void *param) {
    void *syncObj1;
    void *syncObj2;
    u32 temp;

    syncObj1 = (void *)0x80152788;  /* D_80152788 */
    syncObj2 = (void *)0x801527A8;  /* D_801527A8 */

    /* Initialize sync objects */
    sync_init(syncObj1, syncObj2, 8);

    /* Process audio queue entries */
    /* Complex loop - stub for now */
}

/*

 * func_8008B964 (288 bytes)
 * Entity position/rotation calculation with table lookup
 */
void func_8008B964(void *entity, s16 index, s16 flags) {
    s16 entityId;
    void *tableEntry;
    void *entityData;
    f32 scale;
    s32 flag;

    entityId = *(s16 *)((u8 *)entity + 8);

    /* Calculate table offset: id * 0x109 * 8 */
    tableEntry = (void *)(0x8015A250 + (entityId * 0x109 * 8));

    /* Load scale factor */
    scale = *(f32 *)((u8 *)tableEntry + 0x3F0);

    /* Check entity flags */
    flag = *(u8 *)((u8 *)tableEntry + 0x641);

    if (flags < 13 && flag == 0) {
        /* Early return for specific flag combination */
        return;
    }

    /* Additional entity processing... */
}

/*

 * func_8008BA84 (264 bytes)
 * Similar to func_8008B964 but with different flag checks
 */
void func_8008BA84(void *entity, s16 index, s16 flags) {
    s16 entityId;
    void *tableEntry;
    f32 scale;
    u32 entityFlags;

    entityId = *(s16 *)((u8 *)entity + 8);

    /* Calculate table offset */
    tableEntry = (void *)(0x8015A250 + (entityId * 0x109 * 8));

    /* Load scale */
    scale = *(f32 *)((u8 *)tableEntry + 0x3F0);

    /* Entity data at different offset */
    /* flags < 21 check */
    if (flags < 21) {
        entityFlags = *(u32 *)((u8 *)tableEntry + 0xE8);
        if ((entityFlags & 0x4000) != 0) {
            return;
        }
    }

    /* Process entity... */
}

/*

 * func_8008BB8C (288 bytes)
 * Entity animation/state processing
 */
void func_8008BB8C(void *entity, s16 param) {
    s32 *animState;
    s32 *animFrame;
    s32 *animSpeed;
    s32 *animLooping;
    s32 maxFrames;

    if (entity == NULL) {
        return;
    }

    animState = (s32 *)((u8 *)entity + 0xC0);
    animFrame = (s32 *)((u8 *)entity + 0xC4);
    animSpeed = (s32 *)((u8 *)entity + 0xC8);
    animLooping = (s32 *)((u8 *)entity + 0xCC);
    maxFrames = *((s32 *)((u8 *)entity + 0xD0));

    /* Set animation based on param */
    if (param >= 0) {
        *animState = param;
        *animFrame = 0;
    }

    /* Advance animation */
    *animFrame += *animSpeed;

    /* Handle animation end */
    if (*animFrame >= maxFrames) {
        if (*animLooping) {
            *animFrame = 0;
        } else {
            *animFrame = maxFrames - 1;
            *animState = 0;  /* Return to idle */
        }
    }
}

/*

 * func_8008BC94 (264 bytes)
 * Entity position update with bounds checking
 */
void func_8008BC94(void *entity, s16 param) {
    f32 *pos;
    f32 *bounds;
    f32 minX, maxX, minY, maxY, minZ, maxZ;

    if (entity == NULL) {
        return;
    }

    pos = (f32 *)((u8 *)entity + 0x24);
    bounds = (f32 *)0x80158400;  /* World bounds */

    minX = bounds[0];
    maxX = bounds[1];
    minY = bounds[2];
    maxY = bounds[3];
    minZ = bounds[4];
    maxZ = bounds[5];

    /* Clamp position to world bounds */
    if (pos[0] < minX) pos[0] = minX;
    if (pos[0] > maxX) pos[0] = maxX;
    if (pos[1] < minY) pos[1] = minY;
    if (pos[1] > maxY) pos[1] = maxY;
    if (pos[2] < minZ) pos[2] = minZ;
    if (pos[2] > maxZ) pos[2] = maxZ;

    /* Special handling based on param */
    if (param & 0x01) {
        /* Wrap around X */
        if (pos[0] < minX) pos[0] = maxX;
        if (pos[0] > maxX) pos[0] = minX;
    }
    if (param & 0x02) {
        /* Wrap around Z */
        if (pos[2] < minZ) pos[2] = maxZ;
        if (pos[2] > maxZ) pos[2] = minZ;
    }
}

/*

 * func_8008BD9C (720 bytes)
 * Large entity update function - comprehensive entity tick
 */
void func_8008BD9C(void *entity, void *data) {
    s32 *flags;
    s32 *entityType;
    f32 *pos, *vel, *accel;
    f32 dt;
    s32 updateFlags;

    if (entity == NULL) {
        return;
    }

    flags = (s32 *)((u8 *)entity + 0x10);
    entityType = (s32 *)((u8 *)entity + 0x08);
    pos = (f32 *)((u8 *)entity + 0x24);
    vel = (f32 *)((u8 *)entity + 0x34);
    accel = (f32 *)((u8 *)entity + 0x44);

    /* Check if entity needs update */
    if ((*flags & 0x01) == 0) {
        return;  /* Inactive */
    }

    updateFlags = data ? *((s32 *)data) : 0xFF;
    dt = 1.0f / 60.0f;

    /* Physics update */
    if (updateFlags & 0x01) {
        vel[0] += accel[0] * dt;
        vel[1] += accel[1] * dt;
        vel[2] += accel[2] * dt;

        pos[0] += vel[0] * dt;
        pos[1] += vel[1] * dt;
        pos[2] += vel[2] * dt;
    }

    /* Animation update */
    if (updateFlags & 0x02) {
        func_8008BB8C(entity, -1);
    }

    /* Bounds check */
    if (updateFlags & 0x04) {
        func_8008BC94(entity, 0);
    }

    /* Collision */
    if (updateFlags & 0x08) {
        /* Mark for collision testing */
        *flags |= 0x100;
    }

    /* Visibility check */
    if (updateFlags & 0x10) {
        void *camera = (void *)0x8015B000;
        s32 culled = func_80096A00(entity, camera);
        if (culled) {
            *flags &= ~0x200;  /* Not visible */
        } else {
            *flags |= 0x200;   /* Visible */
        }
    }
}

/*

 * func_8008C76C (252 bytes)
 * Floating point comparison with special cases
 */
f32 func_8008C76C(f32 a, f32 b) {
    f32 result;

    /* Compare a and b, handle special cases */
    if (a == 0.0f) {
        if (b >= 0.0f) {
            return *(f32 *)0x801238F4;  /* Constant */
        } else {
            return *(f32 *)0x801238F8;  /* Different constant */
        }
    }

    /* Check for zero crossing */
    if (b == 0.0f) {
        if (a >= 0.0f) {
            return 0.0f;
        }
    }

    /* General case - compute ratio or angle */
    result = a / b;
    return result;
}

/*

 * func_8008C884 (736 bytes)
 * Large entity rendering setup
 */
void func_8008C884(void *entity, s32 mode) {
    s16 entityId;
    s16 entityType;
    void *tableEntry;
    void *renderData;
    s32 flags;

    entityId = *(s16 *)((u8 *)entity + 8);
    entityType = *(s16 *)((u8 *)entity + 4);

    /* Check special rendering flag */
    flags = *(s8 *)(0x801613A8);  /* D_801613A8 */
    if (flags != 0) {
        /* Check frame timing flag */
        s32 frameFlag = *(s32 *)0x801174B4;
        if (frameFlag < 0) {
            return;
        }
    }

    /* Entity table lookup and render setup... */
}

/*

 * func_8008D120 (1524 bytes)
 * Major entity processing function
 */
void func_8008D120(void *entity, s32 param1, s32 param2) {
    /* Large entity processing - stub */
}

/*

 * func_8008D764 (372 bytes)
 * Euler angle to rotation matrix conversion
 */
void func_8008D764(f32 *matrix, f32 *angles) {
    f32 sinX, cosX;
    f32 sinY, cosY;
    f32 sinZ, cosZ;

    /* Get sin/cos for each axis */
    sinX = sinf(angles[0]);
    cosX = cosf(angles[0]);
    sinY = sinf(angles[1]);
    cosY = cosf(angles[1]);
    sinZ = sinf(angles[2]);
    cosZ = cosf(angles[2]);

    /* Build rotation matrix */
    matrix[0] = cosY * cosZ;
    matrix[1] = cosY * sinZ;
    matrix[2] = -sinY;

    matrix[3] = sinX * sinY * cosZ - cosX * sinZ;
    matrix[4] = sinX * sinY * sinZ + cosX * cosZ;
    matrix[5] = sinX * cosY;

    matrix[6] = cosX * sinY * cosZ + sinX * sinZ;
    matrix[7] = cosX * sinY * sinZ - sinX * cosZ;
    matrix[8] = cosX * cosY;
}

/*

 * func_8008D93C (796 bytes)
 * Entity animation state update
 */
void func_8008D93C(void *entity, s16 animState) {
    s16 entityId;
    s16 entityType;
    void *animData;

    if (animState == 0) {
        /* Clear animation state */
        entityType = *(s16 *)((u8 *)entity + 6);
        func_8008AE8C(entityType, 1, 15);
        *(s32 *)((u8 *)entity + 0x14) = 0;
        *(s16 *)((u8 *)entity + 6) = -1;
        return;
    }

    entityId = *(s16 *)((u8 *)entity + 8);
    entityType = *(s16 *)((u8 *)entity + 4);

    /* Process animation state... */
}

/*

 * func_8008E440 (1472 bytes)
 * Major render state processing
 */
void func_8008E440(void *a0, s32 mode, s32 flags, s32 index) {
    void *tableEntry;
    u32 renderFlags;
    s16 scaledIndex;

    scaledIndex = (s16)(index >> 2);
    tableEntry = (void *)(0x801492D8 + (flags * 4));

    /* Process render mode */
    switch (mode) {
        case 0:
            renderFlags = *(u32 *)tableEntry;
            if ((renderFlags & 0x100) != 0) {
                return;
            }
            *(u32 *)tableEntry = renderFlags | 0x100;
            break;
        case 1:
        case 2:
        case 3:
            /* Other render modes... */
            break;
        default:
            break;
    }
}

/*

 * func_8008EA10 (1656 bytes)
 * Entity spawn/initialization - create and initialize new entity
 */
void func_8008EA10(void *params, s32 type) {
    void *entity;
    s32 *entityPool;
    s32 *poolIndex;
    s32 i;
    f32 *pos, *vel;
    f32 *spawnPos;
    s32 maxEntities;

    entityPool = (s32 *)0x80157000;
    poolIndex = (s32 *)0x80157400;
    maxEntities = 256;

    /* Find free slot in entity pool */
    entity = NULL;
    for (i = 0; i < maxEntities; i++) {
        s32 *slot = (s32 *)(entityPool[i]);
        if (slot == NULL || (*slot & 0x01) == 0) {
            /* Found free slot */
            entity = (void *)(0x80160000 + i * 0x100);
            entityPool[i] = (s32)entity;
            break;
        }
    }

    if (entity == NULL) {
        return;  /* Pool full */
    }

    /* Clear entity memory */
    memset(entity, 0, 0x100);

    /* Set entity type */
    *((s32 *)((u8 *)entity + 0x08)) = type;
    *((s32 *)((u8 *)entity + 0x10)) = 0x01;  /* Active flag */

    /* Initialize position from params or defaults */
    pos = (f32 *)((u8 *)entity + 0x24);
    vel = (f32 *)((u8 *)entity + 0x34);

    if (params != NULL) {
        spawnPos = (f32 *)params;
        pos[0] = spawnPos[0];
        pos[1] = spawnPos[1];
        pos[2] = spawnPos[2];
    } else {
        pos[0] = 0.0f;
        pos[1] = 0.0f;
        pos[2] = 0.0f;
    }

    vel[0] = 0.0f;
    vel[1] = 0.0f;
    vel[2] = 0.0f;

    /* Set default bounding radius based on type */
    switch (type) {
        case 1:  /* Car */
            *((f32 *)((u8 *)entity + 0x5C)) = 2.0f;
            break;
        case 2:  /* Prop */
            *((f32 *)((u8 *)entity + 0x5C)) = 1.0f;
            break;
        case 3:  /* Destructible */
            *((f32 *)((u8 *)entity + 0x5C)) = 1.5f;
            break;
        case 4:  /* Projectile */
            *((f32 *)((u8 *)entity + 0x5C)) = 0.5f;
            break;
        default:
            *((f32 *)((u8 *)entity + 0x5C)) = 1.0f;
            break;
    }

    /* Initialize animation */
    *((s32 *)((u8 *)entity + 0xC0)) = 0;  /* animState = idle */
    *((s32 *)((u8 *)entity + 0xC4)) = 0;  /* animFrame = 0 */
    *((s32 *)((u8 *)entity + 0xC8)) = 1;  /* animSpeed = 1 */

    (*poolIndex)++;
}

/*

 * func_80090310 (1036 bytes)
 * Process entity with callback registration
 */
void func_80090310(void *entity) {
    void *result;

    result = func_80090284(0, 0);
    if (result == NULL) {
        return;
    }

    /* Store callback pointer */
    *(void **)((u8 *)result + 0x14) = (void *)0x80090FEC;

    /* Copy initial position from stack */
    /* Additional setup... */
}

/*

 * func_800908A0 (716 bytes)
 * Entity movement/physics update
 */
void func_800908A0(void *entity, s16 flags) {
    f32 *pos, *vel, *accel;
    f32 *rot, *angVel;
    f32 dt, gravity;
    f32 friction, drag;

    if (entity == NULL) {
        return;
    }

    pos = (f32 *)((u8 *)entity + 0x24);
    vel = (f32 *)((u8 *)entity + 0x34);
    accel = (f32 *)((u8 *)entity + 0x44);
    rot = (f32 *)((u8 *)entity + 0x60);
    angVel = (f32 *)((u8 *)entity + 0x70);

    dt = 1.0f / 60.0f;
    gravity = -9.8f;
    friction = 0.98f;
    drag = 0.995f;

    /* Apply gravity if enabled */
    if (flags & 0x01) {
        accel[1] = gravity;
    }

    /* Apply friction if grounded */
    if (flags & 0x02) {
        vel[0] *= friction;
        vel[2] *= friction;
    }

    /* Apply air drag */
    if (flags & 0x04) {
        vel[0] *= drag;
        vel[1] *= drag;
        vel[2] *= drag;
    }

    /* Integrate acceleration */
    vel[0] += accel[0] * dt;
    vel[1] += accel[1] * dt;
    vel[2] += accel[2] * dt;

    /* Integrate velocity */
    pos[0] += vel[0] * dt;
    pos[1] += vel[1] * dt;
    pos[2] += vel[2] * dt;

    /* Angular velocity */
    if (flags & 0x08) {
        rot[0] += angVel[0] * dt;
        rot[1] += angVel[1] * dt;
        rot[2] += angVel[2] * dt;

        /* Apply angular damping */
        angVel[0] *= 0.99f;
        angVel[1] *= 0.99f;
        angVel[2] *= 0.99f;
    }

    /* Clear acceleration for next frame */
    if (flags & 0x10) {
        accel[0] = 0.0f;
        accel[1] = 0.0f;
        accel[2] = 0.0f;
    }
}

/*

 * func_80090B70 (820 bytes)
 * Entity collision detection
 */
void func_80090B70(void *entity) {
    f32 *pos;
    f32 radius;
    s32 *entityPool;
    s32 i;
    void *other;
    f32 *otherPos;
    f32 otherRadius;
    f32 dx, dy, dz, dist;
    f32 overlap;
    s32 maxEntities;

    if (entity == NULL) {
        return;
    }

    pos = (f32 *)((u8 *)entity + 0x24);
    radius = *((f32 *)((u8 *)entity + 0x5C));
    entityPool = (s32 *)0x80157000;
    maxEntities = 256;

    /* Check against all other entities */
    for (i = 0; i < maxEntities; i++) {
        other = (void *)entityPool[i];
        if (other == NULL || other == entity) {
            continue;
        }

        /* Check if other entity is active */
        if ((*((s32 *)other) & 0x01) == 0) {
            continue;
        }

        otherPos = (f32 *)((u8 *)other + 0x24);
        otherRadius = *((f32 *)((u8 *)other + 0x5C));

        /* Calculate distance */
        dx = pos[0] - otherPos[0];
        dy = pos[1] - otherPos[1];
        dz = pos[2] - otherPos[2];
        dist = sqrtf(dx * dx + dy * dy + dz * dz);

        /* Check collision */
        overlap = (radius + otherRadius) - dist;
        if (overlap > 0.0f) {
            /* Collision detected - separate entities */
            if (dist > 0.001f) {
                f32 separationDist = overlap * 0.5f / dist;
                pos[0] += dx * separationDist;
                pos[1] += dy * separationDist;
                pos[2] += dz * separationDist;
                otherPos[0] -= dx * separationDist;
                otherPos[1] -= dy * separationDist;
                otherPos[2] -= dz * separationDist;
            }

            /* Mark collision flags */
            *((s32 *)((u8 *)entity + 0x10)) |= 0x1000;
            *((s32 *)((u8 *)other + 0x10)) |= 0x1000;
        }
    }
}

/*

 * func_80090FEC (2184 bytes)
 * Entity update callback
 */
void func_80090FEC(void *entity, s16 param) {
    s32 globalFlag;

    globalFlag = *(s32 *)0x801170FC;
    if (globalFlag != 0) {
        return;
    }

    /* Major entity update processing... */
}

/*

 * func_80091874 (616 bytes)
 * Entity animation update with texture loading
 */
void func_80091874(void *entity, s16 animFrame) {
    s16 entityId;
    s16 entityType;
    void *tableEntry;
    void *animData;
    s32 flags;

    if (animFrame == 0) {
        /* Clear animation */
        entityType = *(s16 *)((u8 *)entity + 6);
        func_8008AE8C(entityType, 1, 15);
        *(s32 *)((u8 *)entity + 0x14) = 0;
        *(s16 *)((u8 *)entity + 6) = -1;
        return;
    }

    entityId = *(s16 *)((u8 *)entity + 8);
    flags = *(s32 *)((u8 *)entity + 0x0C);

    /* Check animation flag */
    if ((flags & 0x01) != 0) {
        /* Animation flag set - update frame */
    }

    /* Complex animation processing... */
}

/*

 * func_80091E5C (560 bytes)
 * Entity scale/transform with sync
 */
void func_80091E5C(f32 scale) {
    /* Acquire sync */
    sync_acquire((void *)0x80142728, 0, 1);

    if (scale >= 1.0f) {
        /* Clamp scale */
        scale = 1.0f;
    } else if (scale < 0.0f) {
        scale = 0.0f;
    }

    /* Apply scale transform... */
}

/*

 * func_8009229C (600 bytes)
 * Entity state initialization
 */
void func_8009229C(void *entity, void *params) {
    u32 flags;
    void *flagPtr;

    flagPtr = (void *)0x80146104;

    /* Load and apply flags */
    flags = *(u32 *)flagPtr;
    flags = (flags & *(u32 *)((u8 *)params)) | (*(u32 *)((u8 *)params + 4));
    *(u32 *)((u8 *)entity + 0x0C) = flags;

    /* Initialize velocities to zero */
    *(f32 *)((u8 *)entity + 0x24) = -1.0f;
    *(f32 *)((u8 *)entity + 0x28) = -1.0f;
    *(f32 *)((u8 *)entity + 0x2C) = -1.0f;
    *(s32 *)((u8 *)entity + 0x40) = 0;
    *(f32 *)((u8 *)entity + 0x20) = 1.0f;
    *(f32 *)((u8 *)entity + 0x30) = 1.0f;

    /* Call additional init */
    func_8009211C(entity, entity);
}

/*

 * func_800924F4 (1636 bytes)
 * Entity spawn with full initialization
 */
void func_800924F4(void *entity, s16 spawnType) {
    s16 entityId;
    s16 entityType;
    void *tableEntry;

    if (spawnType == 0) {
        /* Destroy entity */
        entityType = *(s16 *)((u8 *)entity + 6);
        func_8008AE8C(entityType, 0, 15);
        *(s32 *)((u8 *)entity + 0x14) = 0;
        *(s16 *)((u8 *)entity + 6) = -1;
        return;
    }

    entityId = *(s16 *)((u8 *)entity + 8);

    /* Calculate table entry */
    tableEntry = (void *)(0x8015A250 + ((entityId * 0x109) << 3));

    /* Complex spawn logic... */
}

/*

 * func_80092E2C (720 bytes)
 * String/name copy with formatting
 */
void func_80092E2C(void *dest, u8 *src, s8 x, s8 y, s8 z) {
    u8 *tempBuf;
    s32 i;

    /* Clamp coordinates */
    if (x < 0) x = 0;
    if (y < 0) y = 0;

    /* Copy default string if src is NULL */
    if (src == NULL || src[0] == 0) {
        tempBuf = (u8 *)(0x80120E68);
        for (i = 0; i < 16; i++) {
            ((u8 *)dest)[i] = tempBuf[i];
        }
    } else {
        func_80092DCC(dest, src, 16);
    }
}

/*

 * func_800930A4 (2684 bytes)
 * Major entity processing loop - comprehensive entity tick
 */
void func_800930A4(void *entity, s32 mode) {
    s32 *entityFlags;
    s32 *entityType;
    s32 flags, type;

    if (entity == NULL) {
        return;
    }

    entityFlags = (s32 *)((u8 *)entity + 0x10);
    entityType = (s32 *)((u8 *)entity + 0x08);
    flags = *entityFlags;
    type = *entityType;

    /* Check if entity is active */
    if ((flags & 0x01) == 0) {
        return;
    }

    /* Process based on mode */
    switch (mode) {
        case 0:  /* Physics update */
            func_800908A0(entity, 0x1F);
            break;

        case 1:  /* Animation update */
            func_8008BB8C(entity, -1);
            break;

        case 2:  /* AI update */
            if (type == 1) {  /* Car entity */
                func_80093B20(entity);
            }
            break;

        case 3:  /* Collision update */
            func_80090B70(entity);
            break;

        case 4:  /* Visibility update */
            {
                void *camera = (void *)0x8015B000;
                s32 culled = func_80096A00(entity, camera);
                if (culled) {
                    *entityFlags &= ~0x200;
                } else {
                    *entityFlags |= 0x200;
                }
            }
            break;

        case 5:  /* Full update */
            func_800908A0(entity, 0x1F);
            func_8008BB8C(entity, -1);
            func_80090B70(entity);
            if (type == 1) {
                func_80093B20(entity);
            }
            break;

        default:
            break;
    }

    /* Update bounds */
    func_8008BC94(entity, 0);
}

/*

 * func_80093B20 (3440 bytes)
 * Entity AI/behavior update - drone car AI
 */
void func_80093B20(void *entity) {
    s32 *aiState;
    s32 *aiTarget;
    f32 *pos, *vel, *rot;
    f32 *targetPos;
    f32 dx, dz, dist;
    f32 targetAngle, currentAngle;
    f32 steerAmount;
    f32 throttle;
    s32 state;

    if (entity == NULL) {
        return;
    }

    aiState = (s32 *)((u8 *)entity + 0x240);
    aiTarget = (s32 *)((u8 *)entity + 0x244);
    pos = (f32 *)((u8 *)entity + 0x24);
    vel = (f32 *)((u8 *)entity + 0x34);
    rot = (f32 *)((u8 *)entity + 0x60);

    state = *aiState;

    switch (state) {
        case 0:  /* Idle */
            /* Wait for race start */
            break;

        case 1:  /* Racing */
            /* Get next waypoint */
            targetPos = (f32 *)(0x8015E000 + (*aiTarget) * 12);

            /* Calculate direction to target */
            dx = targetPos[0] - pos[0];
            dz = targetPos[2] - pos[2];
            dist = sqrtf(dx * dx + dz * dz);

            /* Check if reached waypoint */
            if (dist < 10.0f) {
                (*aiTarget)++;
                if (*aiTarget >= 64) {  /* Waypoint count */
                    *aiTarget = 0;
                }
            }

            /* Calculate steering */
            if (dist > 0.1f) {
                targetAngle = atan2f(dx, dz);
                currentAngle = rot[1];

                steerAmount = targetAngle - currentAngle;

                /* Normalize angle */
                while (steerAmount > 3.14159f) steerAmount -= 6.28318f;
                while (steerAmount < -3.14159f) steerAmount += 6.28318f;

                /* Apply steering */
                rot[1] += steerAmount * 0.1f;
            }

            /* Set throttle based on distance and angle */
            throttle = 1.0f;
            if (steerAmount > 0.5f || steerAmount < -0.5f) {
                throttle = 0.5f;  /* Slow down for sharp turns */
            }

            /* Apply forward force */
            vel[0] += sinf(rot[1]) * throttle * 0.5f;
            vel[2] += cosf(rot[1]) * throttle * 0.5f;

            /* Speed limit */
            {
                f32 speed = sqrtf(vel[0] * vel[0] + vel[2] * vel[2]);
                f32 maxSpeed = 30.0f;
                if (speed > maxSpeed) {
                    vel[0] *= maxSpeed / speed;
                    vel[2] *= maxSpeed / speed;
                }
            }
            break;

        case 2:  /* Crashed */
            /* Recovery logic */
            {
                s32 *crashTimer = (s32 *)((u8 *)entity + 0x248);
                (*crashTimer)--;
                if (*crashTimer <= 0) {
                    *aiState = 1;  /* Resume racing */
                }
            }
            break;

        case 3:  /* Finished */
            /* Slow down and stop */
            vel[0] *= 0.95f;
            vel[2] *= 0.95f;
            break;

        default:
            break;
    }
}

/*

 * func_80094890 (460 bytes)
 * Audio parameter setup - configure audio channel parameters
 */
void func_80094890(void *params, s32 channel) {
    f32 *audioParams;
    s32 *channelState;

    if (channel < 0 || channel >= 16) {
        return;
    }

    audioParams = (f32 *)params;
    channelState = (s32 *)(0x80160000 + channel * 64);

    /* Set channel parameters */
    channelState[0] = 1;  /* Active */
    *(f32 *)&channelState[1] = audioParams[0];  /* Volume */
    *(f32 *)&channelState[2] = audioParams[1];  /* Pan */
    *(f32 *)&channelState[3] = audioParams[2];  /* Pitch */
    channelState[4] = (s32)audioParams[3];  /* Loop flag */
    channelState[5] = (s32)audioParams[4];  /* Priority */

    /* Trigger audio hardware update */
    D_80160400 |= (1 << channel);
}

/*

 * func_80094A54 (472 bytes)
 * Sound effect trigger - play a sound effect
 */
void func_80094A54(s32 soundId, s32 priority) {
    s32 channel;
    s32 *channelState;
    s32 lowestPri;
    s32 lowestChannel;
    s32 i;

    /* Find free channel or lowest priority */
    channel = -1;
    lowestPri = priority;
    lowestChannel = -1;

    for (i = 0; i < 16; i++) {
        channelState = (s32 *)(0x80160000 + i * 64);
        if (channelState[0] == 0) {
            /* Free channel */
            channel = i;
            break;
        }
        if (channelState[5] < lowestPri) {
            lowestPri = channelState[5];
            lowestChannel = i;
        }
    }

    /* Use lowest priority if no free channel */
    if (channel < 0) {
        if (lowestChannel >= 0) {
            channel = lowestChannel;
        } else {
            return;  /* All channels busy with higher priority */
        }
    }

    channelState = (s32 *)(0x80160000 + channel * 64);

    /* Configure channel for sound effect */
    channelState[0] = 1;  /* Active */
    channelState[5] = priority;
    channelState[6] = soundId;
    *(f32 *)&channelState[1] = D_80159300 / 100.0f;  /* SFX volume setting */
    *(f32 *)&channelState[2] = 0.5f;  /* Center pan */

    /* Trigger playback */
    D_80160400 |= (1 << channel);
    D_80160404 = soundId;
}

/*

 * func_80094C30 (668 bytes)
 * Audio volume/pan control - adjust channel volume and pan
 */
void func_80094C30(s32 channel, f32 volume, f32 pan) {
    s32 *channelState;

    if (channel < 0 || channel >= 16) {
        return;
    }

    channelState = (s32 *)(0x80160000 + channel * 64);

    if (channelState[0] == 0) {
        return;  /* Channel not active */
    }

    /* Clamp values */
    if (volume < 0.0f) volume = 0.0f;
    if (volume > 1.0f) volume = 1.0f;
    if (pan < 0.0f) pan = 0.0f;
    if (pan > 1.0f) pan = 1.0f;

    /* Apply master volume */
    volume = volume * (D_80159300 / 100.0f);

    *(f32 *)&channelState[1] = volume;
    *(f32 *)&channelState[2] = pan;

    /* Mark channel for update */
    *(s32*)&D_80160408[0] |= (1 << channel);
}

/*

 * func_80094FF0 (156 bytes)
 * Audio channel reset - stop and reset a channel
 */
void func_80094FF0(s32 channel) {
    s32 *channelState;
    s32 i;

    if (channel < 0 || channel >= 16) {
        return;
    }

    channelState = (s32 *)(0x80160000 + channel * 64);

    /* Clear all channel state */
    for (i = 0; i < 16; i++) {
        channelState[i] = 0;
    }

    /* Mark channel as stopped */
    D_8016040C |= (1 << channel);
}

/*

 * func_800951E0 (492 bytes)
 * Sound position update - update 3D sound position for entity
 */
void func_800951E0(void *entity, f32 *pos) {
    f32 *listenerPos;
    f32 *listenerDir;
    f32 dx, dy, dz;
    f32 distance;
    f32 volume;
    f32 pan;
    s32 channel;

    if (entity == NULL || pos == NULL) {
        return;
    }

    /* Get listener (camera) position */
    listenerPos = (f32 *)0x80161000;
    listenerDir = (f32 *)0x8016100C;

    /* Calculate distance to listener */
    dx = pos[0] - listenerPos[0];
    dy = pos[1] - listenerPos[1];
    dz = pos[2] - listenerPos[2];
    distance = sqrtf(dx * dx + dy * dy + dz * dz);

    /* Calculate volume falloff */
    if (distance < 50.0f) {
        volume = 1.0f;
    } else if (distance > 1000.0f) {
        volume = 0.0f;
    } else {
        volume = 1.0f - ((distance - 50.0f) / 950.0f);
    }

    /* Calculate stereo pan based on relative position */
    if (distance > 1.0f) {
        f32 right = dx * listenerDir[2] - dz * listenerDir[0];
        pan = 0.5f + (right / distance) * 0.5f;
        if (pan < 0.0f) pan = 0.0f;
        if (pan > 1.0f) pan = 1.0f;
    } else {
        pan = 0.5f;
    }

    /* Get channel from entity */
    channel = *(s32 *)((u8 *)entity + 0x1C0);
    if (channel >= 0 && channel < 16) {
        func_80094C30(channel, volume, pan);
    }
}

/*

 * func_800953CC (220 bytes)
 * Audio fade control - fade channel volume over time
 */
void func_800953CC(s32 channel, f32 targetVol, f32 duration) {
    s32 *channelState;
    f32 currentVol;
    f32 fadeRate;

    if (channel < 0 || channel >= 16) {
        return;
    }

    channelState = (s32 *)(0x80160000 + channel * 64);

    if (channelState[0] == 0) {
        return;
    }

    currentVol = *(f32 *)&channelState[1];

    /* Calculate fade rate (per frame at 60fps) */
    if (duration <= 0.0f) {
        fadeRate = targetVol - currentVol;
    } else {
        fadeRate = (targetVol - currentVol) / (duration * 60.0f);
    }

    /* Store fade parameters */
    *(f32 *)&channelState[8] = targetVol;
    *(f32 *)&channelState[9] = fadeRate;
    channelState[10] = 1;  /* Fading flag */
}

/*

 * func_800954A8 (128 bytes)
 * Sound enable/disable - enable or disable a sound channel
 */
void func_800954A8(s32 channel, s32 enable) {
    s32 *channelState;

    if (channel < 0 || channel >= 16) {
        return;
    }

    channelState = (s32 *)(0x80160000 + channel * 64);

    if (enable) {
        channelState[11] = 0;  /* Unmute */
        D_80160410 |= (1 << channel);
    } else {
        channelState[11] = 1;  /* Mute */
        D_80160414 |= (1 << channel);
    }
}

/*

 * func_80095528 (484 bytes)
 * Music track control - control music playback
 */
void func_80095528(s32 trackId, s32 cmd) {
    s32 *musicState = (s32 *)0x80161100;

    switch (cmd) {
        case 0:  /* Stop */
            musicState[0] = 0;
            musicState[1] = -1;
            func_800953CC(0, 0.0f, 0.5f);  /* Fade out music channel */
            break;

        case 1:  /* Play */
            if (trackId >= 0 && trackId < 20) {
                musicState[0] = 1;
                musicState[1] = trackId;
                musicState[2] = 0;  /* Position */
                *(f32 *)&musicState[3] = D_80159304 / 100.0f;  /* Music volume */
                D_80160420 = trackId;
            }
            break;

        case 2:  /* Pause */
            if (musicState[0] == 1) {
                musicState[0] = 2;  /* Paused */
                D_80160424 = 1;
            }
            break;

        case 3:  /* Resume */
            if (musicState[0] == 2) {
                musicState[0] = 1;  /* Playing */
                D_80160424 = 0;
            }
            break;

        case 4:  /* Loop on */
            musicState[4] = 1;
            break;

        case 5:  /* Loop off */
            musicState[4] = 0;
            break;
    }
}

/*

 * func_8009570C (244 bytes)
 * Audio bus routing - route audio between buses
 */
void func_8009570C(s32 srcBus, s32 destBus) {
    s32 *busMatrix = (s32 *)0x80161200;

    if (srcBus < 0 || srcBus >= 4 || destBus < 0 || destBus >= 4) {
        return;
    }

    busMatrix[srcBus * 4 + destBus] = 1;
    D_80160430 = 1;  /* Bus config changed */
}

/*

 * func_80095800 (292 bytes)
 * Reverb/effect setup - configure audio effects
 */
void func_80095800(s32 effectId, f32 param) {
    s32 *effectState = (s32 *)0x80161300;

    switch (effectId) {
        case 0:  /* Reverb */
            effectState[0] = 1;
            *(f32 *)&effectState[1] = param;  /* Reverb amount 0-1 */
            break;

        case 1:  /* Echo */
            effectState[2] = 1;
            *(f32 *)&effectState[3] = param;  /* Echo delay */
            break;

        case 2:  /* Low-pass filter */
            effectState[4] = 1;
            *(f32 *)&effectState[5] = param;  /* Cutoff frequency */
            break;

        case 3:  /* Chorus */
            effectState[6] = 1;
            *(f32 *)&effectState[7] = param;  /* Chorus amount */
            break;
    }

    D_80160434 = 1;  /* Effects changed */
}

/*

 * func_80095924 (184 bytes)
 * Audio timing sync - synchronize audio with video
 */
void func_80095924(void) {
    s32 audioFrame;
    s32 videoFrame;
    s32 drift;

    audioFrame = D_80160440;
    videoFrame = D_80142AFC;

    drift = videoFrame - audioFrame;

    /* Adjust audio timing if drifted */
    if (drift > 2) {
        D_80160444 = 1;  /* Speed up */
    } else if (drift < -2) {
        D_80160444 = -1;  /* Slow down */
    } else {
        D_80160444 = 0;  /* Normal */
    }

    D_80160440 = videoFrame;
}

/*

 * func_80095A24 (236 bytes)
 * Sound priority management - set channel priority
 */
void func_80095A24(s32 channel, s32 priority) {
    s32 *channelState;

    if (channel < 0 || channel >= 16) {
        return;
    }

    channelState = (s32 *)(0x80160000 + channel * 64);
    channelState[5] = priority;
}

/*

 * func_80095B10 (236 bytes)
 * Audio stream control - control streaming audio
 */
void func_80095B10(s32 streamId, s32 cmd) {
    s32 *streamState = (s32 *)(0x80161400 + streamId * 32);

    if (streamId < 0 || streamId >= 4) {
        return;
    }

    switch (cmd) {
        case 0:  /* Stop */
            streamState[0] = 0;
            break;

        case 1:  /* Start */
            streamState[0] = 1;
            streamState[1] = 0;  /* Position */
            break;

        case 2:  /* Pause */
            streamState[0] = 2;
            break;

        case 3:  /* Resume */
            if (streamState[0] == 2) {
                streamState[0] = 1;
            }
            break;
    }
}

/*

 * func_80095BFC (268 bytes)
 * Audio buffer management - manage audio DMA buffers
 */
void func_80095BFC(void *buffer, s32 size) {
    s32 *bufferInfo = (s32 *)0x80161500;

    if (buffer == NULL || size <= 0) {
        return;
    }

    /* Register buffer */
    bufferInfo[0] = (s32)buffer;
    bufferInfo[1] = size;
    bufferInfo[2] = 0;  /* Read position */
    bufferInfo[3] = 0;  /* Write position */
    bufferInfo[4] = 0;  /* Underrun count */

    D_80160450 = 1;  /* Buffer registered */
}

/*

 * func_80095D04 (468 bytes)
 * Audio state save/restore - save or restore audio state
 */
void func_80095D04(s32 cmd) {
    s32 *stateBuffer = (s32 *)0x80161600;
    s32 *channelState;
    s32 i, j;

    if (cmd == 0) {
        /* Save state */
        for (i = 0; i < 16; i++) {
            channelState = (s32 *)(0x80160000 + i * 64);
            for (j = 0; j < 16; j++) {
                stateBuffer[i * 16 + j] = channelState[j];
            }
        }
        D_80160460 = 1;  /* State saved */
    } else {
        /* Restore state */
        for (i = 0; i < 16; i++) {
            channelState = (s32 *)(0x80160000 + i * 64);
            for (j = 0; j < 16; j++) {
                channelState[j] = stateBuffer[i * 16 + j];
            }
        }
        D_80160400 = 0xFFFF;  /* Mark all channels for update */
    }
}

/*

 * func_8009614C (216 bytes)
 * Entity sound attachment with sync
 */
void func_8009614C(void *a0, void *a1, void *a2, void *entity) {
    s16 waitFlag;

    if (entity == NULL) {
        return;
    }

    /* Wait for audio sync */
    waitFlag = *(s16 *)0x8003EB70;
    while (waitFlag != 0) {
        waitFlag = *(s16 *)0x8003EB70;
    }

    /* Acquire sync and process */
    sync_acquire((void *)0x80152770, 0, 1);
    func_80095FD8(entity, 0);
    sync_release((void *)0x80152770, 0, 1);
}

/*

 * func_800963E8 (452 bytes)
 * Display list traversal
 */
void func_800963E8(u32 *dlPtr, void *param1, void *param2, void *param3) {
    u32 cmd;
    u32 cmdHi;

    cmd = *dlPtr;
    cmdHi = cmd & 0xFF000000;

    if (cmdHi == 0xDF000000) {
        /* End display list */
        return;
    }

    /* Process display list commands */
    while (cmdHi != 0xDF000000) {
        /* Check command types: DE00 (call), E100 (load), etc. */
        if ((cmd & 0xFF000000) == 0xDE000000) {
            /* Branch to sub-display list */
            dlPtr = (u32 *)dlPtr[1];
        } else {
            dlPtr += 2;
        }

        cmd = *dlPtr;
        cmdHi = cmd & 0xFF000000;
    }
}

/*

 * func_800965BC (244 bytes)
 * Entity render setup
 */
void func_800965BC(void *entity) {
    void *tableEntry;
    s32 entityIdx;

    /* Call render mode setup */
    func_80096288(entity, 1, 1);

    entityIdx = 0;  /* Preloaded from a3 */
    tableEntry = (void *)(0x80156D38 + (entityIdx * 5 * 4));

    /* Check entity visibility */
    if (*(s8 *)((u8 *)tableEntry + 3) == 0) {
        return;
    }

    /* Process render... */
}

/*

 * func_80096734 (716 bytes)
 * Entity LOD selection - chooses detail level based on distance
 */
void func_80096734(void *entity, f32 distance) {
    s32 *lodLevel;
    s32 *modelIndex;
    s32 baseModel;
    f32 lodDist0, lodDist1, lodDist2;

    if (entity == NULL) {
        return;
    }

    lodLevel = (s32 *)((u8 *)entity + 0xF0);
    modelIndex = (s32 *)((u8 *)entity + 0xF4);
    baseModel = *((s32 *)((u8 *)entity + 0xF8));

    /* LOD distance thresholds */
    lodDist0 = 100.0f;   /* High detail */
    lodDist1 = 300.0f;   /* Medium detail */
    lodDist2 = 600.0f;   /* Low detail */

    /* Select LOD level */
    if (distance < lodDist0) {
        *lodLevel = 0;
        *modelIndex = baseModel;
    } else if (distance < lodDist1) {
        *lodLevel = 1;
        *modelIndex = baseModel + 1;
    } else if (distance < lodDist2) {
        *lodLevel = 2;
        *modelIndex = baseModel + 2;
    } else {
        *lodLevel = 3;
        *modelIndex = baseModel + 3;  /* Billboard/sprite */
    }

    /* Adjust for entity type */
    s32 entityType = *((s32 *)((u8 *)entity + 0x08));
    if (entityType == 1) {  /* Car - use tighter thresholds */
        if (distance < 50.0f) {
            *lodLevel = 0;
        } else if (distance < 150.0f) {
            *lodLevel = 1;
        } else {
            *lodLevel = 2;
        }
        *modelIndex = baseModel + *lodLevel;
    }
}

/*

 * func_80096A00 (348 bytes)
 * Entity cull check - tests entity against view frustum
 */
s32 func_80096A00(void *entity, void *camera) {
    f32 *entityPos;
    f32 *cameraPos;
    f32 *cameraDir;
    f32 entityRadius;
    f32 dx, dy, dz;
    f32 dist;
    f32 dotProduct;
    f32 fov;
    f32 nearPlane, farPlane;

    if (entity == NULL || camera == NULL) {
        return 1;  /* Cull if invalid */
    }

    entityPos = (f32 *)((u8 *)entity + 0x24);
    entityRadius = *((f32 *)((u8 *)entity + 0x5C));
    cameraPos = (f32 *)camera;
    cameraDir = (f32 *)((u8 *)camera + 0x0C);

    /* Default radius if not set */
    if (entityRadius < 1.0f) {
        entityRadius = 5.0f;
    }

    /* Calculate vector from camera to entity */
    dx = entityPos[0] - cameraPos[0];
    dy = entityPos[1] - cameraPos[1];
    dz = entityPos[2] - cameraPos[2];
    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    /* Frustum parameters */
    nearPlane = 1.0f;
    farPlane = 2000.0f;
    fov = 0.7f;  /* ~80 degrees half-angle in radians */

    /* Distance culling */
    if (dist - entityRadius > farPlane) {
        return 1;  /* Too far - cull */
    }
    if (dist + entityRadius < nearPlane) {
        return 1;  /* Behind camera - cull */
    }

    /* Cone culling - check if entity is in front of camera */
    if (dist > 0.01f) {
        dx /= dist;
        dy /= dist;
        dz /= dist;
    }

    dotProduct = dx * cameraDir[0] + dy * cameraDir[1] + dz * cameraDir[2];

    /* Entity must be mostly in front of camera */
    if (dotProduct < -0.2f) {
        return 1;  /* Behind camera - cull */
    }

    /* Check if within field of view (with radius margin) */
    f32 coneAngle = cosf(fov);
    f32 radiusMargin = entityRadius / dist;

    if (dotProduct + radiusMargin < coneAngle) {
        return 1;  /* Outside FOV - cull */
    }

    return 0;  /* Visible */
}

/*

 * func_80096CC4 (1216 bytes)
 * Entity render with transforms
 */
void func_80096CC4(void *entity, void *matrix) {
    /* Render with transforms - stub */
}

/*

 * func_80097184 (876 bytes)
 * Entity collision response
 */
void func_80097184(void *entity, s32 collisionType) {
    void *tableEntry;
    s32 result;

    result = *(s32 *)((u8 *)entity + 0);  /* preloaded from v0 */

    if (result == 0) {
        return;
    }

    /* Process collision response... */
}

/*

 * func_800974EC (692 bytes)
 * Entity state machine update
 */
void func_800974EC(void *entity, s32 newState) {
    void *currentPtr;

    sync_acquire((void *)0x80152770, 0, 1);

    if (entity == NULL) {
        entity = *(void **)(0x801527C8);
    }

    /* Check current state */
    currentPtr = *(void **)((u8 *)entity + 0x1C);
    if (currentPtr == NULL) {
        /* Initialize state */
        /* ... */
    }

    sync_release((void *)0x80152770, 0, 1);
}

/*

 * func_800979A8 (264 bytes)
 * Entity position validation
 */
void func_800979A8(void *entity, s32 flags) {
    s32 checkFlag;

    checkFlag = *(s32 *)0x8012EAA0;
    if (checkFlag == -1) {
        return;
    }

    /* Check if entity matches current player */
    if (entity == *(void **)(0x80151A6C)) {
        return;
    }

    /* Process position validation... */
    func_80097798(entity + 10, 0, 0, 0, 0);
}

/*

 * func_80097AFC (364 bytes)
 * Entity velocity update - applies velocity to entity position
 */
void func_80097AFC(void *entity, f32 *velocity) {
    f32 *pos;
    f32 *vel;
    f32 *accel;
    f32 *mass;
    f32 dt;
    f32 friction;
    f32 speed;

    if (entity == NULL || velocity == NULL) {
        return;
    }

    pos = (f32 *)((u8 *)entity + 0x24);
    vel = (f32 *)((u8 *)entity + 0x34);
    accel = (f32 *)((u8 *)entity + 0x44);
    mass = (f32 *)((u8 *)entity + 0x54);

    dt = 1.0f / 60.0f;  /* Fixed timestep */

    /* Apply input velocity */
    vel[0] = velocity[0];
    vel[1] = velocity[1];
    vel[2] = velocity[2];

    /* Apply gravity */
    vel[1] -= 9.8f * dt;

    /* Apply acceleration */
    vel[0] += accel[0] * dt;
    vel[1] += accel[1] * dt;
    vel[2] += accel[2] * dt;

    /* Apply friction */
    friction = 0.98f;
    vel[0] *= friction;
    vel[2] *= friction;

    /* Clamp velocity */
    speed = sqrtf(vel[0] * vel[0] + vel[1] * vel[1] + vel[2] * vel[2]);
    if (speed > 500.0f) {
        f32 scale = 500.0f / speed;
        vel[0] *= scale;
        vel[1] *= scale;
        vel[2] *= scale;
    }

    /* Update position */
    pos[0] += vel[0] * dt;
    pos[1] += vel[1] * dt;
    pos[2] += vel[2] * dt;
}

/*

 * func_800987E8 (140 bytes)
 * Simple state check
 */
s32 func_800987E8(void *entity) {
    s32 state;

    state = *(s32 *)((u8 *)entity + 0x10);
    return (state != 0);
}

/*

 * func_80098874 (108 bytes)
 * Entity flag check
 */
s32 func_80098874(void *entity, s32 flagMask) {
    s32 flags;

    flags = *(s32 *)((u8 *)entity + 0x0C);
    return (flags & flagMask) != 0;
}

/*

 * func_800988E0 (516 bytes)
 * Entity damage/health update - processes damage and effects
 */
void func_800988E0(void *entity, s32 damage) {
    s32 *health;
    s32 *maxHealth;
    s32 *invulnTimer;
    s32 *damageState;
    f32 *pos;

    if (entity == NULL) {
        return;
    }

    health = (s32 *)((u8 *)entity + 0x100);
    maxHealth = (s32 *)((u8 *)entity + 0x104);
    invulnTimer = (s32 *)((u8 *)entity + 0x108);
    damageState = (s32 *)((u8 *)entity + 0x10C);
    pos = (f32 *)((u8 *)entity + 0x24);

    /* Check invulnerability */
    if (*invulnTimer > 0) {
        return;
    }

    /* Apply damage */
    *health -= damage;

    /* Clamp health */
    if (*health < 0) {
        *health = 0;
    }
    if (*health > *maxHealth) {
        *health = *maxHealth;
    }

    /* Set damage state */
    if (*health <= 0) {
        *damageState = 3;  /* Destroyed */
    } else if (*health < *maxHealth / 4) {
        *damageState = 2;  /* Critical */
    } else if (*health < *maxHealth / 2) {
        *damageState = 1;  /* Damaged */
    } else {
        *damageState = 0;  /* Healthy */
    }

    /* Grant invulnerability frames */
    if (damage > 0) {
        *invulnTimer = 30;  /* 0.5 seconds */

        /* Spawn damage effect */
        func_800E15A8(pos, 0, 5);

        /* Play damage sound */
        func_800B37E8(0x50, 0, NULL, 0);
    }
}

/*

 * func_80098AE4 (1244 bytes)
 * Entity physics step - integrates physics for one timestep
 */
void func_80098AE4(void *entity, f32 dt) {
    f32 *pos;
    f32 *vel;
    f32 *accel;
    f32 *angVel;
    f32 *rot;
    f32 *mass;
    s32 *grounded;
    f32 gravity;
    f32 drag;
    f32 speed;
    f32 groundNormal[3];

    if (entity == NULL) {
        return;
    }

    pos = (f32 *)((u8 *)entity + 0x24);
    vel = (f32 *)((u8 *)entity + 0x34);
    accel = (f32 *)((u8 *)entity + 0x44);
    rot = (f32 *)((u8 *)entity + 0x60);
    angVel = (f32 *)((u8 *)entity + 0x70);
    mass = (f32 *)((u8 *)entity + 0x54);
    grounded = (s32 *)((u8 *)entity + 0x1C0);

    gravity = 30.0f;  /* Gravity constant */
    drag = 0.02f;     /* Air drag */

    /* Apply gravity if not grounded */
    if (!(*grounded)) {
        vel[1] -= gravity * dt;
    }

    /* Apply acceleration */
    vel[0] += accel[0] * dt;
    vel[1] += accel[1] * dt;
    vel[2] += accel[2] * dt;

    /* Apply drag (velocity-squared model) */
    speed = sqrtf(vel[0] * vel[0] + vel[1] * vel[1] + vel[2] * vel[2]);
    if (speed > 0.01f) {
        f32 dragForce = drag * speed * speed;
        f32 dragScale = 1.0f - (dragForce * dt / speed);
        if (dragScale < 0.9f) dragScale = 0.9f;
        vel[0] *= dragScale;
        vel[1] *= dragScale;
        vel[2] *= dragScale;
    }

    /* Integrate position */
    pos[0] += vel[0] * dt;
    pos[1] += vel[1] * dt;
    pos[2] += vel[2] * dt;

    /* Integrate rotation */
    rot[0] += angVel[0] * dt;
    rot[1] += angVel[1] * dt;
    rot[2] += angVel[2] * dt;

    /* Normalize rotation angles */
    while (rot[0] > 3.14159f) rot[0] -= 6.28318f;
    while (rot[0] < -3.14159f) rot[0] += 6.28318f;
    while (rot[1] > 3.14159f) rot[1] -= 6.28318f;
    while (rot[1] < -3.14159f) rot[1] += 6.28318f;
    while (rot[2] > 3.14159f) rot[2] -= 6.28318f;
    while (rot[2] < -3.14159f) rot[2] += 6.28318f;

    /* Angular velocity damping */
    angVel[0] *= 0.98f;
    angVel[1] *= 0.99f;
    angVel[2] *= 0.98f;

    /* Ground collision check */
    if (func_80098FC0(entity, groundNormal)) {
        *grounded = 1;

        /* Apply ground friction */
        vel[0] *= 0.95f;
        vel[2] *= 0.95f;
    } else {
        *grounded = 0;
    }

    /* Clear acceleration for next frame */
    accel[0] = 0.0f;
    accel[1] = 0.0f;
    accel[2] = 0.0f;
}

/*

 * func_80098FC0 (708 bytes)
 * Entity ground check - raycasts down to find ground
 */
s32 func_80098FC0(void *entity, f32 *groundNormal) {
    f32 *pos;
    f32 *vel;
    f32 rayStart[3];
    f32 rayEnd[3];
    f32 hitPoint[3];
    f32 hitNormal[3];
    f32 groundHeight;
    f32 entityHeight;
    s32 surfaceType;

    if (entity == NULL) {
        return 0;
    }

    pos = (f32 *)((u8 *)entity + 0x24);
    vel = (f32 *)((u8 *)entity + 0x34);
    entityHeight = *((f32 *)((u8 *)entity + 0x58));  /* Entity collision height */

    if (entityHeight < 1.0f) {
        entityHeight = 2.0f;  /* Default height */
    }

    /* Cast ray from entity center down */
    rayStart[0] = pos[0];
    rayStart[1] = pos[1];
    rayStart[2] = pos[2];

    rayEnd[0] = pos[0];
    rayEnd[1] = pos[1] - entityHeight - 5.0f;  /* Check slightly below */
    rayEnd[2] = pos[2];

    /* Check track surface */
    surfaceType = func_800BB9B0(rayStart, hitNormal, &groundHeight);

    if (surfaceType > 0) {
        /* Check if close enough to ground */
        f32 distToGround = pos[1] - groundHeight;

        if (distToGround < entityHeight + 0.5f) {
            /* On ground - snap to surface if falling through */
            if (distToGround < entityHeight - 0.1f) {
                pos[1] = groundHeight + entityHeight;

                /* Cancel downward velocity */
                if (vel[1] < 0) {
                    vel[1] = 0;
                }
            }

            /* Return ground normal if requested */
            if (groundNormal != NULL) {
                groundNormal[0] = hitNormal[0];
                groundNormal[1] = hitNormal[1];
                groundNormal[2] = hitNormal[2];
            }

            return 1;  /* Grounded */
        }
    }

    /* Not grounded - set default up normal */
    if (groundNormal != NULL) {
        groundNormal[0] = 0.0f;
        groundNormal[1] = 1.0f;
        groundNormal[2] = 0.0f;
    }

    return 0;
}

/*

 * func_800992AC (2388 bytes)
 * Entity AI pathfinding - calculates path to target
 */
void func_800992AC(void *entity, void *target) {
    f32 *entityPos;
    f32 *targetPos;
    f32 *waypoints;
    s32 *waypointCount;
    s32 *currentWaypoint;
    f32 dx, dy, dz, dist;
    f32 dirX, dirZ;
    s32 i;
    s32 bestWaypoint;
    f32 bestDist;

    if (entity == NULL || target == NULL) {
        return;
    }

    entityPos = (f32 *)((u8 *)entity + 0x24);
    targetPos = (f32 *)((u8 *)target + 0x24);
    waypoints = (f32 *)((u8 *)entity + 0x400);  /* Waypoint array */
    waypointCount = (s32 *)((u8 *)entity + 0x3F0);
    currentWaypoint = (s32 *)((u8 *)entity + 0x3F4);

    /* Calculate direct distance to target */
    dx = targetPos[0] - entityPos[0];
    dy = targetPos[1] - entityPos[1];
    dz = targetPos[2] - entityPos[2];
    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    /* If close enough, go direct */
    if (dist < 100.0f) {
        /* Clear waypoints, go direct */
        *waypointCount = 0;
        *currentWaypoint = -1;

        /* Set steering toward target */
        dirX = dx / dist;
        dirZ = dz / dist;
        *((f32 *)((u8 *)entity + 0x250)) = dirX;
        *((f32 *)((u8 *)entity + 0x258)) = dirZ;
        return;
    }

    /* Check if need to recalculate path */
    if (*waypointCount == 0 || *currentWaypoint >= *waypointCount) {
        /* Build simple waypoint path using track nodes */
        void *trackData = (void *)D_80148000;
        s32 *nodeList = (s32 *)((u8 *)trackData + 0x1000);
        s32 nodeCount = *((s32 *)((u8 *)trackData + 0x0FFC));
        f32 nodeX, nodeY, nodeZ;

        *waypointCount = 0;
        *currentWaypoint = 0;

        /* Find nearest track node to entity */
        bestWaypoint = 0;
        bestDist = 999999.0f;

        for (i = 0; i < nodeCount && i < 100; i++) {
            func_800A2378(0, i, &nodeX, &nodeY, &nodeZ);

            dx = nodeX - entityPos[0];
            dz = nodeZ - entityPos[2];
            dist = sqrtf(dx * dx + dz * dz);

            if (dist < bestDist) {
                bestDist = dist;
                bestWaypoint = i;
            }
        }

        /* Add waypoints from nearest node toward target */
        for (i = 0; i < 8 && *waypointCount < 16; i++) {
            s32 nodeIdx = (bestWaypoint + i) % nodeCount;
            func_800A2378(0, nodeIdx, &nodeX, &nodeY, &nodeZ);

            waypoints[*waypointCount * 3 + 0] = nodeX;
            waypoints[*waypointCount * 3 + 1] = nodeY;
            waypoints[*waypointCount * 3 + 2] = nodeZ;
            (*waypointCount)++;

            /* Check if close to target */
            dx = nodeX - targetPos[0];
            dz = nodeZ - targetPos[2];
            if (sqrtf(dx * dx + dz * dz) < 150.0f) {
                break;
            }
        }
    }

    /* Follow current waypoint */
    if (*currentWaypoint < *waypointCount) {
        f32 wpX = waypoints[*currentWaypoint * 3 + 0];
        f32 wpZ = waypoints[*currentWaypoint * 3 + 2];

        dx = wpX - entityPos[0];
        dz = wpZ - entityPos[2];
        dist = sqrtf(dx * dx + dz * dz);

        /* Check if reached waypoint */
        if (dist < 20.0f) {
            (*currentWaypoint)++;
        } else {
            /* Steer toward waypoint */
            dirX = dx / dist;
            dirZ = dz / dist;
            *((f32 *)((u8 *)entity + 0x250)) = dirX;
            *((f32 *)((u8 *)entity + 0x258)) = dirZ;
        }
    }
}

/*

 * func_80099BFC (10220 bytes)
 * Major entity render function
 */
void func_80099BFC(void *entity) {
    void *dlPtr;
    u32 flags;

    dlPtr = *(void **)(0x80149438);  /* Display list pointer */

    if (entity == NULL) {
        return;
    }

    flags = *(u32 *)((u8 *)entity + 0x1C);

    /* Check render flag */
    if ((flags & 0x80000000) != 0) {
        return;
    }

    /* Add display list command */
    *(u32 *)dlPtr = 0xDE000000;
    *(void **)((u8 *)dlPtr + 4) = *(void **)((u8 *)entity + 0x18);
    *(void **)(0x80149438) = (void *)((u8 *)dlPtr + 8);

    /* Complex rendering... */
}

/*

 * func_8009C5E0 (1560 bytes)
 * Lighting/shading calculation - computes surface lighting
 */
void func_8009C5E0(f32 *color, f32 *normal, f32 *lightDir) {
    f32 ambient[3];
    f32 diffuse[3];
    f32 specular[3];
    f32 nDotL;
    f32 reflection[3];
    f32 viewDir[3];
    f32 rDotV;
    f32 shininess;

    if (color == NULL || normal == NULL || lightDir == NULL) {
        return;
    }

    /* Get global lighting parameters */
    ambient[0] = *((f32 *)0x80160000);  /* Ambient R */
    ambient[1] = *((f32 *)0x80160004);  /* Ambient G */
    ambient[2] = *((f32 *)0x80160008);  /* Ambient B */

    diffuse[0] = *((f32 *)0x8016000C);  /* Light R */
    diffuse[1] = *((f32 *)0x80160010);  /* Light G */
    diffuse[2] = *((f32 *)0x80160014);  /* Light B */

    /* Calculate diffuse lighting (Lambert) */
    nDotL = normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2];
    if (nDotL < 0.0f) {
        nDotL = 0.0f;
    }

    /* Calculate reflection vector for specular */
    reflection[0] = 2.0f * nDotL * normal[0] - lightDir[0];
    reflection[1] = 2.0f * nDotL * normal[1] - lightDir[1];
    reflection[2] = 2.0f * nDotL * normal[2] - lightDir[2];

    /* View direction (assume camera at origin looking down -Z) */
    viewDir[0] = 0.0f;
    viewDir[1] = 0.0f;
    viewDir[2] = -1.0f;

    /* Specular calculation (Phong) */
    rDotV = reflection[0] * viewDir[0] + reflection[1] * viewDir[1] + reflection[2] * viewDir[2];
    if (rDotV < 0.0f) {
        rDotV = 0.0f;
    }

    shininess = 32.0f;
    specular[0] = specular[1] = specular[2] = 0.0f;

    if (rDotV > 0.0f) {
        f32 spec = 1.0f;
        for (s32 i = 0; i < 5; i++) {  /* Approximate pow(rDotV, 32) */
            spec *= rDotV;
        }
        specular[0] = diffuse[0] * spec * 0.5f;
        specular[1] = diffuse[1] * spec * 0.5f;
        specular[2] = diffuse[2] * spec * 0.5f;
    }

    /* Combine lighting components */
    color[0] = ambient[0] + diffuse[0] * nDotL + specular[0];
    color[1] = ambient[1] + diffuse[1] * nDotL + specular[1];
    color[2] = ambient[2] + diffuse[2] * nDotL + specular[2];

    /* Clamp to 0-1 range */
    if (color[0] > 1.0f) color[0] = 1.0f;
    if (color[1] > 1.0f) color[1] = 1.0f;
    if (color[2] > 1.0f) color[2] = 1.0f;
    if (color[0] < 0.0f) color[0] = 0.0f;
    if (color[1] < 0.0f) color[1] = 0.0f;
    if (color[2] < 0.0f) color[2] = 0.0f;
}

/*

 * func_800A1648 (2256 bytes)
 * Track segment loading
 */
void func_800A1648(s32 segmentId) {
    u32 *segmentTable;
    u32 romAddr, segmentSize;
    u8 *destAddr;
    s32 *loadedFlags;

    /* Track segment ROM table at 0x8016B000 */
    segmentTable = (u32 *)0x8016B000;
    loadedFlags = (s32 *)0x8016B800;

    /* Validate segment ID */
    if (segmentId < 0 || segmentId >= 32) {
        return;
    }

    /* Check if already loaded */
    if (loadedFlags[segmentId] != 0) {
        return;
    }

    /* Get ROM address and size from table */
    romAddr = segmentTable[segmentId * 2];
    segmentSize = segmentTable[segmentId * 2 + 1];

    if (romAddr == 0 || segmentSize == 0) {
        return;
    }

    /* Calculate destination address in segment pool */
    /* Each segment gets 32KB slot at 0x80180000 */
    destAddr = (u8 *)(0x80180000 + (segmentId * 0x8000));

    /* DMA segment data from ROM */
    osPiStartDma(&D_80020000, OS_MESG_PRI_NORMAL, OS_READ,
                 romAddr, destAddr, segmentSize, &D_80020010);
    osRecvMesg(&D_80020010, NULL, OS_MESG_BLOCK);

    /* Mark segment as loaded */
    loadedFlags[segmentId] = 1;

    /* If segment is compressed, decompress it */
    if (*(u8 *)destAddr == 0x1F && *(u8 *)(destAddr + 1) == 0x8B) {
        /* GZIP header detected - decompress in place */
        func_800A1F18(destAddr, destAddr, segmentSize);
    }
}

/*

 * func_800A1F18 (644 bytes)
 * Track data decompression
 */
void func_800A1F18(void *dest, void *src, s32 size) {
    u8 *srcPtr, *destPtr;
    u8 *tempBuffer;
    s32 compressedSize;
    s32 i;

    if (dest == NULL || src == NULL || size <= 0) {
        return;
    }

    srcPtr = (u8 *)src;
    destPtr = (u8 *)dest;

    /* Allocate temp buffer for in-place decompression */
    tempBuffer = (u8 *)0x80170000;

    /* Check for GZIP header */
    if (srcPtr[0] == 0x1F && srcPtr[1] == 0x8B) {
        /* Skip 10-byte GZIP header */
        srcPtr += 10;
        compressedSize = size - 10 - 8;  /* minus header and trailer */

        /* Copy compressed data to temp buffer */
        for (i = 0; i < compressedSize; i++) {
            tempBuffer[i] = srcPtr[i];
        }

        /* Call inflate decompressor */
        inflate_entry(tempBuffer, destPtr);
    } else if (srcPtr[0] == 0x78) {
        /* ZLIB header */
        srcPtr += 2;
        compressedSize = size - 2 - 4;

        for (i = 0; i < compressedSize; i++) {
            tempBuffer[i] = srcPtr[i];
        }

        inflate_entry(tempBuffer, destPtr);
    } else {
        /* Raw LZSS format used in Rush */
        lzss_decode(srcPtr, destPtr, size);
    }
}

/*

 * func_800A21A4 (732 bytes)
 * Track collision setup
 */
void func_800A21A4(void *trackData) {
    u8 *data;
    s32 *numTris, *numQuads;
    f32 *collisionVerts;
    s32 *collisionIndices;
    s32 *surfaceTypes;
    f32 *heightGrid;
    u8 *surfaceGrid;
    s32 i, j;
    f32 minX, minZ, maxX, maxZ;
    f32 gridSizeX, gridSizeZ;

    if (trackData == NULL) {
        return;
    }

    data = (u8 *)trackData;

    /* Track collision data format:
     * 0x00: numTris
     * 0x04: numQuads
     * 0x08: vertex array offset
     * 0x0C: index array offset
     * 0x10: surface type array offset
     * 0x14: bounds min XZ
     * 0x1C: bounds max XZ
     */
    numTris = (s32 *)data;
    numQuads = (s32 *)(data + 0x04);
    collisionVerts = (f32 *)(data + *(s32 *)(data + 0x08));
    collisionIndices = (s32 *)(data + *(s32 *)(data + 0x0C));
    surfaceTypes = (s32 *)(data + *(s32 *)(data + 0x10));

    minX = *(f32 *)(data + 0x14);
    minZ = *(f32 *)(data + 0x18);
    maxX = *(f32 *)(data + 0x1C);
    maxZ = *(f32 *)(data + 0x20);

    /* Set up height grid (64x64) at 0x8015C100 */
    heightGrid = (f32 *)0x8015C100;
    surfaceGrid = (u8 *)0x8015D000;

    gridSizeX = (maxX - minX) / 64.0f;
    gridSizeZ = (maxZ - minZ) / 64.0f;

    /* Initialize grids to defaults */
    for (i = 0; i < 64; i++) {
        for (j = 0; j < 64; j++) {
            heightGrid[i * 64 + j] = 0.0f;
            surfaceGrid[i * 64 + j] = 0;  /* Default surface type */
        }
    }

    /* Store grid parameters for height queries */
    *(f32 *)0x8015C000 = minX;
    *(f32 *)0x8015C004 = minZ;
    *(f32 *)0x8015C008 = gridSizeX;
    *(f32 *)0x8015C00C = gridSizeZ;
    *(s32 *)0x8015C010 = *numTris;
    *(s32 *)0x8015C014 = *numQuads;

    /* Build height grid from collision geometry */
    /* This would normally sample triangles, simplified here */
}

/*

 * func_800A2D4C (3116 bytes)
 * Major track processing
 */
void func_800A2D4C(void *a0, void *a1, void *a2, void *a3) {
    s8 initFlag;

    initFlag = *(s8 *)(0x8011194C);
    if (initFlag != 0) {
        return;
    }

    /* Set init flag */
    *(s8 *)(0x8011194C) = 1;

    /* Process track segments... */
}

/*

 * func_800A3654 (296 bytes)
 * Track spline interpolation
 */
void func_800A3654(void *spline, f32 t, f32 *outPos) {
    f32 *controlPoints;
    s32 numPoints;
    s32 segment;
    f32 localT;
    f32 t2, t3;
    f32 p0[3], p1[3], p2[3], p3[3];
    s32 i;

    if (spline == NULL || outPos == NULL) {
        return;
    }

    /* Spline format: [numPoints, x0,y0,z0, x1,y1,z1, ...] */
    numPoints = *(s32 *)spline;
    controlPoints = (f32 *)((u8 *)spline + 4);

    if (numPoints < 4) {
        /* Linear interpolation for minimal points */
        outPos[0] = controlPoints[0];
        outPos[1] = controlPoints[1];
        outPos[2] = controlPoints[2];
        return;
    }

    /* Clamp t */
    if (t < 0.0f) t = 0.0f;
    if (t > 1.0f) t = 1.0f;

    /* Find segment */
    segment = (s32)(t * (numPoints - 3));
    if (segment >= numPoints - 3) {
        segment = numPoints - 4;
    }

    localT = t * (numPoints - 3) - segment;
    t2 = localT * localT;
    t3 = t2 * localT;

    /* Get four control points for Catmull-Rom spline */
    for (i = 0; i < 3; i++) {
        p0[i] = controlPoints[(segment + 0) * 3 + i];
        p1[i] = controlPoints[(segment + 1) * 3 + i];
        p2[i] = controlPoints[(segment + 2) * 3 + i];
        p3[i] = controlPoints[(segment + 3) * 3 + i];
    }

    /* Catmull-Rom interpolation */
    for (i = 0; i < 3; i++) {
        outPos[i] = 0.5f * ((2.0f * p1[i]) +
                           (-p0[i] + p2[i]) * localT +
                           (2.0f * p0[i] - 5.0f * p1[i] + 4.0f * p2[i] - p3[i]) * t2 +
                           (-p0[i] + 3.0f * p1[i] - 3.0f * p2[i] + p3[i]) * t3);
    }
}

/*

 * func_800A377C (3156 bytes)
 * Track render processing
 */
void func_800A377C(void *track, s32 mode) {
    s8 renderFlag;

    renderFlag = *(s8 *)(0x8012EAE0);
    if (renderFlag == 0) {
        return;
    }

    /* Process track rendering... */
}

/*

 * func_800A4508 (568 bytes)
 * Car model LOD selection
 */
void func_800A4508(void *car, f32 distance) {
    s32 *currentLod;
    void **lodModels;
    f32 lodDistances[4];
    s32 newLod;

    if (car == NULL) {
        return;
    }

    /* Car LOD structure offsets:
     * 0x180: current LOD level (0-3)
     * 0x184: LOD model pointers [4]
     */
    currentLod = (s32 *)((u8 *)car + 0x180);
    lodModels = (void **)((u8 *)car + 0x184);

    /* LOD distance thresholds */
    lodDistances[0] = 20.0f;   /* High detail */
    lodDistances[1] = 50.0f;   /* Medium detail */
    lodDistances[2] = 100.0f;  /* Low detail */
    lodDistances[3] = 200.0f;  /* Minimal detail */

    /* Select LOD based on distance */
    if (distance < lodDistances[0]) {
        newLod = 0;
    } else if (distance < lodDistances[1]) {
        newLod = 1;
    } else if (distance < lodDistances[2]) {
        newLod = 2;
    } else {
        newLod = 3;
    }

    /* Only switch if LOD actually changed and model exists */
    if (newLod != *currentLod && lodModels[newLod] != NULL) {
        *currentLod = newLod;

        /* Update active display list pointer */
        *(void **)((u8 *)car + 0x194) = lodModels[newLod];
    }
}

/*

 * func_800A4940 (388 bytes)
 * Wheel rotation update
 *
 * Updates wheel visual rotation based on angular velocity.
 * Also handles tire slip angle calculations for force model.
 *
 * Wheel structure offsets:
 *   0x00: rotation angle
 *   0x04: angular velocity (rad/s)
 *   0x08: radius
 *   0x0C: slip angle
 *   0x10: slip ratio
 *   0x14: contact patch velocity [3]
 */
void func_800A4940(void *wheel, f32 dt) {
    f32 *rotAngle, *angVel;
    f32 radius;
    f32 *slipAngle, *slipRatio;
    f32 *patchVel;
    f32 roadSpeed, wheelSpeed;
    f32 newAngle;

    if (wheel == NULL || dt <= 0.0f) {
        return;
    }

    rotAngle = (f32 *)((u8 *)wheel + 0x00);
    angVel = (f32 *)((u8 *)wheel + 0x04);
    radius = *(f32 *)((u8 *)wheel + 0x08);
    slipAngle = (f32 *)((u8 *)wheel + 0x0C);
    slipRatio = (f32 *)((u8 *)wheel + 0x10);
    patchVel = (f32 *)((u8 *)wheel + 0x14);

    if (radius == 0.0f) radius = 1.0f;

    /* Update rotation angle for visual */
    newAngle = *rotAngle + (*angVel * dt);

    /* Keep angle in 0-2pi range */
    while (newAngle > 6.283185f) {
        newAngle -= 6.283185f;
    }
    while (newAngle < 0.0f) {
        newAngle += 6.283185f;
    }
    *rotAngle = newAngle;

    /* Calculate slip ratio for traction calculations */
    /* Slip ratio = (wheel_speed - road_speed) / max(wheel_speed, road_speed) */
    roadSpeed = patchVel[0];  /* Forward component of contact patch velocity */
    wheelSpeed = *angVel * radius;

    if (fabsf(roadSpeed) > 0.1f || fabsf(wheelSpeed) > 0.1f) {
        f32 maxSpeed = fabsf(roadSpeed);
        if (fabsf(wheelSpeed) > maxSpeed) {
            maxSpeed = fabsf(wheelSpeed);
        }
        *slipRatio = (wheelSpeed - roadSpeed) / maxSpeed;
    } else {
        *slipRatio = 0.0f;
    }

    /* Calculate slip angle from lateral velocity */
    /* Slip angle = atan2(lateral_vel, forward_vel) */
    if (fabsf(patchVel[0]) > 0.1f) {
        *slipAngle = patchVel[1] / patchVel[0];  /* Small angle approximation */
        if (*slipAngle > 0.5f) *slipAngle = 0.5f;
        if (*slipAngle < -0.5f) *slipAngle = -0.5f;
    } else {
        *slipAngle = 0.0f;
    }
}

/*

 * func_800A4CC0 (412 bytes)
 * Suspension compression update
 *
 * Based on arcade tires.c dotireforce() function.
 * Calculates suspension spring and damper forces.
 * Updates suspension compression state.
 *
 * Suspension structure offsets:
 *   0x00: compression (current)
 *   0x04: compression velocity
 *   0x08: spring rate (lb/ft)
 *   0x0C: damping rate (compression)
 *   0x10: damping rate (rebound)
 *   0x14: anti-roll bar rate
 *   0x18: other side compression (for ARB calc)
 *   0x1C: output force
 */
void func_800A4CC0(void *suspension, f32 newCompression) {
    f32 *compression, *compVel;
    f32 springRate, cDamping, rDamping;
    f32 arbRate, otherComp;
    f32 *outputForce;
    f32 springForce, dampForce, arbForce;
    f32 totalForce;
    f32 dt = 0.016f;  /* Assume 60fps */

    if (suspension == NULL) {
        return;
    }

    compression = (f32 *)((u8 *)suspension + 0x00);
    compVel = (f32 *)((u8 *)suspension + 0x04);
    springRate = *(f32 *)((u8 *)suspension + 0x08);
    cDamping = *(f32 *)((u8 *)suspension + 0x0C);
    rDamping = *(f32 *)((u8 *)suspension + 0x10);
    arbRate = *(f32 *)((u8 *)suspension + 0x14);
    otherComp = *(f32 *)((u8 *)suspension + 0x18);
    outputForce = (f32 *)((u8 *)suspension + 0x1C);

    /* Default values if not set */
    if (springRate == 0.0f) springRate = -4000.0f;  /* Negative = upward force */
    if (cDamping == 0.0f) cDamping = -500.0f;
    if (rDamping == 0.0f) rDamping = -500.0f;

    /* Calculate compression velocity */
    *compVel = (newCompression - *compression) / dt;

    /* Update compression */
    *compression = newCompression;

    /* Only apply forces if in contact with ground */
    if (newCompression <= 0.0f) {
        *outputForce = 0.0f;
        return;
    }

    /* Spring force: F = -k * x */
    springForce = springRate * newCompression;

    /* Progressive spring rate for bottoming out */
    if (newCompression > 10.0f) {
        springForce *= (newCompression / 10.0f);
    }

    /* Damping force: F = -c * v */
    if (*compVel > 0.0f) {
        /* Compression stroke */
        dampForce = cDamping * (*compVel);
    } else {
        /* Rebound stroke */
        dampForce = rDamping * (*compVel);
    }

    /* Anti-roll bar force */
    /* Differential force based on compression difference */
    if (arbRate != 0.0f) {
        arbForce = arbRate * (newCompression - otherComp);
    } else {
        arbForce = 0.0f;
    }

    /* Total vertical force */
    totalForce = springForce + dampForce + arbForce;

    /* Clamp to prevent negative (pulling down) forces */
    if (totalForce < 0.0f) {
        totalForce = 0.0f;
    }

    *outputForce = totalForce;
}

/*

 * func_800A4E60 (444 bytes)
 * Tire skid mark generation
 *
 * Creates visual skid marks on the ground based on tire slip.
 * Based on arcade tires.c screech calculations.
 *
 * Tire structure offsets:
 *   0x10: slip ratio
 *   0x0C: slip angle
 *   0x20: skid mark buffer pointer
 *   0x24: skid mark index
 */
void func_800A4E60(void *tire, f32 *pos, f32 intensity) {
    f32 slipRatio, slipAngle;
    f32 totalSlip;
    void **skidBuffer;
    s32 *skidIndex;
    f32 *skidEntry;
    s32 idx;

    if (tire == NULL || pos == NULL) {
        return;
    }

    slipRatio = *(f32 *)((u8 *)tire + 0x10);
    slipAngle = *(f32 *)((u8 *)tire + 0x0C);
    skidBuffer = (void **)((u8 *)tire + 0x20);
    skidIndex = (s32 *)((u8 *)tire + 0x24);

    if (*skidBuffer == NULL) {
        return;
    }

    /* Calculate total slip magnitude */
    totalSlip = sqrtf(slipRatio * slipRatio + slipAngle * slipAngle);

    /* Only generate skid mark if slip exceeds threshold */
    if (totalSlip < 0.15f) {
        return;
    }

    /* Scale intensity by slip amount */
    intensity *= (totalSlip - 0.15f) * 2.0f;
    if (intensity > 1.0f) intensity = 1.0f;
    if (intensity < 0.0f) intensity = 0.0f;

    /* Add new skid mark point */
    idx = *skidIndex;
    skidEntry = (f32 *)((u8 *)(*skidBuffer) + idx * 16);  /* 16 bytes per entry */

    /* Store position */
    skidEntry[0] = pos[0];
    skidEntry[1] = pos[1] + 0.01f;  /* Slightly above ground */
    skidEntry[2] = pos[2];

    /* Store intensity/alpha */
    skidEntry[3] = intensity;

    /* Advance index (circular buffer) */
    *skidIndex = (idx + 1) % 64;  /* 64 entry buffer */
}

/*

 * func_800A51E0 (932 bytes)
 * Car damage visual update - apply damage effects to car model
 */
void func_800A51E0(void *car, s32 damageLevel) {
    f32 *bodyOffset;
    s32 *damageState;
    s32 i;

    if (car == NULL) return;

    bodyOffset = (f32 *)((u8 *)car + 0x200);
    damageState = (s32 *)((u8 *)car + 0x220);

    /* Apply damage deformation based on level */
    if (damageLevel == 0) {
        /* No damage - reset */
        for (i = 0; i < 8; i++) {
            bodyOffset[i] = 0.0f;
        }
        *damageState = 0;
        return;
    }

    /* Light damage - minor dents */
    if (damageLevel == 1) {
        bodyOffset[0] = -0.5f;  /* Front left */
        bodyOffset[1] = 0.3f;   /* Front right */
        *damageState = 1;
    }
    /* Medium damage - visible damage */
    else if (damageLevel == 2) {
        bodyOffset[0] = -1.5f;
        bodyOffset[1] = 1.0f;
        bodyOffset[2] = -0.8f;  /* Rear left */
        bodyOffset[3] = 0.5f;   /* Rear right */
        *damageState = 2;
    }
    /* Heavy damage - severe deformation */
    else if (damageLevel >= 3) {
        bodyOffset[0] = -3.0f;
        bodyOffset[1] = 2.5f;
        bodyOffset[2] = -2.0f;
        bodyOffset[3] = 1.5f;
        bodyOffset[4] = 0.5f;  /* Hood */
        bodyOffset[5] = -1.0f; /* Trunk */
        *damageState = 3;

        /* Trigger smoke effect on heavy damage */
        if (damageLevel >= 4) {
            func_800A5588(car, 2);  /* Smoke */
        }
    }
}

/*

 * func_800A5588 (444 bytes)
 * Engine particle effect - spawn particles from car
 */
void func_800A5588(void *car, s32 effectType) {
    f32 *carPos;
    f32 *carDir;
    s32 *particlePool;
    s32 particleIndex;
    s32 i;

    if (car == NULL) return;

    carPos = (f32 *)((u8 *)car + 0x24);
    carDir = (f32 *)((u8 *)car + 0x60);
    particlePool = (s32 *)0x80162000;
    particleIndex = D_80162100;

    /* Spawn particles based on effect type */
    switch (effectType) {
        case 0:  /* Dust/dirt */
            for (i = 0; i < 4; i++) {
                s32 *particle = &particlePool[particleIndex * 16];
                particle[0] = 1;  /* Active */
                *(f32 *)&particle[1] = carPos[0] + (i - 1.5f) * 2.0f;
                *(f32 *)&particle[2] = carPos[1];
                *(f32 *)&particle[3] = carPos[2] + (i - 1.5f) * 2.0f;
                *(f32 *)&particle[4] = 0.0f;  /* Vel X */
                *(f32 *)&particle[5] = 2.0f;  /* Vel Y (upward) */
                *(f32 *)&particle[6] = 0.0f;  /* Vel Z */
                particle[7] = 30;  /* Lifetime */
                particle[8] = 0;   /* Type: dust */
                particleIndex = (particleIndex + 1) % 64;
            }
            break;

        case 1:  /* Sparks */
            for (i = 0; i < 8; i++) {
                s32 *particle = &particlePool[particleIndex * 16];
                particle[0] = 1;
                *(f32 *)&particle[1] = carPos[0];
                *(f32 *)&particle[2] = carPos[1] + 1.0f;
                *(f32 *)&particle[3] = carPos[2];
                *(f32 *)&particle[4] = (f32)(i - 4) * 3.0f;
                *(f32 *)&particle[5] = 5.0f + (f32)(i % 3);
                *(f32 *)&particle[6] = (f32)((i * 7) % 8 - 4) * 3.0f;
                particle[7] = 15;  /* Short lifetime */
                particle[8] = 1;   /* Type: spark */
                particleIndex = (particleIndex + 1) % 64;
            }
            break;

        case 2:  /* Smoke */
            for (i = 0; i < 3; i++) {
                s32 *particle = &particlePool[particleIndex * 16];
                particle[0] = 1;
                *(f32 *)&particle[1] = carPos[0] + carDir[0] * 3.0f;
                *(f32 *)&particle[2] = carPos[1] + 2.0f;
                *(f32 *)&particle[3] = carPos[2] + carDir[2] * 3.0f;
                *(f32 *)&particle[4] = 0.0f;
                *(f32 *)&particle[5] = 1.0f;  /* Slow rise */
                *(f32 *)&particle[6] = 0.0f;
                particle[7] = 60;  /* Long lifetime */
                particle[8] = 2;   /* Type: smoke */
                particleIndex = (particleIndex + 1) % 64;
            }
            break;
    }

    D_80162100 = particleIndex;
}

/*

 * func_800A5744 (488 bytes)
 * Exhaust smoke effect - render exhaust from car
 */
void func_800A5744(void *car, f32 *exhaustPos) {
    f32 *carVel;
    f32 speed;
    s32 rpm;
    s32 *particlePool;
    s32 particleIndex;
    s32 *particle;

    if (car == NULL || exhaustPos == NULL) return;

    carVel = (f32 *)((u8 *)car + 0x34);
    rpm = *(s32 *)((u8 *)car + 0x10C);

    /* Calculate speed */
    speed = sqrtf(carVel[0] * carVel[0] + carVel[2] * carVel[2]);

    /* Only emit exhaust at high RPM or acceleration */
    if (rpm < 4000 && speed < 20.0f) {
        return;
    }

    particlePool = (s32 *)0x80162000;
    particleIndex = D_80162100;
    particle = &particlePool[particleIndex * 16];

    /* Spawn exhaust particle */
    particle[0] = 1;
    *(f32 *)&particle[1] = exhaustPos[0];
    *(f32 *)&particle[2] = exhaustPos[1];
    *(f32 *)&particle[3] = exhaustPos[2];
    *(f32 *)&particle[4] = -carVel[0] * 0.2f;
    *(f32 *)&particle[5] = 0.5f;
    *(f32 *)&particle[6] = -carVel[2] * 0.2f;
    particle[7] = 20;
    particle[8] = 3;  /* Type: exhaust */

    D_80162100 = (particleIndex + 1) % 64;
}

/*

 * func_800A5D34 (1116 bytes)
 * Car shadow rendering - render blob shadow under car
 */
void func_800A5D34(void *car, void *ground) {
    f32 *carPos;
    f32 *groundY;
    f32 shadowY;
    f32 shadowScale;
    f32 height;
    void *dlPtr;

    if (car == NULL) return;

    carPos = (f32 *)((u8 *)car + 0x24);
    dlPtr = *(void **)(0x80149438);

    /* Get ground height at car position */
    if (ground != NULL) {
        groundY = (f32 *)((u8 *)ground + 0x04);
        shadowY = *groundY + 0.1f;  /* Slight offset to avoid z-fighting */
    } else {
        shadowY = 0.1f;
    }

    /* Calculate shadow scale based on height */
    height = carPos[1] - shadowY;
    if (height < 0.0f) height = 0.0f;
    if (height > 50.0f) height = 50.0f;

    /* Shadow gets smaller and fainter when higher */
    shadowScale = 1.0f - (height / 100.0f);
    if (shadowScale < 0.3f) shadowScale = 0.3f;

    /* Skip if too high */
    if (height > 50.0f) return;

    /* Render shadow quad */
    {
        f32 halfWidth = 3.0f * shadowScale;
        f32 halfLength = 5.0f * shadowScale;
        u8 alpha = (u8)(100 * shadowScale);

        /* Set blend mode for shadow */
        *(u32 *)dlPtr = 0xE200001C;  /* G_SETOTHERMODE_L */
        *(u32 *)((u8 *)dlPtr + 4) = 0x00504240;  /* Blend mode */
        dlPtr = (void *)((u8 *)dlPtr + 8);

        /* Draw shadow texture */
        draw_ui_element(32, (s32)(carPos[0] - halfWidth), (s32)(shadowY), (s32)(halfWidth * 2), (s32)(halfLength * 2), alpha);
    }

    *(void **)(0x80149438) = dlPtr;
}

/*

 * func_800A6094 (428 bytes)
 * Headlight/taillight rendering - render car lights
 */
void func_800A6094(void *car, s32 lightMask) {
    f32 *carPos;
    f32 *carDir;
    f32 lightPos[3];
    s32 alpha;
    s32 i;

    if (car == NULL) return;

    carPos = (f32 *)((u8 *)car + 0x24);
    carDir = (f32 *)((u8 *)car + 0x60);

    /* Headlights (bits 0-1) */
    if (lightMask & 0x03) {
        alpha = (lightMask & 0x01) ? 255 : 128;

        /* Left headlight */
        lightPos[0] = carPos[0] + carDir[0] * 4.0f - carDir[2] * 1.5f;
        lightPos[1] = carPos[1] + 1.0f;
        lightPos[2] = carPos[2] + carDir[2] * 4.0f + carDir[0] * 1.5f;
        draw_ui_element(33, (s32)lightPos[0], (s32)lightPos[1], (s32)lightPos[2], 8, alpha);

        /* Right headlight */
        lightPos[0] = carPos[0] + carDir[0] * 4.0f + carDir[2] * 1.5f;
        lightPos[2] = carPos[2] + carDir[2] * 4.0f - carDir[0] * 1.5f;
        draw_ui_element(33, (s32)lightPos[0], (s32)lightPos[1], (s32)lightPos[2], 8, alpha);
    }

    /* Taillights (bits 2-3) */
    if (lightMask & 0x0C) {
        alpha = (lightMask & 0x04) ? 255 : 100;

        /* Left taillight */
        lightPos[0] = carPos[0] - carDir[0] * 4.0f - carDir[2] * 1.5f;
        lightPos[1] = carPos[1] + 1.0f;
        lightPos[2] = carPos[2] - carDir[2] * 4.0f + carDir[0] * 1.5f;
        draw_ui_element(34, (s32)lightPos[0], (s32)lightPos[1], (s32)lightPos[2], 8, alpha);

        /* Right taillight */
        lightPos[0] = carPos[0] - carDir[0] * 4.0f + carDir[2] * 1.5f;
        lightPos[2] = carPos[2] - carDir[2] * 4.0f - carDir[0] * 1.5f;
        draw_ui_element(34, (s32)lightPos[0], (s32)lightPos[1], (s32)lightPos[2], 8, alpha);
    }
}

/*

 * func_800A6244 (448 bytes)
 * Brake light update - update brake light state
 */
void func_800A6244(void *car, s32 braking) {
    s32 *lightState;
    s32 currentLights;

    if (car == NULL) return;

    lightState = (s32 *)((u8 *)car + 0x230);
    currentLights = *lightState;

    if (braking) {
        /* Turn on brake lights (bits 2-3) */
        currentLights |= 0x0C;
    } else {
        /* Dim taillights */
        currentLights = (currentLights & ~0x0C) | 0x08;
    }

    *lightState = currentLights;

    /* Render lights */
    func_800A6094(car, currentLights);
}

/*

 * func_800A6404 (2016 bytes)
 * Car full render - render complete car with all effects
 */
void func_800A6404(void *car) {
    f32 *carPos;
    f32 *carVel;
    s32 damageLevel;
    s32 lightState;
    s32 braking;
    s32 onGround;
    f32 speed;
    f32 exhaustPos[3];

    if (car == NULL) return;

    carPos = (f32 *)((u8 *)car + 0x24);
    carVel = (f32 *)((u8 *)car + 0x34);
    damageLevel = *(s32 *)((u8 *)car + 0x220);
    lightState = *(s32 *)((u8 *)car + 0x230);
    braking = *(s32 *)((u8 *)car + 0x104);
    onGround = *(s32 *)((u8 *)car + 0x234);

    /* Calculate speed */
    speed = sqrtf(carVel[0] * carVel[0] + carVel[2] * carVel[2]);

    /* Render shadow */
    if (onGround) {
        func_800A5D34(car, NULL);
    }

    /* Render car body */
    func_80099BFC(car);

    /* Apply damage visuals */
    if (damageLevel > 0) {
        func_800A51E0(car, damageLevel);
    }

    /* Render lights */
    func_800A6094(car, lightState);

    /* Update brake lights */
    if (braking > 0) {
        func_800A6244(car, 1);
    } else {
        func_800A6244(car, 0);
    }

    /* Exhaust effect */
    {
        f32 *carDir = (f32 *)((u8 *)car + 0x60);
        exhaustPos[0] = carPos[0] - carDir[0] * 4.5f;
        exhaustPos[1] = carPos[1] + 0.5f;
        exhaustPos[2] = carPos[2] - carDir[2] * 4.5f;
        func_800A5744(car, exhaustPos);
    }

    /* Dust/dirt effect when on ground and moving */
    if (onGround && speed > 30.0f) {
        s32 roadType = *(s32 *)((u8 *)car + 0x118);
        if (roadType == 1 || roadType == 2) {  /* Dirt or gravel */
            func_800A5588(car, 0);  /* Dust */
        }
    }

    /* Spark effect on collision */
    if (*(s32 *)((u8 *)car + 0x114) != 0) {  /* Crash flag */
        func_800A5588(car, 1);  /* Sparks */
    }
}

/*

 * func_800A6BE4 (3300 bytes)
 * Car physics integration - main physics loop
 *
 * Based on arcade drivsym.c sym() and regular() functions.
 * Handles:
 *   1. Controls processing
 *   2. Drivetrain simulation
 *   3. Road/terrain detection
 *   4. Force calculations (tires, gravity, drag)
 *   5. Torque calculations
 *   6. Acceleration integration
 *   7. Velocity integration
 *   8. Position integration
 *
 * Car structure offsets:
 *   0x24: position (vec3)
 *   0x34: velocity (vec3)
 *   0x40: acceleration (vec3)
 *   0x60: forward direction (vec3)
 *   0x6C: up direction (vec3)
 *   0x78: right direction (vec3)
 *   0x84: angular velocity (vec3)
 *   0x90: angular acceleration (vec3)
 *   0x9C: tire forces [4][3]
 *   0xCC: suspension compression [4]
 *   0xDC: mass
 *   0xE0: inverse mass
 *   0xE4: moment of inertia (vec3)
 *   0xF0: inverse MOI (vec3)
 *   0xFC: steer angle
 *   0x100: throttle
 *   0x104: brake
 *   0x108: gear
 *   0x10C: RPM
 *   0x110: torque output
 *   0x114: crash flag
 *   0x118: road code [4]
 *   0x128: wheel base
 *   0x12C: track width
 *   0x130: CG height
 *   0x134: drag coefficient
 *   0x138: roll resistance
 */
void func_800A6BE4(void *car, f32 dt) {
    f32 *pos, *vel, *accel;
    f32 *forward, *up, *right;
    f32 *angVel, *angAccel;
    f32 *tireForces, *susComp;
    f32 mass, invMass;
    f32 *invi;
    f32 steerAngle, throttle, brake;
    f32 dragCoef, rollResist;
    f32 totalForce[3], totalMoment[3];
    f32 temp[3], tempMag;
    f32 gravity[3] = {0.0f, -32.2f, 0.0f};  /* ft/s^2 */
    f32 dragForce, rollForce;
    f32 wheelBase, trackWidth;
    s32 *roadCode;
    s32 crashFlag;
    s32 i;

    if (car == NULL || dt <= 0.0f) {
        return;
    }

    /* Get car state pointers */
    pos = (f32 *)((u8 *)car + 0x24);
    vel = (f32 *)((u8 *)car + 0x34);
    accel = (f32 *)((u8 *)car + 0x40);
    forward = (f32 *)((u8 *)car + 0x60);
    up = (f32 *)((u8 *)car + 0x6C);
    right = (f32 *)((u8 *)car + 0x78);
    angVel = (f32 *)((u8 *)car + 0x84);
    angAccel = (f32 *)((u8 *)car + 0x90);
    tireForces = (f32 *)((u8 *)car + 0x9C);
    susComp = (f32 *)((u8 *)car + 0xCC);
    mass = *(f32 *)((u8 *)car + 0xDC);
    invMass = *(f32 *)((u8 *)car + 0xE0);
    invi = (f32 *)((u8 *)car + 0xF0);
    steerAngle = *(f32 *)((u8 *)car + 0xFC);
    throttle = *(f32 *)((u8 *)car + 0x100);
    brake = *(f32 *)((u8 *)car + 0x104);
    roadCode = (s32 *)((u8 *)car + 0x118);
    wheelBase = *(f32 *)((u8 *)car + 0x128);
    trackWidth = *(f32 *)((u8 *)car + 0x12C);
    dragCoef = *(f32 *)((u8 *)car + 0x134);
    rollResist = *(f32 *)((u8 *)car + 0x138);
    crashFlag = *(s32 *)((u8 *)car + 0x114);

    /* Skip physics if crashed */
    if (crashFlag != 0) {
        return;
    }

    /* Initialize total force and moment */
    totalForce[0] = 0.0f;
    totalForce[1] = 0.0f;
    totalForce[2] = 0.0f;
    totalMoment[0] = 0.0f;
    totalMoment[1] = 0.0f;
    totalMoment[2] = 0.0f;

    /* Calculate speed in forward direction */
    tempMag = vel[0] * forward[0] + vel[1] * forward[1] + vel[2] * forward[2];

    /* Aerodynamic drag: F = -C * v^2 */
    if (tempMag > 0.01f || tempMag < -0.01f) {
        dragForce = -dragCoef * tempMag * fabsf(tempMag);
        totalForce[0] += dragForce * forward[0];
        totalForce[1] += dragForce * forward[1];
        totalForce[2] += dragForce * forward[2];
    }

    /* Rolling resistance */
    rollForce = -rollResist * mass;
    if (tempMag > 0.0f) {
        totalForce[0] += rollForce * forward[0];
        totalForce[2] += rollForce * forward[2];
    } else if (tempMag < 0.0f) {
        totalForce[0] -= rollForce * forward[0];
        totalForce[2] -= rollForce * forward[2];
    }

    /* Sum tire forces */
    for (i = 0; i < 4; i++) {
        totalForce[0] += tireForces[i * 3 + 0];
        totalForce[1] += tireForces[i * 3 + 1];
        totalForce[2] += tireForces[i * 3 + 2];
    }

    /* Add gravity */
    totalForce[0] += gravity[0] * mass;
    totalForce[1] += gravity[1] * mass;
    totalForce[2] += gravity[2] * mass;

    /* Calculate torques from tire forces */
    /* Front right tire */
    temp[0] = wheelBase * 0.5f;
    temp[1] = 0.0f;
    temp[2] = trackWidth * 0.5f;
    totalMoment[0] += temp[1] * tireForces[0*3+2] - temp[2] * tireForces[0*3+1];
    totalMoment[1] += temp[2] * tireForces[0*3+0] - temp[0] * tireForces[0*3+2];
    totalMoment[2] += temp[0] * tireForces[0*3+1] - temp[1] * tireForces[0*3+0];

    /* Front left tire */
    temp[2] = -trackWidth * 0.5f;
    totalMoment[0] += temp[1] * tireForces[1*3+2] - temp[2] * tireForces[1*3+1];
    totalMoment[1] += temp[2] * tireForces[1*3+0] - temp[0] * tireForces[1*3+2];
    totalMoment[2] += temp[0] * tireForces[1*3+1] - temp[1] * tireForces[1*3+0];

    /* Rear right tire */
    temp[0] = -wheelBase * 0.5f;
    temp[2] = trackWidth * 0.5f;
    totalMoment[0] += temp[1] * tireForces[2*3+2] - temp[2] * tireForces[2*3+1];
    totalMoment[1] += temp[2] * tireForces[2*3+0] - temp[0] * tireForces[2*3+2];
    totalMoment[2] += temp[0] * tireForces[2*3+1] - temp[1] * tireForces[2*3+0];

    /* Rear left tire */
    temp[2] = -trackWidth * 0.5f;
    totalMoment[0] += temp[1] * tireForces[3*3+2] - temp[2] * tireForces[3*3+1];
    totalMoment[1] += temp[2] * tireForces[3*3+0] - temp[0] * tireForces[3*3+2];
    totalMoment[2] += temp[0] * tireForces[3*3+1] - temp[1] * tireForces[3*3+0];

    /* Calculate accelerations: A = F / m */
    accel[0] = totalForce[0] * invMass;
    accel[1] = totalForce[1] * invMass;
    accel[2] = totalForce[2] * invMass;

    /* Calculate angular accelerations: AA = M * invI */
    angAccel[0] = totalMoment[0] * invi[0];
    angAccel[1] = totalMoment[1] * invi[1];
    angAccel[2] = totalMoment[2] * invi[2];

    /* Integrate velocities: V = V + A * dt */
    vel[0] += accel[0] * dt;
    vel[1] += accel[1] * dt;
    vel[2] += accel[2] * dt;

    /* Clamp velocity magnitude to prevent instability */
    tempMag = sqrtf(vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2]);
    if (tempMag > 1000.0f) {
        f32 scale = 1000.0f / tempMag;
        vel[0] *= scale;
        vel[1] *= scale;
        vel[2] *= scale;
    }

    /* Integrate angular velocities: W = W + AA * dt */
    angVel[0] += angAccel[0] * dt;
    angVel[1] += angAccel[1] * dt;
    angVel[2] += angAccel[2] * dt;

    /* Integrate positions: P = P + V * dt */
    pos[0] += vel[0] * dt;
    pos[1] += vel[1] * dt;
    pos[2] += vel[2] * dt;

    /* Update orientation from angular velocity */
    func_800A6F00(car, angVel, dt);  /* Update orientation vectors */
}

/*

 * func_800A78C8 (580 bytes)
 * Car steering response
 *
 * Based on arcade controls() function in drivsym.c.
 * Converts steering wheel input to front tire steer angle.
 * Applies steering ratio and speed-sensitive steering reduction.
 *
 * Car structure offsets:
 *   0x34: velocity (vec3)
 *   0x60: forward direction (vec3)
 *   0xFC: steer angle (output)
 *   0x13C: steering ratio (degrees input / degrees wheel)
 *   0x140: max steer angle
 *   0x144: steering speed factor
 */
void func_800A78C8(void *car, f32 steerInput) {
    f32 *vel, *forward;
    f32 *steerAngle;
    f32 steerRatio, maxSteer, speedFactor;
    f32 speed, speedEffect;
    f32 targetAngle, currentAngle;
    f32 steerRate;

    if (car == NULL) {
        return;
    }

    vel = (f32 *)((u8 *)car + 0x34);
    forward = (f32 *)((u8 *)car + 0x60);
    steerAngle = (f32 *)((u8 *)car + 0xFC);
    steerRatio = *(f32 *)((u8 *)car + 0x13C);
    maxSteer = *(f32 *)((u8 *)car + 0x140);
    speedFactor = *(f32 *)((u8 *)car + 0x144);

    /* Default values if not set */
    if (steerRatio == 0.0f) steerRatio = 14.0f;
    if (maxSteer == 0.0f) maxSteer = 0.5f;  /* ~28 degrees in radians */
    if (speedFactor == 0.0f) speedFactor = 0.01f;

    /* Calculate forward speed */
    speed = vel[0] * forward[0] + vel[1] * forward[1] + vel[2] * forward[2];
    speed = fabsf(speed);

    /* Speed-sensitive steering reduction */
    /* At high speeds, reduce max steering angle for stability */
    speedEffect = 1.0f / (1.0f + speedFactor * speed);

    /* Calculate target steer angle from input */
    /* steerInput is normalized -1.0 to 1.0 */
    targetAngle = (steerInput / steerRatio) * maxSteer * speedEffect;

    /* Clamp to max steering angle */
    if (targetAngle > maxSteer) {
        targetAngle = maxSteer;
    } else if (targetAngle < -maxSteer) {
        targetAngle = -maxSteer;
    }

    /* Apply steering with some lag for realism */
    currentAngle = *steerAngle;
    steerRate = 3.0f;  /* Steering response rate */

    if (targetAngle > currentAngle) {
        currentAngle += steerRate * 0.016f;  /* Assume ~60fps */
        if (currentAngle > targetAngle) {
            currentAngle = targetAngle;
        }
    } else if (targetAngle < currentAngle) {
        currentAngle -= steerRate * 0.016f;
        if (currentAngle < targetAngle) {
            currentAngle = targetAngle;
        }
    }

    *steerAngle = currentAngle;

    /* Update front tire steering for tire force calculations */
    func_800A79E0(car, currentAngle);  /* Update tire orientations */
}

/*

 * func_800A7AE4 (440 bytes)
 * Throttle/brake input processing
 *
 * Based on arcade drivetrain() and controls() functions.
 * Processes throttle and brake pedal inputs.
 * Updates engine torque output and brake force.
 *
 * Car structure offsets:
 *   0x100: throttle value (stored)
 *   0x104: brake value (stored)
 *   0x108: current gear
 *   0x10C: RPM
 *   0x110: torque output
 *   0x148: max torque
 *   0x14C: max brake force
 *   0x150: idle RPM
 *   0x154: redline RPM
 *   0x158: gear ratios [6]
 */
void func_800A7AE4(void *car, f32 throttle, f32 brake) {
    f32 *storedThrottle, *storedBrake;
    f32 *torqueOut;
    f32 *rpm;
    f32 maxTorque, maxBrake;
    f32 idleRpm, redlineRpm;
    f32 *gearRatios;
    s32 gear;
    f32 rpmNorm, torqueCurve;
    f32 engineTorque, brakeTorque;

    if (car == NULL) {
        return;
    }

    storedThrottle = (f32 *)((u8 *)car + 0x100);
    storedBrake = (f32 *)((u8 *)car + 0x104);
    gear = *(s32 *)((u8 *)car + 0x108);
    rpm = (f32 *)((u8 *)car + 0x10C);
    torqueOut = (f32 *)((u8 *)car + 0x110);
    maxTorque = *(f32 *)((u8 *)car + 0x148);
    maxBrake = *(f32 *)((u8 *)car + 0x14C);
    idleRpm = *(f32 *)((u8 *)car + 0x150);
    redlineRpm = *(f32 *)((u8 *)car + 0x154);
    gearRatios = (f32 *)((u8 *)car + 0x158);

    /* Default values if not set */
    if (maxTorque == 0.0f) maxTorque = 300.0f;
    if (maxBrake == 0.0f) maxBrake = 5000.0f;
    if (idleRpm == 0.0f) idleRpm = 800.0f;
    if (redlineRpm == 0.0f) redlineRpm = 8000.0f;

    /* Clamp inputs to valid range */
    if (throttle < 0.0f) throttle = 0.0f;
    if (throttle > 1.0f) throttle = 1.0f;
    if (brake < 0.0f) brake = 0.0f;
    if (brake > 1.0f) brake = 1.0f;

    /* Store processed inputs */
    *storedThrottle = throttle;
    *storedBrake = brake;

    /* Calculate normalized RPM position in powerband */
    rpmNorm = (*rpm - idleRpm) / (redlineRpm - idleRpm);
    if (rpmNorm < 0.0f) rpmNorm = 0.0f;
    if (rpmNorm > 1.0f) rpmNorm = 1.0f;

    /* Simple torque curve: peaks around 0.6-0.7 of rev range */
    /* Based on arcade rushtorquecurve pattern */
    if (rpmNorm < 0.3f) {
        torqueCurve = 0.6f + rpmNorm * 1.33f;  /* Ramp up */
    } else if (rpmNorm < 0.7f) {
        torqueCurve = 1.0f;  /* Peak torque band */
    } else {
        torqueCurve = 1.0f - (rpmNorm - 0.7f) * 2.0f;  /* Fall off */
        if (torqueCurve < 0.3f) torqueCurve = 0.3f;
    }

    /* Engine torque = throttle * torque_curve * max_torque */
    engineTorque = throttle * torqueCurve * maxTorque;

    /* Apply gear ratio if valid gear */
    if (gear >= 1 && gear <= 6) {
        f32 ratio = gearRatios[gear - 1];
        if (ratio != 0.0f) {
            engineTorque *= ratio;
        }
    }

    /* Calculate brake torque (negative to oppose motion) */
    brakeTorque = -brake * maxBrake;

    /* Output combined torque */
    /* If braking hard, engine torque is overridden */
    if (brake > 0.5f) {
        *torqueOut = brakeTorque;
    } else {
        *torqueOut = engineTorque + brakeTorque;
    }

    /* Apply torque to drive wheels via drivetrain */
    func_800A7B90(car, *torqueOut);  /* Distribute to drive wheels */
}

/*

 * func_800A7C9C (236 bytes)
 * Car gear shift
 *
 * Based on arcade transmission code.
 * Handles manual and automatic gear changes.
 * Updates gear, recalculates drive ratio, and adjusts RPM.
 *
 * Car structure offsets:
 *   0x108: current gear
 *   0x10C: RPM
 *   0x170: auto transmission flag
 *   0x174: shift timer
 *   0x158: gear ratios [6]
 */
void func_800A7C9C(void *car, s32 newGear) {
    s32 *currentGear;
    f32 *rpm;
    f32 *gearRatios;
    s32 autoTrans;
    f32 *shiftTimer;
    f32 oldRatio, newRatio;
    f32 currentRpm;

    if (car == NULL) {
        return;
    }

    currentGear = (s32 *)((u8 *)car + 0x108);
    rpm = (f32 *)((u8 *)car + 0x10C);
    gearRatios = (f32 *)((u8 *)car + 0x158);
    autoTrans = *(s32 *)((u8 *)car + 0x170);
    shiftTimer = (f32 *)((u8 *)car + 0x174);

    /* Clamp gear to valid range: -1 (reverse), 0 (neutral), 1-6 */
    if (newGear < -1) newGear = -1;
    if (newGear > 6) newGear = 6;

    /* Check if shift is allowed (not in middle of shift) */
    if (*shiftTimer > 0.0f) {
        return;  /* Still shifting */
    }

    /* Don't shift if already in this gear */
    if (newGear == *currentGear) {
        return;
    }

    /* Get current and new gear ratios */
    if (*currentGear >= 1 && *currentGear <= 6) {
        oldRatio = gearRatios[*currentGear - 1];
    } else if (*currentGear == -1) {
        oldRatio = -3.0f;  /* Reverse ratio */
    } else {
        oldRatio = 0.0f;  /* Neutral */
    }

    if (newGear >= 1 && newGear <= 6) {
        newRatio = gearRatios[newGear - 1];
    } else if (newGear == -1) {
        newRatio = -3.0f;  /* Reverse ratio */
    } else {
        newRatio = 0.0f;  /* Neutral */
    }

    /* Update gear */
    *currentGear = newGear;

    /* Adjust RPM for new gear ratio */
    currentRpm = *rpm;
    if (oldRatio != 0.0f && newRatio != 0.0f) {
        *rpm = currentRpm * (newRatio / oldRatio);
    }

    /* Start shift timer (prevents rapid shifting) */
    *shiftTimer = 0.2f;  /* 200ms shift delay */

    /* Clamp RPM to valid range */
    if (*rpm < 800.0f) *rpm = 800.0f;
    if (*rpm > 9000.0f) *rpm = 9000.0f;
}

/*

 * func_800A7D88 (104 bytes)
 * Get current gear
 */
s32 func_800A7D88(void *car) {
    return *(s32 *)((u8 *)car + 0x48);
}

/*

 * func_800A7E00 (1200 bytes - estimated)
 * Tire force calculation (friction circle model)
 *
 * Based on arcade tires.c frictioncircle() function.
 * Calculates lateral and longitudinal tire forces using
 * Pacejka-style tire model with friction circle limit.
 *
 * Tire structure offsets:
 *   0x00: rotation angle
 *   0x04: angular velocity
 *   0x08: radius
 *   0x0C: slip angle
 *   0x10: slip ratio
 *   0x14: contact patch velocity [3]
 *   0x20: normal force
 *   0x24: lateral force (output)
 *   0x28: longitudinal force (output)
 *   0x2C: cornering stiffness
 *   0x30: max friction coefficient
 *   0x34: drive torque input
 */
void func_800A7E00(void *tire, f32 normalForce, f32 driveTorque) {
    f32 *angVel, radius;
    f32 *slipAngle, *slipRatio;
    f32 *patchVel;
    f32 *latForce, *lonForce;
    f32 cStiff, cfMax;
    f32 maxTraction, maxLateral;
    f32 lateralForce, tractionForce;
    f32 totalForce, forceMag;
    f32 roadAngVel, slipSpeed;

    if (tire == NULL) {
        return;
    }

    angVel = (f32 *)((u8 *)tire + 0x04);
    radius = *(f32 *)((u8 *)tire + 0x08);
    slipAngle = (f32 *)((u8 *)tire + 0x0C);
    slipRatio = (f32 *)((u8 *)tire + 0x10);
    patchVel = (f32 *)((u8 *)tire + 0x14);
    latForce = (f32 *)((u8 *)tire + 0x24);
    lonForce = (f32 *)((u8 *)tire + 0x28);
    cStiff = *(f32 *)((u8 *)tire + 0x2C);
    cfMax = *(f32 *)((u8 *)tire + 0x30);

    /* Default tire parameters if not set */
    if (radius == 0.0f) radius = 1.0f;
    if (cStiff == 0.0f) cStiff = 16000.0f;  /* Cornering stiffness lb/rad */
    if (cfMax == 0.0f) cfMax = 1.15f;       /* Max friction coefficient */

    /* No forces if no normal load */
    if (normalForce <= 0.0f) {
        *latForce = 0.0f;
        *lonForce = 0.0f;
        return;
    }

    /* Maximum available friction force */
    maxTraction = cfMax * normalForce;

    /* Calculate road angular velocity (wheel would have if not slipping) */
    roadAngVel = patchVel[0] / radius;

    /* Longitudinal force from drive torque */
    /* Check for wheel spin or lockup */
    if (*angVel > roadAngVel) {
        /* Wheel spinning faster than road - accelerating/wheelspin */
        tractionForce = driveTorque / radius;

        /* Limit by friction circle */
        if (tractionForce > maxTraction) {
            tractionForce = maxTraction;
            /* Wheel continues to spin */
        }

        /* Update wheel angular velocity based on torque and resistance */
        *angVel += (driveTorque - tractionForce * radius) * 0.001f * 0.016f;

    } else if (*angVel < roadAngVel) {
        /* Wheel slower than road - braking/lockup */
        tractionForce = driveTorque / radius;

        if (tractionForce < -maxTraction) {
            tractionForce = -maxTraction;
        }

        *angVel += (driveTorque - tractionForce * radius) * 0.001f * 0.016f;

    } else {
        /* Wheel matched to road - pure rolling */
        tractionForce = driveTorque / radius;
        *angVel = roadAngVel;
    }

    /* Lateral force from cornering */
    /* Using linear tire model up to saturation */
    lateralForce = -cStiff * (*slipAngle);

    /* Calculate total slip speed for friction circle */
    slipSpeed = sqrtf((*slipRatio) * (*slipRatio) + (*slipAngle) * (*slipAngle));

    /* Apply friction circle limit */
    /* Total force magnitude cannot exceed maxTraction */
    forceMag = sqrtf(lateralForce * lateralForce + tractionForce * tractionForce);

    if (forceMag > maxTraction) {
        /* Scale both forces proportionally */
        f32 scale = maxTraction / forceMag;
        lateralForce *= scale;
        tractionForce *= scale;
    }

    /* Output forces */
    *latForce = lateralForce;
    *lonForce = tractionForce;
}

/*

 * func_800A80D0 (3276 bytes)
 * Car AI behavior - main AI update function
 */
void func_800A80D0(void *car, void *target) {
    f32 *carPos;
    f32 *carVel;
    f32 *carDir;
    f32 *targetPos;
    f32 dx, dz;
    f32 distance;
    f32 targetAngle;
    f32 currentAngle;
    f32 angleDiff;
    f32 steerInput;
    f32 throttleInput;
    f32 brakeInput;
    s32 *aiState;
    s32 difficulty;

    if (car == NULL) return;

    carPos = (f32 *)((u8 *)car + 0x24);
    carVel = (f32 *)((u8 *)car + 0x34);
    carDir = (f32 *)((u8 *)car + 0x60);
    aiState = (s32 *)((u8 *)car + 0x240);
    difficulty = D_80159A1C;  /* 0=easy, 1=medium, 2=hard */

    /* Get target position (next waypoint or player) */
    if (target != NULL) {
        targetPos = (f32 *)((u8 *)target + 0x24);
    } else {
        /* Use next waypoint from path */
        s32 waypointIdx = aiState[0];
        func_800A2378(D_80159A08, waypointIdx, &dx, NULL, &dz);
        targetPos = (f32 *)aiState + 4;
        targetPos[0] = dx;
        targetPos[2] = dz;
    }

    /* Calculate direction to target */
    dx = targetPos[0] - carPos[0];
    dz = targetPos[2] - carPos[2];
    distance = sqrtf(dx * dx + dz * dz);

    if (distance < 1.0f) {
        /* Reached waypoint, advance to next */
        aiState[0] = (aiState[0] + 1) % 100;
        return;
    }

    /* Calculate target angle */
    targetAngle = atan2f(dx, dz);

    /* Get current heading angle */
    currentAngle = atan2f(carDir[0], carDir[2]);

    /* Calculate angle difference (-PI to PI) */
    angleDiff = targetAngle - currentAngle;
    while (angleDiff > 3.14159f) angleDiff -= 6.28318f;
    while (angleDiff < -3.14159f) angleDiff += 6.28318f;

    /* Steering input based on angle difference */
    steerInput = angleDiff * 2.0f;
    if (steerInput > 1.0f) steerInput = 1.0f;
    if (steerInput < -1.0f) steerInput = -1.0f;

    /* Calculate speed */
    f32 speed = sqrtf(carVel[0] * carVel[0] + carVel[2] * carVel[2]);

    /* Speed control based on difficulty */
    f32 maxSpeed;
    switch (difficulty) {
        case 0: maxSpeed = 60.0f; break;
        case 1: maxSpeed = 80.0f; break;
        case 2: maxSpeed = 100.0f; break;
        default: maxSpeed = 70.0f; break;
    }

    /* Slow down for turns */
    f32 turnFactor = 1.0f - (fabsf(angleDiff) / 3.14159f) * 0.5f;
    maxSpeed *= turnFactor;

    /* Throttle and brake control */
    if (speed < maxSpeed * 0.9f) {
        throttleInput = 1.0f;
        brakeInput = 0.0f;
    } else if (speed > maxSpeed * 1.1f) {
        throttleInput = 0.0f;
        brakeInput = 0.5f;
    } else {
        throttleInput = 0.5f;
        brakeInput = 0.0f;
    }

    /* Check for obstacles */
    func_800A8F64(car, NULL);

    /* Apply inputs */
    func_800A78FC(car, steerInput);
    func_800A7AE4(car, throttleInput, brakeInput);

    /* Store AI state for debugging */
    aiState[1] = (s32)(steerInput * 100);
    aiState[2] = (s32)(throttleInput * 100);
    aiState[3] = (s32)(brakeInput * 100);
}

/*

 * func_800A8D9C (484 bytes)
 * AI path following - follow racing path
 */
void func_800A8D9C(void *car, void *path) {
    f32 *carPos;
    s32 *aiState;
    s32 currentWaypoint;
    s32 nextWaypoint;
    f32 waypointPos[3];
    f32 nextPos[3];
    f32 dx, dz;
    f32 distance;
    f32 lookahead;

    if (car == NULL || path == NULL) return;

    carPos = (f32 *)((u8 *)car + 0x24);
    aiState = (s32 *)((u8 *)car + 0x240);
    currentWaypoint = aiState[0];

    /* Get current waypoint position */
    func_800A2378(D_80159A08, currentWaypoint, &waypointPos[0], &waypointPos[1], &waypointPos[2]);

    /* Check distance to current waypoint */
    dx = waypointPos[0] - carPos[0];
    dz = waypointPos[2] - carPos[2];
    distance = sqrtf(dx * dx + dz * dz);

    /* Waypoint reached? */
    if (distance < 20.0f) {
        /* Advance to next waypoint */
        aiState[0] = (currentWaypoint + 1) % 100;
    }

    /* Lookahead - get position slightly ahead on path */
    lookahead = 30.0f;  /* Look 30 units ahead */
    nextWaypoint = (currentWaypoint + 1) % 100;
    func_800A2378(D_80159A08, nextWaypoint, &nextPos[0], &nextPos[1], &nextPos[2]);

    /* Interpolate between current and next waypoint */
    f32 t = distance / (distance + lookahead);
    aiState[4] = (s32)(waypointPos[0] * (1.0f - t) + nextPos[0] * t);  /* Target X */
    aiState[6] = (s32)(waypointPos[2] * (1.0f - t) + nextPos[2] * t);  /* Target Z */
}

/*

 * func_800A8F64 (1068 bytes)
 * AI obstacle avoidance - avoid collisions with other cars
 */
void func_800A8F64(void *car, void *obstacles) {
    f32 *carPos;
    f32 *carDir;
    f32 *carVel;
    s32 i;
    s32 numCars;
    f32 avoidX, avoidZ;
    f32 avoidStrength;

    if (car == NULL) return;

    carPos = (f32 *)((u8 *)car + 0x24);
    carDir = (f32 *)((u8 *)car + 0x60);
    carVel = (f32 *)((u8 *)car + 0x34);

    avoidX = 0.0f;
    avoidZ = 0.0f;
    avoidStrength = 0.0f;

    /* Get number of active cars */
    numCars = D_801582E0;

    /* Check each other car */
    for (i = 0; i < numCars; i++) {
        void *otherCar = D_801582C0[i];
        if (otherCar == NULL || otherCar == car) continue;

        f32 *otherPos = (f32 *)((u8 *)otherCar + 0x24);

        /* Calculate distance */
        f32 dx = otherPos[0] - carPos[0];
        f32 dz = otherPos[2] - carPos[2];
        f32 dist = sqrtf(dx * dx + dz * dz);

        /* Check if in danger zone */
        if (dist < 30.0f && dist > 1.0f) {
            /* Check if ahead of us */
            f32 dotFwd = dx * carDir[0] + dz * carDir[2];
            if (dotFwd > 0.0f) {
                /* Other car is ahead */
                f32 weight = (30.0f - dist) / 30.0f;

                /* Push away from obstacle */
                f32 nx = -dx / dist;
                f32 nz = -dz / dist;

                /* Perpendicular direction for avoidance */
                f32 perpX = -carDir[2];
                f32 perpZ = carDir[0];

                /* Determine which side to avoid to */
                f32 side = nx * perpX + nz * perpZ;
                if (side > 0) {
                    avoidX += perpX * weight;
                    avoidZ += perpZ * weight;
                } else {
                    avoidX -= perpX * weight;
                    avoidZ -= perpZ * weight;
                }

                avoidStrength += weight;
            }
        }
    }

    /* Store avoidance vector in AI state */
    if (avoidStrength > 0.0f) {
        s32 *aiState = (s32 *)((u8 *)car + 0x240);
        aiState[8] = (s32)(avoidX * 100);
        aiState[9] = (s32)(avoidZ * 100);
        aiState[10] = (s32)(avoidStrength * 100);
    }
}

/*

 * func_800A9390 (1592 bytes)
 * AI racing line optimization - find optimal path through corners
 */
void func_800A9390(void *car, void *track) {
    f32 *carPos;
    s32 *aiState;
    s32 waypointIdx;
    f32 cornerAngle;
    f32 entrySpeed;
    f32 apexOffset;
    f32 trackWidth;
    s32 i;

    if (car == NULL) return;

    carPos = (f32 *)((u8 *)car + 0x24);
    aiState = (s32 *)((u8 *)car + 0x240);
    waypointIdx = aiState[0];
    trackWidth = 20.0f;  /* Default track width */

    /* Look ahead several waypoints to detect corner */
    cornerAngle = 0.0f;
    for (i = 0; i < 5; i++) {
        s32 idx1 = (waypointIdx + i) % 100;
        s32 idx2 = (waypointIdx + i + 1) % 100;
        s32 idx3 = (waypointIdx + i + 2) % 100;

        f32 p1[3], p2[3], p3[3];
        func_800A2378(D_80159A08, idx1, &p1[0], &p1[1], &p1[2]);
        func_800A2378(D_80159A08, idx2, &p2[0], &p2[1], &p2[2]);
        func_800A2378(D_80159A08, idx3, &p3[0], &p3[1], &p3[2]);

        /* Calculate angle between segments */
        f32 dx1 = p2[0] - p1[0];
        f32 dz1 = p2[2] - p1[2];
        f32 dx2 = p3[0] - p2[0];
        f32 dz2 = p3[2] - p2[2];

        f32 cross = dx1 * dz2 - dz1 * dx2;
        f32 dot = dx1 * dx2 + dz1 * dz2;
        f32 angle = atan2f(cross, dot);

        if (fabsf(angle) > fabsf(cornerAngle)) {
            cornerAngle = angle;
        }
    }

    /* Calculate racing line offset based on corner angle */
    if (fabsf(cornerAngle) > 0.2f) {
        /* Significant corner - adjust racing line */
        if (cornerAngle > 0) {
            /* Right turn - position on left (outside) */
            apexOffset = trackWidth * 0.4f;
        } else {
            /* Left turn - position on right (outside) */
            apexOffset = -trackWidth * 0.4f;
        }

        /* Speed adjustment for corner */
        entrySpeed = 1.0f - fabsf(cornerAngle) * 0.3f;
        if (entrySpeed < 0.5f) entrySpeed = 0.5f;
    } else {
        /* Straight - stay centered, full speed */
        apexOffset = 0.0f;
        entrySpeed = 1.0f;
    }

    /* Store racing line data */
    aiState[12] = (s32)(cornerAngle * 100);
    aiState[13] = (s32)(apexOffset * 10);
    aiState[14] = (s32)(entrySpeed * 100);
}

/*

 * func_800A99C8 (2700 bytes)
 * AI decision making - high-level race decisions
 */
void func_800A99C8(void *car) {
    s32 *aiState;
    s32 position;
    s32 lap;
    s32 totalLaps;
    f32 raceProgress;
    s32 aiMode;
    s32 difficulty;

    if (car == NULL) return;

    aiState = (s32 *)((u8 *)car + 0x240);
    position = *(s32 *)((u8 *)car + 0x5C);
    lap = *(s32 *)((u8 *)car + 0x58);
    totalLaps = D_8015A298;
    difficulty = D_80159A1C;

    raceProgress = (f32)lap / (f32)totalLaps;

    /* Determine AI mode based on race situation */
    if (position == 1) {
        /* Leading - defensive mode */
        aiMode = 0;  /* Defend position */
    } else if (position <= 3) {
        /* Near front - balanced mode */
        aiMode = 1;  /* Normal racing */
    } else {
        /* Behind - aggressive mode */
        aiMode = 2;  /* Catch up */
    }

    /* Rubber banding based on difficulty */
    if (difficulty < 2) {
        /* Easy/medium - help player */
        if (position == 1 && raceProgress > 0.8f) {
            /* Leading near end - slow down slightly */
            aiState[16] = 90;  /* 90% speed */
        } else {
            aiState[16] = 100;
        }
    } else {
        /* Hard - no rubber banding */
        aiState[16] = 100 + (3 - position) * 2;  /* Faster when behind */
    }

    /* Store AI mode */
    aiState[15] = aiMode;

    /* Decision: use shortcut? */
    if (aiMode == 2 && raceProgress < 0.9f) {
        /* Behind and not near finish - maybe use shortcut */
        s32 shortcutChance = difficulty * 30 + 10;  /* 10-70% based on difficulty */
        if ((D_80142AFC % 100) < shortcutChance) {
            aiState[17] = 1;  /* Enable shortcut seeking */
        }
    } else {
        aiState[17] = 0;
    }

    /* Decision: attack/defend? */
    if (aiMode == 0) {
        /* Defend - block overtaking attempts */
        aiState[18] = 1;
    } else if (aiMode == 2) {
        /* Aggressive - attempt overtakes */
        aiState[18] = 2;
    } else {
        aiState[18] = 0;  /* Normal */
    }
}

/*

 * func_800AA454 (692 bytes)
 * AI speed control - control throttle/brake to reach target speed
 */
void func_800AA454(void *car, f32 targetSpeed) {
    f32 *carVel;
    f32 currentSpeed;
    f32 speedError;
    f32 throttle, brake;
    s32 *aiState;
    f32 speedMultiplier;

    if (car == NULL) return;

    carVel = (f32 *)((u8 *)car + 0x34);
    aiState = (s32 *)((u8 *)car + 0x240);

    /* Get speed multiplier from decision system */
    speedMultiplier = (f32)aiState[16] / 100.0f;
    targetSpeed *= speedMultiplier;

    /* Calculate current speed */
    currentSpeed = sqrtf(carVel[0] * carVel[0] + carVel[2] * carVel[2]);

    /* Speed error */
    speedError = targetSpeed - currentSpeed;

    /* P controller for throttle/brake */
    if (speedError > 5.0f) {
        throttle = 1.0f;
        brake = 0.0f;
    } else if (speedError > 0.0f) {
        throttle = 0.5f + speedError * 0.1f;
        brake = 0.0f;
    } else if (speedError > -5.0f) {
        throttle = 0.2f;
        brake = 0.0f;
    } else if (speedError > -15.0f) {
        throttle = 0.0f;
        brake = (-speedError - 5.0f) * 0.05f;
    } else {
        throttle = 0.0f;
        brake = 0.5f;
    }

    /* Clamp values */
    if (throttle > 1.0f) throttle = 1.0f;
    if (brake > 1.0f) brake = 1.0f;

    /* Apply */
    func_800A7AE4(car, throttle, brake);
}

/*

 * func_800AA708 (1084 bytes)
 * AI overtaking behavior - attempt to pass opponent
 */
void func_800AA708(void *car, void *opponent) {
    f32 *carPos, *carVel, *carDir;
    f32 *oppPos, *oppVel;
    f32 dx, dz, dist;
    f32 relSpeed;
    f32 approach;
    s32 *aiState;
    s32 overtakeState;
    f32 steerAdjust;

    if (car == NULL || opponent == NULL) return;

    carPos = (f32 *)((u8 *)car + 0x24);
    carVel = (f32 *)((u8 *)car + 0x34);
    carDir = (f32 *)((u8 *)car + 0x60);
    oppPos = (f32 *)((u8 *)opponent + 0x24);
    oppVel = (f32 *)((u8 *)opponent + 0x34);
    aiState = (s32 *)((u8 *)car + 0x240);

    /* Calculate relative position */
    dx = oppPos[0] - carPos[0];
    dz = oppPos[2] - carPos[2];
    dist = sqrtf(dx * dx + dz * dz);

    /* Calculate relative speed (positive = catching up) */
    f32 ourSpeed = sqrtf(carVel[0] * carVel[0] + carVel[2] * carVel[2]);
    f32 theirSpeed = sqrtf(oppVel[0] * oppVel[0] + oppVel[2] * oppVel[2]);
    relSpeed = ourSpeed - theirSpeed;

    /* Check if opponent is ahead */
    approach = dx * carDir[0] + dz * carDir[2];

    overtakeState = aiState[19];

    if (approach > 0 && dist < 50.0f) {
        /* Opponent ahead and close */
        if (overtakeState == 0 && relSpeed > 5.0f) {
            /* Start overtake - decide which side */
            f32 side = -dx * carDir[2] + dz * carDir[0];
            if (side > 0) {
                overtakeState = 1;  /* Pass on left */
            } else {
                overtakeState = 2;  /* Pass on right */
            }
        }

        if (overtakeState == 1) {
            /* Passing on left */
            steerAdjust = -0.3f;
        } else if (overtakeState == 2) {
            /* Passing on right */
            steerAdjust = 0.3f;
        } else {
            steerAdjust = 0.0f;
        }

        /* Apply steering adjustment */
        aiState[20] = (s32)(steerAdjust * 100);

    } else if (approach < -10.0f || dist > 60.0f) {
        /* Passed opponent or lost them */
        overtakeState = 0;
        aiState[20] = 0;
    }

    aiState[19] = overtakeState;
}

/*

 * func_800AAB44 (808 bytes)
 * AI defensive driving
 */
void func_800AAB44(void *car) {
    /* Defensive AI - stub */
}

/*

 * func_800AAE68 (1756 bytes)
 * AI recovery from crash
 */
void func_800AAE68(void *car) {
    /* Crash recovery - stub */
}

/*

 * func_800AB544 (564 bytes)
 * Player input reading
 *
 * Reads N64 controller input and maps to player car controls.
 *
 * N64 Controller structure (from osContPad):
 *   0x00: buttons (u16) - A, B, Z, Start, D-pad, C buttons, L, R
 *   0x02: stick_x (s8) - Analog stick X (-128 to 127)
 *   0x03: stick_y (s8) - Analog stick Y (-128 to 127)
 *   0x04: errno (u8) - Error code
 *
 * Button masks:
 *   A = 0x8000, B = 0x4000, Z = 0x2000, Start = 0x1000
 *   D-Up = 0x0800, D-Down = 0x0400, D-Left = 0x0200, D-Right = 0x0100
 *   L = 0x0020, R = 0x0010
 *   C-Up = 0x0008, C-Down = 0x0004, C-Left = 0x0002, C-Right = 0x0001
 *
 * Player input offsets:
 *   0xE0: steering input (f32) -1.0 to 1.0
 *   0xE4: throttle input (f32) 0.0 to 1.0
 *   0xE8: brake input (f32) 0.0 to 1.0
 *   0xEC: handbrake (s32) 0 or 1
 *   0xF0: shift up pressed (s32)
 *   0xF4: shift down pressed (s32)
 *   0xF8: view change pressed (s32)
 *   0xFC: wing deploy (s32)
 *   0x100: pause pressed (s32)
 */
void func_800AB544(void *player, void *controller) {
    u16 buttons;
    s8 stickX, stickY;
    f32 *steering, *throttle, *brake;
    s32 *handbrake, *shiftUp, *shiftDown;
    s32 *viewChange, *wingDeploy, *pausePressed;
    f32 stickMag;

    if (player == NULL || controller == NULL) {
        return;
    }

    /* Read controller state */
    buttons = *(u16 *)controller;
    stickX = *(s8 *)((u8 *)controller + 2);
    stickY = *(s8 *)((u8 *)controller + 3);

    /* Get player input pointers */
    steering = (f32 *)((u8 *)player + 0xE0);
    throttle = (f32 *)((u8 *)player + 0xE4);
    brake = (f32 *)((u8 *)player + 0xE8);
    handbrake = (s32 *)((u8 *)player + 0xEC);
    shiftUp = (s32 *)((u8 *)player + 0xF0);
    shiftDown = (s32 *)((u8 *)player + 0xF4);
    viewChange = (s32 *)((u8 *)player + 0xF8);
    wingDeploy = (s32 *)((u8 *)player + 0xFC);
    pausePressed = (s32 *)((u8 *)player + 0x100);

    /* Convert analog stick to steering (-1.0 to 1.0) */
    /* Apply deadzone of ~10 */
    if (stickX > 10) {
        *steering = (f32)(stickX - 10) / 117.0f;
    } else if (stickX < -10) {
        *steering = (f32)(stickX + 10) / 117.0f;
    } else {
        *steering = 0.0f;
    }

    /* Clamp steering */
    if (*steering > 1.0f) *steering = 1.0f;
    if (*steering < -1.0f) *steering = -1.0f;

    /* A button = throttle, B button = brake */
    if (buttons & 0x8000) {  /* A */
        *throttle = 1.0f;
    } else if (stickY > 10) {
        /* Forward on stick = partial throttle */
        *throttle = (f32)(stickY - 10) / 117.0f;
    } else {
        *throttle = 0.0f;
    }

    if (buttons & 0x4000) {  /* B */
        *brake = 1.0f;
    } else if (stickY < -10) {
        /* Back on stick = partial brake */
        *brake = (f32)(-stickY - 10) / 117.0f;
    } else {
        *brake = 0.0f;
    }

    /* Z trigger = handbrake */
    *handbrake = (buttons & 0x2000) ? 1 : 0;

    /* R = shift up, L = shift down */
    *shiftUp = (buttons & 0x0010) ? 1 : 0;
    *shiftDown = (buttons & 0x0020) ? 1 : 0;

    /* C buttons for view/wings */
    *viewChange = (buttons & 0x0008) ? 1 : 0;  /* C-Up */
    *wingDeploy = (buttons & 0x0004) ? 1 : 0;  /* C-Down */

    /* Start = pause */
    *pausePressed = (buttons & 0x1000) ? 1 : 0;
}

/*

 * func_800AB7D8 (1016 bytes)
 * Player state update
 *
 * Updates player state based on current inputs.
 * Handles state transitions (racing, crashed, respawning, etc.)
 *
 * Player state values:
 *   0 = Racing normally
 *   1 = Crashed/wrecked
 *   2 = Respawning
 *   3 = Finished race
 *   4 = In menu/paused
 *
 * Player offsets:
 *   0x104: current state (s32)
 *   0x108: state timer (s32)
 *   0x10C: respawn countdown (s32)
 *   0x110: invincibility timer (s32)
 */
void func_800AB7D8(void *player) {
    s32 *state, *stateTimer, *respawnCountdown, *invincibility;
    s32 *pausePressed, *finished;
    s32 currentState;

    if (player == NULL) {
        return;
    }

    /* Get player state data */
    state = (s32 *)((u8 *)player + 0x104);
    stateTimer = (s32 *)((u8 *)player + 0x108);
    respawnCountdown = (s32 *)((u8 *)player + 0x10C);
    invincibility = (s32 *)((u8 *)player + 0x110);
    pausePressed = (s32 *)((u8 *)player + 0x100);
    finished = (s32 *)((u8 *)player + 0xD4);

    currentState = *state;

    /* Decrement timers */
    if (*stateTimer > 0) {
        (*stateTimer)--;
    }
    if (*invincibility > 0) {
        (*invincibility)--;
    }

    /* State machine */
    switch (currentState) {
        case 0:  /* Racing */
            /* Check for crash condition */
            /* (Crash detection happens in physics/collision) */

            /* Check for pause */
            if (*pausePressed != 0) {
                *state = 4;
                *stateTimer = 0;
            }

            /* Check for finish */
            if (*finished != 0) {
                *state = 3;
                *stateTimer = 180;  /* 3 seconds at 60fps */
            }
            break;

        case 1:  /* Crashed */
            /* Wait for crash animation to complete */
            if (*stateTimer == 0) {
                *state = 2;  /* Begin respawn */
                *respawnCountdown = 120;  /* 2 second respawn delay */
            }
            break;

        case 2:  /* Respawning */
            (*respawnCountdown)--;
            if (*respawnCountdown <= 0) {
                /* Respawn complete */
                *state = 0;  /* Back to racing */
                *invincibility = 120;  /* 2 seconds invincibility */
            }
            break;

        case 3:  /* Finished */
            /* Wait for celebration/results */
            if (*stateTimer == 0) {
                /* Stay in finished state until race ends */
            }
            break;

        case 4:  /* Paused */
            /* Wait for unpause */
            if (*pausePressed != 0 && *stateTimer == 0) {
                *state = 0;
                *stateTimer = 10;  /* Debounce */
            }
            break;
    }
}

/*

 * func_800ABBD0 (248 bytes)
 * Player respawn position
 *
 * Calculates respawn position based on last checkpoint.
 * Places car on track near last valid position.
 */
extern void *D_80158FD0[16];    /* Checkpoint data array */

void func_800ABBD0(void *player, f32 *respawnPos) {
    s32 lastCheckpoint;
    void *checkpoint;
    f32 *cpPos, *cpNormal;

    if (player == NULL || respawnPos == NULL) {
        return;
    }

    /* Get last checkpoint index */
    lastCheckpoint = *(s32 *)((u8 *)player + 0x54);
    if (lastCheckpoint > 0) {
        lastCheckpoint--;  /* Go back one checkpoint */
    }

    /* Get checkpoint data */
    checkpoint = D_80158FD0[lastCheckpoint];
    if (checkpoint == NULL) {
        /* Default to origin if no checkpoint data */
        respawnPos[0] = 0.0f;
        respawnPos[1] = 10.0f;  /* Slightly above ground */
        respawnPos[2] = 0.0f;
        return;
    }

    cpPos = (f32 *)checkpoint;
    cpNormal = (f32 *)((u8 *)checkpoint + 0x10);

    /* Place slightly behind checkpoint */
    respawnPos[0] = cpPos[0] - cpNormal[0] * 20.0f;
    respawnPos[1] = cpPos[1] + 5.0f;  /* Above ground */
    respawnPos[2] = cpPos[2] - cpNormal[2] * 20.0f;
}

/*

 * func_800ABCC8 (2708 bytes)
 * Player full update
 *
 * Main per-frame update for player car.
 * Orchestrates input, physics, collision, and state.
 */
void func_800ABCC8(void *player, f32 dt) {
    s32 state;
    f32 steering, throttle, brake;
    s32 wingDeploy;
    f32 respawnPos[3];

    if (player == NULL) {
        return;
    }

    /* Get current state */
    state = *(s32 *)((u8 *)player + 0x104);

    /* Read controller input */
    func_800AB544(player, D_80159000);

    /* Update state machine */
    func_800AB7D8(player);

    /* Process based on state */
    switch (state) {
        case 0:  /* Racing */
            /* Get input values */
            steering = *(f32 *)((u8 *)player + 0xE0);
            throttle = *(f32 *)((u8 *)player + 0xE4);
            brake = *(f32 *)((u8 *)player + 0xE8);
            wingDeploy = *(s32 *)((u8 *)player + 0xFC);

            /* Apply steering */
            func_800A78C8(player, steering);

            /* Apply throttle/brake */
            func_800A7AE4(player, throttle, brake);

            /* Handle wing deployment (Rush 2049 feature) */
            if (wingDeploy != 0) {
                func_80105480(player);  /* Deploy wings */
            }

            /* Update physics */
            func_800A6BE4(player, dt);

            /* Update audio (engine, tire sounds) */
            func_800B2DF8(player);
            func_800B338C(player);
            break;

        case 1:  /* Crashed */
            /* Minimal physics while crashed */
            func_800A6BE4(player, dt);
            break;

        case 2:  /* Respawning */
            /* Calculate respawn position */
            func_800ABBD0(player, respawnPos);

            /* Check if countdown finished */
            if (*(s32 *)((u8 *)player + 0x10C) <= 0) {
                /* Move to respawn position */
                f32 *pos = (f32 *)((u8 *)player + 0x24);
                pos[0] = respawnPos[0];
                pos[1] = respawnPos[1];
                pos[2] = respawnPos[2];

                /* Reset velocity */
                f32 *vel = (f32 *)((u8 *)player + 0x34);
                vel[0] = 0.0f;
                vel[1] = 0.0f;
                vel[2] = 0.0f;
            }
            break;

        case 3:  /* Finished */
            /* Slow deceleration after finish */
            throttle = 0.0f;
            brake = 0.1f;
            func_800A7AE4(player, throttle, brake);
            func_800A6BE4(player, dt);
            break;

        case 4:  /* Paused */
            /* No updates while paused */
            break;
    }
}

/*

 * func_800AC75C (1076 bytes)
 * Checkpoint collision
 *
 * Checks if a car has crossed a checkpoint trigger plane.
 * Based on arcade CheckCPs() in checkpoint.c:
 *   - Calculates distance from car to checkpoint center
 *   - Uses dot product with checkpoint normal to detect crossing
 *   - Awards time bonus on successful checkpoint pass
 *
 * Car offsets:
 *   0x24: position (f32[3])
 *   0x54: current checkpoint index (s32)
 *   0x58: lap count (s32)
 *   0x5C: race position (s32)
 *   0x60: race time (u32)
 *   0x64: checkpoint times array (u32[16])
 *
 * Checkpoint structure:
 *   0x00: position (f32[3])
 *   0x0C: radius squared (f32)
 *   0x10: normal/direction (f32[3])
 *   0x1C: checkpoint index (s32)
 *   0x20: bonus time (u32)
 *   0x24: is finish line (s32)
 */
extern s32 D_801582B4;          /* Total checkpoints */
extern s32 D_801582B8;          /* Finish line checkpoint index */
extern void func_800B4208(s32 voiceId); /* Play voice */

void func_800AC75C(void *car, void *checkpoint) {
    f32 *carPos, *cpPos, *cpNormal;
    f32 dx, dy, dz;
    f32 distSq, radiusSq;
    f32 dotProduct;
    s32 *carCpIndex, *carLaps, cpIndex;
    u32 *carTime, *cpTimes;
    s32 isFinishLine;
    u32 bonusTime;

    if (car == NULL || checkpoint == NULL) {
        return;
    }

    /* Get car data */
    carPos = (f32 *)((u8 *)car + 0x24);
    carCpIndex = (s32 *)((u8 *)car + 0x54);
    carLaps = (s32 *)((u8 *)car + 0x58);
    carTime = (u32 *)((u8 *)car + 0x60);
    cpTimes = (u32 *)((u8 *)car + 0x64);

    /* Get checkpoint data */
    cpPos = (f32 *)checkpoint;
    radiusSq = *(f32 *)((u8 *)checkpoint + 0x0C);
    cpNormal = (f32 *)((u8 *)checkpoint + 0x10);
    cpIndex = *(s32 *)((u8 *)checkpoint + 0x1C);
    bonusTime = *(u32 *)((u8 *)checkpoint + 0x20);
    isFinishLine = *(s32 *)((u8 *)checkpoint + 0x24);

    /* Only check if this is the next expected checkpoint */
    if (cpIndex != *carCpIndex) {
        return;
    }

    /* Calculate distance from car to checkpoint center */
    dx = carPos[0] - cpPos[0];
    dy = carPos[1] - cpPos[1];
    dz = carPos[2] - cpPos[2];

    distSq = dx * dx + dz * dz;  /* Horizontal distance only */

    /* Check if within checkpoint radius */
    if (distSq > radiusSq) {
        return;
    }

    /* Check if car crossed the checkpoint plane (dot product with normal) */
    dotProduct = dx * cpNormal[0] + dy * cpNormal[1] + dz * cpNormal[2];

    if (dotProduct <= 0.0f) {
        return;  /* Haven't crossed the plane yet */
    }

    /* Checkpoint passed! Record time */
    cpTimes[cpIndex] = D_801582B0;

    /* Award bonus time */
    if (bonusTime > 0) {
        *carTime += bonusTime;
    }

    /* Advance to next checkpoint */
    *carCpIndex = cpIndex + 1;

    /* Check for lap completion */
    if (*carCpIndex >= D_801582B4) {
        *carCpIndex = 0;  /* Wrap to first checkpoint */
    }

    /* Handle finish line crossing */
    if (isFinishLine != 0) {
        (*carLaps)++;

        /* Check for race finish (lap count check done in caller) */
        func_800ACA9C(car, *carLaps);

        /* Play lap-related voice */
        func_800B4208(6);  /* "Final lap" or similar */
    } else {
        /* Regular checkpoint voice */
        func_800B4208(8);  /* "Checkpoint!" */
    }
}

/*

 * func_800ACA9C (380 bytes)
 * Lap time recording
 *
 * Records lap completion time and updates best lap.
 * Based on arcade PassedCP() finish line handling.
 *
 * Player offsets:
 *   0xA4: lap times array (u32[8])
 *   0xC4: best lap time (u32)
 *   0xC8: last lap time (u32)
 *   0xCC: total race time (u32)
 */
extern u32 D_801582BC[8];       /* Best lap times per track */

void func_800ACA9C(void *player, s32 lapNum) {
    u32 *lapTimes;
    u32 *bestLap, *lastLap, *totalTime;
    u32 currentTime, lapTime;
    u32 prevLapEnd;

    if (player == NULL) {
        return;
    }

    if (lapNum < 1 || lapNum > 8) {
        return;
    }

    /* Get player lap data */
    lapTimes = (u32 *)((u8 *)player + 0xA4);
    bestLap = (u32 *)((u8 *)player + 0xC4);
    lastLap = (u32 *)((u8 *)player + 0xC8);
    totalTime = (u32 *)((u8 *)player + 0xCC);

    /* Get current race time */
    currentTime = D_801582B0;

    /* Calculate lap time (difference from previous lap end) */
    if (lapNum == 1) {
        prevLapEnd = 0;
    } else {
        prevLapEnd = lapTimes[lapNum - 2];
    }

    lapTime = currentTime - prevLapEnd;

    /* Record this lap time */
    lapTimes[lapNum - 1] = currentTime;
    *lastLap = lapTime;
    *totalTime = currentTime;

    /* Update best lap if this is faster */
    if (*bestLap == 0 || lapTime < *bestLap) {
        *bestLap = lapTime;

        /* Check against track record */
        if (D_801582BC[0] == 0 || lapTime < D_801582BC[0]) {
            /* New track record! */
            func_800B4208(9);  /* "New record!" */
        }
    }
}

/*

 * func_800ACC18 (1008 bytes)
 * Race position calculation
 *
 * Calculates race positions for all cars based on distance traveled.
 * Based on arcade CheckCPs() position sorting logic:
 *   - Sorts cars by (laps * track_distance + checkpoint_distance)
 *   - Updates place field for each car
 *
 * Car offsets:
 *   0x54: current checkpoint (s32)
 *   0x58: lap count (s32)
 *   0x5C: race position (s32) - output
 *   0xD0: distance along track (f32)
 */

void func_800ACC18(void) {
    s32 i, j;
    s32 numCars;
    f32 distances[8];
    s32 positions[8];
    s32 laps, checkpoint;
    f32 trackDist, carDist;
    f32 totalDist;
    void *car;
    void *tempCar;
    f32 tempDist;

    numCars = D_801582E0;
    if (numCars <= 0 || numCars > 8) {
        return;
    }

    trackDist = D_801582E4;
    if (trackDist <= 0.0f) {
        trackDist = 10000.0f;  /* Default track length */
    }

    /* Calculate total distance for each car */
    for (i = 0; i < numCars; i++) {
        car = D_801582C0[i];
        if (car == NULL) {
            distances[i] = 0.0f;
            positions[i] = i;
            continue;
        }

        laps = *(s32 *)((u8 *)car + 0x58);
        checkpoint = *(s32 *)((u8 *)car + 0x54);
        carDist = *(f32 *)((u8 *)car + 0xD0);

        /* Total distance = laps completed * track length + current progress */
        totalDist = (f32)laps * trackDist + (f32)checkpoint * (trackDist / 16.0f) + carDist;
        distances[i] = totalDist;
        positions[i] = i;
    }

    /* Sort by distance (descending - higher distance = better position) */
    for (i = 0; i < numCars - 1; i++) {
        for (j = i + 1; j < numCars; j++) {
            if (distances[positions[j]] > distances[positions[i]]) {
                /* Swap */
                s32 tempPos = positions[i];
                positions[i] = positions[j];
                positions[j] = tempPos;
            }
        }
    }

    /* Assign positions (0 = 1st place, 1 = 2nd, etc.) */
    for (i = 0; i < numCars; i++) {
        car = D_801582C0[positions[i]];
        if (car != NULL) {
            *(s32 *)((u8 *)car + 0x5C) = i;
        }
    }

    /* Check if player moved into/out of first place for audio cue */
    car = D_801582C0[0];  /* Assume player is car 0 */
    if (car != NULL) {
        s32 *playerPos = (s32 *)((u8 *)car + 0x5C);
        static s32 lastPos = -1;

        if (lastPos != -1) {
            if (*playerPos == 0 && lastPos != 0) {
                /* Player took first place */
                func_800B4208(3);  /* "First!" */
            } else if (*playerPos != 0 && lastPos == 0) {
                /* Player lost first place */
            }
        }
        lastPos = *playerPos;
    }
}

/*

 * func_800AD008 (152 bytes)
 * Get race position
 */
s32 func_800AD008(void *player) {
    return *(s32 *)((u8 *)player + 0x5C);
}

/*

 * func_800AD0A0 (136 bytes)
 * Get lap count
 */
s32 func_800AD0A0(void *player) {
    return *(s32 *)((u8 *)player + 0x58);
}

/*

 * func_800AD128 (1548 bytes)
 * Race finish handling
 *
 * Called when a player completes the final lap.
 * Locks their position and triggers race end sequence.
 *
 * Player offsets:
 *   0x58: lap count (s32)
 *   0x5C: race position (s32)
 *   0xD4: finished flag (s32)
 *   0xD8: finish time (u32)
 *   0xDC: finish position (s32)
 */
void func_800AD128(void *player) {
    s32 *laps, *position;
    s32 *finished, *finishPos;
    u32 *finishTime;
    s32 currentPos;

    if (player == NULL) {
        return;
    }

    /* Get player state */
    laps = (s32 *)((u8 *)player + 0x58);
    position = (s32 *)((u8 *)player + 0x5C);
    finished = (s32 *)((u8 *)player + 0xD4);
    finishTime = (u32 *)((u8 *)player + 0xD8);
    finishPos = (s32 *)((u8 *)player + 0xDC);

    /* Already finished? */
    if (*finished != 0) {
        return;
    }

    /* Check if completed required laps */
    if (*laps < D_801582E8) {
        return;
    }

    /* Mark as finished */
    *finished = 1;
    *finishTime = D_801582B0;
    *finishPos = D_801582EC;  /* Finish order */

    currentPos = *position;

    /* Increment finished count */
    D_801582EC++;

    /* Play appropriate audio */
    if (currentPos == 0) {
        /* First place! */
        func_800B4208(3);   /* "First!" */
    } else if (currentPos == 1) {
        func_800B4208(4);   /* "Second!" */
    } else if (currentPos == 2) {
        func_800B4208(5);   /* "Third!" */
    }

    /* Check if this is the player's car */
    if (player == D_801582C0[0]) {
        /* Player finished - trigger results */
        if (currentPos == 0) {
            /* Winner! */
            func_800B4208(3);  /* Victory sound */
        }

        /* Check for high score */
        if (func_800AEB54(*finishTime) != 0) {
            /* New high score */
            func_800B4208(9);  /* "New record!" */
        }
    }

    /* Check if all cars finished */
    if (D_801582EC >= D_801582E0) {
        D_801582F0 = 1;  /* Race complete */
        func_800AD734();  /* Show results */
    }
}

/*

 * func_800AD734 (1572 bytes)
 * Race results display
 *
 * Displays the race results screen with times and positions.
 * Called after all cars finish or timer expires.
 */
extern void func_800E2A3C(s32 a0); /* Screen transition */

void func_800AD734(void) {
    s32 i;
    void *car;
    s32 position, laps;
    u32 finishTime;
    s32 finished;

    /* Set results screen state */
    D_801582F4 = 1;
    D_801582F8 = 0;

    /* Trigger screen transition */
    func_800E2A3C(5);  /* Results screen type */

    /* Gather and display results for each car */
    for (i = 0; i < D_801582E0; i++) {
        car = D_801582C0[i];
        if (car == NULL) {
            continue;
        }

        position = *(s32 *)((u8 *)car + 0x5C);
        laps = *(s32 *)((u8 *)car + 0x58);
        finished = *(s32 *)((u8 *)car + 0xD4);
        finishTime = *(u32 *)((u8 *)car + 0xD8);

        /* Format: Position, Laps, Time */
        /* HUD rendering happens in display update function */
    }

    /* Pause audio during results */
    func_800B4DAC(0);  /* Don't fully pause, just reduce */
}

/*

 * func_800ADD58 (3580 bytes)
 * Leaderboard update
 *
 * Updates the race leaderboard with current standings.
 * Manages the top 10 best times per track.
 *
 * Leaderboard entry structure (per track):
 *   name[8], time (u32), date (u32)
 */
extern u8 D_80158300[12][10][16];   /* Leaderboard entries [track][rank][data] */

void func_800ADD58(void) {
    s32 i, j;
    void *car;
    u32 finishTime;
    s32 finished;
    s32 rank;
    u8 *leaderboard;

    /* Get current track leaderboard */
    leaderboard = D_80158300[D_80158FC0][0];

    /* Check each car for potential leaderboard entry */
    for (i = 0; i < D_801582E0; i++) {
        car = D_801582C0[i];
        if (car == NULL) {
            continue;
        }

        finished = *(s32 *)((u8 *)car + 0xD4);
        if (finished == 0) {
            continue;
        }

        finishTime = *(u32 *)((u8 *)car + 0xD8);

        /* Find rank on leaderboard */
        rank = -1;
        for (j = 0; j < 10; j++) {
            u32 *entryTime = (u32 *)&D_80158300[D_80158FC0][j][8];
            if (*entryTime == 0 || finishTime < *entryTime) {
                rank = j;
                break;
            }
        }

        /* Insert into leaderboard if ranked */
        if (rank >= 0 && rank < 10) {
            /* Shift entries down */
            for (j = 9; j > rank; j--) {
                s32 k;
                for (k = 0; k < 16; k++) {
                    D_80158300[D_80158FC0][j][k] = D_80158300[D_80158FC0][j-1][k];
                }
            }

            /* Insert new entry */
            /* Name will be filled by high score entry screen */
            *(u32 *)&D_80158300[D_80158FC0][rank][8] = finishTime;
            *(u32 *)&D_80158300[D_80158FC0][rank][12] = 0;  /* Date placeholder */
        }
    }
}

/*

 * func_800AEB54 (528 bytes)
 * High score check
 *
 * Checks if the given time qualifies for the leaderboard.
 * Returns the rank position (1-10) if qualified, 0 if not.
 */
s32 func_800AEB54(s32 time) {
    s32 j;
    u32 checkTime = (u32)time;

    if (checkTime == 0) {
        return 0;
    }

    /* Check against current track leaderboard */
    for (j = 0; j < 10; j++) {
        u32 *entryTime = (u32 *)&D_80158300[D_80158FC0][j][8];

        if (*entryTime == 0) {
            /* Empty slot - qualifies */
            return j + 1;
        }

        if (checkTime < *entryTime) {
            /* Faster than this entry - qualifies at this rank */
            return j + 1;
        }
    }

    /* Didn't qualify */
    return 0;
}

/*

 * func_800AED64 (644 bytes)
 * High score entry
 *
 * Inserts a new high score entry into the leaderboard.
 * Shifts existing entries down to make room.
 *
 * position: 1-10 (rank on leaderboard)
 * name: 3-character name string
 * time: Race completion time
 */
void func_800AED64(s32 position, u8 *name, s32 time) {
    s32 rank, j, k;
    u8 *entry;

    if (position < 1 || position > 10) {
        return;
    }

    if (name == NULL) {
        return;
    }

    rank = position - 1;

    /* Shift entries down */
    for (j = 9; j > rank; j--) {
        for (k = 0; k < 16; k++) {
            D_80158300[D_80158FC0][j][k] = D_80158300[D_80158FC0][j-1][k];
        }
    }

    /* Insert new entry */
    entry = D_80158300[D_80158FC0][rank];

    /* Copy name (up to 8 characters) */
    for (k = 0; k < 8; k++) {
        if (name[k] == '\0') {
            entry[k] = ' ';  /* Pad with spaces */
        } else {
            entry[k] = name[k];
        }
    }

    /* Store time */
    *(u32 *)&entry[8] = (u32)time;

    /* Store date/timestamp (placeholder - could use RTC) */
    *(u32 *)&entry[12] = 0;

    /* Mark as needing save */
    func_800AEFE8();
}

/*

 * func_800AEFE8 (504 bytes)
 * Save high scores
 *
 * Saves high score data to controller pak/EEPROM.
 * Uses N64 save system for persistence.
 */
extern s32 D_80158FCC;          /* Save pending flag */
extern void func_80096240(s32 a0, s32 a1); /* EEPROM write */

void func_800AEFE8(void) {
    /* Mark save as pending */
    D_80158FCC = 1;

    /* Save will be performed during next save opportunity */
    /* Actual save is handled by the save system which batches writes */
    /* to avoid excessive EEPROM wear */
}

/*

 * func_800B087C (1012 bytes)
 * Audio voice allocation - allocates a hardware voice for sound playback
 */
void func_800B087C(s32 voiceId, s32 priority) {
    s32 *voiceTable;
    s32 *voicePriority;
    s32 *voiceActive;
    s32 i;
    s32 lowestPriority;
    s32 lowestVoice;

    voiceTable = (s32 *)0x80170000;      /* Voice allocation table */
    voicePriority = (s32 *)0x80170100;   /* Voice priorities */
    voiceActive = (s32 *)0x80170200;     /* Voice active flags */

    /* Check if voice is already allocated */
    if (voiceId >= 0 && voiceId < 16) {
        if (voiceActive[voiceId] == 0) {
            /* Voice is free, allocate it */
            voiceActive[voiceId] = 1;
            voicePriority[voiceId] = priority;
            voiceTable[voiceId] = voiceId;
            return;
        }
    }

    /* Find lowest priority voice to steal */
    lowestPriority = priority;
    lowestVoice = -1;

    for (i = 0; i < 16; i++) {
        if (voiceActive[i] == 0) {
            /* Found free voice */
            voiceActive[i] = 1;
            voicePriority[i] = priority;
            voiceTable[i] = voiceId;
            return;
        }

        if (voicePriority[i] < lowestPriority) {
            lowestPriority = voicePriority[i];
            lowestVoice = i;
        }
    }

    /* Steal lowest priority voice if our priority is higher */
    if (lowestVoice >= 0 && priority > lowestPriority) {
        voicePriority[lowestVoice] = priority;
        voiceTable[lowestVoice] = voiceId;
    }
}

/*

 * func_800B24EC (4256 bytes)
 * Audio sequence player - plays MIDI-like sequences
 */
s32 func_800B24EC(void *a0, void *a1, s32 a2, s8 objType, s32 a4) {
    void *sequence = a0;
    u8 *seqData;
    s32 *seqPos;
    s32 *seqTempo;
    s32 *seqPlaying;
    s32 *seqTickCounter;
    u8 cmd;
    u8 channel;
    u8 note;
    u8 velocity;
    s32 delta;

    if (sequence == NULL) {
        return;
    }

    seqData = (u8 *)((u8 *)sequence + 0x100);
    seqPos = (s32 *)((u8 *)sequence + 0x00);
    seqTempo = (s32 *)((u8 *)sequence + 0x04);
    seqPlaying = (s32 *)((u8 *)sequence + 0x08);
    seqTickCounter = (s32 *)((u8 *)sequence + 0x0C);

    if (!(*seqPlaying)) {
        return;
    }

    /* Update tick counter */
    (*seqTickCounter)++;

    /* Process events at current tick */
    while (1) {
        /* Read delta time */
        delta = seqData[*seqPos];
        if (delta == 0xFF) {
            /* End of sequence */
            *seqPlaying = 0;
            return;
        }

        if (*seqTickCounter < delta) {
            break;  /* Not time for this event yet */
        }

        (*seqPos)++;
        *seqTickCounter = 0;

        /* Read command */
        cmd = seqData[*seqPos];
        (*seqPos)++;

        if ((cmd & 0xF0) == 0x90) {
            /* Note on */
            channel = cmd & 0x0F;
            note = seqData[*seqPos];
            (*seqPos)++;
            velocity = seqData[*seqPos];
            (*seqPos)++;

            if (velocity > 0) {
                /* Play note */
                func_800B358C(channel, (f32)velocity / 127.0f);
                sound_update_channel(channel, (f32)note / 127.0f);
            }
        } else if ((cmd & 0xF0) == 0x80) {
            /* Note off */
            channel = cmd & 0x0F;
            note = seqData[*seqPos];
            (*seqPos)++;
            (*seqPos)++;  /* Skip velocity */

            /* Silence channel (note off) */
            func_800B358C(channel, 0.0f);
        } else if ((cmd & 0xF0) == 0xB0) {
            /* Control change */
            channel = cmd & 0x0F;
            (*seqPos) += 2;  /* Skip controller and value */
        } else if ((cmd & 0xF0) == 0xC0) {
            /* Program change */
            (*seqPos)++;  /* Skip program */
        } else if (cmd == 0xFF) {
            /* Meta event */
            (*seqPos)++;  /* Skip meta type */
            delta = seqData[*seqPos];  /* Length */
            (*seqPos) += 1 + delta;    /* Skip data */
        }
    }
}

/*

 * sound_set_channel_volume - Audio volume set
 * (func_800B358C - 160 bytes)
 * Sets channel volume with ramping.
 */
void sound_set_channel_volume(s32 channel, f32 volume) {
    f32 *channelVolumes;
    f32 *targetVolumes;

    if (channel < 0 || channel >= 16) {
        return;
    }

    /* Clamp volume */
    if (volume < 0.0f) volume = 0.0f;
    if (volume > 1.0f) volume = 1.0f;

    channelVolumes = (f32 *)0x80170400;
    targetVolumes = (f32 *)0x80170440;

    /* Set target volume for ramping */
    targetVolumes[channel] = volume;

    /* Apply volume immediately if big change */
    if (volume < 0.01f || channelVolumes[channel] < 0.01f) {
        channelVolumes[channel] = volume;
    }
}

/*

 * sound_set_channel_pan - Audio pan set
 * (func_800B362C - 444 bytes)
 * Sets stereo panning for channel.
 */
void sound_set_channel_pan(s32 channel, f32 pan) {
    f32 *channelPan;
    f32 leftVol, rightVol;

    if (channel < 0 || channel >= 16) {
        return;
    }

    /* Clamp pan (-1 = left, 0 = center, 1 = right) */
    if (pan < -1.0f) pan = -1.0f;
    if (pan > 1.0f) pan = 1.0f;

    channelPan = (f32 *)0x80170480;
    channelPan[channel] = pan;

    /* Calculate stereo volumes using constant power panning */
    leftVol = sqrtf((1.0f - pan) * 0.5f);
    rightVol = sqrtf((1.0f + pan) * 0.5f);

    /* Store left/right volumes */
    *((f32 *)(0x801704C0 + channel * 8)) = leftVol;
    *((f32 *)(0x801704C0 + channel * 8 + 4)) = rightVol;
}

/*

 * sound_update_channel - Audio sync/update
 * (func_800B3D18 - 228 bytes)
 * Synchronizes audio state, called periodically.
 */
void sound_update_channel(s32 channel, f32 volume) {
    /* Audio sync/update function - synchronizes audio state */
    /* Called periodically to update audio subsystem */
}

/*

 * sound_apply_effect - Audio effect apply
 * (func_800B3FA4 - 604 bytes)
 * Applies reverb/chorus/etc effects to channel.
 */
s16 sound_apply_effect(s32 channel, s32 effectType, f32 amount) {
    f32 *effectLevels;
    s32 *effectTypes;

    if (channel < 0 || channel >= 16) {
        return;
    }

    /* Clamp amount */
    if (amount < 0.0f) amount = 0.0f;
    if (amount > 1.0f) amount = 1.0f;

    effectLevels = (f32 *)0x80170600;
    effectTypes = (s32 *)0x80170640;

    /* Effect types:
     * 0 = None
     * 1 = Reverb (small room)
     * 2 = Reverb (large hall)
     * 3 = Chorus
     * 4 = Delay
     * 5 = Lowpass filter
     */

    effectTypes[channel] = effectType;
    effectLevels[channel] = amount;

    /* Configure effect parameters based on type */
    switch (effectType) {
        case 1:  /* Small room reverb */
            *((f32 *)(0x80170680 + channel * 16)) = 0.3f;   /* Decay */
            *((f32 *)(0x80170680 + channel * 16 + 4)) = 0.02f;  /* Pre-delay */
            break;
        case 2:  /* Large hall reverb */
            *((f32 *)(0x80170680 + channel * 16)) = 0.7f;   /* Decay */
            *((f32 *)(0x80170680 + channel * 16 + 4)) = 0.05f;  /* Pre-delay */
            break;
        case 3:  /* Chorus */
            *((f32 *)(0x80170680 + channel * 16)) = 2.0f;   /* Rate */
            *((f32 *)(0x80170680 + channel * 16 + 4)) = 0.01f;  /* Depth */
            break;
        case 4:  /* Delay */
            *((f32 *)(0x80170680 + channel * 16)) = 0.25f;  /* Time */
            *((f32 *)(0x80170680 + channel * 16 + 4)) = 0.5f;   /* Feedback */
            break;
        case 5:  /* Lowpass */
            *((f32 *)(0x80170680 + channel * 16)) = 4000.0f;  /* Cutoff Hz */
            break;
    }
}

/*

 * func_800B4200 (352 bytes)
 * Audio buffer fill - fills audio output buffer with mixed samples
 */
void* func_800B4200(void *buffer, s32 samples) {
    s16 *outBuffer;
    f32 *channelVolumes;
    f32 *channelPan;
    s32 i, ch;
    f32 leftSample, rightSample;
    f32 leftVol, rightVol;

    if (buffer == NULL || samples <= 0) {
        return NULL;
    }

    outBuffer = (s16 *)buffer;
    channelVolumes = (f32 *)0x80170400;

    /* Fill buffer with mixed audio */
    for (i = 0; i < samples; i++) {
        leftSample = 0.0f;
        rightSample = 0.0f;

        /* Mix all active channels */
        for (ch = 0; ch < 16; ch++) {
            f32 channelSample;
            s32 *voiceActive = (s32 *)0x80170200;

            if (voiceActive[ch] == 0) {
                continue;
            }

            /* Get sample from channel (placeholder - actual impl reads from sample data) */
            channelSample = 0.0f;  /* Would read from sample buffer */

            /* Get pan volumes */
            leftVol = *((f32 *)(0x801704C0 + ch * 8));
            rightVol = *((f32 *)(0x801704C0 + ch * 8 + 4));

            /* Mix with volume */
            leftSample += channelSample * channelVolumes[ch] * leftVol;
            rightSample += channelSample * channelVolumes[ch] * rightVol;
        }

        /* Clamp and convert to s16 */
        if (leftSample > 1.0f) leftSample = 1.0f;
        if (leftSample < -1.0f) leftSample = -1.0f;
        if (rightSample > 1.0f) rightSample = 1.0f;
        if (rightSample < -1.0f) rightSample = -1.0f;

        outBuffer[i * 2] = (s16)(leftSample * 32767.0f);
        outBuffer[i * 2 + 1] = (s16)(rightSample * 32767.0f);
    }
    return buffer;
}

/*

 * func_800B438C (228 bytes)
 * Audio stream start - starts streaming audio from ROM
 */
void func_800B438C(s32 streamId, void *data) {
    s32 *streamActive;
    void **streamData;
    s32 *streamPos;
    s32 *streamLength;

    if (streamId < 0 || streamId >= 4) {
        return;
    }

    streamActive = (s32 *)0x80170800;
    streamData = (void **)0x80170810;
    streamPos = (s32 *)0x80170820;
    streamLength = (s32 *)0x80170830;

    /* Stop any existing stream on this slot */
    streamActive[streamId] = 0;

    if (data == NULL) {
        return;
    }

    /* Initialize stream */
    streamData[streamId] = data;
    streamPos[streamId] = 0;
    streamLength[streamId] = *((s32 *)data);  /* First word is length */
    streamActive[streamId] = 1;

    /* Start DMA for first buffer */
    osPiStartDma((OSIoMesg *)0x80170900, 0, OS_READ,
                 (u32)data + 4, (void *)0x80171000 + streamId * 0x1000,
                 0x1000, NULL);
}

/*

 * func_800B466C (604 bytes)
 * Audio stream update - updates streaming audio playback
 */
s32 func_800B466C(s32 streamId) {
    s32 *streamActive;
    void **streamData;
    s32 *streamPos;
    s32 *streamLength;
    s32 *streamBuffer;
    s32 bytesRemaining;
    s32 bytesToRead;

    if (streamId < 0 || streamId >= 4) {
        return;
    }

    streamActive = (s32 *)0x80170800;
    streamData = (void **)0x80170810;
    streamPos = (s32 *)0x80170820;
    streamLength = (s32 *)0x80170830;
    streamBuffer = (s32 *)0x80170840;

    if (streamActive[streamId] == 0) {
        return;
    }

    /* Check if we need to fetch more data */
    bytesRemaining = streamLength[streamId] - streamPos[streamId];

    if (bytesRemaining <= 0) {
        /* Stream complete */
        streamActive[streamId] = 0;
        return;
    }

    /* Check if current buffer is consumed */
    if (streamBuffer[streamId] <= 0) {
        /* Calculate bytes to read */
        bytesToRead = 0x1000;
        if (bytesToRead > bytesRemaining) {
            bytesToRead = bytesRemaining;
        }

        /* Start DMA for next buffer */
        osPiStartDma((OSIoMesg *)0x80170900, 0, OS_READ,
                     (u32)streamData[streamId] + 4 + streamPos[streamId],
                     (void *)0x80171000 + streamId * 0x1000,
                     bytesToRead, NULL);

        streamPos[streamId] += bytesToRead;
        streamBuffer[streamId] = bytesToRead;
    }
}

/*

 * func_800B4FB0 (1484 bytes)
 * Audio music playback - plays background music track
 */
void func_800B4FB0(s32 trackId) {
    s32 *currentTrack;
    s32 *musicPlaying;
    s32 *musicVolume;
    void *trackData;
    u32 *trackTable;

    currentTrack = (s32 *)0x80170850;
    musicPlaying = (s32 *)0x80170854;
    musicVolume = (s32 *)0x80170858;

    /* Stop current music if playing */
    if (*musicPlaying) {
        func_800B438C(0, NULL);  /* Stop stream 0 */
        *musicPlaying = 0;
    }

    if (trackId < 0) {
        /* Just stop, don't start new track */
        *currentTrack = -1;
        return;
    }

    /* Get track data from ROM table */
    trackTable = (u32 *)0x80180000;  /* Music track pointer table */

    if (trackId >= 16) {
        return;  /* Invalid track */
    }

    trackData = (void *)trackTable[trackId];
    if (trackData == NULL) {
        return;
    }

    /* Start streaming the track */
    func_800B438C(0, trackData);

    /* Set music channel volume */
    func_800B358C(0, (f32)(*musicVolume) / 100.0f);
    func_800B362C(0, 0.0f);  /* Center pan */

    *currentTrack = trackId;
    *musicPlaying = 1;
}

/*

 * func_800B6024(276 bytes, 0)
 * Get entity float array element
 */
f32 func_800B6024(void *entity, s32 index) {
    f32 *arr = (f32 *)((u8 *)entity + 0x30);
    return arr[index];
}

/*

 * func_800B61FC(380 bytes, 0)
 * Set entity vector with validation
 */
void func_800B61FC(void *entity, f32 *vec) {
    f32 *dest = (f32 *)((u8 *)entity + 0x24);

    if (vec != NULL) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];
    }
}

/*

 * func_800B74A0(2904 bytes, 0)
 * Entity full collision test
 *
 * Performs a complete collision check for an entity against the world.
 * This includes:
 * - Track boundary collision
 * - Other entity collision (cars, obstacles)
 * - Track surface detection
 * - Wall/barrier collision
 */
void func_800B74A0(void *entity, void *world) {
    f32 *pos, *vel, *bounds;
    f32 *worldMin, *worldMax;
    f32 surfaceHeight, penetration;
    s32 *flags, *collisionMask;
    s32 i, numEntities;
    void **entityList;

    if (entity == NULL || world == NULL) {
        return;
    }

    pos = (f32 *)((u8 *)entity + 0x24);
    vel = (f32 *)((u8 *)entity + 0x34);
    bounds = (f32 *)((u8 *)entity + 0x50);  /* Bounding box half-extents */
    flags = (s32 *)((u8 *)entity + 0x0C);
    collisionMask = (s32 *)((u8 *)entity + 0x10);

    worldMin = (f32 *)((u8 *)world + 0x00);
    worldMax = (f32 *)((u8 *)world + 0x0C);
    entityList = (void **)((u8 *)world + 0x40);
    numEntities = *(s32 *)((u8 *)world + 0x38);

    /* Clear previous collision flags */
    *flags &= ~0xFF00;

    /* Track surface query - get height at current XZ position */
    surfaceHeight = 0.0f;
    if (func_800BB9B0(pos, NULL, &surfaceHeight) != 0) {
        /* On valid surface */
        penetration = surfaceHeight - (pos[1] - bounds[1]);
        if (penetration > 0.0f) {
            /* Push entity up out of ground */
            pos[1] += penetration;
            if (vel[1] < 0.0f) {
                vel[1] = 0.0f;
            }
            *flags |= 0x0100;  /* On ground flag */
        }
    }

    /* World boundary checks */
    if (pos[0] - bounds[0] < worldMin[0]) {
        pos[0] = worldMin[0] + bounds[0];
        vel[0] = -vel[0] * 0.5f;
        *flags |= 0x0200;  /* Hit west wall */
    }
    if (pos[0] + bounds[0] > worldMax[0]) {
        pos[0] = worldMax[0] - bounds[0];
        vel[0] = -vel[0] * 0.5f;
        *flags |= 0x0400;  /* Hit east wall */
    }
    if (pos[2] - bounds[2] < worldMin[2]) {
        pos[2] = worldMin[2] + bounds[2];
        vel[2] = -vel[2] * 0.5f;
        *flags |= 0x0800;  /* Hit south wall */
    }
    if (pos[2] + bounds[2] > worldMax[2]) {
        pos[2] = worldMax[2] - bounds[2];
        vel[2] = -vel[2] * 0.5f;
        *flags |= 0x1000;  /* Hit north wall */
    }

    /* Check collisions with other entities */
    for (i = 0; i < numEntities; i++) {
        void *other = entityList[i];
        s32 *otherMask;
        f32 *otherPos, *otherBounds;
        f32 dx, dy, dz, overlapX, overlapY, overlapZ;

        if (other == NULL || other == entity) {
            continue;
        }

        otherMask = (s32 *)((u8 *)other + 0x10);

        /* Check if collision masks overlap */
        if ((*collisionMask & *otherMask) == 0) {
            continue;
        }

        otherPos = (f32 *)((u8 *)other + 0x24);
        otherBounds = (f32 *)((u8 *)other + 0x50);

        /* AABB overlap test */
        dx = pos[0] - otherPos[0];
        dy = pos[1] - otherPos[1];
        dz = pos[2] - otherPos[2];

        overlapX = bounds[0] + otherBounds[0] - fabsf(dx);
        overlapY = bounds[1] + otherBounds[1] - fabsf(dy);
        overlapZ = bounds[2] + otherBounds[2] - fabsf(dz);

        if (overlapX > 0.0f && overlapY > 0.0f && overlapZ > 0.0f) {
            /* Collision detected - resolve along smallest axis */
            f32 normal[3] = {0.0f, 0.0f, 0.0f};

            if (overlapX < overlapY && overlapX < overlapZ) {
                normal[0] = (dx > 0.0f) ? 1.0f : -1.0f;
                pos[0] += normal[0] * overlapX * 0.5f;
            } else if (overlapY < overlapZ) {
                normal[1] = (dy > 0.0f) ? 1.0f : -1.0f;
                pos[1] += normal[1] * overlapY * 0.5f;
            } else {
                normal[2] = (dz > 0.0f) ? 1.0f : -1.0f;
                pos[2] += normal[2] * overlapZ * 0.5f;
            }

            /* Call collision response */
            func_800B82C8(entity, other, normal);
            *flags |= 0x2000;  /* Entity collision flag */
        }
    }
}

/*

 * func_800B82C8 (2380 bytes)
 * Collision response calculation
 *
 * Calculates and applies collision response between two entities.
 * Uses impulse-based physics with restitution and friction.
 */
void func_800B82C8(void *entityA, void *entityB, f32 *normal) {
    f32 *velA, *velB, *massA, *massB;
    f32 relVelX, relVelY, relVelZ, normalVel;
    f32 restitution, impulse, invMassSum;
    f32 impulseX, impulseY, impulseZ;
    f32 tangentX, tangentY, tangentZ, tangentLen;
    f32 friction, tangentImpulse;

    if (entityA == NULL || entityB == NULL || normal == NULL) {
        return;
    }

    velA = (f32 *)((u8 *)entityA + 0x34);
    velB = (f32 *)((u8 *)entityB + 0x34);
    massA = (f32 *)((u8 *)entityA + 0x48);
    massB = (f32 *)((u8 *)entityB + 0x48);

    /* Calculate relative velocity */
    relVelX = velA[0] - velB[0];
    relVelY = velA[1] - velB[1];
    relVelZ = velA[2] - velB[2];

    /* Velocity along collision normal */
    normalVel = relVelX * normal[0] + relVelY * normal[1] + relVelZ * normal[2];

    /* Objects separating, no response needed */
    if (normalVel > 0.0f) {
        return;
    }

    /* Coefficient of restitution (bounciness) */
    restitution = 0.3f;

    /* Calculate inverse mass sum */
    invMassSum = 0.0f;
    if (*massA > 0.0f) {
        invMassSum += 1.0f / *massA;
    }
    if (*massB > 0.0f) {
        invMassSum += 1.0f / *massB;
    }

    if (invMassSum == 0.0f) {
        /* Both objects have infinite mass, no response */
        return;
    }

    /* Calculate impulse magnitude */
    impulse = -(1.0f + restitution) * normalVel / invMassSum;

    /* Apply impulse along normal */
    impulseX = impulse * normal[0];
    impulseY = impulse * normal[1];
    impulseZ = impulse * normal[2];

    if (*massA > 0.0f) {
        velA[0] += impulseX / *massA;
        velA[1] += impulseY / *massA;
        velA[2] += impulseZ / *massA;
    }

    if (*massB > 0.0f) {
        velB[0] -= impulseX / *massB;
        velB[1] -= impulseY / *massB;
        velB[2] -= impulseZ / *massB;
    }

    /* Calculate tangent (friction) direction */
    tangentX = relVelX - normalVel * normal[0];
    tangentY = relVelY - normalVel * normal[1];
    tangentZ = relVelZ - normalVel * normal[2];
    tangentLen = sqrtf(tangentX * tangentX + tangentY * tangentY + tangentZ * tangentZ);

    if (tangentLen > 0.001f) {
        tangentX /= tangentLen;
        tangentY /= tangentLen;
        tangentZ /= tangentLen;

        /* Friction coefficient */
        friction = 0.4f;
        tangentImpulse = -tangentLen / invMassSum;

        /* Clamp friction impulse (Coulomb friction model) */
        if (tangentImpulse > impulse * friction) {
            tangentImpulse = impulse * friction;
        } else if (tangentImpulse < -impulse * friction) {
            tangentImpulse = -impulse * friction;
        }

        /* Apply friction impulse */
        if (*massA > 0.0f) {
            velA[0] += tangentImpulse * tangentX / *massA;
            velA[1] += tangentImpulse * tangentY / *massA;
            velA[2] += tangentImpulse * tangentZ / *massA;
        }

        if (*massB > 0.0f) {
            velB[0] -= tangentImpulse * tangentX / *massB;
            velB[1] -= tangentImpulse * tangentY / *massB;
            velB[2] -= tangentImpulse * tangentZ / *massB;
        }
    }

    /* Play collision sound based on impact strength */
    if (fabsf(normalVel) > 5.0f) {
        func_80094A54(0x20, (s32)(fabsf(normalVel) * 10.0f));  /* Impact sound */
    }
}

/*

 * func_800B8C14 (1252 bytes)
 * Physics constraint solve
 *
 * Solves a physics constraint (joint, limit, or motor).
 * Used for car suspension, wheel connections, etc.
 */
void func_800B8C14(void *constraint) {
    s32 *type;
    void *bodyA, *bodyB;
    f32 *anchorA, *anchorB;
    f32 *posA, *posB, *velA, *velB;
    f32 dx, dy, dz, distance, targetDist;
    f32 correction, lambda;
    f32 nx, ny, nz;

    if (constraint == NULL) {
        return;
    }

    type = (s32 *)((u8 *)constraint + 0x00);
    bodyA = *(void **)((u8 *)constraint + 0x04);
    bodyB = *(void **)((u8 *)constraint + 0x08);
    anchorA = (f32 *)((u8 *)constraint + 0x0C);
    anchorB = (f32 *)((u8 *)constraint + 0x18);
    targetDist = *(f32 *)((u8 *)constraint + 0x24);

    if (bodyA == NULL) {
        return;
    }

    posA = (f32 *)((u8 *)bodyA + 0x24);
    velA = (f32 *)((u8 *)bodyA + 0x34);

    switch (*type) {
        case 0:  /* Distance constraint */
            if (bodyB == NULL) {
                return;
            }
            posB = (f32 *)((u8 *)bodyB + 0x24);
            velB = (f32 *)((u8 *)bodyB + 0x34);

            /* Calculate anchor world positions */
            dx = (posB[0] + anchorB[0]) - (posA[0] + anchorA[0]);
            dy = (posB[1] + anchorB[1]) - (posA[1] + anchorA[1]);
            dz = (posB[2] + anchorB[2]) - (posA[2] + anchorA[2]);

            distance = sqrtf(dx * dx + dy * dy + dz * dz);
            if (distance < 0.001f) {
                return;
            }

            nx = dx / distance;
            ny = dy / distance;
            nz = dz / distance;

            correction = (distance - targetDist) * 0.5f;
            posA[0] += nx * correction;
            posA[1] += ny * correction;
            posA[2] += nz * correction;
            posB[0] -= nx * correction;
            posB[1] -= ny * correction;
            posB[2] -= nz * correction;
            break;

        case 1:  /* Point constraint (fixed anchor) */
            dx = anchorB[0] - (posA[0] + anchorA[0]);
            dy = anchorB[1] - (posA[1] + anchorA[1]);
            dz = anchorB[2] - (posA[2] + anchorA[2]);

            /* Spring-like correction */
            lambda = 0.1f;
            posA[0] += dx * lambda;
            posA[1] += dy * lambda;
            posA[2] += dz * lambda;
            velA[0] += dx * lambda * 0.5f;
            velA[1] += dy * lambda * 0.5f;
            velA[2] += dz * lambda * 0.5f;
            break;

        case 2:  /* Slider constraint (1D motion) */
            if (bodyB == NULL) {
                return;
            }
            posB = (f32 *)((u8 *)bodyB + 0x24);

            /* Constrain to slide along axis defined by anchorA */
            nx = anchorA[0];
            ny = anchorA[1];
            nz = anchorA[2];

            dx = posB[0] - posA[0];
            dy = posB[1] - posA[1];
            dz = posB[2] - posA[2];

            /* Project position difference onto constraint axis */
            lambda = dx * nx + dy * ny + dz * nz;

            /* Remove perpendicular component */
            correction = 0.5f;
            posA[0] += (dx - lambda * nx) * correction;
            posA[1] += (dy - lambda * ny) * correction;
            posA[2] += (dz - lambda * nz) * correction;
            posB[0] -= (dx - lambda * nx) * correction;
            posB[1] -= (dy - lambda * ny) * correction;
            posB[2] -= (dz - lambda * nz) * correction;
            break;
    }
}

/*

 * func_800BAAA0 (744 bytes)
 * Broadphase collision check
 *
 * Performs spatial partitioning to quickly identify potential collision pairs.
 * Uses grid-based spatial hashing for O(n) performance.
 */
void func_800BAAA0(void *world) {
    void **entityList;
    s32 numEntities, numPairs;
    s32 *pairListA, *pairListB;
    s32 *gridCells;
    s32 gridSizeX, gridSizeZ, cellIndex;
    f32 cellWidth, cellHeight;
    f32 *worldMin;
    s32 i, j;

    if (world == NULL) {
        return;
    }

    entityList = (void **)((u8 *)world + 0x40);
    numEntities = *(s32 *)((u8 *)world + 0x38);
    pairListA = (s32 *)((u8 *)world + 0x80);
    pairListB = (s32 *)((u8 *)world + 0x180);
    gridCells = (s32 *)((u8 *)world + 0x280);
    worldMin = (f32 *)((u8 *)world + 0x00);

    gridSizeX = 16;
    gridSizeZ = 16;
    cellWidth = 100.0f;
    cellHeight = 100.0f;

    /* Clear grid cells */
    for (i = 0; i < gridSizeX * gridSizeZ; i++) {
        gridCells[i] = -1;
    }

    numPairs = 0;

    /* Insert entities into grid */
    for (i = 0; i < numEntities && i < 64; i++) {
        void *entity = entityList[i];
        f32 *pos;
        s32 cellX, cellZ, cellIdx;

        if (entity == NULL) {
            continue;
        }

        pos = (f32 *)((u8 *)entity + 0x24);

        cellX = (s32)((pos[0] - worldMin[0]) / cellWidth);
        cellZ = (s32)((pos[2] - worldMin[2]) / cellHeight);

        if (cellX < 0) cellX = 0;
        if (cellX >= gridSizeX) cellX = gridSizeX - 1;
        if (cellZ < 0) cellZ = 0;
        if (cellZ >= gridSizeZ) cellZ = gridSizeZ - 1;

        cellIdx = cellZ * gridSizeX + cellX;

        /* Check for pairs in same cell and adjacent cells */
        for (j = i + 1; j < numEntities && j < 64; j++) {
            void *other = entityList[j];
            f32 *otherPos;
            s32 otherCellX, otherCellZ;

            if (other == NULL) {
                continue;
            }

            otherPos = (f32 *)((u8 *)other + 0x24);

            otherCellX = (s32)((otherPos[0] - worldMin[0]) / cellWidth);
            otherCellZ = (s32)((otherPos[2] - worldMin[2]) / cellHeight);

            if (otherCellX < 0) otherCellX = 0;
            if (otherCellX >= gridSizeX) otherCellX = gridSizeX - 1;
            if (otherCellZ < 0) otherCellZ = 0;
            if (otherCellZ >= gridSizeZ) otherCellZ = gridSizeZ - 1;

            /* If in same or adjacent cell, add to pair list */
            if (abs(cellX - otherCellX) <= 1 && abs(cellZ - otherCellZ) <= 1) {
                if (numPairs < 64) {
                    pairListA[numPairs] = i;
                    pairListB[numPairs] = j;
                    numPairs++;
                }
            }
        }
    }

    /* Store pair count */
    *(s32 *)((u8 *)world + 0x7C) = numPairs;
}

/*

 * func_800BADE0 (3448 bytes)
 * Narrowphase collision
 *
 * Performs detailed collision detection between two entities.
 * Uses separating axis theorem (SAT) for oriented bounding boxes.
 */
void func_800BADE0(void *pairA, void *pairB) {
    f32 *posA, *posB, *boundsA, *boundsB;
    f32 *rotA, *rotB;
    f32 centerDiff[3], absRot[3][3];
    f32 axes[15][3];
    f32 projA, projB, overlap, minOverlap;
    s32 minAxis, i, j;
    f32 contactNormal[3], contactPoint[3];
    f32 penetration;

    if (pairA == NULL || pairB == NULL) {
        return;
    }

    posA = (f32 *)((u8 *)pairA + 0x24);
    posB = (f32 *)((u8 *)pairB + 0x24);
    boundsA = (f32 *)((u8 *)pairA + 0x50);
    boundsB = (f32 *)((u8 *)pairB + 0x50);
    rotA = (f32 *)((u8 *)pairA + 0x60);  /* 3x3 rotation matrix */
    rotB = (f32 *)((u8 *)pairB + 0x60);

    /* Center difference */
    centerDiff[0] = posB[0] - posA[0];
    centerDiff[1] = posB[1] - posA[1];
    centerDiff[2] = posB[2] - posA[2];

    /* Set up 15 potential separating axes:
     * 3 from A's local axes
     * 3 from B's local axes
     * 9 from cross products of A and B axes
     */

    /* A's local axes */
    for (i = 0; i < 3; i++) {
        axes[i][0] = rotA[i * 3 + 0];
        axes[i][1] = rotA[i * 3 + 1];
        axes[i][2] = rotA[i * 3 + 2];
    }

    /* B's local axes */
    for (i = 0; i < 3; i++) {
        axes[3 + i][0] = rotB[i * 3 + 0];
        axes[3 + i][1] = rotB[i * 3 + 1];
        axes[3 + i][2] = rotB[i * 3 + 2];
    }

    /* Cross products (simplified - just checking major axes for N64) */
    for (i = 0; i < 9; i++) {
        s32 aIdx = i / 3;
        s32 bIdx = i % 3;
        f32 *axisA = axes[aIdx];
        f32 *axisB = axes[3 + bIdx];

        axes[6 + i][0] = axisA[1] * axisB[2] - axisA[2] * axisB[1];
        axes[6 + i][1] = axisA[2] * axisB[0] - axisA[0] * axisB[2];
        axes[6 + i][2] = axisA[0] * axisB[1] - axisA[1] * axisB[0];

        /* Normalize */
        f32 len = sqrtf(axes[6 + i][0] * axes[6 + i][0] +
                       axes[6 + i][1] * axes[6 + i][1] +
                       axes[6 + i][2] * axes[6 + i][2]);
        if (len > 0.001f) {
            axes[6 + i][0] /= len;
            axes[6 + i][1] /= len;
            axes[6 + i][2] /= len;
        }
    }

    minOverlap = 999999.0f;
    minAxis = -1;

    /* Test all 15 axes */
    for (i = 0; i < 15; i++) {
        f32 *axis = axes[i];
        f32 axisLen = sqrtf(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);

        if (axisLen < 0.001f) {
            continue;  /* Degenerate axis */
        }

        /* Project A onto axis */
        projA = fabsf(boundsA[0] * (rotA[0] * axis[0] + rotA[1] * axis[1] + rotA[2] * axis[2])) +
                fabsf(boundsA[1] * (rotA[3] * axis[0] + rotA[4] * axis[1] + rotA[5] * axis[2])) +
                fabsf(boundsA[2] * (rotA[6] * axis[0] + rotA[7] * axis[1] + rotA[8] * axis[2]));

        /* Project B onto axis */
        projB = fabsf(boundsB[0] * (rotB[0] * axis[0] + rotB[1] * axis[1] + rotB[2] * axis[2])) +
                fabsf(boundsB[1] * (rotB[3] * axis[0] + rotB[4] * axis[1] + rotB[5] * axis[2])) +
                fabsf(boundsB[2] * (rotB[6] * axis[0] + rotB[7] * axis[1] + rotB[8] * axis[2]));

        /* Project center difference onto axis */
        f32 centerProj = fabsf(centerDiff[0] * axis[0] + centerDiff[1] * axis[1] + centerDiff[2] * axis[2]);

        overlap = projA + projB - centerProj;

        if (overlap < 0.0f) {
            /* Separating axis found, no collision */
            return;
        }

        if (overlap < minOverlap) {
            minOverlap = overlap;
            minAxis = i;
        }
    }

    /* Collision detected - compute contact info */
    if (minAxis >= 0 && minAxis < 15) {
        contactNormal[0] = axes[minAxis][0];
        contactNormal[1] = axes[minAxis][1];
        contactNormal[2] = axes[minAxis][2];

        /* Ensure normal points from A to B */
        f32 dot = contactNormal[0] * centerDiff[0] +
                  contactNormal[1] * centerDiff[1] +
                  contactNormal[2] * centerDiff[2];
        if (dot < 0.0f) {
            contactNormal[0] = -contactNormal[0];
            contactNormal[1] = -contactNormal[1];
            contactNormal[2] = -contactNormal[2];
        }

        penetration = minOverlap;

        /* Contact point approximation (midpoint) */
        contactPoint[0] = (posA[0] + posB[0]) * 0.5f;
        contactPoint[1] = (posA[1] + posB[1]) * 0.5f;
        contactPoint[2] = (posA[2] + posB[2]) * 0.5f;

        /* Call collision response */
        func_800B82C8(pairA, pairB, contactNormal);
    }
}

/*

 * func_800BB9B0 (2500 bytes)
 * Track surface query
 *
 * Queries the track geometry at a given XZ position to find:
 * - Surface height (Y coordinate)
 * - Surface normal
 * - Surface type (asphalt, dirt, etc.)
 *
 * Returns: surface type (0 = off track, 1+ = valid surface)
 */
s32 func_800BB9B0(f32 *pos, f32 *normal, f32 *height) {
    void *trackData = (void *)D_80148000;  /* Track geometry data */
    s32 *triangleList;
    s32 numTriangles;
    f32 *vertices;
    f32 queryX, queryZ;
    s32 foundSurface = 0;
    f32 bestHeight = -99999.0f;
    f32 bestNormal[3] = {0.0f, 1.0f, 0.0f};
    s32 bestSurfaceType = 0;
    s32 i;

    if (pos == NULL || trackData == NULL) {
        if (height != NULL) {
            *height = 0.0f;
        }
        if (normal != NULL) {
            normal[0] = 0.0f;
            normal[1] = 1.0f;
            normal[2] = 0.0f;
        }
        return 0;
    }

    queryX = pos[0];
    queryZ = pos[2];

    triangleList = (s32 *)((u8 *)trackData + 0x10);
    numTriangles = *(s32 *)((u8 *)trackData + 0x08);
    vertices = (f32 *)((u8 *)trackData + 0x100);

    /* Iterate through triangles to find one containing query point */
    for (i = 0; i < numTriangles && i < 4096; i++) {
        s32 *tri = &triangleList[i * 4];  /* v0, v1, v2, surfaceType */
        s32 idx0 = tri[0] * 3;
        s32 idx1 = tri[1] * 3;
        s32 idx2 = tri[2] * 3;
        s32 surfaceType = tri[3];

        f32 x0 = vertices[idx0 + 0];
        f32 y0 = vertices[idx0 + 1];
        f32 z0 = vertices[idx0 + 2];
        f32 x1 = vertices[idx1 + 0];
        f32 y1 = vertices[idx1 + 1];
        f32 z1 = vertices[idx1 + 2];
        f32 x2 = vertices[idx2 + 0];
        f32 y2 = vertices[idx2 + 1];
        f32 z2 = vertices[idx2 + 2];

        /* Point in triangle test (2D, XZ plane) using barycentric coords */
        f32 v0x = x2 - x0;
        f32 v0z = z2 - z0;
        f32 v1x = x1 - x0;
        f32 v1z = z1 - z0;
        f32 v2x = queryX - x0;
        f32 v2z = queryZ - z0;

        f32 dot00 = v0x * v0x + v0z * v0z;
        f32 dot01 = v0x * v1x + v0z * v1z;
        f32 dot02 = v0x * v2x + v0z * v2z;
        f32 dot11 = v1x * v1x + v1z * v1z;
        f32 dot12 = v1x * v2x + v1z * v2z;

        f32 invDenom = dot00 * dot11 - dot01 * dot01;
        if (fabsf(invDenom) < 0.0001f) {
            continue;  /* Degenerate triangle */
        }
        invDenom = 1.0f / invDenom;

        f32 u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        f32 v = (dot00 * dot12 - dot01 * dot02) * invDenom;

        /* Check if point is in triangle */
        if (u >= 0.0f && v >= 0.0f && (u + v) <= 1.0f) {
            /* Interpolate height */
            f32 h = y0 + u * (y2 - y0) + v * (y1 - y0);

            /* Take highest surface at this point (for bridges, etc.) */
            if (h > bestHeight) {
                bestHeight = h;
                bestSurfaceType = surfaceType;

                /* Calculate normal from triangle edges */
                f32 e1x = x1 - x0;
                f32 e1y = y1 - y0;
                f32 e1z = z1 - z0;
                f32 e2x = x2 - x0;
                f32 e2y = y2 - y0;
                f32 e2z = z2 - z0;

                bestNormal[0] = e1y * e2z - e1z * e2y;
                bestNormal[1] = e1z * e2x - e1x * e2z;
                bestNormal[2] = e1x * e2y - e1y * e2x;

                /* Normalize */
                f32 len = sqrtf(bestNormal[0] * bestNormal[0] +
                               bestNormal[1] * bestNormal[1] +
                               bestNormal[2] * bestNormal[2]);
                if (len > 0.001f) {
                    bestNormal[0] /= len;
                    bestNormal[1] /= len;
                    bestNormal[2] /= len;
                }

                /* Ensure normal points up */
                if (bestNormal[1] < 0.0f) {
                    bestNormal[0] = -bestNormal[0];
                    bestNormal[1] = -bestNormal[1];
                    bestNormal[2] = -bestNormal[2];
                }

                foundSurface = 1;
            }
        }
    }

    /* Output results */
    if (height != NULL) {
        *height = bestHeight;
    }
    if (normal != NULL) {
        normal[0] = bestNormal[0];
        normal[1] = bestNormal[1];
        normal[2] = bestNormal[2];
    }

    return foundSurface ? bestSurfaceType : 0;
}

/*

 * func_800BE7BC(1016 bytes)
 * Camera target tracking
 *
 * Smoothly tracks a target entity with the camera.
 * Implements chase cam behavior with configurable lag.
 */
void func_800BE7BC(void *camera, void *target) {
    f32 *camPos;
    f32 *camTarget;
    f32 *camUp;
    f32 *followOffset;
    f32 *lookaheadScale;
    f32 smoothFactor;
    f32 *targetPos;
    f32 *targetVel;
    f32 *targetDir;
    f32 lookahead;
    f32 desiredPos[3];
    f32 desiredTarget[3];

    if (camera == NULL || target == NULL) {
        return;
    }

    camPos = (f32 *)((u8 *)camera + 0x00);
    camTarget = (f32 *)((u8 *)camera + 0x0C);
    camUp = (f32 *)((u8 *)camera + 0x18);
    followOffset = (f32 *)((u8 *)camera + 0x24);  /* Behind/above offset */
    lookaheadScale = (f32 *)((u8 *)camera + 0x30);
    smoothFactor = *(f32 *)((u8 *)camera + 0x34);

    targetPos = (f32 *)((u8 *)target + 0x24);
    targetVel = (f32 *)((u8 *)target + 0x34);
    targetDir = (f32 *)((u8 *)target + 0x60);

    if (smoothFactor <= 0.0f) {
        smoothFactor = 0.1f;
    }

    /* Calculate speed for lookahead */
    f32 speed = sqrtf(targetVel[0] * targetVel[0] +
                     targetVel[1] * targetVel[1] +
                     targetVel[2] * targetVel[2]);
    lookahead = speed * (*lookaheadScale);

    /* Desired camera position: behind and above target */
    desiredPos[0] = targetPos[0] - targetDir[0] * followOffset[0] + targetVel[0] * 0.1f;
    desiredPos[1] = targetPos[1] + followOffset[1];
    desiredPos[2] = targetPos[2] - targetDir[2] * followOffset[0] + targetVel[2] * 0.1f;

    /* Desired look target: ahead of car based on speed */
    desiredTarget[0] = targetPos[0] + targetDir[0] * lookahead;
    desiredTarget[1] = targetPos[1] + followOffset[2];  /* Slight offset up */
    desiredTarget[2] = targetPos[2] + targetDir[2] * lookahead;

    /* Smooth interpolation of camera position */
    camPos[0] += (desiredPos[0] - camPos[0]) * smoothFactor;
    camPos[1] += (desiredPos[1] - camPos[1]) * smoothFactor;
    camPos[2] += (desiredPos[2] - camPos[2]) * smoothFactor;

    /* Smooth interpolation of look target */
    camTarget[0] += (desiredTarget[0] - camTarget[0]) * smoothFactor * 1.5f;
    camTarget[1] += (desiredTarget[1] - camTarget[1]) * smoothFactor * 1.5f;
    camTarget[2] += (desiredTarget[2] - camTarget[2]) * smoothFactor * 1.5f;

    /* Keep up vector mostly vertical with slight tilt on turns */
    f32 turnRate = targetVel[0] * targetDir[2] - targetVel[2] * targetDir[0];
    camUp[0] = -turnRate * 0.01f;
    camUp[1] = 1.0f;
    camUp[2] = 0.0f;

    /* Normalize up vector */
    f32 upLen = sqrtf(camUp[0] * camUp[0] + camUp[1] * camUp[1] + camUp[2] * camUp[2]);
    if (upLen > 0.001f) {
        camUp[0] /= upLen;
        camUp[1] /= upLen;
        camUp[2] /= upLen;
    }

    /* Ground collision for camera */
    f32 groundHeight;
    if (func_800BB9B0(camPos, NULL, &groundHeight) != 0) {
        if (camPos[1] < groundHeight + 2.0f) {
            camPos[1] = groundHeight + 2.0f;
        }
    }
}

/*

 * func_800BF01C()
 * Empty function
 */
void func_800BF01C() {
    /* Empty stub */
}

/*

 * func_800BF0A4(848 bytes, 0, 0)
 * Camera shake effect
 *
 * Applies a shake effect to the camera for impacts, explosions, etc.
 * Uses decaying oscillation with random offset.
 */
void func_800BF0A4(void *camera, f32 intensity, f32 duration) {
    f32 *shakeOffset, *shakeState;
    f32 *shakeTimer, *shakeIntensity;
    f32 currentTime, elapsed, decay;
    f32 shakeX, shakeY, shakeZ;
    s32 seed;

    if (camera == NULL || intensity <= 0.0f) {
        return;
    }

    shakeOffset = (f32 *)((u8 *)camera + 0x40);
    shakeState = (f32 *)((u8 *)camera + 0x4C);
    shakeTimer = (f32 *)((u8 *)camera + 0x58);
    shakeIntensity = (f32 *)((u8 *)camera + 0x5C);

    /* Start new shake if stronger than current */
    if (intensity > *shakeIntensity * 0.5f) {
        *shakeTimer = duration;
        *shakeIntensity = intensity;

        /* Initialize shake state with pseudo-random values */
        seed = D_80159A20 & 0xFFFF;
        shakeState[0] = (f32)(seed % 1000) / 1000.0f * 6.28318f;
        shakeState[1] = (f32)((seed >> 4) % 1000) / 1000.0f * 6.28318f;
        shakeState[2] = (f32)((seed >> 8) % 1000) / 1000.0f * 6.28318f;
    }

    /* Update shake */
    if (*shakeTimer > 0.0f) {
        elapsed = duration - *shakeTimer;
        decay = *shakeTimer / duration;  /* Linear decay */
        decay = decay * decay;  /* Quadratic for smoother falloff */

        /* Oscillating shake with multiple frequencies */
        f32 freq1 = 15.0f;  /* Fast shake */
        f32 freq2 = 8.0f;   /* Slower shake */

        shakeX = sinf(shakeState[0] + elapsed * freq1) * 0.6f +
                 sinf(shakeState[0] * 1.7f + elapsed * freq2) * 0.4f;
        shakeY = sinf(shakeState[1] + elapsed * freq1 * 0.8f) * 0.6f +
                 sinf(shakeState[1] * 1.3f + elapsed * freq2) * 0.4f;
        shakeZ = sinf(shakeState[2] + elapsed * freq1 * 1.2f) * 0.3f;

        /* Apply intensity and decay */
        shakeOffset[0] = shakeX * (*shakeIntensity) * decay;
        shakeOffset[1] = shakeY * (*shakeIntensity) * decay;
        shakeOffset[2] = shakeZ * (*shakeIntensity) * decay * 0.5f;

        /* Decrement timer */
        *shakeTimer -= 1.0f / 60.0f;  /* Assuming 60fps */

        if (*shakeTimer <= 0.0f) {
            *shakeTimer = 0.0f;
            *shakeIntensity = 0.0f;
            shakeOffset[0] = 0.0f;
            shakeOffset[1] = 0.0f;
            shakeOffset[2] = 0.0f;
        }
    }
}

/*

 * func_800C813C (804 bytes)
 * HUD element render
 *
 * Renders a single HUD element by ID.
 * Elements include: speedometer, tachometer, lap counter, position, timer, etc.
 */
void func_800C813C(void *hud, s32 elementId) {
    s32 *visibility;
    f32 *positions;
    f32 *sizes;
    s32 x, y, width, height;

    if (hud == NULL) {
        return;
    }

    visibility = (s32 *)((u8 *)hud + 0x00);
    positions = (f32 *)((u8 *)hud + 0x40);
    sizes = (f32 *)((u8 *)hud + 0xC0);

    /* Check if element is visible */
    if (((*visibility) & (1 << elementId)) == 0) {
        return;
    }

    x = (s32)positions[elementId * 2 + 0];
    y = (s32)positions[elementId * 2 + 1];
    width = (s32)sizes[elementId * 2 + 0];
    height = (s32)sizes[elementId * 2 + 1];

    switch (elementId) {
        case 0:  /* Speedometer background */
            draw_ui_element(0x10, x, y, width, height, 255);  /* Sprite ID 0x10 */
            break;

        case 1:  /* Speedometer needle */
            /* Needle rotation handled by speedometer update */
            draw_ui_element(0x11, x, y, width, height, 255);
            break;

        case 2:  /* Tachometer background */
            draw_ui_element(0x12, x, y, width, height, 255);
            break;

        case 3:  /* Tachometer needle */
            draw_ui_element(0x13, x, y, width, height, 255);
            break;

        case 4:  /* Lap counter background */
            draw_ui_element(0x14, x, y, width, height, 255);
            break;

        case 5:  /* Position indicator */
            draw_ui_element(0x15, x, y, width, height, 255);
            break;

        case 6:  /* Timer background */
            draw_ui_element(0x16, x, y, width, height, 255);
            break;

        case 7:  /* Nitro meter */
            draw_ui_element(0x17, x, y, width, height, 255);
            break;

        case 8:  /* Minimap */
            draw_ui_element(0x18, x, y, width, height, 255);
            break;

        case 9:  /* Wrong way indicator */
            draw_ui_element(0x19, x, y, width, height, 255);
            break;

        case 10:  /* Damage indicator */
            draw_ui_element(0x1A, x, y, width, height, 255);
            break;
    }
}

/*

 * func_800C84FC (868 bytes)
 * Speedometer update
 *
 * Updates the speedometer display with current speed.
 * Includes needle animation and digital readout.
 */
void hud_speed_display(void *hud, f32 speed) {
    f32 *needleAngle, *displaySpeed;
    f32 *positions;
    f32 maxSpeed, minAngle, maxAngle, targetAngle;
    s32 digitalSpeed;
    s32 x, y;
    char speedText[8];

    if (hud == NULL) {
        return;
    }

    needleAngle = (f32 *)((u8 *)hud + 0x140);
    displaySpeed = (f32 *)((u8 *)hud + 0x144);
    positions = (f32 *)((u8 *)hud + 0x40);

    /* Clamp speed to valid range */
    if (speed < 0.0f) speed = 0.0f;

    maxSpeed = 200.0f;  /* Max speed in MPH */
    minAngle = -135.0f;  /* Degrees, starting position */
    maxAngle = 135.0f;   /* Degrees, max speed position */

    /* Calculate target needle angle */
    if (speed > maxSpeed) speed = maxSpeed;
    targetAngle = minAngle + (speed / maxSpeed) * (maxAngle - minAngle);

    /* Smooth needle movement */
    *needleAngle += (targetAngle - *needleAngle) * 0.15f;

    /* Smooth display speed */
    *displaySpeed += (speed - *displaySpeed) * 0.2f;

    /* Render speedometer background */
    x = (s32)positions[0];
    y = (s32)positions[1];
    func_800C813C(hud, 0);  /* Background */

    /* Render needle with rotation */
    /* Needle rendering would need rotation support in the sprite system */
    func_800C813C(hud, 1);  /* Needle */

    /* Digital speed display */
    digitalSpeed = (s32)(*displaySpeed);
    if (digitalSpeed < 0) digitalSpeed = 0;
    if (digitalSpeed > 999) digitalSpeed = 999;

    /* Format speed text */
    speedText[0] = '0' + (digitalSpeed / 100);
    speedText[1] = '0' + ((digitalSpeed / 10) % 10);
    speedText[2] = '0' + (digitalSpeed % 10);
    speedText[3] = '\0';

    /* Render digital readout */
    draw_text(x + 20, y + 40, speedText, 0xFFFFFFFF);
}

/*

 * func_800C885C (816 bytes)
 * Tachometer update
 *
 * Updates the tachometer display with current RPM.
 * Includes redline warning and gear indicator.
 */
void func_800C885C(void) { /* Tachometer update stub */ }

/*

 * func_800C8B8C (1048 bytes)
 * Lap counter update
 *
 * Updates the lap counter display with current and total laps.
 * Shows lap time splits and best lap indicator.
 */
void hud_setup(s32 a, s32 b, s32 c, s32 d, s32 e, f32 f, f32 g, s32 h) {
    /* HUD setup stub */
}

/*

 * func_800C8FA4 (316 bytes)
 * Position display update
 *
 * Shows the player's race position (1st, 2nd, etc.)
 * with ordinal suffix.
 */
void display_enable(s32 flag) { /* Position display stub */ }

/*

 * func_800C9158 (184 bytes)
 * Timer display
 *
 * Displays race time in MM:SS.CC format.
 */
void player_state_set(s32 a, s32 b) {
    /* Timer display stub */
}

/*

 * func_800C9210 (204 bytes)
 * Speed display
 *
 * Digital speed readout with MPH/KPH unit.
 */
void speed_set(s32 speed) {
    /* Speed display stub */
}

/*

 * func_800C9480 (168 bytes)
 * Nitro meter update
 *
 * Displays nitro/boost gauge with fill level.
 */
void func_800C9480(void) { /* Nitro gauge stub */ }

/*

 * func_800C9BE0 (1824 bytes)
 * Full HUD update
 *
 * Updates all HUD elements based on current player state.
 * Called once per frame during gameplay.
 */
void func_800C9BE0(void) { /* HUD visibility stub */ }

/*

 * func_800CA300 (180 bytes)
 * HUD fade effect
 *
 * Fades the entire HUD in/out based on alpha value.
 * Used for transitions and pause/unpause effects.
 */
void func_800CA300(void) {
    /* State change pre-process stub */
}

/*

 * func_800CBF2C (12544 bytes)
 * Menu system update - main menu logic processor
 */
void func_800CBF2C(void *menu) {
    s32 *menuState;
    s32 *selectedItem;
    s32 *itemCount;
    s32 *subMenu;
    s32 *inputDelay;
    s32 *animTimer;
    u16 buttons;
    u16 buttonsPressed;

    if (menu == NULL) {
        return;
    }

    menuState = (s32 *)((u8 *)menu + 0x00);
    selectedItem = (s32 *)((u8 *)menu + 0x04);
    itemCount = (s32 *)((u8 *)menu + 0x08);
    subMenu = (s32 *)((u8 *)menu + 0x0C);
    inputDelay = (s32 *)((u8 *)menu + 0x10);
    animTimer = (s32 *)((u8 *)menu + 0x14);

    /* Get controller input */
    buttons = D_801520A0;
    buttonsPressed = D_801520A4;

    /* Update animation timer */
    (*animTimer)++;

    /* Handle input delay */
    if (*inputDelay > 0) {
        (*inputDelay)--;
        return;
    }

    /* Menu navigation */
    if (buttonsPressed & 0x0800) {  /* D-pad Up */
        (*selectedItem)--;
        if (*selectedItem < 0) {
            *selectedItem = *itemCount - 1;
        }
        *inputDelay = 8;
        func_800B37E8(0x01, 0, NULL, 0);  /* Menu navigate sound */
    }

    if (buttonsPressed & 0x0400) {  /* D-pad Down */
        (*selectedItem)++;
        if (*selectedItem >= *itemCount) {
            *selectedItem = 0;
        }
        *inputDelay = 8;
        func_800B37E8(0x01, 0, NULL, 0);
    }

    /* Menu selection */
    if (buttonsPressed & 0x8000) {  /* A button */
        *inputDelay = 15;
        func_800B37E8(0x02, 0, NULL, 0);  /* Menu select sound */

        /* Handle menu item selection based on current menu */
        switch (*menuState) {
            case 0:  /* Main menu */
                switch (*selectedItem) {
                    case 0:  /* Race */
                        *menuState = 1;
                        *subMenu = 1;
                        *selectedItem = 0;
                        break;
                    case 1:  /* Time Trial */
                        *menuState = 2;
                        *subMenu = 2;
                        *selectedItem = 0;
                        break;
                    case 2:  /* Stunt Mode */
                        *menuState = 3;
                        *subMenu = 3;
                        *selectedItem = 0;
                        break;
                    case 3:  /* Battle */
                        *menuState = 4;
                        *subMenu = 4;
                        *selectedItem = 0;
                        break;
                    case 4:  /* Options */
                        *menuState = 10;
                        *subMenu = 10;
                        *selectedItem = 0;
                        break;
                }
                break;

            case 1:  /* Track select for Race */
            case 2:  /* Track select for Time Trial */
            case 3:  /* Track select for Stunt */
                /* Proceed to car select */
                *menuState = 20;
                D_80159A08 = *selectedItem;  /* Set selected track */
                *selectedItem = 0;
                break;

            case 20:  /* Car select */
                /* Start game */
                D_80159A0C = *selectedItem;  /* Set selected car */
                *menuState = 100;  /* Transition to game */
                break;
        }
    }

    /* Menu back */
    if (buttonsPressed & 0x4000) {  /* B button */
        *inputDelay = 15;
        func_800B37E8(0x03, 0, NULL, 0);  /* Menu back sound */

        if (*menuState == 0) {
            /* Already at main menu */
        } else if (*menuState >= 1 && *menuState <= 10) {
            *menuState = 0;  /* Back to main */
            *selectedItem = 0;
        } else if (*menuState == 20) {
            *menuState = *subMenu;  /* Back to track select */
            *selectedItem = 0;
        }
    }
}

/*

 * func_800CF06C (5748 bytes)
 * Menu render - draws menu UI elements
 */
void func_800CF06C(void *menu) {
    s32 *menuState;
    s32 *selectedItem;
    s32 *itemCount;
    s32 *animTimer;
    s32 i;
    s32 baseX, baseY;
    s32 itemY;
    u32 color;
    f32 selectPulse;

    if (menu == NULL) {
        return;
    }

    menuState = (s32 *)((u8 *)menu + 0x00);
    selectedItem = (s32 *)((u8 *)menu + 0x04);
    itemCount = (s32 *)((u8 *)menu + 0x08);
    animTimer = (s32 *)((u8 *)menu + 0x14);

    /* Calculate selection pulse animation */
    selectPulse = sinf((f32)(*animTimer) * 0.15f) * 0.3f + 0.7f;

    baseX = 80;
    baseY = 100;

    /* Draw menu background */
    func_800C813C(NULL, 0);

    /* Draw menu title based on state */
    switch (*menuState) {
        case 0:
            draw_text(baseX, 50, "RUSH 2049", 0xFF8800FF);
            break;
        case 1:
            draw_text(baseX, 50, "RACE - SELECT TRACK", 0xFF8800FF);
            break;
        case 2:
            draw_text(baseX, 50, "TIME TRIAL - SELECT TRACK", 0xFF8800FF);
            break;
        case 3:
            draw_text(baseX, 50, "STUNT MODE - SELECT TRACK", 0xFF8800FF);
            break;
        case 4:
            draw_text(baseX, 50, "BATTLE - SELECT ARENA", 0xFF8800FF);
            break;
        case 10:
            draw_text(baseX, 50, "OPTIONS", 0xFF8800FF);
            break;
        case 20:
            draw_text(baseX, 50, "SELECT CAR", 0xFF8800FF);
            break;
    }

    /* Draw menu items */
    for (i = 0; i < *itemCount && i < 8; i++) {
        itemY = baseY + i * 24;

        /* Set color based on selection */
        if (i == *selectedItem) {
            /* Selected item - pulsing yellow */
            u8 brightness = (u8)(selectPulse * 255.0f);
            color = (brightness << 24) | (brightness << 16) | 0x00FF;
        } else {
            /* Normal item - white */
            color = 0xFFFFFFFF;
        }

        /* Draw item based on menu state */
        switch (*menuState) {
            case 0:  /* Main menu */
                switch (i) {
                    case 0: draw_text(baseX, itemY, "RACE", color); break;
                    case 1: draw_text(baseX, itemY, "TIME TRIAL", color); break;
                    case 2: draw_text(baseX, itemY, "STUNT MODE", color); break;
                    case 3: draw_text(baseX, itemY, "BATTLE", color); break;
                    case 4: draw_text(baseX, itemY, "OPTIONS", color); break;
                }
                break;

            case 1:  /* Track select */
            case 2:
            case 3:
                switch (i) {
                    case 0: draw_text(baseX, itemY, "TRACK 1", color); break;
                    case 1: draw_text(baseX, itemY, "TRACK 2", color); break;
                    case 2: draw_text(baseX, itemY, "TRACK 3", color); break;
                    case 3: draw_text(baseX, itemY, "TRACK 4", color); break;
                    case 4: draw_text(baseX, itemY, "TRACK 5", color); break;
                    case 5: draw_text(baseX, itemY, "TRACK 6", color); break;
                }
                break;

            case 20:  /* Car select */
                switch (i) {
                    case 0: draw_text(baseX, itemY, "CAR 1", color); break;
                    case 1: draw_text(baseX, itemY, "CAR 2", color); break;
                    case 2: draw_text(baseX, itemY, "CAR 3", color); break;
                    case 3: draw_text(baseX, itemY, "CAR 4", color); break;
                }
                break;
        }

        /* Draw selection arrow */
        if (i == *selectedItem) {
            draw_text(baseX - 20, itemY, ">", color);
        }
    }

    /* Draw control hints at bottom */
    draw_text(40, 200, "A: Select  B: Back", 0x888888FF);
}

/*

 * func_800D0424(3040 bytes, 0)
 * Menu input handling - processes raw input for menu
 */
void func_800D0424(void *menu, void *input) {
    s32 *menuState;
    s32 *selectedItem;
    s32 *inputDelay;
    s8 stickX, stickY;
    u16 buttons;

    if (menu == NULL || input == NULL) {
        return;
    }

    menuState = (s32 *)((u8 *)menu + 0x00);
    selectedItem = (s32 *)((u8 *)menu + 0x04);
    inputDelay = (s32 *)((u8 *)menu + 0x10);

    /* Read analog stick */
    stickX = *((s8 *)((u8 *)input + 0x02));
    stickY = *((s8 *)((u8 *)input + 0x03));
    buttons = *((u16 *)((u8 *)input + 0x00));

    /* Handle input delay */
    if (*inputDelay > 0) {
        return;
    }

    /* Analog stick navigation */
    if (stickY > 50) {  /* Up */
        (*selectedItem)--;
        *inputDelay = 10;
    } else if (stickY < -50) {  /* Down */
        (*selectedItem)++;
        *inputDelay = 10;
    }

    /* Horizontal navigation for some menus */
    if (stickX > 50) {  /* Right */
        if (*menuState == 20) {  /* Car select - rotate car preview */
            s32 *carRotation = (s32 *)((u8 *)menu + 0x20);
            (*carRotation) += 5;
        }
    } else if (stickX < -50) {  /* Left */
        if (*menuState == 20) {
            s32 *carRotation = (s32 *)((u8 *)menu + 0x20);
            (*carRotation) -= 5;
        }
    }

    /* C-buttons for fast navigation */
    if (buttons & 0x0008) {  /* C-Up */
        *selectedItem = 0;  /* Jump to first */
        *inputDelay = 15;
    }
    if (buttons & 0x0004) {  /* C-Down */
        s32 *itemCount = (s32 *)((u8 *)menu + 0x08);
        *selectedItem = *itemCount - 1;  /* Jump to last */
        *inputDelay = 15;
    }

    /* L/R triggers for page navigation */
    if (buttons & 0x0020) {  /* L */
        *selectedItem -= 4;  /* Page up */
        *inputDelay = 15;
    }
    if (buttons & 0x0010) {  /* R */
        *selectedItem += 4;  /* Page down */
        *inputDelay = 15;
    }
}

/*

 * func_800D1004 (5196 bytes)
 * Track select menu - displays track selection screen
 */
void func_800D1004(void *menu) {
    s32 *selectedTrack;
    s32 *previewTimer;
    s32 trackCount;
    s32 i;
    f32 previewAngle;
    char trackName[32];
    char trackInfo[64];

    if (menu == NULL) {
        return;
    }

    selectedTrack = (s32 *)((u8 *)menu + 0x04);
    previewTimer = (s32 *)((u8 *)menu + 0x24);

    trackCount = 6;  /* Number of tracks */

    /* Update preview animation */
    (*previewTimer)++;
    previewAngle = (f32)(*previewTimer) * 0.02f;

    /* Clamp selection */
    if (*selectedTrack < 0) *selectedTrack = trackCount - 1;
    if (*selectedTrack >= trackCount) *selectedTrack = 0;

    /* Draw track preview (3D rotating miniature) */
    func_800A04C4(*selectedTrack, previewAngle, 160, 80);

    /* Draw track list */
    for (i = 0; i < trackCount; i++) {
        s32 y = 120 + i * 16;
        u32 color = (i == *selectedTrack) ? 0xFFFF00FF : 0xFFFFFFFF;

        switch (i) {
            case 0:
                draw_text(60, y, "MARINA", color);
                break;
            case 1:
                draw_text(60, y, "HAIGHT", color);
                break;
            case 2:
                draw_text(60, y, "METRO", color);
                break;
            case 3:
                draw_text(60, y, "MISSION", color);
                break;
            case 4:
                draw_text(60, y, "TENDERLOIN", color);
                break;
            case 5:
                draw_text(60, y, "ALCATRAZ", color);
                break;
        }
    }

    /* Draw track info for selected track */
    switch (*selectedTrack) {
        case 0:
            draw_text(180, 130, "BEGINNER", 0x00FF00FF);
            draw_text(180, 145, "LENGTH: SHORT", 0xAAAAAAFF);
            break;
        case 1:
            draw_text(180, 130, "INTERMEDIATE", 0xFFFF00FF);
            draw_text(180, 145, "LENGTH: MEDIUM", 0xAAAAAAFF);
            break;
        case 2:
            draw_text(180, 130, "ADVANCED", 0xFF8800FF);
            draw_text(180, 145, "LENGTH: LONG", 0xAAAAAAFF);
            break;
        case 3:
            draw_text(180, 130, "EXPERT", 0xFF0000FF);
            draw_text(180, 145, "LENGTH: MEDIUM", 0xAAAAAAFF);
            break;
        case 4:
            draw_text(180, 130, "EXTREME", 0xFF00FFFF);
            draw_text(180, 145, "LENGTH: LONG", 0xAAAAAAFF);
            break;
        case 5:
            draw_text(180, 130, "SECRET", 0x8888FFFF);
            draw_text(180, 145, "LENGTH: ???", 0xAAAAAAFF);
            break;
    }

    /* Draw best time for selected track */
    {
        s32 bestTime = *((s32 *)(0x80158000 + (*selectedTrack) * 4));
        if (bestTime > 0) {
            s32 mins = bestTime / 6000;
            s32 secs = (bestTime / 100) % 60;
            s32 cents = bestTime % 100;
            char timeStr[16];

            timeStr[0] = '0' + mins;
            timeStr[1] = ':';
            timeStr[2] = '0' + (secs / 10);
            timeStr[3] = '0' + (secs % 10);
            timeStr[4] = '.';
            timeStr[5] = '0' + (cents / 10);
            timeStr[6] = '0' + (cents % 10);
            timeStr[7] = '\0';

            draw_text(180, 170, "BEST:", 0x88FF88FF);
            draw_text(220, 170, timeStr, 0x88FF88FF);
        } else {
            draw_text(180, 170, "BEST: --:--.--", 0x888888FF);
        }
    }
}

/*

 * func_800D4DFC (1228 bytes)
 * Car select menu - displays car selection with stats
 */
void func_800D4DFC(void *menu) {
    s32 *selectedCar;
    s32 *carRotation;
    s32 *previewTimer;
    s32 carCount;
    s32 i;
    f32 rotAngle;

    if (menu == NULL) {
        return;
    }

    selectedCar = (s32 *)((u8 *)menu + 0x04);
    carRotation = (s32 *)((u8 *)menu + 0x20);
    previewTimer = (s32 *)((u8 *)menu + 0x24);

    carCount = 4;  /* Number of cars */

    /* Update preview animation */
    (*previewTimer)++;
    rotAngle = (f32)(*carRotation) * 0.0174533f;  /* Degrees to radians */

    /* Clamp selection */
    if (*selectedCar < 0) *selectedCar = carCount - 1;
    if (*selectedCar >= carCount) *selectedCar = 0;

    /* Draw 3D car preview (rotating) */
    func_800E7B44((f32[]){160.0f, 100.0f, 0.0f}, *selectedCar);

    /* Draw car name */
    switch (*selectedCar) {
        case 0:
            draw_text(120, 150, "RAZOR", 0xFFFF00FF);
            break;
        case 1:
            draw_text(120, 150, "VENOM", 0xFF0000FF);
            break;
        case 2:
            draw_text(120, 150, "STALLION", 0x00FF00FF);
            break;
        case 3:
            draw_text(120, 150, "PHANTOM", 0x8888FFFF);
            break;
    }

    /* Draw car stats */
    {
        s32 speed, accel, handling, weight;
        s32 statX = 60;
        s32 statY = 170;

        /* Car stats per vehicle */
        switch (*selectedCar) {
            case 0:  /* Razor - balanced */
                speed = 7; accel = 7; handling = 7; weight = 5;
                break;
            case 1:  /* Venom - speed focused */
                speed = 9; accel = 6; handling = 5; weight = 4;
                break;
            case 2:  /* Stallion - heavy hitter */
                speed = 6; accel = 5; handling = 6; weight = 9;
                break;
            case 3:  /* Phantom - agile */
                speed = 7; accel = 8; handling = 9; weight = 3;
                break;
            default:
                speed = 5; accel = 5; handling = 5; weight = 5;
                break;
        }

        /* Draw stat bars */
        draw_text(statX, statY, "SPEED:", 0xFFFFFFFF);
        for (i = 0; i < speed; i++) {
            draw_text(statX + 60 + i * 8, statY, "|", 0x00FF00FF);
        }

        draw_text(statX, statY + 12, "ACCEL:", 0xFFFFFFFF);
        for (i = 0; i < accel; i++) {
            draw_text(statX + 60 + i * 8, statY + 12, "|", 0xFFFF00FF);
        }

        draw_text(statX, statY + 24, "HANDLING:", 0xFFFFFFFF);
        for (i = 0; i < handling; i++) {
            draw_text(statX + 80 + i * 8, statY + 24, "|", 0x00FFFFFF);
        }

        draw_text(statX, statY + 36, "WEIGHT:", 0xFFFFFFFF);
        for (i = 0; i < weight; i++) {
            draw_text(statX + 70 + i * 8, statY + 36, "|", 0xFF8800FF);
        }
    }

    /* Draw navigation hints */
    draw_text(40, 220, "< > Rotate  A: Select  B: Back", 0x888888FF);
}

/*

 * func_800D52CC()
 * Empty stub
 */
void func_800D52CC() {
    /* Empty */
}

/*

 * func_800D5374 (332 bytes)
 * Options menu - game settings screen
 */
void func_800D5374(void *menu) {
    s32 *selectedOption;
    s32 optionCount;
    s32 i;
    u32 color;

    if (menu == NULL) {
        return;
    }

    selectedOption = (s32 *)((u8 *)menu + 0x04);
    optionCount = 5;

    /* Clamp selection */
    if (*selectedOption < 0) *selectedOption = optionCount - 1;
    if (*selectedOption >= optionCount) *selectedOption = 0;

    /* Draw title */
    draw_text(100, 50, "OPTIONS", 0xFF8800FF);

    /* Draw option items */
    for (i = 0; i < optionCount; i++) {
        s32 y = 90 + i * 20;
        color = (i == *selectedOption) ? 0xFFFF00FF : 0xFFFFFFFF;

        switch (i) {
            case 0:
                draw_text(60, y, "AUDIO", color);
                break;
            case 1:
                draw_text(60, y, "CONTROLS", color);
                break;
            case 2:
                draw_text(60, y, "DISPLAY", color);
                break;
            case 3:
                draw_text(60, y, "SAVE/LOAD", color);
                break;
            case 4:
                draw_text(60, y, "BACK", color);
                break;
        }
    }
}

/*

 * func_800D5524 (628 bytes)
 * Audio options - sound settings
 */
void func_800D5524(void *menu) {
    s32 *selectedOption;
    s32 *musicVolume;
    s32 *sfxVolume;
    s32 *stereo;
    s32 i;
    u32 color;

    if (menu == NULL) {
        return;
    }

    selectedOption = (s32 *)((u8 *)menu + 0x04);
    musicVolume = (s32 *)((u8 *)menu + 0x30);
    sfxVolume = (s32 *)((u8 *)menu + 0x34);
    stereo = (s32 *)((u8 *)menu + 0x38);

    /* Draw title */
    draw_text(100, 50, "AUDIO OPTIONS", 0xFF8800FF);

    /* Music volume */
    color = (*selectedOption == 0) ? 0xFFFF00FF : 0xFFFFFFFF;
    draw_text(60, 90, "MUSIC:", color);
    for (i = 0; i < 10; i++) {
        u32 barColor = (i < *musicVolume) ? 0x00FF00FF : 0x444444FF;
        draw_text(130 + i * 10, 90, "|", barColor);
    }

    /* SFX volume */
    color = (*selectedOption == 1) ? 0xFFFF00FF : 0xFFFFFFFF;
    draw_text(60, 110, "SFX:", color);
    for (i = 0; i < 10; i++) {
        u32 barColor = (i < *sfxVolume) ? 0x00FF00FF : 0x444444FF;
        draw_text(130 + i * 10, 110, "|", barColor);
    }

    /* Stereo toggle */
    color = (*selectedOption == 2) ? 0xFFFF00FF : 0xFFFFFFFF;
    draw_text(60, 130, "MODE:", color);
    if (*stereo) {
        draw_text(130, 130, "STEREO", 0x00FFFFFF);
    } else {
        draw_text(130, 130, "MONO", 0x888888FF);
    }

    /* Back */
    color = (*selectedOption == 3) ? 0xFFFF00FF : 0xFFFFFFFF;
    draw_text(60, 160, "BACK", color);

    /* Controls hint */
    draw_text(40, 200, "< > Adjust  A: Toggle  B: Back", 0x888888FF);
}

/*

 * func_800D5A04 (1704 bytes)
 * Controller config - button mapping screen
 */
void func_800D5A04(void *menu) {
    s32 *selectedOption;
    s32 *buttonMappings;
    s32 *waitingForInput;
    s32 i;
    u32 color;
    u16 buttonsPressed;

    if (menu == NULL) {
        return;
    }

    selectedOption = (s32 *)((u8 *)menu + 0x04);
    buttonMappings = (s32 *)((u8 *)menu + 0x40);
    waitingForInput = (s32 *)((u8 *)menu + 0x3C);

    buttonsPressed = D_801520A4;

    /* Draw title */
    draw_text(80, 50, "CONTROLLER CONFIG", 0xFF8800FF);

    /* Draw action labels */
    for (i = 0; i < 6; i++) {
        s32 y = 90 + i * 18;
        color = (i == *selectedOption) ? 0xFFFF00FF : 0xFFFFFFFF;

        switch (i) {
            case 0:
                draw_text(40, y, "ACCELERATE:", color);
                break;
            case 1:
                draw_text(40, y, "BRAKE:", color);
                break;
            case 2:
                draw_text(40, y, "NITRO:", color);
                break;
            case 3:
                draw_text(40, y, "WINGS:", color);
                break;
            case 4:
                draw_text(40, y, "LOOK BACK:", color);
                break;
            case 5:
                draw_text(40, y, "RESET:", color);
                break;
        }

        /* Show current mapping */
        if (*waitingForInput && i == *selectedOption) {
            draw_text(160, y, "PRESS BUTTON...", 0x00FF00FF);
        } else {
            switch (buttonMappings[i]) {
                case 0x8000: draw_text(160, y, "A", 0x888888FF); break;
                case 0x4000: draw_text(160, y, "B", 0x888888FF); break;
                case 0x2000: draw_text(160, y, "Z", 0x888888FF); break;
                case 0x0020: draw_text(160, y, "L", 0x888888FF); break;
                case 0x0010: draw_text(160, y, "R", 0x888888FF); break;
                case 0x0008: draw_text(160, y, "C-UP", 0x888888FF); break;
                case 0x0004: draw_text(160, y, "C-DOWN", 0x888888FF); break;
                case 0x0002: draw_text(160, y, "C-LEFT", 0x888888FF); break;
                case 0x0001: draw_text(160, y, "C-RIGHT", 0x888888FF); break;
                default: draw_text(160, y, "---", 0x888888FF); break;
            }
        }
    }

    /* Default/Back options */
    color = (*selectedOption == 6) ? 0xFFFF00FF : 0xFFFFFFFF;
    draw_text(40, 200, "DEFAULTS", color);
    color = (*selectedOption == 7) ? 0xFFFF00FF : 0xFFFFFFFF;
    draw_text(140, 200, "BACK", color);

    /* Handle input capture mode */
    if (*waitingForInput) {
        if (buttonsPressed != 0) {
            buttonMappings[*selectedOption] = buttonsPressed;
            *waitingForInput = 0;
            func_800B37E8(0x02, 0, NULL, 0);  /* Confirm sound */
        }
    }
}

/*

 * func_800D60AC (8 bytes)
 * Empty stub
 */
void func_800D60AC(void) {
    /* Empty */
}

/*

 * func_800D6160 (496 bytes)
 * Save/load menu - data management screen
 */
void func_800D6160(void *menu) {
    s32 *selectedOption;
    s32 *saveSlotSelected;
    s32 *operationPending;
    s32 i;
    u32 color;

    if (menu == NULL) {
        return;
    }

    selectedOption = (s32 *)((u8 *)menu + 0x04);
    saveSlotSelected = (s32 *)((u8 *)menu + 0x08);
    operationPending = (s32 *)((u8 *)menu + 0x0C);

    /* Draw title */
    draw_text(100, 50, "SAVE/LOAD", 0xFF8800FF);

    /* Draw save slots */
    for (i = 0; i < 4; i++) {
        s32 y = 90 + i * 24;
        s32 *slotData = (s32 *)(0x80158100 + i * 0x100);
        color = (i == *saveSlotSelected) ? 0xFFFF00FF : 0xFFFFFFFF;

        /* Slot number */
        draw_text(40, y, "SLOT", color);
        draw_text(80, y, (i == 0) ? "1" : (i == 1) ? "2" : (i == 2) ? "3" : "4", color);

        /* Slot status */
        if (slotData[0] == 0x52555348) {  /* "RUSH" magic */
            /* Show progress percentage */
            s32 progress = slotData[1];
            char progressStr[8];
            progressStr[0] = '0' + (progress / 10);
            progressStr[1] = '0' + (progress % 10);
            progressStr[2] = '%';
            progressStr[3] = '\0';
            draw_text(120, y, progressStr, 0x00FF00FF);
        } else {
            draw_text(120, y, "EMPTY", 0x888888FF);
        }
    }

    /* Operation buttons */
    color = (*selectedOption == 0) ? 0xFFFF00FF : 0xFFFFFFFF;
    draw_text(40, 190, "SAVE", color);

    color = (*selectedOption == 1) ? 0xFFFF00FF : 0xFFFFFFFF;
    draw_text(100, 190, "LOAD", color);

    color = (*selectedOption == 2) ? 0xFFFF00FF : 0xFFFFFFFF;
    draw_text(160, 190, "DELETE", color);

    color = (*selectedOption == 3) ? 0xFFFF00FF : 0xFFFFFFFF;
    draw_text(230, 190, "BACK", color);

    /* Show operation status */
    if (*operationPending) {
        draw_text(80, 210, "PLEASE WAIT...", 0x00FFFFFF);
    }
}

/*

 * func_800D6530 (4356 bytes)
 * Memory card operations - controller pak read/write
 */
void func_800D6530(s32 operation) {
    s32 *operationResult;
    s32 *currentSlot;
    void *saveBuffer;
    s32 result;
    OSPfs *pfs;

    operationResult = (s32 *)0x80158500;
    currentSlot = (s32 *)0x80158504;
    saveBuffer = (void *)0x80158600;
    pfs = (OSPfs *)0x80140000;

    *operationResult = 0;  /* Pending */

    switch (operation) {
        case 0:  /* Initialize/detect controller pak */
            result = osPfsInitPak(NULL, pfs, 0);
            if (result == 0) {
                *operationResult = 1;  /* Success */
            } else {
                *operationResult = -1;  /* No pak or error */
            }
            break;

        case 1:  /* Check free space */
            {
                s32 freePages;
                result = osPfsFreeBlocks(pfs, &freePages);
                if (result == 0) {
                    *operationResult = freePages;
                } else {
                    *operationResult = -2;
                }
            }
            break;

        case 2:  /* Save to current slot */
            {
                s32 slot = *currentSlot;
                s32 *slotData = (s32 *)(0x80158100 + slot * 0x100);

                /* Write magic number */
                slotData[0] = 0x52555348;  /* "RUSH" */

                /* Copy save data to slot buffer */
                slotData[1] = D_80159200;  /* Progress */
                slotData[2] = D_80159204;  /* Unlocks */
                slotData[3] = D_80159208;  /* Best times pointer */

                /* Write to controller pak */
                result = osPfsWriteFile(pfs, slot, 0, 0x100, (u8 *)slotData);
                if (result == 0) {
                    *operationResult = 1;
                    func_800B37E8(0x04, 0, NULL, 0);  /* Save complete sound */
                } else {
                    *operationResult = -3;
                    func_800B37E8(0x05, 0, NULL, 0);  /* Error sound */
                }
            }
            break;

        case 3:  /* Load from current slot */
            {
                s32 slot = *currentSlot;
                s32 *slotData = (s32 *)(0x80158100 + slot * 0x100);

                result = osPfsReadFile(pfs, slot, 0, 0x100, (u8 *)slotData);
                if (result == 0 && slotData[0] == 0x52555348) {
                    /* Restore game state */
                    D_80159200 = slotData[1];
                    D_80159204 = slotData[2];
                    *operationResult = 1;
                    func_800B37E8(0x04, 0, NULL, 0);
                } else {
                    *operationResult = -4;
                    func_800B37E8(0x05, 0, NULL, 0);
                }
            }
            break;

        case 4:  /* Delete slot */
            {
                s32 slot = *currentSlot;
                s32 *slotData = (s32 *)(0x80158100 + slot * 0x100);

                /* Clear magic number */
                slotData[0] = 0;

                result = osPfsDeleteFile(pfs, 0, slot);
                *operationResult = (result == 0) ? 1 : -5;
            }
            break;

        default:
            *operationResult = -10;  /* Unknown operation */
            break;
    }
}

/*

 * func_800D7634 (1804 bytes)
 * Profile management - player profile data
 */
void func_800D7634(void *profile) {
    s32 *profileId;
    char *playerName;
    s32 *totalRaces;
    s32 *wins;
    s32 *crashes;
    s32 *stuntsCompleted;
    s32 *bestLapTime;
    s32 *unlockedTracks;
    s32 *unlockedCars;

    if (profile == NULL) {
        return;
    }

    profileId = (s32 *)((u8 *)profile + 0x00);
    playerName = (char *)((u8 *)profile + 0x04);
    totalRaces = (s32 *)((u8 *)profile + 0x14);
    wins = (s32 *)((u8 *)profile + 0x18);
    crashes = (s32 *)((u8 *)profile + 0x1C);
    stuntsCompleted = (s32 *)((u8 *)profile + 0x20);
    bestLapTime = (s32 *)((u8 *)profile + 0x24);  /* Array of 6 tracks */
    unlockedTracks = (s32 *)((u8 *)profile + 0x40);
    unlockedCars = (s32 *)((u8 *)profile + 0x44);

    /* Initialize new profile */
    if (*profileId == 0) {
        *profileId = D_80159A20;  /* Use frame counter as ID */

        /* Default name "PLAYER" */
        playerName[0] = 'P';
        playerName[1] = 'L';
        playerName[2] = 'A';
        playerName[3] = 'Y';
        playerName[4] = 'E';
        playerName[5] = 'R';
        playerName[6] = '\0';

        *totalRaces = 0;
        *wins = 0;
        *crashes = 0;
        *stuntsCompleted = 0;

        /* No best times yet */
        for (s32 i = 0; i < 6; i++) {
            bestLapTime[i] = 0;
        }

        /* Start with first track and car unlocked */
        *unlockedTracks = 0x01;  /* Track 1 */
        *unlockedCars = 0x01;    /* Car 1 */
    }

    /* Calculate win percentage */
    {
        s32 winPercent = 0;
        if (*totalRaces > 0) {
            winPercent = (*wins * 100) / *totalRaces;
        }
        *((s32 *)((u8 *)profile + 0x48)) = winPercent;
    }

    /* Calculate total stunts score */
    {
        s32 totalStuntScore = 0;
        s32 *stuntScores = (s32 *)((u8 *)profile + 0x80);
        for (s32 i = 0; i < 16; i++) {
            totalStuntScore += stuntScores[i];
        }
        *((s32 *)((u8 *)profile + 0x4C)) = totalStuntScore;
    }
}

/*

 * func_800D91A0 (8260 bytes)
 * Garage/car customization - car modification screen
 */
void func_800D91A0(void *garage) {
    s32 *selectedCar;
    s32 *selectedOption;
    s32 *carRotation;
    s32 *animTimer;
    s32 i;
    u32 color;
    f32 rotAngle;

    if (garage == NULL) {
        return;
    }

    selectedCar = (s32 *)((u8 *)garage + 0x00);
    selectedOption = (s32 *)((u8 *)garage + 0x04);
    carRotation = (s32 *)((u8 *)garage + 0x08);
    animTimer = (s32 *)((u8 *)garage + 0x0C);

    /* Update animation */
    (*animTimer)++;
    (*carRotation) += 1;
    rotAngle = (f32)(*carRotation) * 0.0174533f;

    /* Draw title */
    draw_text(100, 30, "GARAGE", 0xFF8800FF);

    /* Draw 3D car model (rotating) */
    {
        f32 carPos[3] = {160.0f, 100.0f, 0.0f};
        func_800E7B44(carPos, *selectedCar);
    }

    /* Draw car name */
    draw_text(120, 150, "CAR NAME", 0xFFFFFFFF);

    /* Draw customization options */
    for (i = 0; i < 5; i++) {
        s32 y = 170 + i * 16;
        color = (i == *selectedOption) ? 0xFFFF00FF : 0xFFFFFFFF;

        switch (i) {
            case 0:
                draw_text(60, y, "PAINT", color);
                break;
            case 1:
                draw_text(60, y, "WHEELS", color);
                break;
            case 2:
                draw_text(60, y, "WINGS", color);
                break;
            case 3:
                draw_text(60, y, "SPOILER", color);
                break;
            case 4:
                draw_text(60, y, "BACK", color);
                break;
        }

        /* Show current selection for each option */
        if (i < 4) {
            s32 *carOptions = (s32 *)((u8 *)garage + 0x20 + i * 4);
            char numStr[4];
            numStr[0] = '0' + (*carOptions);
            numStr[1] = '\0';
            draw_text(180, y, numStr, 0x888888FF);
        }
    }

    /* Draw car stats */
    {
        s32 statX = 200;
        s32 statY = 170;

        draw_text(statX, statY, "SPD:", 0x888888FF);
        draw_text(statX, statY + 12, "ACC:", 0x888888FF);
        draw_text(statX, statY + 24, "HND:", 0x888888FF);
    }

    /* Draw controls hint */
    draw_text(30, 230, "< > Change  A: Select  B: Back", 0x888888FF);
}

/*

 * func_800DB1E0 (1524 bytes)
 * Paint selection - applies paint color to car
 */
void func_800DB1E0(void *car, s32 paintId) {
    u32 *carColor;
    u32 *carSecondary;
    u32 *carMetallic;
    s32 *unlocked;

    if (car == NULL) {
        return;
    }

    /* Check if paint is unlocked */
    unlocked = (s32 *)0x80159204;
    if (paintId >= 8 && !((*unlocked >> (40 + paintId - 8)) & 1)) {
        return;  /* Paint not unlocked */
    }

    carColor = (u32 *)((u8 *)car + 0x200);
    carSecondary = (u32 *)((u8 *)car + 0x204);
    carMetallic = (u32 *)((u8 *)car + 0x208);

    /* Predefined paint colors */
    switch (paintId) {
        case 0:  /* Red */
            *carColor = 0xFF0000FF;
            *carSecondary = 0x880000FF;
            *carMetallic = 0;
            break;
        case 1:  /* Blue */
            *carColor = 0x0000FFFF;
            *carSecondary = 0x000088FF;
            *carMetallic = 0;
            break;
        case 2:  /* Green */
            *carColor = 0x00FF00FF;
            *carSecondary = 0x008800FF;
            *carMetallic = 0;
            break;
        case 3:  /* Yellow */
            *carColor = 0xFFFF00FF;
            *carSecondary = 0x888800FF;
            *carMetallic = 0;
            break;
        case 4:  /* Orange */
            *carColor = 0xFF8800FF;
            *carSecondary = 0x884400FF;
            *carMetallic = 0;
            break;
        case 5:  /* Purple */
            *carColor = 0x8800FFFF;
            *carSecondary = 0x440088FF;
            *carMetallic = 0;
            break;
        case 6:  /* White */
            *carColor = 0xFFFFFFFF;
            *carSecondary = 0xCCCCCCFF;
            *carMetallic = 0;
            break;
        case 7:  /* Black */
            *carColor = 0x222222FF;
            *carSecondary = 0x111111FF;
            *carMetallic = 0;
            break;
        case 8:  /* Chrome (unlockable) */
            *carColor = 0xCCCCCCFF;
            *carSecondary = 0xAAAAAAFF;
            *carMetallic = 1;
            break;
        case 9:  /* Gold (unlockable) */
            *carColor = 0xFFD700FF;
            *carSecondary = 0xDAA520FF;
            *carMetallic = 1;
            break;
        case 10:  /* Rainbow (unlockable) */
            *carColor = 0xFFFFFFFF;  /* Special shader flag */
            *carSecondary = 0x00000000;
            *carMetallic = 2;  /* Rainbow mode */
            break;
        default:
            *carColor = 0x888888FF;
            *carSecondary = 0x444444FF;
            *carMetallic = 0;
            break;
    }

    /* Store selected paint */
    *((s32 *)((u8 *)car + 0x20C)) = paintId;
}

/*

 * func_800E114C (1012 bytes)
 * Replay system update
 *
 * Updates the replay system - handles recording or playback.
 * Manages frame buffer, timing, and input sync.
 */
void func_800E114C(void *replay) {
    s32 *mode, *frameIndex, *maxFrames;
    s32 *recordBuffer;
    f32 *playbackSpeed;
    s32 currentFrame;

    if (replay == NULL) {
        return;
    }

    mode = (s32 *)((u8 *)replay + 0x00);  /* 0=off, 1=record, 2=playback */
    frameIndex = (s32 *)((u8 *)replay + 0x04);
    maxFrames = (s32 *)((u8 *)replay + 0x08);
    recordBuffer = (s32 *)((u8 *)replay + 0x10);
    playbackSpeed = (f32 *)((u8 *)replay + 0x0C);

    switch (*mode) {
        case 0:  /* Off */
            break;

        case 1:  /* Recording */
            if (*frameIndex < *maxFrames) {
                /* Record current frame data */
                func_800E1AA0(replay, (void *)(*frameIndex));
                (*frameIndex)++;
            } else {
                /* Buffer full, stop recording */
                *mode = 0;
            }
            break;

        case 2:  /* Playback */
            currentFrame = *frameIndex;

            /* Advance playback with speed control */
            currentFrame += (s32)(*playbackSpeed * 1.0f);

            if (currentFrame < 0) {
                currentFrame = 0;
            }
            if (currentFrame >= *maxFrames) {
                /* Loop or stop */
                currentFrame = 0;  /* Loop for now */
            }

            *frameIndex = currentFrame;

            /* Apply recorded frame data */
            func_800E15A0(replay);
            break;
    }
}

/*

 * func_800E15A0 (1280 bytes)
 * Replay playback
 *
 * Applies recorded frame data to all cars during replay playback.
 * Interpolates between frames for smooth motion.
 */
void func_800E15A0(void *replay) {
    s32 *frameIndex, *maxFrames;
    void *frameData;
    s32 currentFrame, nextFrame;
    f32 *playbackSpeed;
    f32 t;  /* Interpolation factor */
    s32 i, numCars;
    void **carList;

    if (replay == NULL) {
        return;
    }

    frameIndex = (s32 *)((u8 *)replay + 0x04);
    maxFrames = (s32 *)((u8 *)replay + 0x08);
    playbackSpeed = (f32 *)((u8 *)replay + 0x0C);
    carList = (void **)((u8 *)replay + 0x100);
    numCars = *(s32 *)((u8 *)replay + 0xFC);

    currentFrame = *frameIndex;
    nextFrame = currentFrame + 1;
    if (nextFrame >= *maxFrames) {
        nextFrame = currentFrame;
    }

    /* Calculate interpolation factor */
    t = (*playbackSpeed) - (f32)(s32)(*playbackSpeed);
    if (t < 0.0f) t = 0.0f;
    if (t > 1.0f) t = 1.0f;

    /* Apply frame data to each car */
    for (i = 0; i < numCars && i < 8; i++) {
        void *car = carList[i];
        f32 *carPos, *carRot, *carVel;
        f32 *framePos, *nextPos;
        s32 frameOffset;

        if (car == NULL) {
            continue;
        }

        carPos = (f32 *)((u8 *)car + 0x24);
        carRot = (f32 *)((u8 *)car + 0x60);
        carVel = (f32 *)((u8 *)car + 0x34);

        /* Calculate frame data offset */
        /* Each frame stores: pos(3), rot(4 quat), vel(3), inputs(2) = 12 floats per car */
        frameOffset = 0x200 + (currentFrame * numCars * 48) + (i * 48);
        framePos = (f32 *)((u8 *)replay + frameOffset);
        nextPos = (f32 *)((u8 *)replay + frameOffset + (numCars * 48));

        if (currentFrame == nextFrame) {
            /* No interpolation needed */
            carPos[0] = framePos[0];
            carPos[1] = framePos[1];
            carPos[2] = framePos[2];
        } else {
            /* Linear interpolation */
            carPos[0] = framePos[0] + (nextPos[0] - framePos[0]) * t;
            carPos[1] = framePos[1] + (nextPos[1] - framePos[1]) * t;
            carPos[2] = framePos[2] + (nextPos[2] - framePos[2]) * t;

            carVel[0] = framePos[7] + (nextPos[7] - framePos[7]) * t;
            carVel[1] = framePos[8] + (nextPos[8] - framePos[8]) * t;
            carVel[2] = framePos[9] + (nextPos[9] - framePos[9]) * t;
        }

        /* Apply quaternion rotation (simplified - just copy for now) */
        carRot[0] = framePos[3];
        carRot[1] = framePos[4];
        carRot[2] = framePos[5];
    }
}

/*

 * func_800E1AA0(404 bytes, 0)
 * Replay record frame
 *
 * Records the current game state into the replay buffer.
 * Captures car positions, rotations, velocities, and inputs.
 */
void func_800E1AA0(void *replay, void *frame) {
    s32 *frameIndex;
    s32 i, numCars;
    void **carList;
    s32 frameOffset;

    if (replay == NULL) {
        return;
    }

    frameIndex = (s32 *)((u8 *)replay + 0x04);
    carList = (void **)((u8 *)replay + 0x100);
    numCars = *(s32 *)((u8 *)replay + 0xFC);

    /* Record each car's state */
    for (i = 0; i < numCars && i < 8; i++) {
        void *car = carList[i];
        f32 *carPos, *carRot, *carVel;
        f32 *frameData;
        f32 steer, throttle;

        if (car == NULL) {
            continue;
        }

        carPos = (f32 *)((u8 *)car + 0x24);
        carRot = (f32 *)((u8 *)car + 0x60);
        carVel = (f32 *)((u8 *)car + 0x34);
        steer = *(f32 *)((u8 *)car + 0xFC);
        throttle = *(f32 *)((u8 *)car + 0x100);

        /* Calculate frame data offset */
        frameOffset = 0x200 + (*frameIndex * numCars * 48) + (i * 48);
        frameData = (f32 *)((u8 *)replay + frameOffset);

        /* Store position */
        frameData[0] = carPos[0];
        frameData[1] = carPos[1];
        frameData[2] = carPos[2];

        /* Store rotation (forward vector) */
        frameData[3] = carRot[0];
        frameData[4] = carRot[1];
        frameData[5] = carRot[2];
        frameData[6] = 1.0f;  /* Placeholder for W component */

        /* Store velocity */
        frameData[7] = carVel[0];
        frameData[8] = carVel[1];
        frameData[9] = carVel[2];

        /* Store inputs */
        frameData[10] = steer;
        frameData[11] = throttle;
    }
}

/*

 * func_800E1C30(1908 bytes, 0)
 * Replay camera control - cinematic camera during replay
 */
void func_800E1C30(void *replay, void *camera) {
    s32 *cameraMode;
    s32 *cameraTimer;
    s32 *targetCar;
    f32 *camPos;
    f32 *camTarget;
    f32 *carPos;
    f32 *carVel;
    f32 t;
    f32 orbitAngle;

    if (replay == NULL || camera == NULL) {
        return;
    }

    cameraMode = (s32 *)((u8 *)replay + 0x80);
    cameraTimer = (s32 *)((u8 *)replay + 0x84);
    targetCar = (s32 *)((u8 *)replay + 0x88);
    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);

    /* Get target car position */
    carPos = (f32 *)(0x80152818 + (*targetCar) * 0x400 + 0x24);
    carVel = (f32 *)(0x80152818 + (*targetCar) * 0x400 + 0x34);

    /* Update camera timer */
    (*cameraTimer)++;

    /* Auto-switch camera mode every 5 seconds */
    if (*cameraTimer > 300) {
        *cameraMode = (*cameraMode + 1) % 5;
        *cameraTimer = 0;
    }

    t = (f32)(*cameraTimer) / 300.0f;

    switch (*cameraMode) {
        case 0:  /* Chase cam */
            {
                f32 speed = sqrtf(carVel[0] * carVel[0] + carVel[2] * carVel[2]);
                f32 dirX = (speed > 0.1f) ? carVel[0] / speed : 0.0f;
                f32 dirZ = (speed > 0.1f) ? carVel[2] / speed : 1.0f;

                camPos[0] = carPos[0] - dirX * 80.0f;
                camPos[1] = carPos[1] + 30.0f;
                camPos[2] = carPos[2] - dirZ * 80.0f;

                camTarget[0] = carPos[0] + dirX * 20.0f;
                camTarget[1] = carPos[1] + 5.0f;
                camTarget[2] = carPos[2] + dirZ * 20.0f;
            }
            break;

        case 1:  /* Orbit cam */
            orbitAngle = t * 6.28318f;
            camPos[0] = carPos[0] + sinf(orbitAngle) * 100.0f;
            camPos[1] = carPos[1] + 40.0f;
            camPos[2] = carPos[2] + cosf(orbitAngle) * 100.0f;

            camTarget[0] = carPos[0];
            camTarget[1] = carPos[1] + 10.0f;
            camTarget[2] = carPos[2];
            break;

        case 2:  /* Helicopter cam */
            camPos[0] = carPos[0];
            camPos[1] = carPos[1] + 200.0f;
            camPos[2] = carPos[2] + 50.0f;

            camTarget[0] = carPos[0];
            camTarget[1] = carPos[1];
            camTarget[2] = carPos[2];
            break;

        case 3:  /* Front cam */
            {
                f32 speed = sqrtf(carVel[0] * carVel[0] + carVel[2] * carVel[2]);
                f32 dirX = (speed > 0.1f) ? carVel[0] / speed : 0.0f;
                f32 dirZ = (speed > 0.1f) ? carVel[2] / speed : 1.0f;

                camPos[0] = carPos[0] + dirX * 60.0f;
                camPos[1] = carPos[1] + 15.0f;
                camPos[2] = carPos[2] + dirZ * 60.0f;

                camTarget[0] = carPos[0];
                camTarget[1] = carPos[1] + 5.0f;
                camTarget[2] = carPos[2];
            }
            break;

        case 4:  /* Wide angle */
            camPos[0] = carPos[0] + 150.0f;
            camPos[1] = carPos[1] + 80.0f;
            camPos[2] = carPos[2] + 150.0f;

            camTarget[0] = carPos[0];
            camTarget[1] = carPos[1];
            camTarget[2] = carPos[2];
            break;
    }
}

/*

 * func_800E23A4 (1680 bytes)
 * Replay UI - displays replay controls and info
 */
void func_800E23A4(void *replay) {
    s32 *playbackState;
    s32 *currentFrame;
    s32 *totalFrames;
    s32 *playbackSpeed;
    s32 *cameraMode;
    f32 progressPercent;
    s32 timeMs;
    char timeStr[12];

    if (replay == NULL) {
        return;
    }

    playbackState = (s32 *)((u8 *)replay + 0x00);
    currentFrame = (s32 *)((u8 *)replay + 0x04);
    totalFrames = (s32 *)((u8 *)replay + 0x08);
    playbackSpeed = (s32 *)((u8 *)replay + 0x8C);
    cameraMode = (s32 *)((u8 *)replay + 0x80);

    /* Calculate progress */
    if (*totalFrames > 0) {
        progressPercent = (f32)(*currentFrame) / (f32)(*totalFrames);
    } else {
        progressPercent = 0.0f;
    }

    /* Draw replay header */
    draw_text(110, 20, "REPLAY", 0xFF8800FF);

    /* Draw playback state */
    if (*playbackState == 0) {
        draw_text(10, 210, "PAUSED", 0xFFFF00FF);
    } else if (*playbackState == 1) {
        if (*playbackSpeed == 1) {
            draw_text(10, 210, "PLAYING", 0x00FF00FF);
        } else if (*playbackSpeed == 2) {
            draw_text(10, 210, "2x SPEED", 0x00FF00FF);
        } else if (*playbackSpeed == -1) {
            draw_text(10, 210, "REWIND", 0x00FFFFFF);
        }
    }

    /* Draw progress bar */
    {
        s32 barX = 40;
        s32 barY = 225;
        s32 barWidth = 200;
        s32 barHeight = 4;
        s32 progressWidth = (s32)(progressPercent * barWidth);

        /* Background */
        func_800C813C(NULL, 10);  /* Dark bar */

        /* Progress fill */
        func_800C813C(NULL, 11);  /* Progress bar */
    }

    /* Draw current time */
    timeMs = (*currentFrame * 100) / 60;  /* Convert frames to centiseconds */
    {
        s32 mins = timeMs / 6000;
        s32 secs = (timeMs / 100) % 60;
        s32 cents = timeMs % 100;

        timeStr[0] = '0' + (mins / 10);
        timeStr[1] = '0' + (mins % 10);
        timeStr[2] = ':';
        timeStr[3] = '0' + (secs / 10);
        timeStr[4] = '0' + (secs % 10);
        timeStr[5] = '.';
        timeStr[6] = '0' + (cents / 10);
        timeStr[7] = '0' + (cents % 10);
        timeStr[8] = '\0';

        draw_text(250, 210, timeStr, 0xFFFFFFFF);
    }

    /* Draw camera mode indicator */
    switch (*cameraMode) {
        case 0: draw_text(250, 20, "CHASE", 0x888888FF); break;
        case 1: draw_text(250, 20, "ORBIT", 0x888888FF); break;
        case 2: draw_text(250, 20, "HELI", 0x888888FF); break;
        case 3: draw_text(250, 20, "FRONT", 0x888888FF); break;
        case 4: draw_text(250, 20, "WIDE", 0x888888FF); break;
    }

    /* Draw controls hint */
    draw_text(50, 230, "A:Play/Pause B:Exit C:Camera L/R:Speed", 0x666666FF);
}

/*

 * func_800E0050 (1440 bytes)
 * Weather effect system
 *
 * Updates weather effects (rain, snow, fog).
 * Controls intensity, wind, and transitions.
 */
void func_800E0050(void *weather) {
    s32 *weatherType, *intensity;
    f32 *windDir, *windSpeed;
    f32 *transitionTimer, *targetIntensity;
    s32 type;

    if (weather == NULL) {
        return;
    }

    weatherType = (s32 *)((u8 *)weather + 0x00);
    intensity = (s32 *)((u8 *)weather + 0x04);
    windDir = (f32 *)((u8 *)weather + 0x08);
    windSpeed = (f32 *)((u8 *)weather + 0x14);
    transitionTimer = (f32 *)((u8 *)weather + 0x18);
    targetIntensity = (f32 *)((u8 *)weather + 0x1C);

    type = *weatherType;

    /* Handle weather transitions */
    if (*transitionTimer > 0.0f) {
        *transitionTimer -= 1.0f / 60.0f;
        f32 currentInt = (f32)(*intensity);
        currentInt += (*targetIntensity - currentInt) * 0.02f;
        *intensity = (s32)currentInt;
    }

    /* Update wind direction slightly */
    windDir[0] += (((D_80159A20 & 0xFF) / 255.0f) - 0.5f) * 0.01f;
    windDir[2] += (((D_80159A20 >> 8 & 0xFF) / 255.0f) - 0.5f) * 0.01f;

    /* Normalize wind direction */
    f32 windLen = sqrtf(windDir[0] * windDir[0] + windDir[2] * windDir[2]);
    if (windLen > 0.001f) {
        windDir[0] /= windLen;
        windDir[2] /= windLen;
    }

    /* Apply weather effects based on type */
    switch (type) {
        case 0:  /* Clear */
            break;

        case 1:  /* Rain */
            func_800E05F0((f32)(*intensity) / 100.0f);
            break;

        case 2:  /* Snow */
            /* Snow would use different particles */
            break;

        case 3:  /* Fog */
            /* Fog adjusts render distance and adds overlay */
            break;
    }
}

/*

 * func_800E05F0 (1328 bytes)
 * Rain effect rendering
 *
 * Renders rain droplets as falling particles.
 * Adjusts density based on intensity.
 */
void func_800E05F0(f32 intensity) {
    s32 numDrops;
    s32 i;
    f32 *cameraPos;
    f32 dropX, dropY, dropZ;
    f32 dropLen;
    s32 seed;

    if (intensity <= 0.0f) {
        return;
    }

    /* Get camera position for culling */
    cameraPos = (f32 *)0x80161000;

    /* Number of drops based on intensity */
    numDrops = (s32)(intensity * 200.0f);
    if (numDrops < 10) numDrops = 10;
    if (numDrops > 200) numDrops = 200;

    /* Initialize random seed from frame counter */
    seed = D_80159A20;

    for (i = 0; i < numDrops; i++) {
        /* Generate pseudo-random position around camera */
        seed = seed * 1103515245 + 12345;
        dropX = cameraPos[0] + ((seed >> 16) & 0xFF) - 128.0f;

        seed = seed * 1103515245 + 12345;
        dropY = cameraPos[1] + ((seed >> 16) & 0xFF) * 0.5f;

        seed = seed * 1103515245 + 12345;
        dropZ = cameraPos[2] + ((seed >> 16) & 0xFF) - 128.0f;

        /* Rain drop length based on speed */
        dropLen = 2.0f + intensity * 3.0f;

        /* Render rain drop as line (simplified) */
        /* In actual game, this would use the graphics display list */
        draw_ui_element(0, 0, 0, 0, 0, 0);
    }
}

/*

 * func_800E0B20 (1576 bytes)
 * Particle system update
 *
 * Updates all active particles in the system.
 * Handles physics, lifetime, and rendering.
 */
void func_800E0B20(void *particles) {
    s32 *pool;
    s32 maxParticles, i;
    f32 gravity, drag;

    if (particles == NULL) {
        return;
    }

    pool = (s32 *)((u8 *)particles + 0x00);
    maxParticles = *(s32 *)((u8 *)particles + 0x100);
    gravity = -0.5f;
    drag = 0.98f;

    if (maxParticles > 256) maxParticles = 256;

    for (i = 0; i < maxParticles; i++) {
        s32 *particle = &pool[i * 16];
        s32 active = particle[0];
        s32 lifetime = particle[7];
        s32 type = particle[8];
        f32 *pos, *vel;

        if (!active) {
            continue;
        }

        pos = (f32 *)&particle[1];
        vel = (f32 *)&particle[4];

        /* Decrease lifetime */
        lifetime--;
        if (lifetime <= 0) {
            particle[0] = 0;  /* Deactivate */
            continue;
        }
        particle[7] = lifetime;

        /* Apply physics based on type */
        switch (type) {
            case 0:  /* Dust/smoke - rises slowly, drifts */
                vel[1] += 0.02f;
                vel[0] *= 0.95f;
                vel[2] *= 0.95f;
                break;

            case 1:  /* Sparks - gravity, bounces */
                vel[1] += gravity;
                break;

            case 2:  /* Debris - heavy gravity */
                vel[1] += gravity * 2.0f;
                break;

            case 3:  /* Water splash - rises then falls */
                if (lifetime > 15) {
                    vel[1] += 0.1f;
                } else {
                    vel[1] += gravity;
                }
                break;
        }

        /* Apply drag */
        vel[0] *= drag;
        vel[1] *= drag;
        vel[2] *= drag;

        /* Update position */
        pos[0] += vel[0];
        pos[1] += vel[1];
        pos[2] += vel[2];

        /* Kill if below ground */
        if (pos[1] < -100.0f) {
            particle[0] = 0;
        }
    }
}

/*

 * func_800E15A8 (1176 bytes)
 * Explosion effect
 *
 * Creates an explosion at the given position.
 * Spawns particles, camera shake, and sound.
 */
void func_800E15A8(f32 *pos, f32 size) {
    s32 *particlePool;
    s32 *particleIndex;
    s32 numParticles, i;
    f32 angle, speed;
    s32 seed;

    if (pos == NULL || size <= 0.0f) {
        return;
    }

    particlePool = (s32 *)0x80162000;
    particleIndex = (s32 *)0x80162100;

    /* Number of particles based on size */
    numParticles = (s32)(size * 20.0f);
    if (numParticles < 5) numParticles = 5;
    if (numParticles > 50) numParticles = 50;

    seed = D_80159A20;

    /* Spawn explosion particles */
    for (i = 0; i < numParticles; i++) {
        s32 *particle = &particlePool[(*particleIndex) * 16];

        /* Activate particle */
        particle[0] = 1;

        /* Set position at explosion center */
        *(f32 *)&particle[1] = pos[0];
        *(f32 *)&particle[2] = pos[1];
        *(f32 *)&particle[3] = pos[2];

        /* Random outward velocity */
        seed = seed * 1103515245 + 12345;
        angle = ((seed >> 16) & 0xFFFF) / 65535.0f * 6.28318f;

        seed = seed * 1103515245 + 12345;
        speed = size * (0.5f + ((seed >> 16) & 0xFF) / 255.0f);

        *(f32 *)&particle[4] = cosf(angle) * speed;
        *(f32 *)&particle[5] = ((seed >> 8) & 0xFF) / 255.0f * size;
        *(f32 *)&particle[6] = sinf(angle) * speed;

        /* Lifetime */
        particle[7] = 30 + (seed & 0x1F);

        /* Type: debris or spark */
        particle[8] = (i < numParticles / 2) ? 2 : 1;

        (*particleIndex) = ((*particleIndex) + 1) % 64;
    }

    /* Camera shake based on size */
    void *camera = (void *)D_80152800;
    if (camera != NULL) {
        func_800BF0A4(camera, size * 0.5f, 0.5f);
    }

    /* Play explosion sound */
    func_80094A54(0x30, (s32)(size * 50.0f));
}

/*

 * func_800E1F80 (984 bytes)
 * Debris spawning
 *
 * Spawns debris particles from a car (crash, damage, etc.)
 */
void func_800E1F80(void *car, s32 debrisType) {
    f32 *carPos, *carVel;
    s32 *particlePool;
    s32 *particleIndex;
    s32 numDebris, i;
    f32 angle, speed;
    s32 seed;

    if (car == NULL) {
        return;
    }

    carPos = (f32 *)((u8 *)car + 0x24);
    carVel = (f32 *)((u8 *)car + 0x34);

    particlePool = (s32 *)0x80162000;
    particleIndex = (s32 *)0x80162100;

    /* Number of debris based on type */
    switch (debrisType) {
        case 0:  /* Minor scrape */
            numDebris = 3;
            break;
        case 1:  /* Medium impact */
            numDebris = 8;
            break;
        case 2:  /* Major crash */
            numDebris = 15;
            break;
        default:
            numDebris = 5;
    }

    seed = D_80159A20;

    for (i = 0; i < numDebris; i++) {
        s32 *particle = &particlePool[(*particleIndex) * 16];

        particle[0] = 1;  /* Active */

        /* Position at car */
        *(f32 *)&particle[1] = carPos[0];
        *(f32 *)&particle[2] = carPos[1] + 1.0f;
        *(f32 *)&particle[3] = carPos[2];

        /* Velocity: inherit car velocity plus random scatter */
        seed = seed * 1103515245 + 12345;
        angle = ((seed >> 16) & 0xFFFF) / 65535.0f * 6.28318f;
        speed = 2.0f + ((seed >> 8) & 0xFF) / 255.0f * 5.0f;

        *(f32 *)&particle[4] = carVel[0] * 0.5f + cosf(angle) * speed;
        *(f32 *)&particle[5] = 3.0f + ((seed & 0xFF) / 255.0f * 5.0f);
        *(f32 *)&particle[6] = carVel[2] * 0.5f + sinf(angle) * speed;

        /* Lifetime */
        particle[7] = 45 + (seed & 0x1F);

        /* Type: debris */
        particle[8] = 2;

        (*particleIndex) = ((*particleIndex) + 1) % 64;
    }

    /* Play debris sound */
    func_80094A54(0x28, 80);
}

/*

 * func_800E2F00 (716 bytes)
 * Spark effect
 *
 * Creates sparks at a position with given velocity.
 * Used for metal-on-metal impacts and scraping.
 */
void func_800E2F00(f32 *pos, f32 *velocity) {
    s32 *particlePool;
    s32 *particleIndex;
    s32 i, numSparks;
    f32 baseVelX, baseVelY, baseVelZ;
    s32 seed;

    if (pos == NULL) {
        return;
    }

    particlePool = (s32 *)0x80162000;
    particleIndex = (s32 *)0x80162100;

    numSparks = 5 + (D_80159A20 & 0x7);
    seed = D_80159A20;

    if (velocity != NULL) {
        baseVelX = velocity[0];
        baseVelY = velocity[1];
        baseVelZ = velocity[2];
    } else {
        baseVelX = 0.0f;
        baseVelY = 2.0f;
        baseVelZ = 0.0f;
    }

    for (i = 0; i < numSparks; i++) {
        s32 *particle = &particlePool[(*particleIndex) * 16];

        particle[0] = 1;  /* Active */

        /* Position */
        *(f32 *)&particle[1] = pos[0];
        *(f32 *)&particle[2] = pos[1];
        *(f32 *)&particle[3] = pos[2];

        /* Random velocity scatter */
        seed = seed * 1103515245 + 12345;
        *(f32 *)&particle[4] = baseVelX + ((seed >> 16 & 0xFF) - 128) / 64.0f;
        *(f32 *)&particle[5] = baseVelY + ((seed >> 8 & 0xFF)) / 64.0f;
        *(f32 *)&particle[6] = baseVelZ + ((seed & 0xFF) - 128) / 64.0f;

        /* Short lifetime for sparks */
        particle[7] = 10 + (seed & 0xF);

        /* Type: spark */
        particle[8] = 1;

        (*particleIndex) = ((*particleIndex) + 1) % 64;
    }
}

/*

 * func_800E31D4 (248 bytes)
 * Smoke puff
 *
 * Creates a single smoke puff at the given position.
 * Used for engine smoke, tire smoke, etc.
 */
void func_800E31D4(f32 *pos, f32 size) {
    s32 *particlePool;
    s32 *particleIndex;
    s32 *particle;
    s32 seed;

    if (pos == NULL || size <= 0.0f) {
        return;
    }

    particlePool = (s32 *)0x80162000;
    particleIndex = (s32 *)0x80162100;
    seed = D_80159A20;

    particle = &particlePool[(*particleIndex) * 16];

    particle[0] = 1;  /* Active */

    /* Position with slight randomization */
    *(f32 *)&particle[1] = pos[0] + ((seed & 0xFF) - 128) / 256.0f;
    *(f32 *)&particle[2] = pos[1];
    *(f32 *)&particle[3] = pos[2] + ((seed >> 8 & 0xFF) - 128) / 256.0f;

    /* Slow upward drift */
    *(f32 *)&particle[4] = ((seed >> 16 & 0xFF) - 128) / 512.0f;
    *(f32 *)&particle[5] = 0.5f + size * 0.2f;
    *(f32 *)&particle[6] = ((seed >> 24 & 0xFF) - 128) / 512.0f;

    /* Longer lifetime for smoke */
    particle[7] = (s32)(30 + size * 20);

    /* Type: smoke */
    particle[8] = 0;

    /* Size stored in extra slot */
    *(f32 *)&particle[9] = size;

    (*particleIndex) = ((*particleIndex) + 1) % 64;
}

/*

 * func_800E32CC (1112 bytes)
 * Dust cloud
 *
 * Creates a cloud of dust particles.
 * Used for driving on dirt, sand, or off-road.
 */
void func_800E32CC(f32 *pos, f32 *velocity, f32 size) {
    s32 *particlePool;
    s32 *particleIndex;
    s32 i, numParticles;
    f32 baseVelX, baseVelY, baseVelZ;
    s32 seed;

    if (pos == NULL || size <= 0.0f) {
        return;
    }

    particlePool = (s32 *)0x80162000;
    particleIndex = (s32 *)0x80162100;

    numParticles = (s32)(size * 8.0f);
    if (numParticles < 3) numParticles = 3;
    if (numParticles > 20) numParticles = 20;

    seed = D_80159A20;

    if (velocity != NULL) {
        baseVelX = velocity[0] * 0.3f;
        baseVelY = velocity[1] * 0.1f;
        baseVelZ = velocity[2] * 0.3f;
    } else {
        baseVelX = 0.0f;
        baseVelY = 0.0f;
        baseVelZ = 0.0f;
    }

    for (i = 0; i < numParticles; i++) {
        s32 *particle = &particlePool[(*particleIndex) * 16];

        particle[0] = 1;  /* Active */

        /* Position with spread */
        seed = seed * 1103515245 + 12345;
        *(f32 *)&particle[1] = pos[0] + ((seed >> 16 & 0xFF) - 128) / 128.0f * size;
        *(f32 *)&particle[2] = pos[1] + ((seed >> 8 & 0xFF)) / 255.0f * 0.5f;
        *(f32 *)&particle[3] = pos[2] + ((seed & 0xFF) - 128) / 128.0f * size;

        /* Velocity with outward spread and rise */
        seed = seed * 1103515245 + 12345;
        *(f32 *)&particle[4] = baseVelX + ((seed >> 16 & 0xFF) - 128) / 256.0f;
        *(f32 *)&particle[5] = 0.3f + ((seed >> 8 & 0xFF)) / 512.0f;
        *(f32 *)&particle[6] = baseVelZ + ((seed & 0xFF) - 128) / 256.0f;

        /* Lifetime */
        particle[7] = 40 + (seed & 0x1F);

        /* Type: dust/smoke */
        particle[8] = 0;

        /* Size */
        *(f32 *)&particle[9] = size * 0.5f;

        (*particleIndex) = ((*particleIndex) + 1) % 64;
    }
}

/*

 * func_800E3724 (612 bytes)
 * Water splash
 *
 * Creates water splash particles.
 * Used when car drives through water or puddles.
 */
void func_800E3724(f32 *pos, f32 size) {
    s32 *particlePool;
    s32 *particleIndex;
    s32 i, numParticles;
    f32 angle, speed;
    s32 seed;

    if (pos == NULL || size <= 0.0f) {
        return;
    }

    particlePool = (s32 *)0x80162000;
    particleIndex = (s32 *)0x80162100;

    numParticles = (s32)(size * 12.0f);
    if (numParticles < 5) numParticles = 5;
    if (numParticles > 30) numParticles = 30;

    seed = D_80159A20;

    for (i = 0; i < numParticles; i++) {
        s32 *particle = &particlePool[(*particleIndex) * 16];

        particle[0] = 1;  /* Active */

        /* Position at water surface */
        *(f32 *)&particle[1] = pos[0];
        *(f32 *)&particle[2] = pos[1];
        *(f32 *)&particle[3] = pos[2];

        /* Outward and upward velocity */
        seed = seed * 1103515245 + 12345;
        angle = ((seed >> 16) & 0xFFFF) / 65535.0f * 6.28318f;
        speed = size * (0.3f + ((seed >> 8) & 0xFF) / 255.0f * 0.7f);

        *(f32 *)&particle[4] = cosf(angle) * speed;
        *(f32 *)&particle[5] = size * (1.0f + ((seed & 0xFF) / 255.0f));
        *(f32 *)&particle[6] = sinf(angle) * speed;

        /* Lifetime */
        particle[7] = 20 + (seed & 0xF);

        /* Type: water splash */
        particle[8] = 3;

        /* Size */
        *(f32 *)&particle[9] = size * 0.3f;

        (*particleIndex) = ((*particleIndex) + 1) % 64;
    }

    /* Play splash sound */
    func_80094A54(0x24, (s32)(size * 60.0f));
}

/*

 * func_800E398C (2960 bytes)
 * Particle render
 *
 * Renders all active particles as billboarded sprites.
 * Handles different particle types with appropriate textures.
 */
void func_800E398C(void *particles) {
    s32 *pool;
    s32 maxParticles, i;
    f32 *cameraPos;
    f32 dx, dy, dz, dist;

    if (particles == NULL) {
        return;
    }

    pool = (s32 *)((u8 *)particles + 0x00);
    maxParticles = *(s32 *)((u8 *)particles + 0x100);
    cameraPos = (f32 *)0x80161000;

    if (maxParticles > 256) maxParticles = 256;

    for (i = 0; i < maxParticles; i++) {
        s32 *particle = &pool[i * 16];
        s32 active = particle[0];
        s32 lifetime = particle[7];
        s32 type = particle[8];
        f32 *pos;
        f32 size, alpha;
        s32 spriteId;

        if (!active) {
            continue;
        }

        pos = (f32 *)&particle[1];
        size = *(f32 *)&particle[9];

        /* Distance culling */
        dx = pos[0] - cameraPos[0];
        dy = pos[1] - cameraPos[1];
        dz = pos[2] - cameraPos[2];
        dist = sqrtf(dx * dx + dy * dy + dz * dz);

        if (dist > 500.0f) {
            continue;  /* Too far to render */
        }

        /* Calculate alpha based on lifetime */
        alpha = (f32)lifetime / 60.0f;
        if (alpha > 1.0f) alpha = 1.0f;

        /* Select sprite based on type */
        switch (type) {
            case 0:  /* Smoke/dust */
                spriteId = 0x40;
                /* Smoke grows as it ages */
                size *= (1.0f + (1.0f - alpha) * 2.0f);
                break;

            case 1:  /* Spark */
                spriteId = 0x41;
                /* Sparks stay small */
                size *= 0.3f;
                break;

            case 2:  /* Debris */
                spriteId = 0x42;
                break;

            case 3:  /* Water */
                spriteId = 0x43;
                /* Water fades faster */
                alpha *= alpha;
                break;

            default:
                spriteId = 0x40;
        }

        /* Render billboard at particle position */
        func_800E7B44(pos, spriteId);
    }
}

/*

 * func_800E451C (1596 bytes)
 * Lens flare effect
 *
 * Renders lens flare when looking towards the sun.
 * Creates multiple flare elements along sun-to-center axis.
 */
void func_800E451C(void *camera, f32 *sunPos) {
    f32 *camPos, *camDir;
    f32 toSunX, toSunY, toSunZ, toSunLen;
    f32 dot, intensity;
    f32 screenX, screenY;
    f32 flareX, flareY;
    s32 i;

    /* Flare element positions along axis (0 = sun, 1 = center, 2 = opposite) */
    f32 flarePositions[6] = {0.0f, 0.3f, 0.5f, 0.7f, 1.0f, 1.3f};
    s32 flareSizes[6] = {32, 16, 24, 8, 20, 12};
    s32 flareSprites[6] = {0x50, 0x51, 0x52, 0x51, 0x53, 0x51};

    if (camera == NULL || sunPos == NULL) {
        return;
    }

    camPos = (f32 *)((u8 *)camera + 0x00);
    camDir = (f32 *)((u8 *)camera + 0x0C);

    /* Calculate direction to sun */
    toSunX = sunPos[0] - camPos[0];
    toSunY = sunPos[1] - camPos[1];
    toSunZ = sunPos[2] - camPos[2];
    toSunLen = sqrtf(toSunX * toSunX + toSunY * toSunY + toSunZ * toSunZ);

    if (toSunLen < 0.001f) {
        return;
    }

    toSunX /= toSunLen;
    toSunY /= toSunLen;
    toSunZ /= toSunLen;

    /* Check if sun is in front of camera */
    dot = toSunX * camDir[0] + toSunY * camDir[1] + toSunZ * camDir[2];

    if (dot < 0.0f) {
        return;  /* Sun behind camera */
    }

    /* Calculate intensity based on how directly we're looking at sun */
    intensity = dot * dot;
    if (intensity < 0.1f) {
        return;  /* Not looking at sun enough */
    }

    /* Project sun position to screen (simplified) */
    screenX = 160.0f + toSunX * 100.0f / (dot + 0.1f);
    screenY = 120.0f - toSunY * 100.0f / (dot + 0.1f);

    /* Render flare elements */
    for (i = 0; i < 6; i++) {
        f32 t = flarePositions[i];

        /* Interpolate from sun to screen center */
        flareX = screenX + (160.0f - screenX) * t;
        flareY = screenY + (120.0f - screenY) * t;

        /* Render flare sprite */
        draw_ui_element(0, 0, 0, 0, 0, 0);
    }
}

/*

 * func_800E4B58 (2284 bytes)
 * Sky rendering
 *
 * Renders the skybox/skydome based on time of day.
 * Includes gradient sky, clouds, and sun/moon.
 */
void func_800E4B58(void *camera) {
    f32 *camDir;
    s32 timeOfDay;
    f32 sunAngle, sunHeight;
    f32 skyTopR, skyTopG, skyTopB;
    f32 skyBotR, skyBotG, skyBotB;
    f32 sunPos[3];

    if (camera == NULL) {
        return;
    }

    camDir = (f32 *)((u8 *)camera + 0x0C);
    timeOfDay = D_80159A28;  /* 0-2400 representing time */

    /* Calculate sun position based on time */
    sunAngle = (f32)timeOfDay / 2400.0f * 6.28318f - 1.5708f;
    sunHeight = sinf(sunAngle);

    sunPos[0] = cosf(sunAngle) * 1000.0f;
    sunPos[1] = sunHeight * 500.0f + 200.0f;
    sunPos[2] = 0.0f;

    /* Calculate sky colors based on time of day */
    if (timeOfDay >= 600 && timeOfDay < 1800) {
        /* Day time - blue sky */
        skyTopR = 0.3f;
        skyTopG = 0.5f;
        skyTopB = 0.9f;
        skyBotR = 0.6f;
        skyBotG = 0.7f;
        skyBotB = 0.9f;
    } else if (timeOfDay >= 500 && timeOfDay < 700) {
        /* Sunrise */
        skyTopR = 0.5f;
        skyTopG = 0.4f;
        skyTopB = 0.6f;
        skyBotR = 0.9f;
        skyBotG = 0.5f;
        skyBotB = 0.3f;
    } else if (timeOfDay >= 1700 && timeOfDay < 1900) {
        /* Sunset */
        skyTopR = 0.5f;
        skyTopG = 0.3f;
        skyTopB = 0.5f;
        skyBotR = 0.9f;
        skyBotG = 0.4f;
        skyBotB = 0.2f;
    } else {
        /* Night */
        skyTopR = 0.05f;
        skyTopG = 0.05f;
        skyTopB = 0.15f;
        skyBotR = 0.1f;
        skyBotG = 0.1f;
        skyBotB = 0.2f;
    }

    /* Render sky gradient (would use RDP fill/texture commands) */
    /* This is simplified - actual N64 would use display list */

    /* Render sun/moon */
    if (sunHeight > -0.1f) {
        /* Sun is visible */
        func_800E451C(camera, sunPos);
    }

    /* Render clouds */
    func_800E5444(camera);
}

/*

 * func_800E5444 (712 bytes)
 * Horizon line
 *
 * Renders distant horizon with haze/fog effect.
 * Also renders distant clouds as layered sprites.
 */
void func_800E5444(void *camera) {
    f32 *camPos, *camDir;
    f32 horizonY;
    s32 i;
    f32 cloudOffset;

    if (camera == NULL) {
        return;
    }

    camPos = (f32 *)((u8 *)camera + 0x00);
    camDir = (f32 *)((u8 *)camera + 0x0C);

    /* Calculate horizon position based on camera pitch */
    horizonY = 120.0f - camDir[1] * 80.0f;

    /* Clamp to screen */
    if (horizonY < 0.0f) horizonY = 0.0f;
    if (horizonY > 240.0f) horizonY = 240.0f;

    /* Render horizon haze line */
    draw_ui_element(0, (s32)horizonY, 320, 0, 255, 200);  /* Haze sprite */

    /* Render scrolling clouds */
    cloudOffset = (f32)(D_80159A20 % 6400) / 20.0f;

    for (i = 0; i < 5; i++) {
        f32 cloudX = (f32)(i * 80) - cloudOffset;
        while (cloudX < -40.0f) {
            cloudX += 400.0f;
        }
        while (cloudX > 360.0f) {
            cloudX -= 400.0f;
        }

        f32 cloudY = horizonY - 30.0f - (i & 1) * 15.0f;

        if (cloudY > 10.0f && cloudY < 200.0f) {
            draw_ui_element(0, 0, 0, 0, 0, 0);  /* Cloud sprite */
        }
    }
}

/*

 * func_800E571C (4360 bytes)
 * Environment mapping
 *
 * Applies environment/reflection mapping to surfaces.
 * Uses camera-relative texture coordinates for fake reflections.
 */
void func_800E571C(void *surface) {
    f32 *normal, *camPos, *surfPos;
    f32 viewX, viewY, viewZ, viewLen;
    f32 reflectX, reflectY, reflectZ;
    f32 dot;
    s32 envU, envV;

    if (surface == NULL) {
        return;
    }

    normal = (f32 *)((u8 *)surface + 0x00);
    surfPos = (f32 *)((u8 *)surface + 0x0C);
    camPos = (f32 *)0x80161000;

    /* Calculate view direction */
    viewX = surfPos[0] - camPos[0];
    viewY = surfPos[1] - camPos[1];
    viewZ = surfPos[2] - camPos[2];
    viewLen = sqrtf(viewX * viewX + viewY * viewY + viewZ * viewZ);

    if (viewLen < 0.001f) {
        return;
    }

    viewX /= viewLen;
    viewY /= viewLen;
    viewZ /= viewLen;

    /* Calculate reflection vector: R = V - 2(V.N)N */
    dot = viewX * normal[0] + viewY * normal[1] + viewZ * normal[2];

    reflectX = viewX - 2.0f * dot * normal[0];
    reflectY = viewY - 2.0f * dot * normal[1];
    reflectZ = viewZ - 2.0f * dot * normal[2];

    /* Convert reflection to texture coordinates */
    /* Using spherical mapping */
    envU = (s32)((reflectX * 0.5f + 0.5f) * 31.0f);
    envV = (s32)((reflectY * 0.5f + 0.5f) * 31.0f);

    /* Clamp to texture bounds */
    if (envU < 0) envU = 0;
    if (envU > 31) envU = 31;
    if (envV < 0) envV = 0;
    if (envV > 31) envV = 31;

    /* Store calculated UV in surface for rendering */
    *(s32 *)((u8 *)surface + 0x18) = envU;
    *(s32 *)((u8 *)surface + 0x1C) = envV;
}

/*

 * func_800E6824 (708 bytes)
 * Reflection update
 *
 * Updates reflection state for reflective surfaces.
 * Called each frame for surfaces like car paint, water.
 */
void func_800E6824(void *surface) {
    f32 *intensity;
    s32 *reflectType;
    f32 fresnel;
    f32 viewDot;

    if (surface == NULL) {
        return;
    }

    intensity = (f32 *)((u8 *)surface + 0x20);
    reflectType = (s32 *)((u8 *)surface + 0x24);

    /* Get view dot product calculated earlier */
    viewDot = *(f32 *)((u8 *)surface + 0x28);

    /* Calculate Fresnel effect (more reflective at grazing angles) */
    fresnel = 1.0f - fabsf(viewDot);
    fresnel = fresnel * fresnel;

    /* Adjust intensity based on surface type */
    switch (*reflectType) {
        case 0:  /* Matte - no reflection */
            *intensity = 0.0f;
            break;

        case 1:  /* Glossy - moderate reflection */
            *intensity = 0.3f + fresnel * 0.4f;
            break;

        case 2:  /* Chrome - high reflection */
            *intensity = 0.7f + fresnel * 0.3f;
            break;

        case 3:  /* Water - variable reflection */
            *intensity = 0.2f + fresnel * 0.6f;
            break;

        default:
            *intensity = 0.1f;
    }

    /* Update environment map UVs */
    func_800E571C(surface);
}

/*

 * func_800E6AF8 (1596 bytes)
 * Shadow volume
 *
 * Calculates shadow projection for an object.
 * Projects shadow onto ground plane based on light direction.
 */
void func_800E6AF8(void *object, f32 *lightDir) {
    f32 *objPos, *objBounds;
    f32 shadowVerts[8][3];
    f32 groundY;
    f32 lightDirNorm[3], lightLen;
    s32 i;

    if (object == NULL || lightDir == NULL) {
        return;
    }

    objPos = (f32 *)((u8 *)object + 0x24);
    objBounds = (f32 *)((u8 *)object + 0x50);

    /* Normalize light direction */
    lightLen = sqrtf(lightDir[0] * lightDir[0] +
                    lightDir[1] * lightDir[1] +
                    lightDir[2] * lightDir[2]);
    if (lightLen < 0.001f) {
        return;
    }

    lightDirNorm[0] = lightDir[0] / lightLen;
    lightDirNorm[1] = lightDir[1] / lightLen;
    lightDirNorm[2] = lightDir[2] / lightLen;

    /* Get ground height at object position */
    func_800BB9B0(objPos, NULL, &groundY);

    /* Generate bounding box corners */
    for (i = 0; i < 8; i++) {
        f32 cornerX = objPos[0] + ((i & 1) ? objBounds[0] : -objBounds[0]);
        f32 cornerY = objPos[1] + ((i & 2) ? objBounds[1] : -objBounds[1]);
        f32 cornerZ = objPos[2] + ((i & 4) ? objBounds[2] : -objBounds[2]);

        /* Project corner onto ground along light direction */
        f32 t = (cornerY - groundY) / (-lightDirNorm[1] + 0.001f);

        shadowVerts[i][0] = cornerX + lightDirNorm[0] * t;
        shadowVerts[i][1] = groundY + 0.1f;  /* Slight offset to avoid z-fighting */
        shadowVerts[i][2] = cornerZ + lightDirNorm[2] * t;
    }

    /* Store shadow vertices for rendering */
    f32 *shadowData = (f32 *)((u8 *)object + 0x100);
    for (i = 0; i < 8; i++) {
        shadowData[i * 3 + 0] = shadowVerts[i][0];
        shadowData[i * 3 + 1] = shadowVerts[i][1];
        shadowData[i * 3 + 2] = shadowVerts[i][2];
    }
}

/*

 * func_800E7134 (2576 bytes)
 * Crowd rendering
 *
 * Renders animated crowd sprites along track sides.
 * Uses billboarded sprites with animation.
 */
void func_800E7134(void *crowd) {
    f32 *positions;
    s32 *animFrames;
    s32 numSpectators, i;
    f32 *cameraPos;
    f32 dx, dz, dist;
    s32 animOffset;

    if (crowd == NULL) {
        return;
    }

    positions = (f32 *)((u8 *)crowd + 0x00);
    animFrames = (s32 *)((u8 *)crowd + 0x400);
    numSpectators = *(s32 *)((u8 *)crowd + 0x800);
    cameraPos = (f32 *)0x80161000;

    if (numSpectators > 64) numSpectators = 64;

    /* Animation offset based on frame */
    animOffset = (D_80159A20 >> 3) % 4;

    for (i = 0; i < numSpectators; i++) {
        f32 *pos = &positions[i * 3];
        s32 baseFrame = animFrames[i];

        /* Distance culling */
        dx = pos[0] - cameraPos[0];
        dz = pos[2] - cameraPos[2];
        dist = sqrtf(dx * dx + dz * dz);

        if (dist > 200.0f) {
            continue;  /* Too far */
        }

        /* LOD - use simpler sprite at distance */
        s32 spriteId;
        if (dist > 100.0f) {
            spriteId = 0x60;  /* Distant crowd sprite */
        } else {
            /* Animated sprite */
            spriteId = 0x61 + ((baseFrame + animOffset) % 4);
        }

        /* Render billboard */
        func_800E7B44(pos, spriteId);
    }
}

/*

 * func_800E7B44 (472 bytes)
 * Billboard sprite
 *
 * Renders a camera-facing sprite at 3D position.
 * Used for particles, crowd, trees, etc.
 */
void func_800E7B44(f32 *pos, s32 spriteId) {
    f32 *cameraPos, *cameraDir;
    f32 dx, dy, dz, dist;
    f32 screenX, screenY;
    f32 scale;
    s32 size;

    if (pos == NULL) {
        return;
    }

    cameraPos = (f32 *)0x80161000;
    cameraDir = (f32 *)0x8016100C;

    /* Calculate distance to camera */
    dx = pos[0] - cameraPos[0];
    dy = pos[1] - cameraPos[1];
    dz = pos[2] - cameraPos[2];
    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    if (dist < 1.0f || dist > 1000.0f) {
        return;  /* Too close or too far */
    }

    /* Check if in front of camera */
    f32 dot = dx * cameraDir[0] + dy * cameraDir[1] + dz * cameraDir[2];
    if (dot < 0.0f) {
        return;  /* Behind camera */
    }

    /* Project to screen (simplified perspective) */
    f32 invDist = 200.0f / dist;
    screenX = 160.0f + dx * invDist;
    screenY = 120.0f - dy * invDist;

    /* Check screen bounds */
    if (screenX < -32 || screenX > 352 || screenY < -32 || screenY > 272) {
        return;
    }

    /* Size based on distance */
    scale = 64.0f / dist;
    size = (s32)(32.0f * scale);
    if (size < 4) size = 4;
    if (size > 64) size = 64;

    /* Render sprite */
    draw_ui_element(0, 0, 0, 0, 0, 0);
}

/*

 * func_800E7D14 (684 bytes)
 * Animated billboard
 *
 * Renders an animated billboard sprite.
 * Animation frame selected based on time parameter.
 */
void func_800E7D14(f32 *pos, s32 animId, f32 time) {
    s32 *animData;
    s32 numFrames, frameRate;
    s32 baseSprite, currentFrame;
    s32 spriteId;

    if (pos == NULL) {
        return;
    }

    /* Animation data table (would be loaded from ROM) */
    animData = (s32 *)(0x80150000 + animId * 16);

    baseSprite = animData[0];
    numFrames = animData[1];
    frameRate = animData[2];  /* Frames per second * 100 */

    if (numFrames <= 0) numFrames = 1;
    if (frameRate <= 0) frameRate = 1000;  /* Default 10 fps */

    /* Calculate current frame */
    currentFrame = (s32)(time * (f32)frameRate / 100.0f) % numFrames;

    spriteId = baseSprite + currentFrame;

    /* Render using regular billboard function */
    func_800E7B44(pos, spriteId);
}

/*

 * func_800E7FC8 (3312 bytes)
 * Track decoration rendering
 *
 * Renders track-side decorations (signs, trees, barriers).
 * Uses LOD and distance culling for performance.
 */
void func_800E7FC8(void *track) {
    s32 numDecorations, i;
    f32 *positions, *cameraPos;
    s32 *types, *lodLevels;
    f32 dx, dz, dist;

    if (track == NULL) {
        return;
    }

    numDecorations = func_800E8CB8(track);
    if (numDecorations <= 0 || numDecorations > 256) {
        return;
    }

    positions = (f32 *)((u8 *)track + 0x100);
    types = (s32 *)((u8 *)track + 0x1000);
    lodLevels = (s32 *)((u8 *)track + 0x1400);
    cameraPos = (f32 *)0x80161000;

    for (i = 0; i < numDecorations; i++) {
        f32 *pos = &positions[i * 3];
        s32 type = types[i];
        s32 lod;
        s32 spriteId;

        /* Distance check */
        dx = pos[0] - cameraPos[0];
        dz = pos[2] - cameraPos[2];
        dist = sqrtf(dx * dx + dz * dz);

        if (dist > 300.0f) {
            continue;  /* Too far to render */
        }

        /* Determine LOD level */
        if (dist < 50.0f) {
            lod = 0;  /* High detail */
        } else if (dist < 150.0f) {
            lod = 1;  /* Medium detail */
        } else {
            lod = 2;  /* Low detail */
        }

        /* Select sprite based on type and LOD */
        switch (type) {
            case 0:  /* Tree */
                spriteId = 0x70 + lod;
                break;
            case 1:  /* Sign */
                spriteId = 0x73 + lod;
                break;
            case 2:  /* Barrier */
                spriteId = 0x76 + lod;
                break;
            case 3:  /* Building */
                spriteId = 0x79 + lod;
                break;
            case 4:  /* Light post */
                spriteId = 0x7C + lod;
                break;
            default:
                spriteId = 0x70;
        }

        /* Render decoration */
        func_800E7B44(pos, spriteId);
    }
}

/*

 * func_800E8CB8 (152 bytes)
 * Get decoration count
 */
s32 func_800E8CB8(void *track) {
    return *(s32 *)((u8 *)track + 0x24);
}

/*

 * func_800E8D50 (448 bytes)
 * LOD distance check
 *
 * Checks if object is within render distance and returns LOD level.
 * Returns: -1 if too far, 0-3 for LOD level
 */
s32 func_800E8D50(f32 *pos, f32 *camera, f32 maxDist) {
    f32 dx, dy, dz, dist;
    f32 lodDist0, lodDist1, lodDist2;

    if (pos == NULL || camera == NULL) {
        return -1;
    }

    dx = pos[0] - camera[0];
    dy = pos[1] - camera[1];
    dz = pos[2] - camera[2];
    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    if (dist > maxDist) {
        return -1;  /* Too far to render */
    }

    /* LOD thresholds as fractions of max distance */
    lodDist0 = maxDist * 0.15f;  /* High detail */
    lodDist1 = maxDist * 0.4f;   /* Medium detail */
    lodDist2 = maxDist * 0.7f;   /* Low detail */

    if (dist < lodDist0) {
        return 0;  /* Highest detail */
    } else if (dist < lodDist1) {
        return 1;  /* Medium-high detail */
    } else if (dist < lodDist2) {
        return 2;  /* Medium-low detail */
    } else {
        return 3;  /* Lowest detail */
    }
    return 0;
}

/*

 * func_800E8F10 (952 bytes)
 * Ambient light setup - sets global ambient illumination
 */
void func_800E8F10(f32 *color, f32 intensity) {
    f32 *ambientLight;
    f32 *lightState;
    f32 clampedIntensity;

    /* Ambient light stored at 0x80160100 */
    ambientLight = (f32 *)0x80160100;
    lightState = (f32 *)0x80160140;

    /* Clamp intensity to valid range */
    clampedIntensity = intensity;
    if (clampedIntensity < 0.0f) {
        clampedIntensity = 0.0f;
    }
    if (clampedIntensity > 1.0f) {
        clampedIntensity = 1.0f;
    }

    /* Set ambient color with intensity */
    if (color != NULL) {
        ambientLight[0] = color[0] * clampedIntensity;
        ambientLight[1] = color[1] * clampedIntensity;
        ambientLight[2] = color[2] * clampedIntensity;
    } else {
        /* Default gray ambient */
        ambientLight[0] = 0.2f * clampedIntensity;
        ambientLight[1] = 0.2f * clampedIntensity;
        ambientLight[2] = 0.2f * clampedIntensity;
    }

    ambientLight[3] = clampedIntensity;  /* Store raw intensity */

    /* Mark ambient as active */
    lightState[0] = 1.0f;
}

/*

 * func_800E92C8 (788 bytes)
 * Directional light - sun/moon lighting
 */
void func_800E92C8(f32 *direction, f32 *color, f32 intensity) {
    f32 *dirLight;
    f32 *lightState;
    f32 len, invLen;
    f32 clampedIntensity;

    /* Directional light at 0x80160110 */
    dirLight = (f32 *)0x80160110;
    lightState = (f32 *)0x80160140;

    /* Clamp intensity */
    clampedIntensity = intensity;
    if (clampedIntensity < 0.0f) {
        clampedIntensity = 0.0f;
    }
    if (clampedIntensity > 2.0f) {
        clampedIntensity = 2.0f;
    }

    /* Normalize direction vector */
    if (direction != NULL) {
        len = sqrtf(direction[0] * direction[0] +
                    direction[1] * direction[1] +
                    direction[2] * direction[2]);
        if (len > 0.001f) {
            invLen = 1.0f / len;
            dirLight[0] = direction[0] * invLen;
            dirLight[1] = direction[1] * invLen;
            dirLight[2] = direction[2] * invLen;
        } else {
            /* Default: straight down */
            dirLight[0] = 0.0f;
            dirLight[1] = -1.0f;
            dirLight[2] = 0.0f;
        }
    } else {
        dirLight[0] = 0.0f;
        dirLight[1] = -1.0f;
        dirLight[2] = 0.0f;
    }

    /* Set color with intensity */
    if (color != NULL) {
        dirLight[4] = color[0] * clampedIntensity;
        dirLight[5] = color[1] * clampedIntensity;
        dirLight[6] = color[2] * clampedIntensity;
    } else {
        /* Default warm white sunlight */
        dirLight[4] = 1.0f * clampedIntensity;
        dirLight[5] = 0.95f * clampedIntensity;
        dirLight[6] = 0.85f * clampedIntensity;
    }

    dirLight[7] = clampedIntensity;

    /* Mark directional as active */
    lightState[1] = 1.0f;
}

/*

 * func_800E95DC (1684 bytes)
 * Point light - local light source (street lamps, etc.)
 */
void func_800E95DC(f32 *pos, f32 *color, f32 radius) {
    f32 *pointLights;
    s32 *numPointLights;
    s32 lightIndex;
    f32 *light;

    /* Point light array at 0x80160200 */
    pointLights = (f32 *)0x80160200;
    numPointLights = (s32 *)0x80160148;

    /* Max 8 point lights */
    if (*numPointLights >= 8) {
        return;
    }

    lightIndex = *numPointLights;
    light = pointLights + (lightIndex * 8);

    /* Store position */
    if (pos != NULL) {
        light[0] = pos[0];
        light[1] = pos[1];
        light[2] = pos[2];
    } else {
        light[0] = 0.0f;
        light[1] = 0.0f;
        light[2] = 0.0f;
    }

    /* Store color */
    if (color != NULL) {
        light[3] = color[0];
        light[4] = color[1];
        light[5] = color[2];
    } else {
        /* Default white */
        light[3] = 1.0f;
        light[4] = 1.0f;
        light[5] = 1.0f;
    }

    /* Store radius (for attenuation) */
    if (radius < 1.0f) {
        radius = 1.0f;
    }
    light[6] = radius;
    light[7] = 1.0f;  /* Active flag */

    (*numPointLights)++;
}

/*

 * func_800E9C70 (444 bytes)
 * Light fade - animate light intensity over time
 */
void func_800E9C70(void *light, f32 targetIntensity, f32 duration) {
    f32 *currentIntensity;
    f32 *fadeTarget;
    f32 *fadeRate;
    s32 *fading;

    if (light == NULL) {
        return;
    }

    /* Light structure offsets for fade animation */
    currentIntensity = (f32 *)((u8 *)light + 0x1C);
    fadeTarget = (f32 *)((u8 *)light + 0x20);
    fadeRate = (f32 *)((u8 *)light + 0x24);
    fading = (s32 *)((u8 *)light + 0x28);

    /* Clamp target */
    if (targetIntensity < 0.0f) {
        targetIntensity = 0.0f;
    }
    if (targetIntensity > 2.0f) {
        targetIntensity = 2.0f;
    }

    *fadeTarget = targetIntensity;

    /* Calculate fade rate (assume 60fps) */
    if (duration <= 0.0f) {
        /* Instant change */
        *currentIntensity = targetIntensity;
        *fading = 0;
    } else {
        f32 diff = targetIntensity - *currentIntensity;
        *fadeRate = diff / (duration * 60.0f);
        *fading = 1;
    }
}

/*

 * func_800E9E2C (476 bytes)
 * Light flicker - simulate flickering effect
 */
void func_800E9E2C(void *light, f32 frequency, f32 amplitude) {
    f32 *baseIntensity;
    f32 *flickerPhase;
    f32 *flickerFreq;
    f32 *flickerAmp;
    s32 *flickering;

    if (light == NULL) {
        return;
    }

    baseIntensity = (f32 *)((u8 *)light + 0x1C);
    flickerPhase = (f32 *)((u8 *)light + 0x2C);
    flickerFreq = (f32 *)((u8 *)light + 0x30);
    flickerAmp = (f32 *)((u8 *)light + 0x34);
    flickering = (s32 *)((u8 *)light + 0x38);

    /* Clamp parameters */
    if (frequency < 0.1f) {
        frequency = 0.1f;
    }
    if (frequency > 30.0f) {
        frequency = 30.0f;
    }
    if (amplitude < 0.0f) {
        amplitude = 0.0f;
    }
    if (amplitude > 1.0f) {
        amplitude = 1.0f;
    }

    *flickerFreq = frequency;
    *flickerAmp = amplitude * (*baseIntensity);
    *flickerPhase = 0.0f;
    *flickering = (amplitude > 0.0f) ? 1 : 0;
}

/*

 * func_800EA108 (468 bytes)
 * Headlight cone - car headlight projection
 */
void func_800EA108(void *car, f32 *direction) {
    f32 *headlightData;
    f32 *carPos;
    f32 *carForward;
    f32 headlightOffset[3];
    f32 len, invLen;

    if (car == NULL) {
        return;
    }

    carPos = (f32 *)((u8 *)car + 0x24);
    carForward = (f32 *)((u8 *)car + 0x60);
    headlightData = (f32 *)((u8 *)car + 0x380);

    /* Headlight position (offset from car center) */
    headlightOffset[0] = 0.0f;
    headlightOffset[1] = 0.5f;   /* Slightly above center */
    headlightOffset[2] = 1.5f;   /* Forward from car center */

    /* Transform offset by car orientation */
    headlightData[0] = carPos[0] + headlightOffset[2] * carForward[0];
    headlightData[1] = carPos[1] + headlightOffset[1];
    headlightData[2] = carPos[2] + headlightOffset[2] * carForward[2];

    /* Light direction */
    if (direction != NULL) {
        len = sqrtf(direction[0] * direction[0] +
                    direction[1] * direction[1] +
                    direction[2] * direction[2]);
        if (len > 0.001f) {
            invLen = 1.0f / len;
            headlightData[3] = direction[0] * invLen;
            headlightData[4] = direction[1] * invLen;
            headlightData[5] = direction[2] * invLen;
        } else {
            /* Use car forward */
            headlightData[3] = carForward[0];
            headlightData[4] = -0.1f;  /* Slight downward tilt */
            headlightData[5] = carForward[2];
        }
    } else {
        headlightData[3] = carForward[0];
        headlightData[4] = -0.1f;
        headlightData[5] = carForward[2];
    }

    /* Headlight properties */
    headlightData[6] = 1.0f;   /* Intensity */
    headlightData[7] = 0.5f;   /* Cone angle (radians) */
    headlightData[8] = 50.0f;  /* Range */
}

/*

 * func_800EA2DC (276 bytes)
 * Light enable/disable - toggle light on/off
 */
void func_800EA2DC(void *light, s32 enable) {
    s32 *active;
    f32 *savedIntensity;
    f32 *currentIntensity;

    if (light == NULL) {
        return;
    }

    active = (s32 *)((u8 *)light + 0x00);
    currentIntensity = (f32 *)((u8 *)light + 0x1C);
    savedIntensity = (f32 *)((u8 *)light + 0x3C);

    if (enable) {
        if (*active == 0) {
            *active = 1;
            /* Restore saved intensity */
            if (*savedIntensity > 0.0f) {
                *currentIntensity = *savedIntensity;
            } else {
                *currentIntensity = 1.0f;
            }
        }
    } else {
        if (*active != 0) {
            /* Save current intensity before disabling */
            *savedIntensity = *currentIntensity;
            *currentIntensity = 0.0f;
            *active = 0;
        }
    }
}

/*

 * func_800EA3F4 (2548 bytes)
 * Full lighting update - process all lights each frame
 */
void func_800EA3F4(void *scene) {
    f32 *ambientLight;
    f32 *dirLight;
    f32 *pointLights;
    s32 *numPointLights;
    f32 *lightState;
    s32 i;
    f32 *light;
    f32 phase, intensity;
    f32 fadeTarget, fadeRate, currentIntensity;
    s32 fading, flickering;

    if (scene == NULL) {
        return;
    }

    ambientLight = (f32 *)0x80160100;
    dirLight = (f32 *)0x80160110;
    pointLights = (f32 *)0x80160200;
    numPointLights = (s32 *)0x80160148;
    lightState = (f32 *)0x80160140;

    /* Update point light animations */
    for (i = 0; i < *numPointLights; i++) {
        light = pointLights + (i * 8);

        /* Check if light is active */
        if (light[7] < 0.5f) {
            continue;
        }

        /* Get animation state (using extended light structure) */
        fading = *((s32 *)((u8 *)light + 0x28));
        flickering = *((s32 *)((u8 *)light + 0x38));

        /* Process fade animation */
        if (fading) {
            currentIntensity = *((f32 *)((u8 *)light + 0x1C));
            fadeTarget = *((f32 *)((u8 *)light + 0x20));
            fadeRate = *((f32 *)((u8 *)light + 0x24));

            currentIntensity += fadeRate;

            /* Check if fade complete */
            if ((fadeRate > 0.0f && currentIntensity >= fadeTarget) ||
                (fadeRate < 0.0f && currentIntensity <= fadeTarget)) {
                currentIntensity = fadeTarget;
                *((s32 *)((u8 *)light + 0x28)) = 0;  /* Stop fading */
            }

            *((f32 *)((u8 *)light + 0x1C)) = currentIntensity;
        }

        /* Process flicker animation */
        if (flickering) {
            f32 *flickerPhase = (f32 *)((u8 *)light + 0x2C);
            f32 *flickerFreq = (f32 *)((u8 *)light + 0x30);
            f32 *flickerAmp = (f32 *)((u8 *)light + 0x34);
            f32 baseIntensity = *((f32 *)((u8 *)light + 0x1C));

            /* Update phase */
            *flickerPhase += *flickerFreq / 60.0f;
            if (*flickerPhase > 6.28318f) {
                *flickerPhase -= 6.28318f;
            }

            /* Apply flicker using sin wave + noise */
            phase = *flickerPhase;
            intensity = baseIntensity + *flickerAmp * sinf(phase);

            /* Add some randomness for realistic flicker */
            if ((s32)(phase * 10.0f) % 7 == 0) {
                intensity *= 0.9f + 0.2f * ((phase - (s32)phase));
            }

            if (intensity < 0.0f) {
                intensity = 0.0f;
            }

            /* Apply to light color */
            light[3] *= intensity / baseIntensity;
            light[4] *= intensity / baseIntensity;
            light[5] *= intensity / baseIntensity;
        }
    }

    /* Clear point light count for next frame (rebuilt each frame) */
    /* Note: commented out - lights persist until explicitly removed */
    /* *numPointLights = 0; */
}

/*

 * func_800F0050 (1644 bytes)
 * Network message send - queue message for transmission
 *
 * N64 Rush 2049 uses the Transfer Pak for link play.
 * Messages are serialized car state + inputs.
 */
void func_800F0050(void *msg, s32 size) {
    u8 *sendBuffer;
    s32 *sendHead, *sendTail, *sendSize;
    s32 bufferSize;
    s32 writePos;
    s32 i;
    u8 *msgData;

    if (msg == NULL || size <= 0) {
        return;
    }

    /* Network send buffer at 0x80164000 */
    sendBuffer = (u8 *)0x80164000;
    sendHead = (s32 *)0x80163FF0;
    sendTail = (s32 *)0x80163FF4;
    sendSize = (s32 *)0x80163FF8;
    bufferSize = 4096;

    /* Check if buffer has space */
    if (*sendSize + size + 4 > bufferSize) {
        /* Buffer full - drop message */
        return;
    }

    /* Write message header (size) */
    writePos = *sendHead;
    sendBuffer[writePos] = (size >> 8) & 0xFF;
    writePos = (writePos + 1) % bufferSize;
    sendBuffer[writePos] = size & 0xFF;
    writePos = (writePos + 1) % bufferSize;

    /* Write message data */
    msgData = (u8 *)msg;
    for (i = 0; i < size; i++) {
        sendBuffer[writePos] = msgData[i];
        writePos = (writePos + 1) % bufferSize;
    }

    *sendHead = writePos;
    *sendSize += size + 2;
}

/*

 * func_800F0698 (1408 bytes)
 * Network message receive - dequeue received message
 */
s32 func_800F0698(void *buffer, s32 maxSize) {
    u8 *recvBuffer;
    s32 *recvHead, *recvTail, *recvSize;
    s32 bufferSize;
    s32 readPos;
    s32 msgSize;
    s32 i;
    u8 *dstData;

    if (buffer == NULL || maxSize <= 0) {
        return 0;
    }

    /* Network receive buffer at 0x80165000 */
    recvBuffer = (u8 *)0x80165000;
    recvHead = (s32 *)0x80164FF0;
    recvTail = (s32 *)0x80164FF4;
    recvSize = (s32 *)0x80164FF8;
    bufferSize = 4096;

    /* Check if data available */
    if (*recvSize < 2) {
        return 0;  /* No complete message */
    }

    /* Read message size header */
    readPos = *recvTail;
    msgSize = (recvBuffer[readPos] << 8);
    readPos = (readPos + 1) % bufferSize;
    msgSize |= recvBuffer[readPos];
    readPos = (readPos + 1) % bufferSize;

    /* Validate message size */
    if (msgSize <= 0 || msgSize > *recvSize - 2) {
        /* Invalid or incomplete - skip header */
        *recvTail = readPos;
        *recvSize -= 2;
        return 0;
    }

    if (msgSize > maxSize) {
        /* Message too large for buffer - skip it */
        *recvTail = (readPos + msgSize) % bufferSize;
        *recvSize -= msgSize + 2;
        return -1;
    }

    /* Copy message data */
    dstData = (u8 *)buffer;
    for (i = 0; i < msgSize; i++) {
        dstData[i] = recvBuffer[readPos];
        readPos = (readPos + 1) % bufferSize;
    }

    *recvTail = readPos;
    *recvSize -= msgSize + 2;

    return msgSize;
}

/*

 * func_800F0C18 (2036 bytes)
 * Network state sync - synchronize game state across players
 */
void func_800F0C18(void *state) {
    u8 syncBuffer[256];
    s32 bufferPos;
    s32 *frameCounter;
    s32 *numPlayers;
    s32 i;
    void *playerCar;
    f32 *carPos, *carVel, *carRot;
    u16 *carInputs;

    if (state == NULL) {
        return;
    }

    frameCounter = (s32 *)0x80142AFC;
    numPlayers = (s32 *)((u8 *)state + 0x00);

    bufferPos = 0;

    /* Header: message type (0x01 = state sync) */
    syncBuffer[bufferPos++] = 0x01;

    /* Frame number for synchronization */
    syncBuffer[bufferPos++] = (*frameCounter >> 24) & 0xFF;
    syncBuffer[bufferPos++] = (*frameCounter >> 16) & 0xFF;
    syncBuffer[bufferPos++] = (*frameCounter >> 8) & 0xFF;
    syncBuffer[bufferPos++] = *frameCounter & 0xFF;

    /* Number of players */
    syncBuffer[bufferPos++] = *numPlayers;

    /* Serialize each player's car state */
    for (i = 0; i < *numPlayers && i < 4; i++) {
        playerCar = (void *)(D_80152818 + i * 0x400);

        carPos = (f32 *)((u8 *)playerCar + 0x24);
        carVel = (f32 *)((u8 *)playerCar + 0x34);
        carRot = (f32 *)((u8 *)playerCar + 0x60);
        carInputs = (u16 *)((u8 *)playerCar + 0x200);

        /* Position (12 bytes) */
        memcpy(&syncBuffer[bufferPos], carPos, 12);
        bufferPos += 12;

        /* Velocity (12 bytes) */
        memcpy(&syncBuffer[bufferPos], carVel, 12);
        bufferPos += 12;

        /* Rotation (12 bytes) */
        memcpy(&syncBuffer[bufferPos], carRot, 12);
        bufferPos += 12;

        /* Inputs (2 bytes) */
        syncBuffer[bufferPos++] = (*carInputs >> 8) & 0xFF;
        syncBuffer[bufferPos++] = *carInputs & 0xFF;
    }

    /* Send state sync message */
    func_800F0050(syncBuffer, bufferPos);
}

/*

 * func_800F13F0 (1364 bytes)
 * Multiplayer lobby - handle lobby state and player management
 */
void func_800F13F0(void *lobby) {
    s32 *lobbyState;
    s32 *numPlayers;
    s32 *readyFlags;
    s32 *selectedTrack;
    s32 *hostPlayer;
    s32 i;
    s32 allReady;
    u8 msgBuffer[32];

    if (lobby == NULL) {
        return;
    }

    lobbyState = (s32 *)((u8 *)lobby + 0x00);
    numPlayers = (s32 *)((u8 *)lobby + 0x04);
    readyFlags = (s32 *)((u8 *)lobby + 0x08);
    selectedTrack = (s32 *)((u8 *)lobby + 0x0C);
    hostPlayer = (s32 *)((u8 *)lobby + 0x10);

    switch (*lobbyState) {
        case 0:  /* Waiting for players */
            /* Check for incoming connection messages */
            if (func_800F0698(msgBuffer, 32) > 0) {
                if (msgBuffer[0] == 0x10) {  /* Join request */
                    if (*numPlayers < 4) {
                        func_800F1944(*numPlayers);
                        (*numPlayers)++;
                    }
                }
            }
            break;

        case 1:  /* Players joined, waiting for ready */
            /* Check if all players ready */
            allReady = 1;
            for (i = 0; i < *numPlayers; i++) {
                if ((*readyFlags & (1 << i)) == 0) {
                    allReady = 0;
                    break;
                }
            }

            if (allReady && *numPlayers >= 2) {
                *lobbyState = 2;  /* All ready - start countdown */
            }
            break;

        case 2:  /* Starting game */
            /* Host initiates game start */
            if (*hostPlayer == 0) {  /* We are host */
                func_800F1F3C();
            }
            *lobbyState = 3;
            break;

        case 3:  /* Game in progress */
            /* Lobby inactive during gameplay */
            break;
    }
}

/*

 * func_800F1944 (852 bytes)
 * Player join handling - initialize new player
 */
void func_800F1944(s32 playerSlot) {
    void *playerCar;
    s32 *playerActive;
    s32 *playerController;
    f32 *spawnPos;
    f32 *carPos;
    u8 joinMsg[8];

    if (playerSlot < 0 || playerSlot >= 4) {
        return;
    }

    /* Get player car slot */
    playerCar = (void *)(D_80152818 + playerSlot * 0x400);
    playerActive = (s32 *)((u8 *)playerCar + 0x00);
    playerController = (s32 *)((u8 *)playerCar + 0x04);
    carPos = (f32 *)((u8 *)playerCar + 0x24);

    /* Mark player as active */
    *playerActive = 1;
    *playerController = playerSlot;

    /* Set spawn position based on slot */
    spawnPos = (f32 *)0x80158000;  /* Track spawn points */
    carPos[0] = spawnPos[playerSlot * 3 + 0];
    carPos[1] = spawnPos[playerSlot * 3 + 1];
    carPos[2] = spawnPos[playerSlot * 3 + 2];

    /* Initialize car to default state */
    memset((u8 *)playerCar + 0x34, 0, 0x100);  /* Clear velocity/state */

    /* Send join acknowledgment */
    joinMsg[0] = 0x11;  /* Join ack message type */
    joinMsg[1] = playerSlot;
    joinMsg[2] = 0x00;
    joinMsg[3] = 0x00;
    func_800F0050(joinMsg, 4);
}

/*

 * func_800F1C98 (676 bytes)
 * Player leave handling - cleanup disconnected player
 */
void func_800F1C98(s32 playerSlot) {
    void *playerCar;
    s32 *playerActive;
    s32 *lobbyReadyFlags;
    u8 leaveMsg[8];

    if (playerSlot < 0 || playerSlot >= 4) {
        return;
    }

    /* Get player car slot */
    playerCar = (void *)(D_80152818 + playerSlot * 0x400);
    playerActive = (s32 *)((u8 *)playerCar + 0x00);

    /* Mark player as inactive */
    *playerActive = 0;

    /* Clear player's car state */
    memset(playerCar, 0, 0x100);

    /* Clear ready flag in lobby */
    lobbyReadyFlags = (s32 *)0x80166008;
    *lobbyReadyFlags &= ~(1 << playerSlot);

    /* Notify other players */
    leaveMsg[0] = 0x12;  /* Leave notification message type */
    leaveMsg[1] = playerSlot;
    leaveMsg[2] = 0x00;
    leaveMsg[3] = 0x00;
    func_800F0050(leaveMsg, 4);
}

/*

 * func_800F1F3C (2208 bytes)
 * Network game start - synchronize game start across players
 */
void func_800F1F3C(void) {
    u8 startMsg[32];
    s32 *gstate;
    s32 *selectedTrack;
    s32 *selectedLaps;
    s32 *numPlayers;
    s32 *randomSeed;
    s32 i;

    gstate = (s32 *)0x801146EC;
    selectedTrack = (s32 *)0x80166010;
    selectedLaps = (s32 *)0x80166014;
    numPlayers = (s32 *)0x80166004;
    randomSeed = (s32 *)0x80166018;

    /* Generate random seed for synchronized randomness */
    *randomSeed = *((s32 *)0x80142AFC) ^ 0x12345678;

    /* Build game start message */
    startMsg[0] = 0x20;  /* Game start message type */
    startMsg[1] = *numPlayers;
    startMsg[2] = *selectedTrack;
    startMsg[3] = *selectedLaps;

    /* Random seed (4 bytes) */
    startMsg[4] = (*randomSeed >> 24) & 0xFF;
    startMsg[5] = (*randomSeed >> 16) & 0xFF;
    startMsg[6] = (*randomSeed >> 8) & 0xFF;
    startMsg[7] = *randomSeed & 0xFF;

    /* Player starting positions */
    for (i = 0; i < *numPlayers && i < 4; i++) {
        startMsg[8 + i] = i;  /* Grid position = player slot for now */
    }

    /* Send start message to all players */
    func_800F0050(startMsg, 12);

    /* Transition to countdown state */
    *gstate = 8;  /* COUNTDOWN state */
}

/*

 * func_800F27DC (1632 bytes)
 * Input sync - synchronize player inputs across network
 */
void func_800F27DC(void *inputs) {
    u8 inputMsg[64];
    s32 bufferPos;
    s32 *frameCounter;
    s32 *localPlayer;
    s32 i;
    u16 *inputBuffer;
    s8 *stickX, *stickY;

    if (inputs == NULL) {
        return;
    }

    frameCounter = (s32 *)0x80142AFC;
    localPlayer = (s32 *)0x80166020;
    inputBuffer = (u16 *)inputs;
    stickX = (s8 *)((u8 *)inputs + 0x08);
    stickY = (s8 *)((u8 *)inputs + 0x09);

    bufferPos = 0;

    /* Message header */
    inputMsg[bufferPos++] = 0x30;  /* Input sync message type */
    inputMsg[bufferPos++] = *localPlayer;

    /* Frame number (for input prediction/rollback) */
    inputMsg[bufferPos++] = (*frameCounter >> 8) & 0xFF;
    inputMsg[bufferPos++] = *frameCounter & 0xFF;

    /* Pack current frame's inputs */
    inputMsg[bufferPos++] = (inputBuffer[0] >> 8) & 0xFF;
    inputMsg[bufferPos++] = inputBuffer[0] & 0xFF;
    inputMsg[bufferPos++] = *stickX;
    inputMsg[bufferPos++] = *stickY;

    /* Include last 3 frames of input history for redundancy */
    for (i = 1; i < 4; i++) {
        inputMsg[bufferPos++] = (inputBuffer[i * 2] >> 8) & 0xFF;
        inputMsg[bufferPos++] = inputBuffer[i * 2] & 0xFF;
    }

    func_800F0050(inputMsg, bufferPos);
}

/*

 * func_800F2E3C (784 bytes)
 * Latency compensation - predict entity position based on latency
 */
void func_800F2E3C(void *entity, s32 frames) {
    f32 *pos, *vel, *accel;
    f32 dt;
    s32 i;

    if (entity == NULL || frames <= 0) {
        return;
    }

    /* Cap prediction to avoid wild extrapolation */
    if (frames > 10) {
        frames = 10;
    }

    pos = (f32 *)((u8 *)entity + 0x24);
    vel = (f32 *)((u8 *)entity + 0x34);
    accel = (f32 *)((u8 *)entity + 0x44);

    /* Time step per frame (60fps = 1/60 sec) */
    dt = 1.0f / 60.0f;

    /* Simple Euler integration for prediction */
    for (i = 0; i < frames; i++) {
        /* Update position: p = p + v*dt + 0.5*a*dt^2 */
        pos[0] += vel[0] * dt + 0.5f * accel[0] * dt * dt;
        pos[1] += vel[1] * dt + 0.5f * accel[1] * dt * dt;
        pos[2] += vel[2] * dt + 0.5f * accel[2] * dt * dt;

        /* Update velocity: v = v + a*dt */
        vel[0] += accel[0] * dt;
        vel[1] += accel[1] * dt;
        vel[2] += accel[2] * dt;
    }
}

/*

 * func_800F314C (1084 bytes)
 * Network error handling - process network errors
 */
void func_800F314C(s32 errorCode) {
    s32 *netState;
    s32 *errorCount;
    s32 *lastError;
    s32 *gstate;

    netState = (s32 *)0x80166000;
    errorCount = (s32 *)0x80166024;
    lastError = (s32 *)0x80166028;
    gstate = (s32 *)0x801146EC;

    *lastError = errorCode;
    (*errorCount)++;

    switch (errorCode) {
        case 0:  /* No error */
            break;

        case 1:  /* Connection lost */
            /* Return to single player mode */
            *netState = 0;
            /* Could transition to error screen */
            break;

        case 2:  /* Timeout */
            if (*errorCount > 5) {
                /* Too many timeouts - disconnect */
                *netState = 0;
            }
            break;

        case 3:  /* Sync error */
            /* Request full state resync */
            {
                u8 resyncMsg[4];
                resyncMsg[0] = 0x40;  /* Resync request */
                resyncMsg[1] = 0x00;
                func_800F0050(resyncMsg, 2);
            }
            break;

        case 4:  /* Protocol error */
            /* Invalid message received - ignore */
            break;

        case 5:  /* Host disconnected */
            /* End multiplayer session */
            *netState = 0;
            *gstate = 0;  /* Return to attract/menu */
            break;

        default:
            /* Unknown error */
            break;
    }
}

/*

 * func_800F3588 (836 bytes)
 * Session management - handle multiplayer session lifecycle
 */
void func_800F3588(s32 cmd) {
    s32 *netState;
    s32 *sessionId;
    s32 *isHost;
    s32 *numPlayers;
    s32 i;

    netState = (s32 *)0x80166000;
    sessionId = (s32 *)0x8016602C;
    isHost = (s32 *)0x80166030;
    numPlayers = (s32 *)0x80166004;

    switch (cmd) {
        case 0:  /* Initialize session */
            *netState = 0;
            *sessionId = 0;
            *isHost = 0;
            *numPlayers = 1;

            /* Clear network buffers */
            *((s32 *)0x80163FF0) = 0;  /* Send head */
            *((s32 *)0x80163FF4) = 0;  /* Send tail */
            *((s32 *)0x80163FF8) = 0;  /* Send size */
            *((s32 *)0x80164FF0) = 0;  /* Recv head */
            *((s32 *)0x80164FF4) = 0;  /* Recv tail */
            *((s32 *)0x80164FF8) = 0;  /* Recv size */
            break;

        case 1:  /* Host session */
            *netState = 1;
            *isHost = 1;
            *sessionId = *((s32 *)0x80142AFC);  /* Use frame counter as ID */
            *numPlayers = 1;
            break;

        case 2:  /* Join session */
            *netState = 2;
            *isHost = 0;
            break;

        case 3:  /* Leave session */
            if (*netState != 0) {
                /* Notify other players we're leaving */
                func_800F1C98(0);  /* Local player is always slot 0 for us */
            }
            *netState = 0;
            *numPlayers = 1;
            break;

        case 4:  /* End session (host only) */
            if (*isHost) {
                /* Notify all players */
                for (i = 1; i < *numPlayers; i++) {
                    func_800F1C98(i);
                }
            }
            *netState = 0;
            *numPlayers = 1;
            break;
    }
}

/*

 * func_800F38BC (1912 bytes)
 * Ghost data recording
 *
 * Records player car state for ghost playback.
 * Captures position, rotation, velocity each frame.
 */
void func_800F38BC(void *ghost) {
    s32 *frameCount, *maxFrames;
    s32 *recording;
    f32 *frameData;
    void *playerCar;
    f32 *carPos, *carRot, *carVel;
    s32 frameOffset;

    if (ghost == NULL) {
        return;
    }

    recording = (s32 *)((u8 *)ghost + 0x00);
    frameCount = (s32 *)((u8 *)ghost + 0x04);
    maxFrames = (s32 *)((u8 *)ghost + 0x08);
    frameData = (f32 *)((u8 *)ghost + 0x100);

    if (*recording == 0) {
        return;  /* Not recording */
    }

    if (*frameCount >= *maxFrames) {
        *recording = 0;  /* Buffer full */
        return;
    }

    /* Get player car */
    playerCar = (void *)D_80152818;
    if (playerCar == NULL) {
        return;
    }

    carPos = (f32 *)((u8 *)playerCar + 0x24);
    carRot = (f32 *)((u8 *)playerCar + 0x60);
    carVel = (f32 *)((u8 *)playerCar + 0x34);

    /* Calculate frame data offset (9 floats per frame) */
    frameOffset = (*frameCount) * 9;

    /* Store position */
    frameData[frameOffset + 0] = carPos[0];
    frameData[frameOffset + 1] = carPos[1];
    frameData[frameOffset + 2] = carPos[2];

    /* Store rotation (forward vector) */
    frameData[frameOffset + 3] = carRot[0];
    frameData[frameOffset + 4] = carRot[1];
    frameData[frameOffset + 5] = carRot[2];

    /* Store velocity */
    frameData[frameOffset + 6] = carVel[0];
    frameData[frameOffset + 7] = carVel[1];
    frameData[frameOffset + 8] = carVel[2];

    (*frameCount)++;
}

/*

 * func_800F4034 (1536 bytes)
 * Ghost playback - interpolates ghost car position from recorded data
 */
void func_800F4034(void *ghost) {
    s32 *frameCount;
    s32 *playbackFrame;
    s32 *maxFrames;
    s32 *playbackState;
    f32 *frameData;
    f32 *ghostPos;
    f32 *ghostRot;
    f32 *ghostVel;
    f32 t;
    s32 frame0, frame1;
    s32 offset0, offset1;

    if (ghost == NULL) {
        return;
    }

    playbackState = (s32 *)((u8 *)ghost + 0x00);
    playbackFrame = (s32 *)((u8 *)ghost + 0x04);
    maxFrames = (s32 *)((u8 *)ghost + 0x08);
    frameData = (f32 *)((u8 *)ghost + 0x100);
    ghostPos = (f32 *)((u8 *)ghost + 0x40);
    ghostRot = (f32 *)((u8 *)ghost + 0x50);
    ghostVel = (f32 *)((u8 *)ghost + 0x60);

    /* Check if playback is active */
    if (*playbackState != 2) {
        return;
    }

    /* Check bounds */
    if (*playbackFrame >= *maxFrames - 1) {
        *playbackState = 0;  /* Playback complete */
        return;
    }

    /* Get interpolation frames */
    frame0 = *playbackFrame;
    frame1 = frame0 + 1;

    /* Calculate interpolation factor (sub-frame position) */
    frameCount = (s32 *)D_80159A20;
    t = (f32)((*frameCount) & 1) * 0.5f;

    /* Frame data layout: 9 floats per frame (pos[3], rot[3], vel[3]) */
    offset0 = frame0 * 9;
    offset1 = frame1 * 9;

    /* Interpolate position */
    ghostPos[0] = frameData[offset0 + 0] * (1.0f - t) + frameData[offset1 + 0] * t;
    ghostPos[1] = frameData[offset0 + 1] * (1.0f - t) + frameData[offset1 + 1] * t;
    ghostPos[2] = frameData[offset0 + 2] * (1.0f - t) + frameData[offset1 + 2] * t;

    /* Interpolate rotation (simple lerp, should use slerp for accuracy) */
    ghostRot[0] = frameData[offset0 + 3] * (1.0f - t) + frameData[offset1 + 3] * t;
    ghostRot[1] = frameData[offset0 + 4] * (1.0f - t) + frameData[offset1 + 4] * t;
    ghostRot[2] = frameData[offset0 + 5] * (1.0f - t) + frameData[offset1 + 5] * t;

    /* Interpolate velocity (for motion blur) */
    ghostVel[0] = frameData[offset0 + 6] * (1.0f - t) + frameData[offset1 + 6] * t;
    ghostVel[1] = frameData[offset0 + 7] * (1.0f - t) + frameData[offset1 + 7] * t;
    ghostVel[2] = frameData[offset0 + 8] * (1.0f - t) + frameData[offset1 + 8] * t;

    /* Advance playback frame every other game frame */
    if (((*frameCount) & 1) == 0) {
        (*playbackFrame)++;
    }
}

/*

 * func_800F4634 (908 bytes)
 * Ghost save - saves ghost data to controller pak
 */
void func_800F4634(void *ghost, s32 slot) {
    s32 *maxFrames;
    s32 *trackId;
    s32 *lapTime;
    f32 *frameData;
    u8 *saveBuffer;
    s32 frameCount;
    s32 dataSize;
    s32 headerSize;
    s32 i;
    s32 result;

    if (ghost == NULL) {
        return;
    }

    if (slot < 0 || slot >= 4) {
        return;
    }

    maxFrames = (s32 *)((u8 *)ghost + 0x08);
    trackId = (s32 *)((u8 *)ghost + 0x0C);
    lapTime = (s32 *)((u8 *)ghost + 0x10);
    frameData = (f32 *)((u8 *)ghost + 0x100);

    frameCount = *maxFrames;
    if (frameCount <= 0) {
        return;
    }

    /* Calculate save data size */
    headerSize = 32;  /* Track ID, lap time, frame count, checksum */
    dataSize = frameCount * 9 * sizeof(f32);  /* 9 floats per frame */

    /* Allocate temporary save buffer */
    saveBuffer = (u8 *)0x80180000;  /* Temporary buffer area */

    /* Write header */
    saveBuffer[0] = 'G';
    saveBuffer[1] = 'H';
    saveBuffer[2] = 'S';
    saveBuffer[3] = 'T';
    *((s32 *)(saveBuffer + 4)) = *trackId;
    *((s32 *)(saveBuffer + 8)) = *lapTime;
    *((s32 *)(saveBuffer + 12)) = frameCount;
    *((s32 *)(saveBuffer + 16)) = 0x20490001;  /* Version */

    /* Copy frame data */
    for (i = 0; i < frameCount * 9; i++) {
        *((f32 *)(saveBuffer + headerSize + i * 4)) = frameData[i];
    }

    /* Calculate checksum */
    {
        u32 checksum = 0;
        for (i = 0; i < headerSize + dataSize - 4; i++) {
            checksum += saveBuffer[i];
        }
        *((u32 *)(saveBuffer + headerSize + dataSize - 4)) = checksum;
    }

    /* Save to controller pak slot */
    result = osPfsWriteFile((OSPfs *)0x80140000, slot, 0, headerSize + dataSize, saveBuffer);
    if (result != 0) {
        /* Save failed - could set error flag */
    }
}

/*

 * func_800F49C0 (876 bytes)
 * Ghost load - loads ghost data from controller pak
 */
s32 func_800F49C0(void *ghost, s32 slot) {
    s32 *maxFrames;
    s32 *trackId;
    s32 *lapTime;
    s32 *playbackState;
    s32 *playbackFrame;
    f32 *frameData;
    u8 *loadBuffer;
    s32 frameCount;
    s32 dataSize;
    s32 headerSize;
    s32 i;
    s32 result;
    u32 checksum, storedChecksum;

    if (ghost == NULL) {
        return -1;
    }

    if (slot < 0 || slot >= 4) {
        return -2;
    }

    /* Use temporary buffer */
    loadBuffer = (u8 *)0x80180000;
    headerSize = 32;

    /* Read header first to get size */
    result = osPfsReadFile((OSPfs *)0x80140000, slot, 0, headerSize, loadBuffer);
    if (result != 0) {
        return -3;
    }

    /* Verify magic number */
    if (loadBuffer[0] != 'G' || loadBuffer[1] != 'H' ||
        loadBuffer[2] != 'S' || loadBuffer[3] != 'T') {
        return -4;
    }

    /* Get header data */
    frameCount = *((s32 *)(loadBuffer + 12));
    if (frameCount <= 0 || frameCount > 18000) {  /* Max 5 minute recording at 60fps */
        return -5;
    }

    /* Calculate data size and read full data */
    dataSize = frameCount * 9 * sizeof(f32);
    result = osPfsReadFile((OSPfs *)0x80140000, slot, 0, headerSize + dataSize, loadBuffer);
    if (result != 0) {
        return -6;
    }

    /* Verify checksum */
    checksum = 0;
    for (i = 0; i < headerSize + dataSize - 4; i++) {
        checksum += loadBuffer[i];
    }
    storedChecksum = *((u32 *)(loadBuffer + headerSize + dataSize - 4));
    if (checksum != storedChecksum) {
        return -7;
    }

    /* Copy to ghost structure */
    playbackState = (s32 *)((u8 *)ghost + 0x00);
    playbackFrame = (s32 *)((u8 *)ghost + 0x04);
    maxFrames = (s32 *)((u8 *)ghost + 0x08);
    trackId = (s32 *)((u8 *)ghost + 0x0C);
    lapTime = (s32 *)((u8 *)ghost + 0x10);
    frameData = (f32 *)((u8 *)ghost + 0x100);

    *trackId = *((s32 *)(loadBuffer + 4));
    *lapTime = *((s32 *)(loadBuffer + 8));
    *maxFrames = frameCount;
    *playbackFrame = 0;
    *playbackState = 0;  /* Loaded but not playing */

    /* Copy frame data */
    for (i = 0; i < frameCount * 9; i++) {
        frameData[i] = *((f32 *)(loadBuffer + headerSize + i * 4));
    }

    return 0;
}

/*

 * func_800F4D2C (752 bytes)
 * Ghost render - renders translucent ghost car
 */
void func_800F4D2C(void *ghost) {
    s32 *playbackState;
    f32 *ghostPos;
    f32 *ghostRot;
    f32 *cameraPos;
    f32 dx, dy, dz, dist;
    f32 alpha;
    s32 carModel;
    Mtx *mtx;
    Gfx *gfx;

    if (ghost == NULL) {
        return;
    }

    playbackState = (s32 *)((u8 *)ghost + 0x00);
    if (*playbackState != 2) {
        return;  /* Not playing back */
    }

    ghostPos = (f32 *)((u8 *)ghost + 0x40);
    ghostRot = (f32 *)((u8 *)ghost + 0x50);
    carModel = *((s32 *)((u8 *)ghost + 0x20));
    cameraPos = (f32 *)0x80161000;

    /* Calculate distance to camera for LOD/culling */
    dx = ghostPos[0] - cameraPos[0];
    dy = ghostPos[1] - cameraPos[1];
    dz = ghostPos[2] - cameraPos[2];
    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    /* Cull if too far */
    if (dist > 5000.0f) {
        return;
    }

    /* Calculate alpha based on distance (fade out at range) */
    if (dist > 3000.0f) {
        alpha = 128.0f * (1.0f - (dist - 3000.0f) / 2000.0f);
    } else {
        alpha = 128.0f;  /* 50% translucent */
    }

    /* Get display list pointer */
    gfx = (Gfx *)D_80159A30;
    mtx = (Mtx *)(D_80159A40 + 0x40);

    /* Build transformation matrix */
    guTranslateF((MtxF *)mtx, ghostPos[0], ghostPos[1], ghostPos[2]);
    guRotateRPYF((MtxF *)mtx, ghostRot[0], ghostRot[1], ghostRot[2]);

    /* Set translucent render mode */
    gDPSetRenderMode(gfx++, G_RM_XLU_SURF, G_RM_XLU_SURF2);
    gDPSetPrimColor(gfx++, 0, 0, 128, 128, 255, (s32)alpha);
    gDPSetCombineMode(gfx++, G_CC_MODULATEIA_PRIM, G_CC_MODULATEIA_PRIM);

    /* Push matrix */
    gSPMatrix(gfx++, OS_K0_TO_PHYSICAL(mtx),
              G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_PUSH);

    /* Draw ghost car model (bluish tint) */
    if (carModel >= 0 && carModel < 8) {
        gSPDisplayList(gfx++, D_80130000 + carModel * 0x1000);
    }

    /* Pop matrix */
    gSPPopMatrix(gfx++, G_MTX_MODELVIEW);

    /* Restore render mode */
    gDPSetRenderMode(gfx++, G_RM_AA_ZB_OPA_SURF, G_RM_AA_ZB_OPA_SURF2);

    /* Update display list pointer */
    *((Gfx **)D_80159A30) = gfx;
}

/*

 * func_800F5000 (3832 bytes)
 * Stunt system - detects and scores aerial stunts
 */
void func_800F5000(void *car) {
    f32 *carPos;
    f32 *carVel;
    f32 *carRot;
    f32 *carAngVel;
    s32 *airborne;
    s32 *stuntState;
    s32 *currentStunt;
    s32 *comboCount;
    s32 *comboTimer;
    s32 *totalScore;
    f32 *stuntRotation;
    f32 *landingAngle;
    f32 heightAboveGround;
    f32 rotSpeed;
    f32 rollDelta, pitchDelta, yawDelta;
    s32 newStunt;
    s32 stuntScore;

    if (car == NULL) {
        return;
    }

    carPos = (f32 *)((u8 *)car + 0x24);
    carVel = (f32 *)((u8 *)car + 0x34);
    carRot = (f32 *)((u8 *)car + 0x60);
    carAngVel = (f32 *)((u8 *)car + 0x70);
    airborne = (s32 *)((u8 *)car + 0x1C0);
    stuntState = (s32 *)((u8 *)car + 0x300);
    currentStunt = (s32 *)((u8 *)car + 0x304);
    comboCount = (s32 *)((u8 *)car + 0x308);
    comboTimer = (s32 *)((u8 *)car + 0x30C);
    totalScore = (s32 *)((u8 *)car + 0x310);
    stuntRotation = (f32 *)((u8 *)car + 0x320);
    landingAngle = (f32 *)((u8 *)car + 0x330);

    /* Get height above track */
    heightAboveGround = func_800BB9B0(carPos, NULL, NULL) > 0 ? carPos[1] : 0.0f;

    /* Check if just became airborne */
    if (*airborne && *stuntState == 0) {
        *stuntState = 1;  /* Airborne, tracking */
        *currentStunt = 0;
        stuntRotation[0] = 0.0f;  /* Roll accumulator */
        stuntRotation[1] = 0.0f;  /* Pitch accumulator */
        stuntRotation[2] = 0.0f;  /* Yaw accumulator */
        landingAngle[0] = carRot[0];
        landingAngle[1] = carRot[1];
        landingAngle[2] = carRot[2];
    }

    /* While airborne, accumulate rotation */
    if (*stuntState == 1 && *airborne) {
        /* Track rotation deltas */
        rollDelta = carAngVel[0];
        pitchDelta = carAngVel[1];
        yawDelta = carAngVel[2];

        stuntRotation[0] += rollDelta;
        stuntRotation[1] += pitchDelta;
        stuntRotation[2] += yawDelta;

        /* Detect stunt types */
        newStunt = 0;

        /* Barrel roll (full 360 roll) */
        if (stuntRotation[0] > 6.28f || stuntRotation[0] < -6.28f) {
            if (stuntRotation[0] > 0) {
                newStunt |= 0x01;  /* Right barrel roll */
            } else {
                newStunt |= 0x02;  /* Left barrel roll */
            }
            stuntRotation[0] = 0.0f;  /* Reset for next roll */
        }

        /* Flip (full 360 pitch) */
        if (stuntRotation[1] > 6.28f || stuntRotation[1] < -6.28f) {
            if (stuntRotation[1] > 0) {
                newStunt |= 0x04;  /* Front flip */
            } else {
                newStunt |= 0x08;  /* Back flip */
            }
            stuntRotation[1] = 0.0f;
        }

        /* Spin (full 360 yaw) */
        if (stuntRotation[2] > 6.28f || stuntRotation[2] < -6.28f) {
            if (stuntRotation[2] > 0) {
                newStunt |= 0x10;  /* Clockwise spin */
            } else {
                newStunt |= 0x20;  /* Counter-clockwise spin */
            }
            stuntRotation[2] = 0.0f;
        }

        /* Check for half rotations (180 degrees = 3.14 radians) */
        rotSpeed = sqrtf(rollDelta * rollDelta + pitchDelta * pitchDelta + yawDelta * yawDelta);
        if (rotSpeed > 0.5f) {
            /* High speed rotation bonus */
            newStunt |= 0x40;
        }

        /* Apply new stunts */
        if (newStunt != 0) {
            *currentStunt |= newStunt;
            func_800F6144(car, newStunt);  /* Add to combo */
        }

        /* Wings extended bonus */
        if (*((s32 *)((u8 *)car + 0x1E0)) != 0) {
            /* Track wing time for bonus */
            *((s32 *)((u8 *)car + 0x340)) += 1;
        }
    }

    /* Check for landing */
    if (*stuntState == 1 && !(*airborne)) {
        /* Calculate landing quality */
        f32 landAngleDiff;
        s32 landingBonus;

        landAngleDiff = carRot[0] * carRot[0] + carRot[2] * carRot[2];
        landAngleDiff = sqrtf(landAngleDiff);

        if (landAngleDiff < 0.2f) {
            landingBonus = 3;  /* Perfect landing - 3x multiplier */
        } else if (landAngleDiff < 0.5f) {
            landingBonus = 2;  /* Good landing - 2x multiplier */
        } else if (landAngleDiff < 1.0f) {
            landingBonus = 1;  /* Normal landing */
        } else {
            landingBonus = 0;  /* Crash - no points */
            *comboCount = 0;
            *comboTimer = 0;
        }

        if (landingBonus > 0 && *currentStunt != 0) {
            /* Calculate stunt score */
            stuntScore = func_800F5EF8(*currentStunt);
            stuntScore *= landingBonus;

            /* Apply combo multiplier */
            if (*comboCount > 1) {
                stuntScore *= *comboCount;
            }

            *totalScore += stuntScore;

            /* Display stunt notification */
            stunt_command_send(*currentStunt, stuntScore, landingBonus);
        }

        /* Reset stunt state */
        *stuntState = 0;
        *currentStunt = 0;
    }

    /* Decay combo timer */
    if (*comboTimer > 0) {
        (*comboTimer)--;
        if (*comboTimer == 0) {
            *comboCount = 0;
        }
    }
}

/*

 * func_800F5EF8 (588 bytes)
 * Stunt score - calculates point value for stunt type
 */
s32 func_800F5EF8(s32 stuntType) {
    s32 score;
    s32 count;

    score = 0;
    count = 0;

    /* Right barrel roll - 500 points */
    if (stuntType & 0x01) {
        score += 500;
        count++;
    }

    /* Left barrel roll - 500 points */
    if (stuntType & 0x02) {
        score += 500;
        count++;
    }

    /* Front flip - 750 points */
    if (stuntType & 0x04) {
        score += 750;
        count++;
    }

    /* Back flip - 750 points */
    if (stuntType & 0x08) {
        score += 750;
        count++;
    }

    /* Clockwise spin - 300 points */
    if (stuntType & 0x10) {
        score += 300;
        count++;
    }

    /* Counter-clockwise spin - 300 points */
    if (stuntType & 0x20) {
        score += 300;
        count++;
    }

    /* High speed rotation bonus - 200 points */
    if (stuntType & 0x40) {
        score += 200;
    }

    /* Combo bonus for multiple tricks */
    if (count >= 3) {
        score = (score * 3) / 2;  /* 1.5x for triple */
    } else if (count >= 2) {
        score = (score * 5) / 4;  /* 1.25x for double */
    }

    /* Special combos */
    /* Corkscrew: barrel roll + flip */
    if ((stuntType & 0x03) && (stuntType & 0x0C)) {
        score += 1000;  /* Corkscrew bonus */
    }

    /* Rodeo: flip + spin */
    if ((stuntType & 0x0C) && (stuntType & 0x30)) {
        score += 800;  /* Rodeo bonus */
    }

    return score;
}

/*

 * func_800F6144 (1888 bytes)
 * Stunt combo - tracks and chains stunts together
 */
void func_800F6144(void *car, s32 stuntType) {
    s32 *comboCount;
    s32 *comboTimer;
    s32 *comboHistory;
    s32 *bestCombo;
    s32 *comboScore;
    s32 stuntScore;
    s32 i;

    if (car == NULL) {
        return;
    }

    comboCount = (s32 *)((u8 *)car + 0x308);
    comboTimer = (s32 *)((u8 *)car + 0x30C);
    comboHistory = (s32 *)((u8 *)car + 0x350);  /* Array of 16 recent stunts */
    bestCombo = (s32 *)((u8 *)car + 0x390);
    comboScore = (s32 *)((u8 *)car + 0x394);

    /* Add stunt to combo */
    (*comboCount)++;

    /* Reset combo timer (3 seconds at 60fps) */
    *comboTimer = 180;

    /* Shift combo history and add new stunt */
    for (i = 15; i > 0; i--) {
        comboHistory[i] = comboHistory[i - 1];
    }
    comboHistory[0] = stuntType;

    /* Calculate combo score */
    stuntScore = func_800F5EF8(stuntType);

    /* Apply combo multiplier */
    if (*comboCount >= 10) {
        stuntScore *= 5;  /* 5x at 10+ combo */
    } else if (*comboCount >= 7) {
        stuntScore *= 4;  /* 4x at 7-9 combo */
    } else if (*comboCount >= 5) {
        stuntScore *= 3;  /* 3x at 5-6 combo */
    } else if (*comboCount >= 3) {
        stuntScore *= 2;  /* 2x at 3-4 combo */
    }

    *comboScore += stuntScore;

    /* Update best combo */
    if (*comboCount > *bestCombo) {
        *bestCombo = *comboCount;
    }

    /* Check for special combo sequences */
    /* Triple roll: three barrel rolls in a row */
    if (*comboCount >= 3) {
        if ((comboHistory[0] & 0x03) && (comboHistory[1] & 0x03) && (comboHistory[2] & 0x03)) {
            *comboScore += 2000;  /* Triple roll bonus */
        }
    }

    /* Triple flip: three flips in a row */
    if (*comboCount >= 3) {
        if ((comboHistory[0] & 0x0C) && (comboHistory[1] & 0x0C) && (comboHistory[2] & 0x0C)) {
            *comboScore += 3000;  /* Triple flip bonus */
        }
    }

    /* Variety bonus: 5 different stunt types */
    if (*comboCount >= 5) {
        s32 variety = 0;
        s32 seen = 0;
        for (i = 0; i < 5; i++) {
            if ((comboHistory[i] & 0x3F) && !((comboHistory[i] & 0x3F) & seen)) {
                variety++;
                seen |= (comboHistory[i] & 0x3F);
            }
        }
        if (variety >= 4) {
            *comboScore += 1500;  /* Variety bonus */
        }
    }

    /* Play combo sound effect */
    if (*comboCount == 3) {
        func_800B37E8(0x20, 0, NULL, 0);  /* Nice combo sound */
    } else if (*comboCount == 5) {
        func_800B37E8(0x21, 0, NULL, 0);  /* Great combo sound */
    } else if (*comboCount == 10) {
        func_800B37E8(0x22, 0, NULL, 0);  /* Insane combo sound */
    }

    /* Update HUD combo display */
    scene_cleanup_slots();
}

/*

 * func_800F6894 (580 bytes)
 * Wing deploy - extends/retracts car wings for air control
 */
void func_800F6894(void *car, s32 deploy) {
    s32 *wingState;
    s32 *wingTimer;
    f32 *liftForce;
    f32 *dragCoeff;
    f32 *carVel;
    f32 speed;

    if (car == NULL) {
        return;
    }

    wingState = (s32 *)((u8 *)car + 0x1E0);
    wingTimer = (s32 *)((u8 *)car + 0x1E4);
    liftForce = (f32 *)((u8 *)car + 0x1E8);
    dragCoeff = (f32 *)((u8 *)car + 0x1EC);
    carVel = (f32 *)((u8 *)car + 0x34);

    if (deploy) {
        /* Deploy wings */
        if (*wingState == 0) {
            *wingState = 1;
            *wingTimer = 0;

            /* Play deploy sound */
            func_800B37E8(0x30, 0, NULL, 0);
        }

        /* Animate wing extension (takes 10 frames) */
        if (*wingTimer < 10) {
            (*wingTimer)++;
        }

        /* Calculate lift based on speed and wing extension */
        speed = sqrtf(carVel[0] * carVel[0] + carVel[1] * carVel[1] + carVel[2] * carVel[2]);

        /* Lift force increases with speed and wing extension */
        *liftForce = speed * 0.02f * ((f32)(*wingTimer) / 10.0f);

        /* Clamp lift force */
        if (*liftForce > 15.0f) {
            *liftForce = 15.0f;
        }

        /* Wings add drag */
        *dragCoeff = 0.05f + 0.03f * ((f32)(*wingTimer) / 10.0f);
    } else {
        /* Retract wings */
        if (*wingState == 1) {
            *wingState = 0;

            /* Play retract sound */
            func_800B37E8(0x31, 0, NULL, 0);
        }

        /* Animate wing retraction */
        if (*wingTimer > 0) {
            (*wingTimer)--;
        }

        /* Reduce lift as wings retract */
        speed = sqrtf(carVel[0] * carVel[0] + carVel[1] * carVel[1] + carVel[2] * carVel[2]);
        *liftForce = speed * 0.02f * ((f32)(*wingTimer) / 10.0f);

        /* Reduce drag */
        *dragCoeff = 0.05f + 0.03f * ((f32)(*wingTimer) / 10.0f);
    }
}

/*

 * func_800F6AD8 (740 bytes)
 * Trick detection - identifies trick type from car state
 */
s32 func_800F6AD8(void *car) {
    f32 *carRot;
    f32 *carAngVel;
    f32 *prevRot;
    s32 *airborne;
    s32 *airTime;
    f32 rollRate, pitchRate, yawRate;
    f32 totalRot;
    s32 trick;

    if (car == NULL) {
        return 0;
    }

    carRot = (f32 *)((u8 *)car + 0x60);
    carAngVel = (f32 *)((u8 *)car + 0x70);
    prevRot = (f32 *)((u8 *)car + 0x80);
    airborne = (s32 *)((u8 *)car + 0x1C0);
    airTime = (s32 *)((u8 *)car + 0x1C4);

    /* Must be airborne for tricks */
    if (!(*airborne)) {
        return 0;
    }

    /* Need minimum air time (0.5 seconds) */
    if (*airTime < 30) {
        return 0;
    }

    trick = 0;
    rollRate = carAngVel[0];
    pitchRate = carAngVel[1];
    yawRate = carAngVel[2];

    /* Detect barrel roll (high roll rate) */
    if (rollRate > 0.3f) {
        trick |= 0x01;  /* Right barrel roll */
    } else if (rollRate < -0.3f) {
        trick |= 0x02;  /* Left barrel roll */
    }

    /* Detect flip (high pitch rate) */
    if (pitchRate > 0.25f) {
        trick |= 0x04;  /* Front flip */
    } else if (pitchRate < -0.25f) {
        trick |= 0x08;  /* Back flip */
    }

    /* Detect spin (high yaw rate) */
    if (yawRate > 0.2f) {
        trick |= 0x10;  /* Clockwise spin */
    } else if (yawRate < -0.2f) {
        trick |= 0x20;  /* Counter-clockwise spin */
    }

    /* Calculate total rotation magnitude */
    totalRot = sqrtf(rollRate * rollRate + pitchRate * pitchRate + yawRate * yawRate);

    /* High speed rotation bonus */
    if (totalRot > 0.5f) {
        trick |= 0x40;
    }

    /* Detect inverted (upside down) */
    if (carRot[0] > 2.5f || carRot[0] < -2.5f) {
        trick |= 0x80;  /* Inverted bonus */
    }

    /* Detect superman (nose down, high speed) */
    if (carRot[1] < -0.8f && *airTime > 60) {
        trick |= 0x100;  /* Superman pose */
    }

    /* Store previous rotation for next frame comparison */
    prevRot[0] = carRot[0];
    prevRot[1] = carRot[1];
    prevRot[2] = carRot[2];

    return trick;
}

/*

 * func_800F6DBC (1168 bytes)
 * Landing detection - evaluates landing quality after aerial
 */
s32 func_800F6DBC(void *car) {
    f32 *carPos;
    f32 *carVel;
    f32 *carRot;
    s32 *airborne;
    s32 *wasAirborne;
    s32 *airTime;
    f32 verticalVel;
    f32 rollAngle, pitchAngle;
    f32 landingAngle;
    s32 surfaceType;
    f32 surfaceNormal[3];
    f32 surfaceHeight;
    s32 landingQuality;

    if (car == NULL) {
        return 0;
    }

    carPos = (f32 *)((u8 *)car + 0x24);
    carVel = (f32 *)((u8 *)car + 0x34);
    carRot = (f32 *)((u8 *)car + 0x60);
    airborne = (s32 *)((u8 *)car + 0x1C0);
    wasAirborne = (s32 *)((u8 *)car + 0x1C8);
    airTime = (s32 *)((u8 *)car + 0x1C4);

    /* Check if just landed */
    if (*wasAirborne && !(*airborne)) {
        /* Get surface info at landing point */
        surfaceType = func_800BB9B0(carPos, surfaceNormal, &surfaceHeight);

        /* Calculate landing angle relative to surface */
        rollAngle = carRot[0];
        pitchAngle = carRot[2];

        /* Normalize angles to 0-2pi */
        while (rollAngle > 3.14159f) rollAngle -= 6.28318f;
        while (rollAngle < -3.14159f) rollAngle += 6.28318f;
        while (pitchAngle > 3.14159f) pitchAngle -= 6.28318f;
        while (pitchAngle < -3.14159f) pitchAngle += 6.28318f;

        /* Calculate total landing angle deviation */
        landingAngle = sqrtf(rollAngle * rollAngle + pitchAngle * pitchAngle);

        /* Get vertical impact velocity */
        verticalVel = -carVel[1];  /* Positive = downward */

        /* Determine landing quality */
        if (landingAngle < 0.1f && verticalVel < 30.0f) {
            landingQuality = 4;  /* Perfect - wheels down, soft landing */
        } else if (landingAngle < 0.3f && verticalVel < 50.0f) {
            landingQuality = 3;  /* Great - mostly level */
        } else if (landingAngle < 0.6f && verticalVel < 80.0f) {
            landingQuality = 2;  /* Good - acceptable angle */
        } else if (landingAngle < 1.0f && verticalVel < 120.0f) {
            landingQuality = 1;  /* OK - rough but survivable */
        } else {
            landingQuality = 0;  /* Crash - too steep or fast */
        }

        /* Surface type affects quality */
        if (surfaceType == 0) {
            /* Off-track landing - reduce quality */
            if (landingQuality > 0) {
                landingQuality--;
            }
        }

        /* Long air time bonus */
        if (*airTime > 120 && landingQuality >= 2) {
            landingQuality++;  /* Bonus for 2+ second air */
            if (landingQuality > 4) {
                landingQuality = 4;
            }
        }

        /* Play landing sound based on quality */
        switch (landingQuality) {
            case 4:
                func_800B37E8(0x40, 0, NULL, 0);  /* Perfect landing */
                break;
            case 3:
                func_800B37E8(0x41, 0, NULL, 0);  /* Good landing */
                break;
            case 2:
            case 1:
                func_800B37E8(0x42, 0, NULL, 0);  /* Rough landing */
                break;
            case 0:
                func_800B37E8(0x43, 0, NULL, 0);  /* Crash */
                break;
        }

        /* Reset airborne tracking */
        *wasAirborne = 0;
        *airTime = 0;

        return landingQuality;
    }

    /* Track airborne state */
    *wasAirborne = *airborne;
    if (*airborne) {
        (*airTime)++;
    }

    return -1;  /* Not landing this frame */
}

/*

 * func_800F724C (252 bytes)
 * Stunt multiplier - calculates score multiplier based on conditions
 */
f32 func_800F724C(void *car) {
    s32 *comboCount;
    s32 *airTime;
    s32 *wingState;
    f32 *carVel;
    f32 multiplier;
    f32 speed;
    f32 heightBonus;

    if (car == NULL) {
        return 1.0f;
    }

    comboCount = (s32 *)((u8 *)car + 0x308);
    airTime = (s32 *)((u8 *)car + 0x1C4);
    wingState = (s32 *)((u8 *)car + 0x1E0);
    carVel = (f32 *)((u8 *)car + 0x34);

    multiplier = 1.0f;

    /* Combo multiplier */
    if (*comboCount >= 10) {
        multiplier *= 3.0f;
    } else if (*comboCount >= 7) {
        multiplier *= 2.5f;
    } else if (*comboCount >= 5) {
        multiplier *= 2.0f;
    } else if (*comboCount >= 3) {
        multiplier *= 1.5f;
    }

    /* Air time bonus (after 1 second) */
    if (*airTime > 60) {
        heightBonus = 1.0f + (f32)(*airTime - 60) / 180.0f;
        if (heightBonus > 2.0f) {
            heightBonus = 2.0f;
        }
        multiplier *= heightBonus;
    }

    /* Speed bonus */
    speed = sqrtf(carVel[0] * carVel[0] + carVel[2] * carVel[2]);
    if (speed > 100.0f) {
        multiplier *= 1.0f + (speed - 100.0f) / 200.0f;
    }

    /* Wings deployed bonus */
    if (*wingState != 0) {
        multiplier *= 1.25f;
    }

    /* Cap maximum multiplier */
    if (multiplier > 10.0f) {
        multiplier = 10.0f;
    }

    return multiplier;
}

/*

 * func_800F9428 (1604 bytes)
 * Attract mode camera - automatic camera movement for attract mode
 */
void func_800F9428(void *camera) {
    f32 *camPos;
    f32 *camTarget;
    f32 *camAngle;
    s32 camMode;
    s32 camTimer;
    s32 trackId;
    f32 t;
    f32 pathProgress;

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 12);
    camAngle = (f32 *)((u8 *)camera + 24);

    camMode = D_8015A500;
    camTimer = D_8015A504;
    trackId = D_80159A08;

    camTimer++;

    /* Switch camera mode periodically */
    if (camTimer > 300) {  /* 5 seconds */
        camMode = (camMode + 1) % 4;
        camTimer = 0;
    }

    /* Calculate path progress (0.0 to 1.0) */
    pathProgress = (f32)camTimer / 300.0f;

    switch (camMode) {
        case 0:  /* Flyover - follow track path from above */
            {
                f32 trackX, trackY, trackZ;
                s32 pathPoint = (D_8015A508 + camTimer / 10) % 100;

                /* Get track path point */
                func_800A2378(trackId, pathPoint, &trackX, &trackY, &trackZ);

                /* Position camera above and behind */
                camPos[0] = trackX + 100.0f;
                camPos[1] = trackY + 200.0f;
                camPos[2] = trackZ + 100.0f;

                /* Look at path */
                camTarget[0] = trackX;
                camTarget[1] = trackY;
                camTarget[2] = trackZ;
            }
            break;

        case 1:  /* Rotating around center */
            {
                f32 centerX = D_8015A510;
                f32 centerY = D_8015A514;
                f32 centerZ = D_8015A518;
                f32 radius = 500.0f;
                f32 angle = pathProgress * 6.28318f;  /* Full rotation */

                camPos[0] = centerX + radius * sinf(angle);
                camPos[1] = centerY + 150.0f;
                camPos[2] = centerZ + radius * cosf(angle);

                camTarget[0] = centerX;
                camTarget[1] = centerY;
                camTarget[2] = centerZ;
            }
            break;

        case 2:  /* Follow car (if any) */
            {
                void *car = D_8015A520;
                if (car != NULL) {
                    f32 *carPos = (f32 *)((u8 *)car + 0x10);
                    f32 *carDir = (f32 *)((u8 *)car + 0x40);

                    /* Position behind and above car */
                    camPos[0] = carPos[0] - carDir[0] * 80.0f;
                    camPos[1] = carPos[1] + 40.0f;
                    camPos[2] = carPos[2] - carDir[2] * 80.0f;

                    camTarget[0] = carPos[0];
                    camTarget[1] = carPos[1];
                    camTarget[2] = carPos[2];
                }
            }
            break;

        case 3:  /* Static scenic view */
            {
                s32 viewIdx = D_8015A524;
                func_800A2504(NULL, NULL, 0);
            }
            break;
    }

    D_8015A500 = camMode;
    D_8015A504 = camTimer;
}

/*

 * func_800F9A74 (952 bytes)
 * Demo playback - plays back a recorded demo for attract mode
 */
void func_800F9A74(void *demo) {
    u8 *demoData;
    s32 demoFrame;
    s32 demoLength;
    s32 input;
    void *car;

    demoData = (u8 *)demo;
    demoFrame = D_8015A530;
    demoLength = *(s32 *)demoData;  /* First 4 bytes = length */

    /* Check for user input to skip */
    input = (s32)(long)D_80158100[0] & 0xFFFF;
    if (input & 0x9000) {  /* START or A */
        D_8015A530 = 0;
        D_8015A534 = 0;  /* Demo ended */
        D_801146EC = 1;  /* Go to menu */
        return;
    }

    /* Check if demo finished */
    if (demoFrame >= demoLength) {
        D_8015A530 = 0;
        D_8015A534 = 0;
        /* Cycle to next demo or title screen */
        D_8015A538++;
        if (D_8015A538 >= 3) {
            D_8015A538 = 0;
            D_801146EC = 0;  /* Back to ATTRACT/title */
        }
        return;
    }

    /* Get player car */
    car = D_8015A520;
    if (car == NULL) {
        return;
    }

    /* Read demo input for this frame */
    {
        u32 *inputData = (u32 *)(demoData + 4 + demoFrame * 4);
        u32 demoInput = *inputData;

        /* Apply demo input to car */
        /* Input format: buttons (16 bits) + stick X (8 bits) + stick Y (8 bits) */
        *(u16 *)((u8 *)car + 0x200) = (u16)(demoInput >> 16);  /* Buttons */
        *(s8 *)((u8 *)car + 0x202) = (s8)((demoInput >> 8) & 0xFF);  /* Stick X */
        *(s8 *)((u8 *)car + 0x203) = (s8)(demoInput & 0xFF);  /* Stick Y */
    }

    /* Advance frame */
    demoFrame++;
    D_8015A530 = demoFrame;

    /* Update camera to follow demo car */
    func_800F9428(D_8015A540);

    /* Display "DEMO" text */
    {
        u32 flash = ((D_80142AFC / 30) & 1) ? 0xFFFFFFFF : 0xB4B4B4FF;
        draw_text(140, 20, "DEMO", flash);
        draw_text(105, 220, "PRESS START", 0x969696FF);
    }
}

/*

 * func_800F9E2C (684 bytes)
 * Title screen - animated logo and press start
 */
void func_800F9E2C(void) {
    s32 input;
    s32 animFrame;
    s32 logoAlpha;
    s32 textAlpha;
    s32 flashPhase;

    animFrame = D_8015A410;

    /* Handle input */
    input = (s32)(long)D_80158100[0] & 0xFFFF;

    /* Any button press goes to main menu */
    if (input & 0x9000) {  /* START or A */
        sound_play_menu(10);
        D_801146EC = 1;  /* TRKSEL / main menu state */
        D_8015A410 = 0;
        return;
    }

    /* Increment animation frame */
    animFrame++;
    if (animFrame > 600) {
        /* After 10 seconds, go to attract mode */
        D_801146EC = 0;  /* ATTRACT */
        D_8015A410 = 0;
        return;
    }

    /* Calculate logo fade in */
    if (animFrame < 60) {
        logoAlpha = (animFrame * 255) / 60;
    } else {
        logoAlpha = 255;
    }

    /* Calculate "PRESS START" flash */
    flashPhase = (animFrame / 15) & 1;
    if (animFrame < 90) {
        textAlpha = 0;
    } else {
        textAlpha = flashPhase ? 255 : 128;
    }

    /* Clear screen */
    func_800C6E60(0, 0, 320, 240, 0x000000);

    /* Draw logo (centered) */
    draw_ui_element(0, 60, 40, 200, 100, logoAlpha);

    /* Draw "2049" text */
    draw_text(135, 130, "2049", logoAlpha);

    /* Draw "PRESS START" */
    if (textAlpha > 0) {
        draw_text(105, 180, "PRESS START", textAlpha);
    }

    /* Copyright notice */
    draw_text(80, 220, "(C) 2000 MIDWAY GAMES", 0xFFFFFF78);

    D_8015A410 = animFrame;
}

/*

 * func_800FA0D8 (2356 bytes)
 * Credits display - scrolling credits screen
 */
void func_800FA0D8(void) {
    s32 scrollY;
    s32 i;
    s32 lineY;
    s32 input;
    s32 alpha;
    char *credits[32];
    s32 numLines;

    /* Credits text */
    credits[0] = "SAN FRANCISCO RUSH 2049";
    credits[1] = "";
    credits[2] = "DEVELOPED BY";
    credits[3] = "ATARI GAMES";
    credits[4] = "";
    credits[5] = "PRODUCER";
    credits[6] = "ED LOGG";
    credits[7] = "";
    credits[8] = "LEAD PROGRAMMER";
    credits[9] = "MARK PIERCE";
    credits[10] = "";
    credits[11] = "N64 PROGRAMMING";
    credits[12] = "HANFORD LEMOORE";
    credits[13] = "CHRIS WARD";
    credits[14] = "";
    credits[15] = "GAME DESIGN";
    credits[16] = "ED LOGG";
    credits[17] = "MARK PIERCE";
    credits[18] = "";
    credits[19] = "ART DIRECTOR";
    credits[20] = "WILL NOBLE";
    credits[21] = "";
    credits[22] = "TRACK DESIGN";
    credits[23] = "MARK LINN";
    credits[24] = "";
    credits[25] = "AUDIO";
    credits[26] = "BRAD FULLER";
    credits[27] = "CHRIS GRANNER";
    credits[28] = "";
    credits[29] = "SPECIAL THANKS";
    credits[30] = "MIDWAY GAMES";
    credits[31] = "";
    numLines = 32;

    scrollY = D_8015A400;

    /* Handle input */
    input = (s32)(long)D_80158100[0] & 0xFFFF;

    /* Speed up with A button */
    if (input & 0x8000) {
        scrollY = scrollY + 3;
    } else {
        scrollY = scrollY + 1;
    }

    /* Skip with B button */
    if (input & 0x4000) {
        D_8015A400 = 0;
        menu_back();
        return;
    }

    /* Check if credits finished */
    if (scrollY > numLines * 25 + 240) {
        D_8015A400 = 0;
        menu_back();
        return;
    }

    /* Clear screen */
    func_800C6E60(0, 0, 320, 240, 0x000010);

    /* Draw credits lines */
    for (i = 0; i < numLines; i++) {
        lineY = 240 - scrollY + i * 25;

        /* Skip if off screen */
        if (lineY < -20 || lineY > 250) {
            continue;
        }

        /* Calculate alpha for fade at edges */
        if (lineY < 40) {
            alpha = (lineY + 20) * 255 / 60;
        } else if (lineY > 200) {
            alpha = (250 - lineY) * 255 / 50;
        } else {
            alpha = 255;
        }
        if (alpha < 0) alpha = 0;
        if (alpha > 255) alpha = 255;

        /* Draw centered text */
        if (credits[i][0] != '\0') {
            s32 textWidth = func_800C7520(credits[i]);
            s32 textX = (320 - textWidth) / 2;

            /* Headers in brighter color */
            if (i == 0 || credits[i - 1][0] == '\0') {
                draw_text(credits[i], textX, lineY, alpha);
            } else {
                /* Names in dimmer color */
                draw_text(credits[i], textX, lineY, (alpha * 180) / 255);
            }
        }
    }

    /* Draw skip hint */
    draw_text(130, 225, "B: SKIP", 0xFFFFFF64);

    D_8015A400 = scrollY;
}

/*

 * func_800FA9E4 (1296 bytes)
 * Loading screen - displays progress bar during track loading
 */
void func_800FA9E4(f32 progress) {
    s32 barWidth;
    s32 barX = 40;
    s32 barY = 140;
    s32 barMaxWidth = 240;
    s32 barHeight = 20;
    s32 dotCount;
    s32 i;
    s32 animFrame;
    char *loadingTips[8];
    s32 tipIndex;

    loadingTips[0] = "USE WINGS FOR BIG AIR";
    loadingTips[1] = "TAP BRAKE TO DRIFT";
    loadingTips[2] = "SHORTCUTS ARE EVERYWHERE";
    loadingTips[3] = "HOLD Z FOR WING DEPLOY";
    loadingTips[4] = "COMBOS MULTIPLY SCORES";
    loadingTips[5] = "FIND ALL HIDDEN COINS";
    loadingTips[6] = "MASTER EACH SHORTCUT";
    loadingTips[7] = "USE ENVIRONMENT TO WIN";

    /* Clear screen with gradient effect */
    func_800C6E60(0, 0, 320, 240, 0x101020);

    /* Logo at top */
    draw_ui_element(1, 110, 30, 100, 50, 255);

    /* "LOADING" text with animated dots */
    animFrame = D_80142AFC & 0x1F;
    dotCount = (animFrame / 8) + 1;
    if (dotCount > 3) dotCount = 3;

    draw_text(125, 100, "LOADING", 0xFFFFFFFF);

    /* Animated dots */
    for (i = 0; i < dotCount; i++) {
        draw_text(".", 175 + i * 8, 100, 255);
    }

    /* Progress bar background */
    func_800C6E60(barX - 2, barY - 2, barMaxWidth + 4, barHeight + 4, 0x404040);

    /* Progress bar fill */
    if (progress < 0.0f) progress = 0.0f;
    if (progress > 1.0f) progress = 1.0f;
    barWidth = (s32)(progress * barMaxWidth);
    if (barWidth > 0) {
        /* Gradient fill - darker to lighter */
        func_800C6E60(barX, barY, barWidth, barHeight / 2, 0x3080E0);
        func_800C6E60(barX, barY + barHeight / 2, barWidth, barHeight / 2, 0x2060B0);
    }

    /* Progress percentage */
    {
        char percentStr[8];
        s32 pct = (s32)(progress * 100);
        percentStr[0] = '0' + (pct / 100);
        percentStr[1] = '0' + ((pct / 10) % 10);
        percentStr[2] = '0' + (pct % 10);
        percentStr[3] = '%';
        percentStr[4] = '\0';
        if (pct < 100) {
            percentStr[0] = ' ';
            if (pct < 10) percentStr[1] = ' ';
        }
        draw_text(percentStr, 145, 170, 220);
    }

    /* Loading tip */
    tipIndex = (D_80142AFC / 180) % 8;  /* Change tip every 3 seconds */
    draw_text(60, 205, "TIP:", 0xFFFFFF96);
    draw_text(loadingTips[tipIndex], 95, 205, 180);

    /* Track name being loaded */
    if (D_80159A08 >= 0 && D_80159A08 < 12) {
        char *trackNames[12];
        trackNames[0] = "MARINA";
        trackNames[1] = "HAIGHT";
        trackNames[2] = "SOMA";
        trackNames[3] = "MISSION";
        trackNames[4] = "NOB HILL";
        trackNames[5] = "EMBARCADERO";
        trackNames[6] = "PRESIDIO";
        trackNames[7] = "SUNSET";
        trackNames[8] = "RICHMOND";
        trackNames[9] = "BAY BRIDGE";
        trackNames[10] = "GOLDEN GATE";
        trackNames[11] = "ALCATRAZ";

        draw_text(trackNames[D_80159A08], 120, 70, 200);
    }
}

/*

 * func_800FAEF4 (1808 bytes)
 * Pause menu - in-race pause screen with options
 */
void func_800FAEF4(void *pause) {
    s32 input;
    s32 selectedOption;
    s32 confirmState;
    char *menuItems[6];
    s32 numItems;
    s32 i;
    s32 itemAlpha;
    s32 baseY;

    menuItems[0] = "RESUME";
    menuItems[1] = "RESTART RACE";
    menuItems[2] = "OPTIONS";
    menuItems[3] = "VIEW CONTROLS";
    menuItems[4] = "QUIT TO MENU";
    numItems = 5;

    selectedOption = D_80159F40;
    confirmState = D_80159F44;

    input = func_800CB748(D_80158100);

    if (confirmState == 0) {
        /* Normal pause menu */
        if (input == 4) {  /* Up */
            selectedOption--;
            if (selectedOption < 0) selectedOption = numItems - 1;
            sound_play_menu(12);
        } else if (input == 5) {  /* Down */
            selectedOption++;
            if (selectedOption >= numItems) selectedOption = 0;
            sound_play_menu(12);
        } else if (input == 1) {  /* A */
            if (selectedOption == 0) {
                /* Resume - unpause */
                func_800FB5F4(0);
} else if (selectedOption == 1) {
                /* Restart - confirm */
                confirmState = 1;
            } else if (selectedOption == 2) {
                /* Options submenu */
                D_80159F48 = 1;  /* Options mode */
            } else if (selectedOption == 3) {
                /* Controls view */
                D_80159F48 = 2;  /* Controls mode */
            } else if (selectedOption == 4) {
                /* Quit - confirm */
                confirmState = 2;
            }
            sound_play_menu(10);
        } else if (input == 2 || ((s32)(long)D_80158100[0] & 0x1000)) {  /* B or START */
            /* Resume */
            func_800FB5F4(0);
}
    } else if (confirmState == 1) {
        /* Restart confirmation */
        if (input == 1) {  /* A - yes */
            /* Restart race */
            D_80159F44 = 0;
            D_801146EC = 7;  /* PREPLAY */
            func_800FB5F4(0);
            sound_play_menu(10);
        } else if (input == 2) {  /* B - no */
            confirmState = 0;
            sound_play_menu(11);
        }
    } else if (confirmState == 2) {
        /* Quit confirmation */
        if (input == 1) {  /* A - yes */
            D_80159F44 = 0;
            D_801146EC = 1;  /* TRKSEL or menu */
            func_800FB5F4(0);
            sound_play_menu(10);
        } else if (input == 2) {  /* B - no */
            confirmState = 0;
            sound_play_menu(11);
        }
    }

    /* Render pause overlay */
    /* Darken background */
    func_800C6E60(0, 0, 320, 240, 0x00000080);

    /* Pause box */
    func_800C6E60(70, 50, 180, 160, 0x202040);
    func_800C6E60(72, 52, 176, 156, 0x303060);

    draw_text(130, 60, "PAUSED", 0xFFFFFFFF);

    if (confirmState == 0) {
        /* Normal menu */
        baseY = 90;
        for (i = 0; i < numItems; i++) {
            if (i == selectedOption) {
                itemAlpha = 255;
                /* Highlight bar */
                func_800C6E60(80, baseY + i * 22 - 2, 160, 18, 0x404080);
            } else {
                itemAlpha = 150;
            }
            draw_text(menuItems[i], 100, baseY + i * 22, itemAlpha);
        }
    } else if (confirmState == 1) {
        /* Restart confirmation */
        draw_text(105, 100, "RESTART RACE?", 0xFFFFFFFF);
        draw_text(100, 140, "A: YES   B: NO", 0xFFFFFFC8);
    } else if (confirmState == 2) {
        /* Quit confirmation */
        draw_text(105, 100, "QUIT TO MENU?", 0xFFFFFFFF);
        draw_text(100, 140, "A: YES   B: NO", 0xFFFFFFC8);
    }

    D_80159F40 = selectedOption;
    D_80159F44 = confirmState;
}

/*

 * func_800FB5F4 (820 bytes)
 * Pause state toggle - handles entering/exiting pause
 */
void func_800FB5F4(s32 pause) {
    s32 prevPause;

    prevPause = D_80159F50;
    D_80159F50 = pause;

    if (pause && !prevPause) {
        /* Entering pause */
        D_80159F40 = 0;  /* Reset menu selection */
        D_80159F44 = 0;  /* Reset confirm state */
        D_80159F48 = 0;  /* Reset submenu state */

        /* Pause game timer */
        D_80159F54 = D_80142AFC;  /* Store pause start time */

        /* Stop audio */
        func_800B37E8(0, 0, NULL, 0);  /* Pause music */
        sound_play_menu(15);  /* Pause sound effect */

        /* Set render mode for pause overlay */
        D_80159F58 = 1;

    } else if (!pause && prevPause) {
        /* Exiting pause */
        s32 pauseDuration;

        /* Calculate pause duration and adjust game timer */
        pauseDuration = D_80142AFC - D_80159F54;
        D_8015A000 = D_8015A000 + pauseDuration;  /* Add to pause accumulator */

        /* Resume audio */
        func_800B37E8(1, 0, NULL, 0);  /* Resume music */

        /* Clear pause state */
        D_80159F58 = 0;
    }
}

/*

 * func_800FB928 (712 bytes)
 * Game timer update - updates race clock and lap times
 */
void func_800FB928(void) {
    s32 currentFrame;
    s32 elapsedTime;
    s32 raceTime;
    s32 i;

    /* Skip if paused */
    if (D_80159F50) {
        return;
    }

    currentFrame = D_80142AFC;

    /* Calculate race time (excluding pause time) */
    elapsedTime = currentFrame - D_8015A004;  /* Start time */
    elapsedTime = elapsedTime - D_8015A000;   /* Subtract pause time */

    /* Convert frames to hundredths (60fps) */
    raceTime = (elapsedTime * 100) / 60;

    /* Store current race time */
    D_8015A008 = raceTime;

    /* Update lap time */
    D_8015A00C = raceTime - D_8015A010;  /* Current lap = race - last lap total */

    /* Update split times for display */
    for (i = 0; i < 4; i++) {
        if (D_8015A020[i] > 0) {
            s32 splitAge = currentFrame - D_8015A030[i];
            if (splitAge > 180) {  /* 3 seconds */
                D_8015A020[i] = 0;  /* Clear split display */
            }
        }
    }

    /* Time limit check (if enabled) */
    if (D_80159A18 > 0) {
        s32 timeLimit = D_80159A18 * 100;  /* In hundredths */
        if (raceTime >= timeLimit) {
            /* Time's up! */
            D_8015A040 = 1;  /* Time expired flag */
        }
    }

    /* Best lap tracking */
    if (D_8015A00C > 0 && D_8015A00C < D_8015A044) {
        D_8015A044 = D_8015A00C;  /* New best lap */
    }
}

/*

 * func_800FC3D8 (1516 bytes)
 * Bonus mode - hidden coin collection mode
 */
void func_800FC3D8(void *bonus) {
    s32 coinCount;
    s32 totalCoins;
    s32 i;
    s32 trackId;

    trackId = D_80159A08;
    coinCount = 0;
    totalCoins = D_8015A050[trackId];  /* Total coins on track */

    /* Count collected coins */
    for (i = 0; i < 16; i++) {
        if (D_8015A060[trackId * 16 + i] != 0) {
            coinCount++;
        }
    }

    /* Update HUD coin counter */
    D_8015A080 = coinCount;
    D_8015A084 = totalCoins;

    /* Check for all coins collected */
    if (coinCount >= totalCoins && totalCoins > 0) {
        /* All coins collected - trigger unlock */
        if (D_8015A088 == 0) {
            D_8015A088 = 1;  /* Coins complete flag */
            func_800FCEB0(trackId + 20);  /* Unlock bonus for this track */
            sound_play_menu(20);  /* Bonus sound */
        }
    }

    /* Render coin HUD */
    {
        char coinStr[8];
        s32 x = 260;
        s32 y = 20;

        /* Coin icon */
        draw_ui_element(30, x, y, 16, 16, 255);

        /* Count text */
        coinStr[0] = '0' + (coinCount / 10);
        coinStr[1] = '0' + (coinCount % 10);
        coinStr[2] = '/';
        coinStr[3] = '0' + (totalCoins / 10);
        coinStr[4] = '0' + (totalCoins % 10);
        coinStr[5] = '\0';
        draw_text(coinStr, x + 20, y + 2, 255);
    }
}

/*

 * func_800FC9B8 (1284 bytes)
 * Unlock check - check if content is unlocked
 *
 * Unlock IDs:
 * 0-11: Tracks (0=Marina, 1=Haight, etc.)
 * 12-19: Cars (12=Venom, 13=Crusher, etc.)
 * 20-31: Track bonuses (coins collected)
 * 32-39: Stunt arenas
 * 40-47: Paint jobs/colors
 * 48-55: Cheats
 * 56+: Misc unlocks
 */
s32 func_800FC9B8(s32 unlockId) {
    u32 unlockWord;
    s32 bitIndex;

    /* Basic tracks and cars always unlocked */
    if (unlockId < 4) {
        return 1;  /* First 4 tracks unlocked */
    }
    if (unlockId >= 12 && unlockId < 16) {
        return 1;  /* First 4 cars unlocked */
    }

    /* Check unlock bits from save data */
    unlockWord = D_8015A100[unlockId / 32];
    bitIndex = unlockId % 32;

    if (unlockWord & (1 << bitIndex)) {
        return 1;
    }

    return 0;
}

/*

 * func_800FCEB0 (948 bytes)
 * Unlock trigger - unlock new content
 */
void func_800FCEB0(s32 unlockId) {
    u32 *unlockWord;
    s32 bitIndex;
    s32 wasLocked;

    /* Check if already unlocked */
    wasLocked = !func_800FC9B8(unlockId);

    if (!wasLocked) {
        return;  /* Already unlocked */
    }

    /* Set unlock bit */
    unlockWord = &D_8015A100[unlockId / 32];
    bitIndex = unlockId % 32;
    *unlockWord = *unlockWord | (1 << bitIndex);

    /* Show unlock notification */
    D_8015A110 = unlockId;
    D_8015A114 = 300;  /* Show for 5 seconds */

    /* Play unlock sound */
    sound_play_menu(25);

    /* Queue save */
    D_8015A118 = 1;

    /* Set unlock message based on ID */
    if (unlockId >= 0 && unlockId < 12) {
        /* Track unlock */
        D_8015A11C = 0;  /* "NEW TRACK UNLOCKED!" */
    } else if (unlockId >= 12 && unlockId < 20) {
        /* Car unlock */
        D_8015A11C = 1;  /* "NEW CAR UNLOCKED!" */
    } else if (unlockId >= 20 && unlockId < 32) {
        /* Bonus unlock */
        D_8015A11C = 2;  /* "BONUS UNLOCKED!" */
    } else if (unlockId >= 32 && unlockId < 40) {
        /* Arena unlock */
        D_8015A11C = 3;  /* "NEW ARENA UNLOCKED!" */
    } else if (unlockId >= 40 && unlockId < 48) {
        /* Paint job */
        D_8015A11C = 4;  /* "NEW PAINT UNLOCKED!" */
    } else if (unlockId >= 48 && unlockId < 56) {
        /* Cheat */
        D_8015A11C = 5;  /* "CHEAT UNLOCKED!" */
    } else {
        D_8015A11C = 6;  /* "SECRET UNLOCKED!" */
    }
}

/*

 * func_800FD264 (512 bytes)
 * Progress save - save game progress to Controller Pak
 */
void func_800FD264(void) {
    u8 saveData[256];
    s32 i;
    s32 offset;
    u16 checksum;

    /* Check if save needed */
    if (D_8015A118 == 0) {
        return;
    }
    D_8015A118 = 0;

    /* Build save data block */
    offset = 0;

    /* Header/magic */
    saveData[offset++] = 'R';
    saveData[offset++] = 'U';
    saveData[offset++] = 'S';
    saveData[offset++] = 'H';

    /* Version */
    saveData[offset++] = 1;
    saveData[offset++] = 0;

    /* Unlock bits (8 bytes = 64 unlocks) */
    for (i = 0; i < 2; i++) {
        u32 unlockWord = D_8015A100[i];
        saveData[offset++] = (unlockWord >> 24) & 0xFF;
        saveData[offset++] = (unlockWord >> 16) & 0xFF;
        saveData[offset++] = (unlockWord >> 8) & 0xFF;
        saveData[offset++] = unlockWord & 0xFF;
    }

    /* Best times (12 tracks * 4 bytes = 48 bytes) */
    for (i = 0; i < 12; i++) {
        s32 time = D_80159A10[i];
        saveData[offset++] = (time >> 24) & 0xFF;
        saveData[offset++] = (time >> 16) & 0xFF;
        saveData[offset++] = (time >> 8) & 0xFF;
        saveData[offset++] = time & 0xFF;
    }

    /* Best laps (12 tracks * 4 bytes = 48 bytes) */
    for (i = 0; i < 12; i++) {
        s32 time = D_80159D10[i];
        saveData[offset++] = (time >> 24) & 0xFF;
        saveData[offset++] = (time >> 16) & 0xFF;
        saveData[offset++] = (time >> 8) & 0xFF;
        saveData[offset++] = time & 0xFF;
    }

    /* Options (8 bytes) */
    saveData[offset++] = D_80159300;  /* Music volume */
    saveData[offset++] = D_80159304;  /* SFX volume */
    saveData[offset++] = D_80159308;  /* Controller config */
    saveData[offset++] = D_8015930C;  /* Vibration */
    saveData[offset++] = D_80159310;  /* Display mode */
    saveData[offset++] = D_80159314;  /* Misc flags */
    saveData[offset++] = 0;
    saveData[offset++] = 0;

    /* Calculate checksum */
    checksum = 0;
    for (i = 0; i < offset; i++) {
        checksum = checksum + saveData[i];
    }
    saveData[offset++] = (checksum >> 8) & 0xFF;
    saveData[offset++] = checksum & 0xFF;

    /* Write to Controller Pak */
    func_800B0580(0, saveData, offset);
}

/*

 * func_800FDA90 (4560 bytes)
 * Race init - initialize race state for new race
 */
void func_800FDA90(void *race) {
    s32 i;
    s32 numPlayers;
    s32 trackId;
    s32 numLaps;

    trackId = D_80159A08;
    numLaps = D_80159A0C;
    numPlayers = D_80159C18;
    if (numPlayers < 1) numPlayers = 1;

    /* Reset timer state */
    D_8015A000 = 0;  /* Pause accumulator */
    D_8015A004 = D_80142AFC;  /* Race start frame */
    D_8015A008 = 0;  /* Race time */
    D_8015A00C = 0;  /* Lap time */
    D_8015A010 = 0;  /* Last lap total */
    D_8015A040 = 0;  /* Time expired flag */
    D_8015A044 = 0x7FFFFFFF;  /* Best lap (max) */

    /* Clear split times */
    for (i = 0; i < 4; i++) {
        D_8015A020[i] = 0;
        D_8015A030[i] = 0;
    }

    /* Initialize player race state */
    for (i = 0; i < 4; i++) {
        D_8015A200[i] = 0;  /* Position */
        D_8015A210[i] = 0;  /* Lap count */
        D_8015A220[i] = 0;  /* Checkpoint */
        D_8015A230[i] = 0;  /* Race time */
        D_8015A240[i] = 0;  /* Finished flag */
        D_8015A250[i] = 0;  /* DNF flag */
        D_8015A260[i] = 0;  /* Respawn count */
    }

    /* Load track data */
    func_800A0F74(trackId);

    /* Initialize checkpoint system */
    func_800958A4(trackId, numLaps);

    /* Initialize car positions at starting grid */
    for (i = 0; i < numPlayers; i++) {
        func_80095A30(i, i);  /* Player i at grid position i */
    }

    /* Initialize AI drones if single player or need fill */
    if (numPlayers == 1) {
        s32 numDrones = 5;  /* 5 AI opponents */
        for (i = 0; i < numDrones; i++) {
            func_800960D4(i, i + 1);  /* Drone at grid positions 1-5 */
        }
        D_8015A280 = numDrones;
    } else {
        D_8015A280 = 0;
    }

    /* Set race state */
    D_8015A290 = 0;  /* Race phase: countdown */
    D_8015A294 = 0;  /* Countdown timer */
    D_8015A298 = numLaps;

    /* Initialize stunt score if stunt mode */
    if (D_80159A04 == 2) {  /* Stunt mode */
        for (i = 0; i < 4; i++) {
            D_8015A2A0[i] = 0;  /* Score */
            D_8015A2B0[i] = 0;  /* Combo */
            D_8015A2C0[i] = 1;  /* Multiplier */
        }
    }

    /* Initialize battle mode if battle */
    if (D_80159A04 == 3) {  /* Battle mode */
        for (i = 0; i < 4; i++) {
            D_8015A2D0[i] = 0;  /* Frags */
            D_8015A2E0[i] = 0;  /* Deaths */
            D_8015A2F0[i] = 3;  /* Lives/health */
        }
    }

    /* Reset ghost recording if time attack */
    if (D_80159A14 == 0 && D_80159A04 == 1) {  /* Time attack, not playing ghost */
        D_8015A300 = 0;  /* Ghost frame count */
        D_8015A304 = 1;  /* Recording flag */
    }

    /* Initialize coin collection if bonus mode */
    D_8015A088 = 0;
    for (i = 0; i < 16; i++) {
        D_8015A060[trackId * 16 + i] = 0;
    }

    /* Play starting music */
    func_800B358C(trackId, 0.0f);

    /* Clear pause state */
    D_80159F50 = 0;
    D_80159F58 = 0;
}

/*

 * func_800FEC78 (1808 bytes)
 * Race cleanup - clean up after race ends
 */
void func_800FEC78(void) {
    s32 i;
    s32 trackId;
    s32 raceTime;
    s32 bestLap;
    s32 numPlayers;

    trackId = D_80159A08;
    raceTime = D_8015A008;
    bestLap = D_8015A044;
    numPlayers = D_80159C18;
    if (numPlayers < 1) numPlayers = 1;

    /* Stop music */
    func_800B37E8(2, 0, NULL, 0);  /* Stop */

    /* Save ghost data if recording */
    if (D_8015A304 && D_8015A240[0]) {
        /* Player finished, save ghost */
        func_800B0618(trackId, D_8015A300);
        D_8015A304 = 0;
    }

    /* Check for new records */
    if (D_80159A04 == 0 || D_80159A04 == 1) {
        /* Circuit or Time Attack */

        /* Check best race time */
        if (D_8015A240[0] && raceTime > 0) {
            if (D_80159A10[trackId] == 0 || raceTime < D_80159A10[trackId]) {
                D_80159A10[trackId] = raceTime;
                D_8015A118 = 1;  /* Queue save */
                D_8015A310 = 1;  /* New record flag */
            }
        }

        /* Check best lap */
        if (bestLap < 0x7FFFFFFF) {
            if (D_80159D10[trackId] == 0 || bestLap < D_80159D10[trackId]) {
                D_80159D10[trackId] = bestLap;
                D_8015A118 = 1;  /* Queue save */
                D_8015A314 = 1;  /* New lap record flag */
            }
        }
    }

    /* Check for stunt high score */
    if (D_80159A04 == 2) {
        s32 score = D_8015A2A0[0];
        if (score > D_80159D40[trackId * 5]) {
            /* New high score - shift others down */
            for (i = 4; i > 0; i--) {
                D_80159D40[trackId * 5 + i] = D_80159D40[trackId * 5 + i - 1];
            }
            D_80159D40[trackId * 5] = score;
            D_8015A118 = 1;
            D_8015A318 = 1;  /* New stunt record flag */
        }
    }

    /* Check unlock conditions */
    /* Finishing first on a track unlocks next track */
    if (D_8015A200[0] == 1 && D_8015A240[0]) {
        s32 nextTrack = trackId + 1;
        if (nextTrack < 12 && !func_800FC9B8(nextTrack)) {
            func_800FCEB0(nextTrack);
        }
    }

    /* Perfect lap unlocks bonus car */
    if (bestLap < D_8015A320[trackId]) {  /* Par time for track */
        s32 bonusCar = 16 + (trackId / 3);  /* Bonus cars 16-19 */
        if (!func_800FC9B8(bonusCar)) {
            func_800FCEB0(bonusCar);
        }
    }

    /* Update statistics */
    D_8015A330++;  /* Total races */
    if (D_8015A200[0] == 1 && D_8015A240[0]) {
        D_8015A334++;  /* Wins */
    }
    D_8015A338 = D_8015A338 + D_8015A33C;  /* Add distance traveled */

    /* Free track resources */
    func_800A11E4(trackId, 0, 0, NULL, 0, 0);

    /* Clear drone state */
    for (i = 0; i < 8; i++) {
        func_800963B0(i);
    }

    /* Save progress */
    func_800FD264();
}

/*

 * func_80087118 (1772 bytes)
 * Major RDP render mode setup
 */
void func_80087118(s32 mode, s32 flags) {
    u32 *dlPtr;
    u32 currentMode;

    dlPtr = *(u32 **)(0x80149438);

    /* Set render mode based on flags */
    currentMode = *(u32 *)(0x8013E60C);

    /* Complex render mode setup - stub */
}

/*
 * func_80087A08 (10048 bytes)
 * Major object rendering function - Renders 3D objects with transforms
 *
 * Handles model rendering with transformation matrix, lighting, and texturing.
 * This is one of the largest and most complex render functions.
 *
 * @param object Object data structure with model and state
 * @param matrix Transformation matrix (4x4 fixed point)
 */
void func_80087A08(void *object, void *matrix) {
    u32 *dlPtr;
    u8 *objData;
    s32 *mtx;
    void *model;
    s32 flags;
    s32 numVerts;
    s32 numTris;

    if (object == NULL) {
        return;
    }

    objData = (u8 *)object;
    dlPtr = *(u32 **)0x80149438;

    /* Get object flags and model pointer */
    flags = *(s32 *)(objData + 0x08);
    model = *(void **)(objData + 0x10);

    if (model == NULL) {
        return;
    }

    /* Check visibility flag */
    if (!(flags & 0x01)) {
        return;
    }

    /* Push matrix if provided */
    if (matrix != NULL) {
        mtx = (s32 *)matrix;

        /* G_MTX with push */
        *dlPtr++ = 0xDA380001;
        *dlPtr++ = (u32)matrix;
    }

    /* Set geometry mode */
    *dlPtr++ = 0xB7000000;
    *dlPtr++ = 0x00022000;  /* Enable lighting and culling */

    /* Load model vertices and triangles */
    numVerts = *(s32 *)((u8 *)model + 0x00);
    numTris = *(s32 *)((u8 *)model + 0x04);

    if (numVerts > 0 && numVerts <= 32) {
        void *vertData = *(void **)((u8 *)model + 0x08);

        /* G_VTX - load vertices */
        *dlPtr++ = 0x01000000 | ((numVerts - 1) << 12) | (numVerts << 1);
        *dlPtr++ = (u32)vertData;
    }

    if (numTris > 0) {
        void *triData = *(void **)((u8 *)model + 0x0C);

        /* G_DL - call display list for triangles */
        *dlPtr++ = 0x06000000;
        *dlPtr++ = (u32)triData;
    }

    /* Pop matrix if we pushed one */
    if (matrix != NULL) {
        *dlPtr++ = 0xD8380040;
        *dlPtr++ = 0x00000040;
    }

    *(u32 **)0x80149438 = dlPtr;
}

/*
 * func_8008A77C (676 bytes)
 * Audio queue processing - Processes pending audio commands
 *
 * Dequeues and executes audio commands from the audio subsystem queue.
 *
 * @param queue Audio command queue structure
 */
void func_8008A77C(void *queue) {
    u8 *queueData;
    s32 head, tail;
    s32 *cmdPtr;
    s32 cmd, param1, param2;

    if (queue == NULL) {
        return;
    }

    queueData = (u8 *)queue;
    head = *(s32 *)(queueData + 0x00);
    tail = *(s32 *)(queueData + 0x04);

    while (head != tail) {
        /* Get command from queue */
        cmdPtr = (s32 *)(queueData + 0x10 + head * 12);
        cmd = cmdPtr[0];
        param1 = cmdPtr[1];
        param2 = cmdPtr[2];

        switch (cmd) {
            case 0:  /* Play sound */
                func_800B358C(param1, (f32)param2 / 255.0f);
                break;

            case 1:  /* Stop sound */
                func_800B362C(0, 0);
                break;

            case 2:  /* Set volume */
                sound_update_channel(param1, (f32)param2 / 255.0f);
                break;

            case 3:  /* Set pan */
                /* func_800B38XX(param1, param2); */
                break;

            case 4:  /* Set pitch */
                sound_update_channel(param1, (f32)param2 / 255.0f);
                break;

            case 5:  /* Fade volume */
                /* Gradual volume change over time */
                break;
        }

        /* Advance head */
        head = (head + 1) % 32;
    }

    *(s32 *)(queueData + 0x00) = head;
}

/*
 * func_8009C8F0 (5368 bytes)
 * Track geometry processing - Builds track geometry for rendering
 *
 * Processes track segment data and builds display lists for rendering.
 * Handles track surface, walls, and decorations.
 *
 * @param track Track data structure
 */
void func_8009C8F0(void *track) {
    u8 *trackData;
    s32 numSegments;
    s32 currentSegment;
    void *segmentData;
    s32 i;

    if (track == NULL) {
        return;
    }

    trackData = (u8 *)track;
    numSegments = *(s32 *)(trackData + 0x00);
    currentSegment = *(s32 *)(trackData + 0x04);

    /* Process visible segments */
    for (i = 0; i < 8; i++) {
        s32 segIdx = (currentSegment + i) % numSegments;
        segmentData = *(void **)(trackData + 0x10 + segIdx * 4);

        if (segmentData != NULL) {
            func_8009DD88(segmentData);
        }
    }

    /* Process reverse segments for rearview */
    for (i = 1; i <= 2; i++) {
        s32 segIdx = (currentSegment - i + numSegments) % numSegments;
        segmentData = *(void **)(trackData + 0x10 + segIdx * 4);

        if (segmentData != NULL) {
            func_8009DD88(segmentData);
        }
    }
}

/*
 * func_8009DD88 (3304 bytes)
 * Track segment render - Renders a single track segment
 *
 * Builds and executes display list for one track segment including
 * road surface, barriers, and decorative elements.
 *
 * @param segment Segment data structure
 */
void func_8009DD88(void *segment) {
    u8 *segData;
    u32 *dlPtr;
    void *roadVerts;
    void *barrierVerts;
    s32 roadVertCount;
    s32 barrierVertCount;
    s32 flags;

    if (segment == NULL) {
        return;
    }

    segData = (u8 *)segment;
    dlPtr = *(u32 **)0x80149438;

    /* Get segment data */
    flags = *(s32 *)(segData + 0x00);
    roadVerts = *(void **)(segData + 0x04);
    roadVertCount = *(s32 *)(segData + 0x08);
    barrierVerts = *(void **)(segData + 0x0C);
    barrierVertCount = *(s32 *)(segData + 0x10);

    /* Set up road texture */
    *dlPtr++ = 0xFD100000;  /* G_SETTIMG */
    *dlPtr++ = 0x80140000;  /* Road texture address */

    /* Set tile parameters */
    *dlPtr++ = 0xF5100000;
    *dlPtr++ = 0x00000000;

    /* Load road vertices */
    if (roadVerts != NULL && roadVertCount > 0) {
        *dlPtr++ = 0x01000000 | ((roadVertCount - 1) << 12) | (roadVertCount << 1);
        *dlPtr++ = (u32)roadVerts;

        /* Draw road surface triangles */
        *dlPtr++ = 0x06000000;
        *dlPtr++ = (u32)(segData + 0x20);  /* Triangle list offset */
    }

    /* Draw barriers if present */
    if ((flags & 0x02) && barrierVerts != NULL && barrierVertCount > 0) {
        /* Set barrier texture */
        *dlPtr++ = 0xFD100000;
        *dlPtr++ = 0x80141000;  /* Barrier texture */

        *dlPtr++ = 0x01000000 | ((barrierVertCount - 1) << 12) | (barrierVertCount << 1);
        *dlPtr++ = (u32)barrierVerts;

        *dlPtr++ = 0x06000000;
        *dlPtr++ = (u32)(segData + 0x100);  /* Barrier triangle list */
    }

    *(u32 **)0x80149438 = dlPtr;
}

/*

 * func_8009EA70 (168 bytes)
 * Track bounds check - check if position is within track boundaries
 */
s32 func_8009EA70(f32 *pos) {
    f32 *trackBounds;
    f32 x, y, z;

    if (pos == NULL) {
        return 1;  /* Out of bounds */
    }

    trackBounds = (f32 *)0x8015C000;
    x = pos[0];
    y = pos[1];
    z = pos[2];

    /* Check X bounds */
    if (x < trackBounds[0] || x > trackBounds[1]) {
        return 1;
    }

    /* Check Y bounds */
    if (y < trackBounds[2] || y > trackBounds[3]) {
        return 1;
    }

    /* Check Z bounds */
    if (z < trackBounds[4] || z > trackBounds[5]) {
        return 1;
    }

    return 0;  /* Within bounds */
}

/*

 * func_8009EB18 (168 bytes)
 * Track height query - get terrain height at position
 */
f32 func_8009EB18(f32 x, f32 z) {
    s32 *heightGrid;
    s32 gridWidth, gridHeight;
    f32 cellSize;
    s32 gridX, gridZ;
    s32 idx;
    f32 height;

    heightGrid = (s32 *)0x8015C100;
    gridWidth = 64;
    gridHeight = 64;
    cellSize = 50.0f;

    /* Convert world position to grid index */
    gridX = (s32)((x + 1600.0f) / cellSize);
    gridZ = (s32)((z + 1600.0f) / cellSize);

    /* Clamp to grid bounds */
    if (gridX < 0) gridX = 0;
    if (gridX >= gridWidth) gridX = gridWidth - 1;
    if (gridZ < 0) gridZ = 0;
    if (gridZ >= gridHeight) gridZ = gridHeight - 1;

    idx = gridZ * gridWidth + gridX;
    height = (f32)heightGrid[idx] / 256.0f;

    return height;
}

/*

 * func_8009EBC0 (1188 bytes)
 * Track surface type query - get surface material at position
 */
s32 func_8009EBC0(f32 *pos) {
    u8 *surfaceGrid;
    s32 gridWidth, gridHeight;
    f32 cellSize;
    s32 gridX, gridZ;
    s32 idx;
    s32 surfaceType;

    if (pos == NULL) {
        return 0;  /* Default asphalt */
    }

    surfaceGrid = (u8 *)0x8015D000;
    gridWidth = 64;
    gridHeight = 64;
    cellSize = 50.0f;

    /* Convert world position to grid index */
    gridX = (s32)((pos[0] + 1600.0f) / cellSize);
    gridZ = (s32)((pos[2] + 1600.0f) / cellSize);

    /* Clamp to grid bounds */
    if (gridX < 0) gridX = 0;
    if (gridX >= gridWidth) gridX = gridWidth - 1;
    if (gridZ < 0) gridZ = 0;
    if (gridZ >= gridHeight) gridZ = gridHeight - 1;

    idx = gridZ * gridWidth + gridX;
    surfaceType = surfaceGrid[idx];

    /* Surface types:
     * 0 = Asphalt (normal)
     * 1 = Dirt (low grip)
     * 2 = Grass (very low grip)
     * 3 = Sand (very low grip, slow)
     * 4 = Water (reset position)
     * 5 = Ice (slippery)
     * 6 = Boost pad
     * 7 = Jump ramp
     */
    return surfaceType;
}

/*

 * func_8009F064 (8600 bytes)
 * Track collision test - raycast against track geometry
 */
s32 func_8009F064(f32 *start, f32 *end, f32 *hitPoint) {
    f32 dir[3];
    f32 len;
    f32 t;
    f32 step;
    f32 testPos[3];
    f32 terrainHeight;
    s32 i;
    s32 maxSteps;

    if (start == NULL || end == NULL) {
        return 0;
    }

    /* Calculate ray direction */
    dir[0] = end[0] - start[0];
    dir[1] = end[1] - start[1];
    dir[2] = end[2] - start[2];

    len = sqrtf(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
    if (len < 0.001f) {
        return 0;
    }

    dir[0] /= len;
    dir[1] /= len;
    dir[2] /= len;

    /* Step along ray checking terrain height */
    step = 1.0f;
    maxSteps = (s32)(len / step) + 1;
    if (maxSteps > 200) {
        maxSteps = 200;
    }

    for (i = 0; i < maxSteps; i++) {
        t = (f32)i * step;
        if (t > len) {
            t = len;
        }

        testPos[0] = start[0] + dir[0] * t;
        testPos[1] = start[1] + dir[1] * t;
        testPos[2] = start[2] + dir[2] * t;

        /* Check terrain height at this position */
        terrainHeight = func_8009EB18(testPos[0], testPos[2]);

        /* Hit if below terrain */
        if (testPos[1] <= terrainHeight) {
            if (hitPoint != NULL) {
                hitPoint[0] = testPos[0];
                hitPoint[1] = terrainHeight;
                hitPoint[2] = testPos[2];
            }
            return 1;  /* Hit */
        }

        /* Check bounds */
        if (func_8009EA70(testPos) != 0) {
            if (hitPoint != NULL) {
                hitPoint[0] = testPos[0];
                hitPoint[1] = testPos[1];
                hitPoint[2] = testPos[2];
            }
            return 2;  /* Out of bounds */
        }
    }

    return 0;  /* No hit */
}

/*

 * func_800AF06C (1396 bytes)
 * Save game data - write save structure to buffer
 */
void func_800AF06C(void *saveData) {
    u8 *data;
    s32 offset;
    s32 i;
    s32 *unlockFlags;
    s32 *bestTimes;
    s32 *bestLaps;
    u8 *settings;

    if (saveData == NULL) {
        return;
    }

    data = (u8 *)saveData;
    offset = 0;

    /* Magic header */
    data[offset++] = 'R';
    data[offset++] = 'U';
    data[offset++] = 'S';
    data[offset++] = 'H';
    data[offset++] = '2';
    data[offset++] = '0';
    data[offset++] = '4';
    data[offset++] = '9';

    /* Version */
    data[offset++] = 0x01;
    data[offset++] = 0x00;

    /* Unlock flags (8 bytes) */
    unlockFlags = (s32 *)0x8015A100;
    for (i = 0; i < 2; i++) {
        data[offset++] = (unlockFlags[i] >> 24) & 0xFF;
        data[offset++] = (unlockFlags[i] >> 16) & 0xFF;
        data[offset++] = (unlockFlags[i] >> 8) & 0xFF;
        data[offset++] = unlockFlags[i] & 0xFF;
    }

    /* Best times (12 tracks, 4 bytes each = 48 bytes) */
    bestTimes = (s32 *)0x80159A10;
    for (i = 0; i < 12; i++) {
        data[offset++] = (bestTimes[i] >> 24) & 0xFF;
        data[offset++] = (bestTimes[i] >> 16) & 0xFF;
        data[offset++] = (bestTimes[i] >> 8) & 0xFF;
        data[offset++] = bestTimes[i] & 0xFF;
    }

    /* Best lap times (12 tracks, 4 bytes each = 48 bytes) */
    bestLaps = (s32 *)0x80159D10;
    for (i = 0; i < 12; i++) {
        data[offset++] = (bestLaps[i] >> 24) & 0xFF;
        data[offset++] = (bestLaps[i] >> 16) & 0xFF;
        data[offset++] = (bestLaps[i] >> 8) & 0xFF;
        data[offset++] = bestLaps[i] & 0xFF;
    }

    /* Settings (16 bytes) */
    settings = (u8 *)0x80159300;
    for (i = 0; i < 16; i++) {
        data[offset++] = settings[i];
    }

    /* Checksum */
    {
        u16 checksum = 0;
        for (i = 0; i < offset; i++) {
            checksum += data[i];
        }
        data[offset++] = (checksum >> 8) & 0xFF;
        data[offset++] = checksum & 0xFF;
    }
}

/*

 * func_800AF5E0 (176 bytes)
 * Save slot check - verify if save slot has valid data
 */
s32 func_800AF5E0(s32 slot) {
    OSPfs pfs;
    s32 result;
    u8 header[16];

    if (slot < 0 || slot >= 4) {
        return 0;  /* Invalid slot */
    }

    /* Initialize controller pak */
    result = osPfsInitPak(0, &pfs, slot);
    if (result != 0) {
        return 0;  /* No pak or error */
    }

    /* Read save header */
    result = osPfsReadWriteFile(&pfs, slot, PFS_READ, 0, 16, header);
    if (result != 0) {
        return 0;  /* Read error */
    }

    /* Check magic header */
    if (header[0] != 'R' || header[1] != 'U' ||
        header[2] != 'S' || header[3] != 'H' ||
        header[4] != '2' || header[5] != '0' ||
        header[6] != '4' || header[7] != '9') {
        return 0;  /* Invalid header */
    }

    return 1;  /* Valid save */
}

/*

 * func_800AF690 (572 bytes)
 * Load game data - read save from controller pak
 */
s32 func_800AF690(void *saveData, s32 slot) {
    OSPfs pfs;
    s32 result;
    u8 *data;
    s32 saveSize;

    if (saveData == NULL || slot < 0 || slot >= 4) {
        return 0;
    }

    /* Save data is 140 bytes:
     * 8 header + 2 version + 8 unlocks + 48 times + 48 laps + 16 settings + 2 checksum + padding
     */
    saveSize = 140;
    data = (u8 *)saveData;

    /* Initialize controller pak */
    result = osPfsInitPak(0, &pfs, slot);
    if (result != 0) {
        return 0;
    }

    /* Read save data */
    result = osPfsReadWriteFile(&pfs, slot, PFS_READ, 0, saveSize, data);
    if (result != 0) {
        return 0;
    }

    /* Verify header */
    if (data[0] != 'R' || data[1] != 'U' ||
        data[2] != 'S' || data[3] != 'H') {
        return 0;
    }

    /* Verify checksum */
    {
        u16 storedSum, calcSum;
        s32 i;

        storedSum = (data[saveSize - 2] << 8) | data[saveSize - 1];
        calcSum = 0;
        for (i = 0; i < saveSize - 2; i++) {
            calcSum += data[i];
        }

        if (storedSum != calcSum) {
            return 0;  /* Checksum mismatch */
        }
    }

    return 1;  /* Success */
}

/*

 * func_800AF8CC (620 bytes)
 * Delete save - erase save data from slot
 */
void func_800AF8CC(s32 slot) {
    OSPfs pfs;
    s32 result;
    u8 emptyData[140];
    s32 i;

    if (slot < 0 || slot >= 4) {
        return;
    }

    /* Initialize controller pak */
    result = osPfsInitPak(0, &pfs, slot);
    if (result != 0) {
        return;
    }

    /* Clear data buffer */
    for (i = 0; i < 140; i++) {
        emptyData[i] = 0;
    }

    /* Write empty data to slot */
    result = osPfsReadWriteFile(&pfs, slot, PFS_WRITE, 0, 140, emptyData);
    if (result != 0) {
        /* Write failed, try to delete file entry */
        osPfsDeleteFile(&pfs, 0, slot, "RUSH2049");
    }
}

/*

 * func_800AFB38 (548 bytes)
 * Save validation - verify save data integrity
 */
s32 func_800AFB38(void *saveData) {
    u8 *data;
    u16 storedChecksum, calcChecksum;
    s32 i;
    s32 dataSize;

    if (saveData == NULL) {
        return 0;
    }

    data = (u8 *)saveData;
    dataSize = 140;

    /* Check header */
    if (data[0] != 'R' || data[1] != 'U' ||
        data[2] != 'S' || data[3] != 'H' ||
        data[4] != '2' || data[5] != '0' ||
        data[6] != '4' || data[7] != '9') {
        return 0;
    }

    /* Check version */
    if (data[8] != 0x01) {
        return 0;  /* Unsupported version */
    }

    /* Verify checksum */
    storedChecksum = (data[dataSize - 2] << 8) | data[dataSize - 1];
    calcChecksum = 0;
    for (i = 0; i < dataSize - 2; i++) {
        calcChecksum += data[i];
    }

    if (storedChecksum != calcChecksum) {
        return 0;
    }

    return 1;  /* Valid */
}

/*

 * func_800AFD5C (1060 bytes)
 * Controller pak init - initialize controller pak
 */
s32 func_800AFD5C(s32 controller) {
    OSPfs pfs;
    s32 result;
    s32 *pakState;

    if (controller < 0 || controller >= 4) {
        return -1;
    }

    pakState = (s32 *)(0x80166100 + controller * 4);

    /* Initialize pak */
    result = osPfsInitPak(0, &pfs, controller);

    if (result == 0) {
        *pakState = 1;  /* Pak present and initialized */
        return 0;
    } else if (result == PFS_ERR_NOPACK) {
        *pakState = 0;  /* No pak inserted */
        return -2;
    } else {
        *pakState = -1;  /* Error */
        return -1;
    }
}

/*

 * func_800B0180 (868 bytes)
 * Controller pak read - read data from controller pak
 */
s32 func_800B0180(s32 controller, void *buffer, s32 offset, s32 size) {
    OSPfs pfs;
    s32 result;

    if (controller < 0 || controller >= 4) {
        return -1;
    }

    if (buffer == NULL || size <= 0) {
        return -1;
    }

    /* Initialize pak */
    result = osPfsInitPak(0, &pfs, controller);
    if (result != 0) {
        return -2;
    }

    /* Read data */
    result = osPfsReadWriteFile(&pfs, 0, PFS_READ, offset, size, buffer);
    if (result != 0) {
        return -3;
    }

    return size;  /* Return bytes read */
}

/*

 * func_800B0904 (396 bytes)
 * Audio init subsystem - initialize N64 audio
 */
void func_800B0904(void) {
    s32 *audioState;
    s32 *channelStates;
    s32 i;

    audioState = (s32 *)0x80130000;
    channelStates = (s32 *)0x80160000;

    /* Initialize audio state */
    audioState[0] = 1;  /* Audio enabled */
    audioState[1] = 0;  /* No sounds playing */
    audioState[2] = 0;  /* No music playing */

    /* Clear all channels */
    for (i = 0; i < 16; i++) {
        s32 *channel = channelStates + i * 16;
        channel[0] = 0;  /* Inactive */
        channel[1] = 0;  /* Volume = 0 */
        channel[2] = 0;  /* Pan center */
        channel[3] = 0;  /* Default pitch */
        channel[4] = 0;  /* No loop */
        channel[5] = 0;  /* Priority 0 */
    }

    /* Initialize audio hardware */
    osAiSetFrequency(22050);  /* 22kHz sample rate */

    /* Audio system ready */
    audioState[3] = 1;
}

/*

 * func_800B0A90 (440 bytes)
 * Audio shutdown - cleanup audio system
 */
void func_800B0A90(void) {
    s32 *audioState;
    s32 *channelStates;
    s32 i;

    audioState = (s32 *)0x80130000;
    channelStates = (s32 *)0x80160000;

    /* Stop all sounds */
    for (i = 0; i < 16; i++) {
        s32 *channel = channelStates + i * 16;
        channel[0] = 0;  /* Deactivate */
    }

    /* Stop music */
    audioState[2] = 0;

    /* Mark audio as disabled */
    audioState[0] = 0;
    audioState[3] = 0;
}

/*

 * func_800B0C48 (800 bytes)
 * Audio frame update - process audio each frame
 */
void func_800B0C48(void) {
    s32 *audioState;
    s32 *channelStates;
    s32 i;
    s32 activeCount;

    audioState = (s32 *)0x80130000;
    channelStates = (s32 *)0x80160000;

    /* Check if audio enabled */
    if (audioState[0] == 0) {
        return;
    }

    activeCount = 0;

    /* Update each channel */
    for (i = 0; i < 16; i++) {
        s32 *channel = channelStates + i * 16;

        if (channel[0] == 0) {
            continue;  /* Inactive */
        }

        activeCount++;

        /* Check if sound finished (non-looping) */
        if (channel[4] == 0) {  /* Not looping */
            s32 *timer = &channel[6];
            if (*timer > 0) {
                (*timer)--;
                if (*timer <= 0) {
                    channel[0] = 0;  /* Deactivate */
                }
            }
        }

        /* Apply volume fade if active */
        if (channel[7] != 0) {
            f32 *volume = (f32 *)&channel[1];
            f32 *fadeRate = (f32 *)&channel[8];
            f32 *fadeTarget = (f32 *)&channel[9];

            *volume += *fadeRate;

            if ((*fadeRate > 0 && *volume >= *fadeTarget) ||
                (*fadeRate < 0 && *volume <= *fadeTarget)) {
                *volume = *fadeTarget;
                channel[7] = 0;  /* Fade complete */

                if (*volume <= 0.0f) {
                    channel[0] = 0;  /* Stop if faded to silence */
                }
            }
        }
    }

    audioState[1] = activeCount;
}

/*

 * func_800B0F68 (364 bytes)
 * Sound bank load - load sound bank from ROM
 */
void func_800B0F68(s32 bankId) {
    s32 *bankState;
    u32 *bankTable;
    u32 romAddr, ramAddr, size;

    if (bankId < 0 || bankId >= 16) {
        return;
    }

    bankState = (s32 *)(0x80130100 + bankId * 4);
    bankTable = (u32 *)0x80130200;

    /* Check if already loaded */
    if (*bankState == 1) {
        return;
    }

    /* Get bank info from ROM table */
    romAddr = bankTable[bankId * 3 + 0];
    ramAddr = bankTable[bankId * 3 + 1];
    size = bankTable[bankId * 3 + 2];

    if (size == 0) {
        return;  /* Invalid bank */
    }

    /* DMA load from ROM */
    osPiStartDma(0, OS_READ, romAddr, (void *)ramAddr, size, 0);

    *bankState = 1;  /* Mark as loaded */
}

/*

 * func_800B10D4 (1248 bytes)
 * Sound bank unload - free sound bank memory
 */
void func_800B10D4(s32 bankId) {
    s32 *bankState;
    s32 *channelStates;
    s32 i;

    if (bankId < 0 || bankId >= 16) {
        return;
    }

    bankState = (s32 *)(0x80130100 + bankId * 4);
    channelStates = (s32 *)0x80160000;

    /* Check if loaded */
    if (*bankState == 0) {
        return;
    }

    /* Stop any sounds using this bank */
    for (i = 0; i < 16; i++) {
        s32 *channel = channelStates + i * 16;
        if (channel[0] != 0 && channel[10] == bankId) {
            channel[0] = 0;  /* Stop */
        }
    }

    *bankState = 0;  /* Mark as unloaded */
}

/*

 * func_800B15B4 (1428 bytes)
 * Music sequence load - load music sequence from ROM
 */
void func_800B15B4(s32 seqId) {
    s32 *audioState;
    s32 *seqState;
    u32 *seqTable;
    u32 romAddr, size;

    if (seqId < 0 || seqId >= 32) {
        return;
    }

    audioState = (s32 *)0x80130000;
    seqState = (s32 *)0x80130300;
    seqTable = (u32 *)0x80130400;

    /* Get sequence info */
    romAddr = seqTable[seqId * 2 + 0];
    size = seqTable[seqId * 2 + 1];

    if (size == 0) {
        return;
    }

    /* Load sequence to RAM */
    osPiStartDma(0, OS_READ, romAddr, (void *)0x80135000, size, 0);

    /* Store current sequence */
    seqState[0] = seqId;
    seqState[1] = size;
    seqState[2] = 0;  /* Position = start */
    seqState[3] = 0;  /* Not playing yet */

    audioState[4] = seqId;  /* Current sequence ID */
}

/*

 * func_800B1B48 (1020 bytes)
 * Music playback control - control music playback
 */
void func_800B1B48(s32 cmd, s32 param) {
    s32 *audioState;
    s32 *seqState;

    audioState = (s32 *)0x80130000;
    seqState = (s32 *)0x80130300;

    switch (cmd) {
        case 0:  /* Stop */
            seqState[3] = 0;
            audioState[2] = 0;
            break;

        case 1:  /* Play */
            seqState[3] = 1;
            audioState[2] = 1;
            break;

        case 2:  /* Pause */
            seqState[3] = 2;
            break;

        case 3:  /* Resume */
            if (seqState[3] == 2) {
                seqState[3] = 1;
            }
            break;

        case 4:  /* Restart */
            seqState[2] = 0;  /* Reset position */
            seqState[3] = 1;
            break;

        case 5:  /* Set loop */
            seqState[4] = param;
            break;

        case 6:  /* Fade out */
            seqState[5] = param;  /* Fade duration in frames */
            seqState[6] = 1;      /* Fading flag */
            break;

        default:
            break;
    }
}

/*

 * func_800B1F44 (200 bytes)
 * Music volume
 */
void func_800B1F44(f32 volume) {
    f32 *musicVolume;
    f32 *masterVolume;
    s32 i;
    f32 finalVolume;

    /* Audio system at 0x80160000, music state at offset 0x400 */
    musicVolume = (f32 *)0x80160400;
    masterVolume = (f32 *)0x80160008;

    /* Clamp volume to valid range */
    if (volume < 0.0f) {
        volume = 0.0f;
    }
    if (volume > 1.0f) {
        volume = 1.0f;
    }

    *musicVolume = volume;
    finalVolume = volume * (*masterVolume);

    /* Update all music channels (channels 12-15 are music) */
    for (i = 12; i < 16; i++) {
        f32 *channelVolume = (f32 *)(0x80160000 + (i * 0x20) + 0x08);
        *channelVolume = finalVolume;
    }
}

/*

 * func_800B200C (1612 bytes)
 * Music tempo
 */
void func_800B200C(f32 tempo) {
    f32 *musicTempo;
    f32 *baseTickRate;
    f32 *currentTickRate;
    s32 *seqPosition;
    s32 *seqData;
    s32 *seqLength;
    f32 *noteTimers;
    s32 i;

    /* Music playback state at 0x80160400 */
    musicTempo = (f32 *)0x80160410;
    baseTickRate = (f32 *)0x80160414;
    currentTickRate = (f32 *)0x80160418;
    seqPosition = (s32 *)0x80160420;
    seqData = (s32 *)0x80160428;
    seqLength = (s32 *)0x8016042C;
    noteTimers = (f32 *)0x80160500;

    /* Clamp tempo to reasonable range (0.25x to 4x) */
    if (tempo < 0.25f) {
        tempo = 0.25f;
    }
    if (tempo > 4.0f) {
        tempo = 4.0f;
    }

    *musicTempo = tempo;
    *currentTickRate = (*baseTickRate) * tempo;

    /* Scale all active note timers */
    for (i = 0; i < 64; i++) {
        if (noteTimers[i] > 0.0f) {
            noteTimers[i] = noteTimers[i] / tempo;
        }
    }

    /* Update pitch for tempo-synced sounds */
    for (i = 12; i < 16; i++) {
        f32 *channelPitch = (f32 *)(0x80160000 + (i * 0x20) + 0x10);
        f32 basePitch = *(f32 *)(0x80160000 + (i * 0x20) + 0x14);
        *channelPitch = basePitch * tempo;
    }
}

/*

 * func_800B2658 (464 bytes)
 * Sound effect play
 */
void func_800B2658(s32 soundId, f32 volume, f32 pan) {
    s32 *sfxChannels;
    s32 i;
    s32 freeChannel;
    f32 *channelVolume;
    f32 *channelPan;
    s32 *channelSound;
    s32 *channelState;
    f32 *masterVolume;
    f32 *sfxVolume;

    /* Audio system base */
    sfxChannels = (s32 *)0x80160000;
    masterVolume = (f32 *)0x80160008;
    sfxVolume = (f32 *)0x8016000C;

    /* Validate soundId */
    if (soundId < 0 || soundId >= 256) {
        return;
    }

    /* Clamp volume and pan */
    if (volume < 0.0f) volume = 0.0f;
    if (volume > 1.0f) volume = 1.0f;
    if (pan < -1.0f) pan = -1.0f;
    if (pan > 1.0f) pan = 1.0f;

    /* Find free SFX channel (0-11 are SFX, 12-15 are music) */
    freeChannel = -1;
    for (i = 0; i < 12; i++) {
        channelState = (s32 *)(0x80160000 + (i * 0x20));
        if (*channelState == 0) {
            freeChannel = i;
            break;
        }
    }

    /* If no free channel, steal oldest */
    if (freeChannel < 0) {
        s32 oldestAge = 0;
        for (i = 0; i < 12; i++) {
            s32 *channelAge = (s32 *)(0x80160000 + (i * 0x20) + 0x1C);
            if (*channelAge > oldestAge) {
                oldestAge = *channelAge;
                freeChannel = i;
            }
        }
        if (freeChannel < 0) {
            freeChannel = 0;
        }
    }

    /* Set up channel */
    channelState = (s32 *)(0x80160000 + (freeChannel * 0x20));
    channelSound = (s32 *)(0x80160000 + (freeChannel * 0x20) + 0x04);
    channelVolume = (f32 *)(0x80160000 + (freeChannel * 0x20) + 0x08);
    channelPan = (f32 *)(0x80160000 + (freeChannel * 0x20) + 0x0C);

    *channelState = 1;  /* Playing */
    *channelSound = soundId;
    *channelVolume = volume * (*masterVolume) * (*sfxVolume);
    *channelPan = pan;

    /* Reset age counter */
    *(s32 *)(0x80160000 + (freeChannel * 0x20) + 0x1C) = 0;
}

/*

 * func_800B2828 (256 bytes)
 * Sound effect stop
 */
void func_800B2828(s32 handle) {
    s32 *channelState;
    s32 *channelSound;
    s32 i;

    /* Handle is either a channel index or a sound ID to stop all instances */
    if (handle >= 0 && handle < 12) {
        /* Direct channel stop */
        channelState = (s32 *)(0x80160000 + (handle * 0x20));
        *channelState = 0;
        *(s32 *)(0x80160000 + (handle * 0x20) + 0x04) = 0;
    } else if (handle >= 256) {
        /* Stop all instances of a sound ID */
        s32 soundId = handle - 256;
        for (i = 0; i < 12; i++) {
            channelState = (s32 *)(0x80160000 + (i * 0x20));
            channelSound = (s32 *)(0x80160000 + (i * 0x20) + 0x04);
            if (*channelState != 0 && *channelSound == soundId) {
                *channelState = 0;
                *channelSound = 0;
            }
        }
    }
}

/*

 * func_800B2928 (1016 bytes)
 * 3D sound position
 */
void func_800B2928(s32 handle, f32 *pos) {
    f32 *channelPos;
    f32 *channelVolume;
    f32 *channelPan;
    f32 *listenerPos;
    f32 *listenerFwd;
    f32 dx, dy, dz;
    f32 dist, attenuation;
    f32 pan;
    f32 right_x, right_z;

    /* Validate handle */
    if (handle < 0 || handle >= 12 || pos == NULL) {
        return;
    }

    /* Get listener position and forward */
    listenerPos = (f32 *)0x80160600;
    listenerFwd = (f32 *)0x80160610;

    /* Calculate distance from listener */
    dx = pos[0] - listenerPos[0];
    dy = pos[1] - listenerPos[1];
    dz = pos[2] - listenerPos[2];
    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    /* Distance attenuation (linear falloff from 0 to 1000 units) */
    if (dist < 1.0f) {
        attenuation = 1.0f;
    } else if (dist > 1000.0f) {
        attenuation = 0.0f;
    } else {
        attenuation = 1.0f - (dist / 1000.0f);
    }

    /* Calculate pan based on listener right vector */
    /* Right vector = cross(forward, up) where up = (0,1,0) */
    right_x = listenerFwd[2];
    right_z = -listenerFwd[0];

    /* Normalize direction to listener */
    if (dist > 0.001f) {
        dx /= dist;
        dz /= dist;
    }

    /* Pan = dot(direction, right) */
    pan = dx * right_x + dz * right_z;
    if (pan < -1.0f) pan = -1.0f;
    if (pan > 1.0f) pan = 1.0f;

    /* Update channel position data */
    channelPos = (f32 *)(0x80160000 + (handle * 0x20) + 0x10);
    channelVolume = (f32 *)(0x80160000 + (handle * 0x20) + 0x08);
    channelPan = (f32 *)(0x80160000 + (handle * 0x20) + 0x0C);

    channelPos[0] = pos[0];
    channelPos[1] = pos[1];
    channelPos[2] = pos[2];

    /* Apply 3D attenuation to base volume */
    *channelVolume = (*channelVolume) * attenuation;
    *channelPan = pan;
}

/*

 * func_800B2D20 (216 bytes)
 * Sound listener position
 */
void func_800B2D20(f32 *pos, f32 *forward) {
    f32 *listenerPos;
    f32 *listenerFwd;
    f32 len;

    listenerPos = (f32 *)0x80160600;
    listenerFwd = (f32 *)0x80160610;

    if (pos != NULL) {
        listenerPos[0] = pos[0];
        listenerPos[1] = pos[1];
        listenerPos[2] = pos[2];
    }

    if (forward != NULL) {
        /* Normalize forward vector */
        len = sqrtf(forward[0] * forward[0] + forward[1] * forward[1] + forward[2] * forward[2]);
        if (len > 0.001f) {
            listenerFwd[0] = forward[0] / len;
            listenerFwd[1] = forward[1] / len;
            listenerFwd[2] = forward[2] / len;
        } else {
            /* Default forward = -Z */
            listenerFwd[0] = 0.0f;
            listenerFwd[1] = 0.0f;
            listenerFwd[2] = -1.0f;
        }
    }
}

/*

 * func_800B2DF8 (1428 bytes)
 * Engine sound update
 *
 * Based on arcade carsnd.c DoEngineSound().
 * Updates engine sound pitch and volume based on RPM and throttle.
 *
 * Car structure offsets for audio:
 *   0x10C: RPM
 *   0x100: throttle
 *   0x200: engine sound handle
 *   0x204: engine sound pitch
 *   0x208: engine sound volume
 *   0x20C: engine sound state (0=off, 1=idle, 2=revving, 3=redline)
 */

void func_800B2DF8(void *car) {
    f32 rpm;
    f32 throttle;
    s32 *soundHandle;
    s32 *soundPitch;
    s32 *soundVolume;
    s32 *soundState;
    f32 idleRpm = 800.0f;
    f32 redlineRpm = 8000.0f;
    f32 rpmNorm;
    s32 pitch, volume;

    if (car == NULL) {
        return;
    }

    rpm = *(f32 *)((u8 *)car + 0x10C);
    throttle = *(f32 *)((u8 *)car + 0x100);
    soundHandle = (s32 *)((u8 *)car + 0x200);
    soundPitch = (s32 *)((u8 *)car + 0x204);
    soundVolume = (s32 *)((u8 *)car + 0x208);
    soundState = (s32 *)((u8 *)car + 0x20C);

    /* Start engine sound if not playing */
    if (*soundHandle == 0) {
        *soundHandle = func_80090284(10, 0x8000);  /* Engine loop sound */
        *soundState = 1;  /* Idle */
    }

    if (*soundHandle == 0) {
        return;  /* Failed to start */
    }

    /* Normalize RPM (0.0 = idle, 1.0 = redline) */
    rpmNorm = (rpm - idleRpm) / (redlineRpm - idleRpm);
    if (rpmNorm < 0.0f) rpmNorm = 0.0f;
    if (rpmNorm > 1.0f) rpmNorm = 1.0f;

    /* Calculate pitch (0x1000 = normal, scaled by RPM) */
    /* Arcade uses 0x800 to 0x1700 range */
    pitch = (s32)(0x800 + rpmNorm * 0xF00);
    if (pitch > 0x1700) pitch = 0x1700;

    /* Calculate volume based on throttle and RPM */
    /* More throttle = louder */
    volume = (s32)(80 + throttle * 47 + rpmNorm * 30);
    if (volume > 127) volume = 127;
    if (volume < 40) volume = 40;

    /* Update sound state */
    if (rpmNorm > 0.9f) {
        *soundState = 3;  /* Redline */
    } else if (throttle > 0.3f) {
        *soundState = 2;  /* Revving */
    } else {
        *soundState = 1;  /* Idle */
    }

    /* Apply pitch and volume */
    if (pitch != *soundPitch) {
        func_80090F44(*soundHandle, pitch);
        *soundPitch = pitch;
    }

    if (volume != *soundVolume) {
        func_80090E9C(*soundHandle, volume);
        *soundVolume = volume;
    }
}

/*

 * func_800B338C (900 bytes)
 * Tire sound update
 *
 * Based on arcade carsnd.c DoTireSqueals().
 * Plays tire squeal sounds based on tire slip.
 *
 * Car structure offsets:
 *   0x9C: tire forces [4][3]
 *   0x210: tire squeal handles [4]
 *   0x220: tire squeal volumes [4]
 */
void func_800B338C(void *car) {
    f32 *tireForces;
    s32 *squealHandles;
    s32 *squealVolumes;
    f32 lateralForce, slipAmount;
    s32 volume;
    s32 i;

    if (car == NULL) {
        return;
    }

    tireForces = (f32 *)((u8 *)car + 0x9C);
    squealHandles = (s32 *)((u8 *)car + 0x210);
    squealVolumes = (s32 *)((u8 *)car + 0x220);

    for (i = 0; i < 4; i++) {
        /* Get lateral (side) force on this tire */
        lateralForce = fabsf(tireForces[i * 3 + 1]);

        /* Squeal threshold - need significant lateral force */
        if (lateralForce > 500.0f) {
            /* Calculate slip amount (normalized) */
            slipAmount = (lateralForce - 500.0f) / 2000.0f;
            if (slipAmount > 1.0f) slipAmount = 1.0f;

            /* Calculate volume */
            volume = (s32)(40 + slipAmount * 87);
            if (volume > 127) volume = 127;

            /* Start squeal if not playing */
            if (squealHandles[i] == 0) {
                squealHandles[i] = func_80090284(20 + i, 0x8000);  /* Tire squeal loop */
            }

            /* Update volume */
            if (squealHandles[i] != 0 && volume != squealVolumes[i]) {
                func_80090E9C(squealHandles[i], volume);
                squealVolumes[i] = volume;
            }
        } else {
            /* Stop squeal if force below threshold */
            if (squealHandles[i] != 0) {
                func_800B358C(squealHandles[i], 0.0f);
                squealHandles[i] = 0;
                squealVolumes[i] = 0;
            }
        }
    }
}

/*

 * func_800B3710 (684 bytes)
 * Collision sound trigger
 *
 * Based on arcade carsnd.c car bump sounds.
 * Plays impact sounds when car collides with objects.
 *
 * Different sounds based on intensity:
 *   Light (< 0.3): Small bump
 *   Medium (0.3-0.6): Medium crash
 *   Heavy (> 0.6): Big crash
 */

void func_800B3710(void *car, f32 intensity) {
    s32 soundId;
    s32 volume;
    s32 *lastBumpTime;

    if (car == NULL) {
        return;
    }

    lastBumpTime = (s32 *)((u8 *)car + 0x230);

    /* Debounce - don't play too frequently */
    /* Assume frame counter at D_80142AFC */
    if (*lastBumpTime > 0) {
        (*lastBumpTime)--;
        return;
    }

    /* Clamp intensity */
    if (intensity < 0.0f) intensity = 0.0f;
    if (intensity > 1.0f) intensity = 1.0f;

    /* Select sound based on intensity */
    if (intensity < 0.3f) {
        soundId = 30;  /* Light bump */
        volume = (s32)(40 + intensity * 100);
        *lastBumpTime = 5;  /* Short debounce */
    } else if (intensity < 0.6f) {
        soundId = 31;  /* Medium crash */
        volume = (s32)(60 + intensity * 67);
        *lastBumpTime = 10;  /* Medium debounce */
    } else {
        soundId = 32;  /* Heavy crash */
        volume = 127;
        *lastBumpTime = 20;  /* Long debounce */
    }

    /* Play collision sound */
    func_80091FBC(soundId, 100, volume);
}

/*

 * func_800B39BC (396 bytes)
 * Wind sound update
 *
 * Wind noise that increases with speed.
 * Based on arcade wind_state handling.
 *
 * Car structure offsets:
 *   0x34: velocity (vec3)
 *   0x234: wind sound handle
 *   0x238: wind sound volume
 */
void func_800B39BC(void *car) {
    f32 *vel;
    f32 speed;
    s32 *windHandle;
    s32 *windVolume;
    s32 volume;
    f32 speedThreshold = 30.0f;  /* Wind starts at 30 fps */
    f32 maxSpeed = 200.0f;

    if (car == NULL) {
        return;
    }

    vel = (f32 *)((u8 *)car + 0x34);
    windHandle = (s32 *)((u8 *)car + 0x234);
    windVolume = (s32 *)((u8 *)car + 0x238);

    /* Calculate speed */
    speed = sqrtf(vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2]);

    if (speed > speedThreshold) {
        /* Calculate wind volume (scales with speed) */
        volume = (s32)((speed - speedThreshold) / (maxSpeed - speedThreshold) * 100);
        if (volume > 100) volume = 100;
        if (volume < 0) volume = 0;

        /* Start wind sound if needed */
        if (*windHandle == 0) {
            *windHandle = func_80090284(40, 0x8000);  /* Wind loop */
        }

        /* Update volume */
        if (*windHandle != 0 && volume != *windVolume) {
            func_80090E9C(*windHandle, volume);
            *windVolume = volume;
        }
    } else {
        /* Stop wind sound when slow */
        if (*windHandle != 0) {
            func_800B358C(*windHandle, 0.0f);
            *windHandle = 0;
            *windVolume = 0;
        }
    }
}

/*

 * func_800B3B4C (468 bytes)
 * Crowd cheer trigger
 *
 * Plays crowd cheer sounds for stunts and checkpoints.
 * Different sounds based on intensity/achievement.
 */
void func_800B3B4C(s32 intensity) {
    s32 soundId;
    s32 volume;

    /* Select cheer based on intensity */
    if (intensity < 0) intensity = 0;
    if (intensity > 10) intensity = 10;

    if (intensity <= 2) {
        soundId = 50;  /* Small cheer */
        volume = 60 + intensity * 15;
    } else if (intensity <= 5) {
        soundId = 51;  /* Medium cheer */
        volume = 80 + intensity * 8;
    } else if (intensity <= 8) {
        soundId = 52;  /* Big cheer */
        volume = 100 + intensity * 3;
    } else {
        soundId = 53;  /* Huge cheer (epic trick) */
        volume = 127;
    }

    /* Play one-shot cheer */
    func_80091FBC(soundId, 50, volume);
}

/*

 * func_800B3D20 (488 bytes)
 * Ambient sound control
 *
 * Controls environmental ambient sounds (city noise, track ambience).
 *
 * Ambient IDs:
 *   0 = City ambient (traffic, horns)
 *   1 = Stadium ambient (crowd murmur)
 *   2 = Tunnel echo
 *   3 = Underwater muffled
 *   4 = Wind gust
 */

void func_800B3D20(s32 ambientId, f32 volume) {
    s32 intVolume;
    s32 soundId;

    if (ambientId < 0 || ambientId > 7) {
        return;
    }

    /* Clamp volume */
    if (volume < 0.0f) volume = 0.0f;
    if (volume > 1.0f) volume = 1.0f;
    intVolume = (s32)(volume * 127);

    /* Stop if volume is zero */
    if (intVolume == 0) {
        if (D_80158100[ambientId] != 0) {
            func_800B358C(D_80158100[ambientId], 0.0f);
            D_80158100[ambientId] = 0;
            D_80158120[ambientId] = 0;
        }
        return;
    }

    /* Map ambient ID to sound ID */
    soundId = 60 + ambientId;

    /* Start ambient if needed */
    if (D_80158100[ambientId] == 0) {
        D_80158100[ambientId] = func_80090284(soundId, 0x8000);  /* Loop */
    }

    /* Update volume */
    if (D_80158100[ambientId] != 0 && intVolume != D_80158120[ambientId]) {
        func_80090E9C(D_80158100[ambientId], intVolume);
        D_80158120[ambientId] = intVolume;
    }
}

/*

 * func_800B4208 (1328 bytes)
 * Voice playback
 *
 * Plays announcer voice clips for game events.
 * Voice IDs correspond to different announcements:
 *   0-2  = Race start announcer ("Ready", "Set", "Go!")
 *   3-5  = Position calls ("First!", "Second!", "Third!")
 *   6    = "Final Lap!"
 *   7    = "Time Extended!"
 *   8    = "Checkpoint!"
 *   9    = "New Record!"
 *   10   = "Game Over"
 *   11-13 = Lap calls ("2 laps", "3 laps")
 *   14-16 = Stunt calls ("Nice!", "Awesome!", "Incredible!")
 *   17   = "Wings deployed"
 *   18   = "Perfect landing!"
 *
 * Reference: Arcade announcer_sound[] and kill_announcer[] in game.c
 */
extern s32 D_80158140;          /* Current voice handle */
extern s32 D_80158144;          /* Voice playing flag */
extern s32 D_80158148;          /* Voice queue */
extern s32 D_8015814C;          /* Voice priority */
extern s32 D_80158150;          /* Voice fade timer */

/* External audio functions */

void func_800B4208(s32 voiceId) {
    s32 soundId;
    s32 priority;
    s32 baseSoundId;

    /* Validate voice ID */
    if (voiceId < 0 || voiceId > 31) {
        return;
    }

    /* Map voice ID to sound ID */
    baseSoundId = 100;  /* Voice sounds start at ID 100 */
    soundId = baseSoundId + voiceId;

    /* Determine priority (higher = more important) */
    switch (voiceId) {
        case 0: case 1: case 2:  /* Start sequence */
            priority = 100;
            break;
        case 3: case 4: case 5:  /* Position calls */
            priority = 80;
            break;
        case 6:  /* Final lap */
            priority = 90;
            break;
        case 7:  /* Time extended */
            priority = 95;
            break;
        case 8:  /* Checkpoint */
            priority = 70;
            break;
        case 9:  /* New record */
            priority = 100;
            break;
        case 10:  /* Game over */
            priority = 100;
            break;
        case 14: case 15: case 16:  /* Stunt calls */
            priority = 60;
            break;
        default:
            priority = 50;
            break;
    }

    /* Check if current voice should be preempted */
    if (D_80158144 != 0) {
        /* Voice already playing */
        if (priority <= D_8015814C) {
            /* Queue this voice if higher priority isn't playing */
            D_80158148 = voiceId;
            return;
        }

        /* Stop current voice (fade out quickly) */
        if (D_80158140 != 0) {
            func_800B358C(D_80158140, 0.0f);
            D_80158140 = 0;
        }
    }

    /* Start new voice */
    D_80158140 = func_80090284(soundId, 0x0000);  /* One-shot, no loop */

    if (D_80158140 != 0) {
        D_80158144 = 1;
        D_8015814C = priority;
        D_80158150 = 0;

        /* Set full volume for voices */
        func_80090E9C(D_80158140, 127);

        /* Center pitch */
        func_80090F44(D_80158140, 0x1000);
    }
}

/*

 * func_800B4738 (224 bytes)
 * Voice stop
 *
 * Stops the currently playing voice and clears the queue.
 * Similar to arcade kill_announcer[] usage in game.c.
 */
void func_800B4738(void) {
    /* Stop current voice */
    if (D_80158140 != 0) {
        func_800B358C(D_80158140, 0.0f);
        D_80158140 = 0;
    }

    /* Clear state */
    D_80158144 = 0;
    D_80158148 = -1;  /* Clear queue */
    D_8015814C = 0;
    D_80158150 = 0;
}

/*

 * func_800B4818 (892 bytes)
 * Audio bus mix
 *
 * Sets volume levels for different audio buses (categories).
 * N64 audio system uses multiple buses for mixing:
 *   Bus 0 = Music
 *   Bus 1 = Sound effects (engine, tire, collision)
 *   Bus 2 = Voice/announcer
 *   Bus 3 = Ambient sounds
 *   Bus 4 = UI sounds
 *
 * levels[] array: [left, right, center, sub] for each bus
 * Values 0.0-1.0
 */
extern f32 D_80158160[8][4];    /* Bus levels [bus][channel] */
extern s32 D_801581E0;          /* Bus dirty flags */

void func_800B4818(s32 bus, f32 *levels) {
    f32 left, right, center, sub;
    f32 finalLeft, finalRight;

    /* Validate bus */
    if (bus < 0 || bus > 7) {
        return;
    }

    /* Validate levels pointer */
    if (levels == NULL) {
        return;
    }

    /* Extract channel levels */
    left = levels[0];
    right = levels[1];
    center = levels[2];
    sub = levels[3];

    /* Clamp values */
    if (left < 0.0f) left = 0.0f;
    if (left > 1.0f) left = 1.0f;
    if (right < 0.0f) right = 0.0f;
    if (right > 1.0f) right = 1.0f;
    if (center < 0.0f) center = 0.0f;
    if (center > 1.0f) center = 1.0f;
    if (sub < 0.0f) sub = 0.0f;
    if (sub > 1.0f) sub = 1.0f;

    /* Store levels */
    D_80158160[bus][0] = left;
    D_80158160[bus][1] = right;
    D_80158160[bus][2] = center;
    D_80158160[bus][3] = sub;

    /* Mark bus as dirty */
    D_801581E0 |= (1 << bus);

    /* Calculate stereo mix (N64 is stereo only, no center/sub) */
    /* Center channel mixed equally to L/R */
    finalLeft = left + (center * 0.707f);
    finalRight = right + (center * 0.707f);

    /* Clamp final output */
    if (finalLeft > 1.0f) finalLeft = 1.0f;
    if (finalRight > 1.0f) finalRight = 1.0f;

    /* Apply to audio system */
    func_80091B00(0);
}

/*

 * func_800B4B94 (536 bytes)
 * Reverb setup
 *
 * Configures reverb effect for different environments.
 * Rush 2049 uses reverb for tunnels, stadiums, underwater, etc.
 *
 * Reverb types:
 *   0 = None (outdoor)
 *   1 = Small room (garage)
 *   2 = Large room (stadium)
 *   3 = Tunnel (long delay)
 *   4 = Underwater (heavy, muffled)
 *   5 = Metallic (industrial)
 *   6 = Cave
 *
 * N64 audio uses AL_FX_BIGROOM, AL_FX_SMALLROOM, etc.
 */
extern f32 D_801581E8;          /* Current reverb amount */

void func_800B4B94(s32 reverbType, f32 amount) {
    f32 decay, diffusion, wet;

    /* Validate type */
    if (reverbType < 0 || reverbType > 6) {
        reverbType = 0;
    }

    /* Clamp amount */
    if (amount < 0.0f) amount = 0.0f;
    if (amount > 1.0f) amount = 1.0f;

    /* Store current settings */
    D_801581E4 = reverbType;
    D_801581E8 = amount;

    /* Get reverb parameters based on type */
    switch (reverbType) {
        case 0:  /* None */
            decay = 0.0f;
            diffusion = 0.0f;
            wet = 0.0f;
            break;
        case 1:  /* Small room */
            decay = 0.3f;
            diffusion = 0.4f;
            wet = amount * 0.3f;
            break;
        case 2:  /* Large room */
            decay = 0.6f;
            diffusion = 0.6f;
            wet = amount * 0.4f;
            break;
        case 3:  /* Tunnel */
            decay = 1.2f;
            diffusion = 0.3f;
            wet = amount * 0.5f;
            break;
        case 4:  /* Underwater */
            decay = 0.8f;
            diffusion = 0.9f;
            wet = amount * 0.7f;
            break;
        case 5:  /* Metallic */
            decay = 0.5f;
            diffusion = 0.2f;
            wet = amount * 0.4f;
            break;
        case 6:  /* Cave */
            decay = 1.5f;
            diffusion = 0.5f;
            wet = amount * 0.6f;
            break;
        default:
            decay = 0.0f;
            diffusion = 0.0f;
            wet = 0.0f;
            break;
    }

    /* Apply to audio system */
    func_80091BA8((void*)(long)reverbType, (void*)&decay);
}

/*

 * func_800B4DAC (196 bytes)
 * Audio pause
 *
 * Pauses or resumes all game audio.
 * Used for pause menu, attract mode transitions, etc.
 */
extern s32 D_80158224;          /* Audio paused flag */

void func_800B4DAC(s32 pause) {
    /* Set paused state */
    if (pause != 0) {
        if (D_80158224 == 0) {
            D_80158224 = 1;
            func_80091CA4(1);  /* Pause audio system */
        }
    } else {
        if (D_80158224 != 0) {
            D_80158224 = 0;
            func_80091CA4(0);  /* Resume audio system */
        }
    }
}

/*

 * func_800B4E70 (2108 bytes)
 * Audio ducking
 *
 * Reduces volume of lower-priority audio when higher-priority sounds play.
 * Common in racing games to ensure voices/announcements are heard over
 * engine sounds.
 *
 * Priority levels:
 *   0 = No ducking (normal)
 *   1 = Low priority (ambient sounds duck)
 *   2 = Medium priority (SFX duck)
 *   3 = High priority (music ducks)
 *   4 = Critical (everything ducks except voice)
 */
extern s32 D_80158228;          /* Current duck priority */
extern f32 D_8015822C;          /* Duck amount (0-1) */
extern f32 D_80158244[5];       /* Duck current values */
extern s32 D_80158258;          /* Duck timer */

void func_800B4E70(s32 priority) {
    f32 duckAmount;
    f32 targetLevel;
    f32 attackRate, releaseRate;
    s32 i;

    /* Validate priority */
    if (priority < 0) priority = 0;
    if (priority > 4) priority = 4;

    /* Store priority */
    D_80158228 = priority;

    /* Calculate duck amount based on priority */
    switch (priority) {
        case 0:  /* No ducking */
            duckAmount = 0.0f;
            break;
        case 1:  /* Low - duck ambient only */
            duckAmount = 0.3f;
            break;
        case 2:  /* Medium - duck ambient and some SFX */
            duckAmount = 0.5f;
            break;
        case 3:  /* High - duck music too */
            duckAmount = 0.7f;
            break;
        case 4:  /* Critical - heavy ducking */
            duckAmount = 0.85f;
            break;
        default:
            duckAmount = 0.0f;
            break;
    }

    D_8015822C = duckAmount;

    /* Set duck targets per bus */
    /* Bus 0 = Music */
    if (priority >= 3) {
        D_80158230[0] = 1.0f - (duckAmount * 0.6f);  /* Music ducks 60% */
    } else {
        D_80158230[0] = 1.0f;
    }

    /* Bus 1 = SFX (engine, tire, collision) */
    if (priority >= 2) {
        D_80158230[1] = 1.0f - (duckAmount * 0.4f);  /* SFX duck 40% */
    } else {
        D_80158230[1] = 1.0f;
    }

    /* Bus 2 = Voice - never ducks */
    D_80158230[2] = 1.0f;

    /* Bus 3 = Ambient */
    if (priority >= 1) {
        D_80158230[3] = 1.0f - (duckAmount * 0.8f);  /* Ambient ducks 80% */
    } else {
        D_80158230[3] = 1.0f;
    }

    /* Bus 4 = UI */
    D_80158230[4] = 1.0f;

    /* Smooth transitions - attack fast, release slow */
    attackRate = 0.2f;   /* ~5 frames to duck */
    releaseRate = 0.05f; /* ~20 frames to release */

    /* Update current values toward targets */
    for (i = 0; i < 5; i++) {
        targetLevel = D_80158230[i];

        if (D_80158244[i] > targetLevel) {
            /* Ducking - fast attack */
            D_80158244[i] -= attackRate;
            if (D_80158244[i] < targetLevel) {
                D_80158244[i] = targetLevel;
            }
        } else if (D_80158244[i] < targetLevel) {
            /* Releasing - slow release */
            D_80158244[i] += releaseRate;
            if (D_80158244[i] > targetLevel) {
                D_80158244[i] = targetLevel;
            }
        }

        /* Apply ducked level to bus (stereo) */
        func_80091B00(0);
}

    /* Update timer */
    D_80158258++;
}

/*

 * func_800B5694 (184 bytes)
 * Sound priority set
 *
 * Sets priority for a sound handle.
 * Higher priority sounds won't be stolen by lower priority.
 */

void func_800B5694(s32 handle, s32 priority) {
    /* Validate handle */
    if (handle == 0) {
        return;
    }

    /* Clamp priority */
    if (priority < 0) priority = 0;
    if (priority > 255) priority = 255;

    /* Set priority in audio system */
    func_8009211C(handle, priority);
}

/*

 * func_800B574C (340 bytes)
 * Sound loop control
 *
 * Enables or disables looping for a playing sound.
 * Used for engine sounds, ambient loops, etc.
 *
 * loop: 0 = one-shot, 1 = loop forever, >1 = loop N times
 */

void func_800B574C(s32 handle, s32 loop) {
    s32 loopCount;

    /* Validate handle */
    if (handle == 0) {
        return;
    }

    /* Convert loop parameter */
    if (loop == 0) {
        loopCount = 1;  /* Play once */
    } else if (loop == 1) {
        loopCount = -1;  /* Loop forever (negative = infinite) */
    } else {
        loopCount = loop;  /* Loop specific count */
    }

    /* Set loop in audio system */
    func_80092360(loopCount);
}

/*
 * Sound pitch set helper
 */
void func_800B58A0(s32 handle, f32 pitch) {
    s32 pitchVal;

    /* Validate handle */
    if (handle == 0) {
        return;
    }

    /* Clamp pitch to reasonable range */
    if (pitch < 0.25f) pitch = 0.25f;
    if (pitch > 4.0f) pitch = 4.0f;

    /* Convert float pitch to N64 fixed-point */
    /* N64 audio uses 0x1000 = 1.0 pitch */
    pitchVal = (s32)(pitch * 4096.0f);

    /* Clamp to valid range */
    if (pitchVal < 0x400) pitchVal = 0x400;    /* 0.25x */
    if (pitchVal > 0x4000) pitchVal = 0x4000;  /* 4.0x */

    /* Set pitch */
    func_80090F44(handle, pitchVal);
}

/*

 * func_800B5948 (176 bytes)
 * Sound volume set
 *
 * Sets volume for a playing sound.
 * volume: 0.0 = silent, 1.0 = full volume
 */
void func_800B5948(s32 handle, f32 volume) {
    s32 volumeVal;

    /* Validate handle */
    if (handle == 0) {
        return;
    }

    /* Clamp volume */
    if (volume < 0.0f) volume = 0.0f;
    if (volume > 1.0f) volume = 1.0f;

    /* Convert to N64 volume (0-127) */
    volumeVal = (s32)(volume * 127.0f);

    /* Set volume */
    func_80090E9C(handle, volumeVal);
}

/*

 * func_800B59F8 (1472 bytes)
 * Audio spatialization
 *
 * Positions a sound in 3D space relative to the listener (camera).
 * Calculates pan, volume attenuation, and doppler shift.
 *
 * pos[3]: World position of sound source
 * velocity[3]: Velocity of sound source (for doppler)
 */
extern f32 D_8015825C[3];       /* Listener position (camera) */
extern f32 D_80158268[3];       /* Listener velocity */
extern f32 D_80158274[3];       /* Listener forward vector */

void func_800B59F8(s32 handle, f32 *pos, f32 *velocity) {
    f32 dx, dy, dz;
    f32 distance;
    f32 rightDot, forwardDot;
    f32 pan, volume, doppler;
    f32 relVelSource, relVelListener;
    f32 closingSpeed;
    s32 panVal, volVal, pitchVal;

    /* Validate handle */
    if (handle == 0) {
        return;
    }

    /* Calculate vector from listener to source */
    dx = pos[0] - D_8015825C[0];
    dy = pos[1] - D_8015825C[1];
    dz = pos[2] - D_8015825C[2];

    /* Calculate distance */
    distance = sqrtf(dx * dx + dy * dy + dz * dz);

    /* Avoid division by zero */
    if (distance < 1.0f) {
        distance = 1.0f;
    }

    /* Normalize direction */
    dx /= distance;
    dy /= distance;
    dz /= distance;

    /* Calculate pan based on dot product with listener's right vector */
    rightDot = dx * D_80158280[0] + dy * D_80158280[1] + dz * D_80158280[2];

    /* Pan: -1.0 = full left, 0.0 = center, 1.0 = full right */
    pan = rightDot;
    if (pan < -1.0f) pan = -1.0f;
    if (pan > 1.0f) pan = 1.0f;

    /* Calculate volume based on distance attenuation */
    volume = func_800B65B8(distance, 500.0f);

    /* Calculate forward dot for front/back attenuation */
    forwardDot = dx * D_80158274[0] + dy * D_80158274[1] + dz * D_80158274[2];

    /* Sounds behind are slightly quieter */
    if (forwardDot < 0.0f) {
        volume *= (1.0f + forwardDot * 0.3f);  /* Up to 30% quieter */
    }

    /* Doppler effect */
    if (velocity != NULL) {
        /* Calculate relative velocity along the direction vector */
        relVelSource = velocity[0] * dx + velocity[1] * dy + velocity[2] * dz;
        relVelListener = D_80158268[0] * dx + D_80158268[1] * dy + D_80158268[2] * dz;

        /* Closing speed (positive = approaching) */
        closingSpeed = relVelListener - relVelSource;

        /* Doppler ratio */
        doppler = (D_8015828C + closingSpeed * D_80158290) / D_8015828C;

        /* Clamp doppler to reasonable range */
        if (doppler < 0.5f) doppler = 0.5f;
        if (doppler > 2.0f) doppler = 2.0f;
    } else {
        doppler = 1.0f;
    }

    /* Convert to N64 audio values */
    /* Pan: 0 = left, 64 = center, 127 = right */
    panVal = (s32)((pan + 1.0f) * 63.5f);
    if (panVal < 0) panVal = 0;
    if (panVal > 127) panVal = 127;

    /* Volume: 0-127 */
    volVal = (s32)(volume * 127.0f);
    if (volVal < 0) volVal = 0;
    if (volVal > 127) volVal = 127;

    /* Pitch: 0x1000 = 1.0 */
    pitchVal = (s32)(doppler * 4096.0f);
    if (pitchVal < 0x800) pitchVal = 0x800;    /* 0.5x min */
    if (pitchVal > 0x2000) pitchVal = 0x2000;  /* 2.0x max */

    /* Apply to audio system */
    func_80092C58(handle, (void*)(long)panVal, (void*)(long)volVal, pitchVal, NULL);
}

/*

 * func_800B65B8 (464 bytes)
 * Audio distance attenuation
 *
 * Calculates volume attenuation based on distance.
 * Uses inverse distance model with rolloff.
 *
 * distance: Distance from listener to source
 * maxDist: Maximum audible distance
 *
 * Returns: Volume multiplier 0.0-1.0
 */
f32 func_800B65B8(f32 distance, f32 maxDist) {
    f32 minDist;
    f32 rolloff;
    f32 attenuation;
    f32 range;

    /* Minimum distance (full volume) */
    minDist = 10.0f;

    /* Rolloff factor (1.0 = realistic, 2.0 = faster falloff) */
    rolloff = 1.5f;

    /* Below minimum distance = full volume */
    if (distance <= minDist) {
        return 1.0f;
    }

    /* Beyond maximum distance = silent */
    if (distance >= maxDist) {
        return 0.0f;
    }

    /* Calculate attenuation using inverse distance with rolloff */
    /* Formula: 1 / (1 + rolloff * (d - minDist) / (maxDist - minDist)) */
    range = maxDist - minDist;
    attenuation = 1.0f / (1.0f + rolloff * (distance - minDist) / range);

    /* Apply squared falloff for more natural sound */
    attenuation = attenuation * attenuation;

    /* Clamp result */
    if (attenuation < 0.0f) attenuation = 0.0f;
    if (attenuation > 1.0f) attenuation = 1.0f;

    return attenuation;
}

/*

 * func_800B6788 (1124 bytes)
 * Audio doppler effect
 *
 * Calculates doppler pitch shift based on relative motion.
 * Uses the classic Doppler formula:
 *   f' = f * (c + vr) / (c + vs)
 * where c = speed of sound, vr = receiver velocity, vs = source velocity
 *
 * Returns: Pitch multiplier (1.0 = no shift, >1.0 = higher pitch, <1.0 = lower)
 */
f32 func_800B6788(f32 *listenerPos, f32 *listenerVel, f32 *sourcePos, f32 *sourceVel) {
    f32 dx, dy, dz;
    f32 dist, invDist;
    f32 dirX, dirY, dirZ;
    f32 listenerSpeed, sourceSpeed;
    f32 speedOfSound;
    f32 dopplerRatio;

    /* Speed of sound in game units (approximate) */
    speedOfSound = 1100.0f;

    /* Validate inputs */
    if (listenerPos == NULL || sourcePos == NULL) {
        return 1.0f;
    }

    /* Calculate direction from source to listener */
    dx = listenerPos[0] - sourcePos[0];
    dy = listenerPos[1] - sourcePos[1];
    dz = listenerPos[2] - sourcePos[2];

    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    /* If very close, no doppler */
    if (dist < 1.0f) {
        return 1.0f;
    }

    /* Normalize direction */
    invDist = 1.0f / dist;
    dirX = dx * invDist;
    dirY = dy * invDist;
    dirZ = dz * invDist;

    /* Calculate velocity components along the direction */
    if (listenerVel != NULL) {
        listenerSpeed = listenerVel[0] * dirX + listenerVel[1] * dirY + listenerVel[2] * dirZ;
    } else {
        listenerSpeed = 0.0f;
    }

    if (sourceVel != NULL) {
        sourceSpeed = sourceVel[0] * dirX + sourceVel[1] * dirY + sourceVel[2] * dirZ;
    } else {
        sourceSpeed = 0.0f;
    }

    /* Doppler formula: f' = f * (c + vr) / (c - vs) */
    /* Note: positive listenerSpeed = listener moving toward source */
    /* Note: positive sourceSpeed = source moving toward listener (inverted) */
    dopplerRatio = (speedOfSound + listenerSpeed) / (speedOfSound - sourceSpeed);

    /* Clamp to reasonable range */
    if (dopplerRatio < 0.5f) dopplerRatio = 0.5f;
    if (dopplerRatio > 2.0f) dopplerRatio = 2.0f;

    return dopplerRatio;
}

/*

 * func_800B6BEC (1520 bytes)
 * Audio occlusion
 *
 * Calculates audio occlusion (blocking) between listener and source.
 * Checks if geometry blocks the sound path for muffling effect.
 * Used for sounds behind walls, inside tunnels, underwater, etc.
 *
 * Returns: Occlusion factor 0.0-1.0 (1.0 = no occlusion, 0.0 = fully blocked)
 */

f32 func_800B6BEC(f32 *listenerPos, f32 *sourcePos) {
    f32 dx, dy, dz;
    f32 dist;
    f32 occlusion;
    s32 hitCount;
    f32 rayStart[3], rayEnd[3];

    /* Validate inputs */
    if (listenerPos == NULL || sourcePos == NULL) {
        return 1.0f;
    }

    /* Calculate distance */
    dx = sourcePos[0] - listenerPos[0];
    dy = sourcePos[1] - listenerPos[1];
    dz = sourcePos[2] - listenerPos[2];
    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    /* Very close = no occlusion */
    if (dist < 5.0f) {
        return 1.0f;
    }

    /* Start occlusion at full pass-through */
    occlusion = 1.0f;

    /* Check zone-based occlusion */
    switch (D_801582A0) {
        case 0:  /* Normal outdoor */
            /* No extra occlusion */
            break;
        case 1:  /* Tunnel */
            /* Tunnel reverb handled elsewhere, slight muffling */
            occlusion *= 0.9f;
            break;
        case 2:  /* Underwater */
            /* Heavy muffling underwater */
            occlusion *= 0.4f;
            break;
        case 3:  /* Indoor/garage */
            occlusion *= 0.85f;
            break;
        default:
            break;
    }

    /* Set up ray for geometry test */
    rayStart[0] = listenerPos[0];
    rayStart[1] = listenerPos[1];
    rayStart[2] = listenerPos[2];
    rayEnd[0] = sourcePos[0];
    rayEnd[1] = sourcePos[1];
    rayEnd[2] = sourcePos[2];

    /* Cast ray to check for blocking geometry */
    /* Flags: 0x01 = check buildings, 0x02 = check terrain */
    func_800A2378(0, 0, &rayStart[0], &rayStart[1], &rayStart[2]);  /* TODO: stub */
    hitCount = 0;

    /* Each hit reduces volume */
    if (hitCount > 0) {
        /* First hit = 50% reduction, each additional = 30% more */
        occlusion *= 0.5f;
        if (hitCount > 1) {
            s32 i;
            for (i = 1; i < hitCount && i < 4; i++) {
                occlusion *= 0.7f;
            }
        }
    }

    /* Distance-based additional occlusion */
    /* Far sounds are slightly more occluded */
    if (dist > 200.0f) {
        f32 distFactor = (dist - 200.0f) / 300.0f;
        if (distFactor > 1.0f) distFactor = 1.0f;
        occlusion *= (1.0f - distFactor * 0.3f);
    }

    /* Clamp result */
    if (occlusion < 0.0f) occlusion = 0.0f;
    if (occlusion > 1.0f) occlusion = 1.0f;

    return occlusion;
}

/*

 * func_800B71DC (536 bytes)
 * Entity audio update
 *
 * Updates all audio for a game entity (car, drone, object).
 * Handles 3D spatialization, occlusion, and doppler for the entity's sounds.
 *
 * Entity audio offsets:
 *   0x200: Active sound handles array [8]
 *   0x220: Sound source positions [8][3]
 *   0x280: Sound flags (playing, looping, etc)
 */
void func_800B71DC(void *entity) {
    f32 *entityPos, *entityVel;
    s32 *soundHandles;
    f32 *soundPos;
    s32 flags;
    s32 i;
    f32 occlusion, volume;
    s32 handle;

    if (entity == NULL) {
        return;
    }

    /* Get entity position and velocity */
    entityPos = (f32 *)((u8 *)entity + 0x24);
    entityVel = (f32 *)((u8 *)entity + 0x34);

    /* Get audio data */
    soundHandles = (s32 *)((u8 *)entity + 0x200);
    soundPos = (f32 *)((u8 *)entity + 0x220);
    flags = *(s32 *)((u8 *)entity + 0x280);

    /* Update each active sound */
    for (i = 0; i < 8; i++) {
        handle = soundHandles[i];

        if (handle == 0) {
            continue;
        }

        /* Check if sound slot is active */
        if ((flags & (1 << i)) == 0) {
            continue;
        }

        /* Get sound source position (relative to entity or absolute) */
        f32 sourcePos[3];
        if ((flags & (0x100 << i)) != 0) {
            /* Absolute position */
            sourcePos[0] = soundPos[i * 3 + 0];
            sourcePos[1] = soundPos[i * 3 + 1];
            sourcePos[2] = soundPos[i * 3 + 2];
        } else {
            /* Relative to entity */
            sourcePos[0] = entityPos[0] + soundPos[i * 3 + 0];
            sourcePos[1] = entityPos[1] + soundPos[i * 3 + 1];
            sourcePos[2] = entityPos[2] + soundPos[i * 3 + 2];
        }

        /* Calculate occlusion */
        occlusion = func_800B6BEC(D_8015825C, sourcePos);

        /* Base volume with occlusion */
        volume = occlusion;

        /* Apply 3D spatialization (handles pan, distance, doppler) */
        func_800B59F8(handle, sourcePos, entityVel);

        /* Apply additional occlusion volume reduction */
        if (occlusion < 1.0f) {
            s32 volVal = (s32)(occlusion * 127.0f);
            func_80090E9C(handle, volVal);
        }
    }
}

/*

 * func_800BC3E0 (7640 bytes)
 * Camera main update
 *
 * Based on arcade camera.c - updates camera position/orientation to follow target
 * Camera structure offsets:
 *   0x00: position (f32[3])
 *   0x0C: target position (f32[3])
 *   0x18: look direction (f32[3])
 *   0x24: up vector (f32[3])
 *   0x30: right vector (f32[3])
 *   0x3C: fov (f32)
 *   0x40: near plane (f32)
 *   0x44: far plane (f32)
 *   0x48: mode (s32)
 *   0x4C: shake intensity (f32)
 *   0x50: distance (f32)
 *   0x54: yaw (f32)
 *   0x58: pitch (f32)
 */
void func_800BC3E0(void *camera, void *target) {
    f32 *camPos, *camTarget, *camLook, *camUp;
    f32 *targetPos, *targetVel;
    f32 dx, dy, dz, dist, invDist;
    f32 lookAhead[3];
    f32 elasticity;
    s32 mode;

    if (camera == NULL || target == NULL) {
        return;
    }

    /* Get camera components */
    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);
    camLook = (f32 *)((u8 *)camera + 0x18);
    camUp = (f32 *)((u8 *)camera + 0x24);
    mode = *(s32 *)((u8 *)camera + 0x48);

    /* Get target position and velocity */
    targetPos = (f32 *)((u8 *)target + 0x24);
    targetVel = (f32 *)((u8 *)target + 0x34);

    /* Elasticity based on mode (0 = rigid, 1 = smooth) */
    elasticity = 0.85f;

    /* Calculate look-ahead position based on velocity */
    lookAhead[0] = targetPos[0] + targetVel[0] * 0.5f;
    lookAhead[1] = targetPos[1];
    lookAhead[2] = targetPos[2] + targetVel[2] * 0.5f;

    /* Smooth interpolate camera target */
    camTarget[0] = camTarget[0] * elasticity + lookAhead[0] * (1.0f - elasticity);
    camTarget[1] = camTarget[1] * elasticity + lookAhead[1] * (1.0f - elasticity);
    camTarget[2] = camTarget[2] * elasticity + lookAhead[2] * (1.0f - elasticity);

    /* Calculate look direction */
    dx = camTarget[0] - camPos[0];
    dy = camTarget[1] - camPos[1];
    dz = camTarget[2] - camPos[2];
    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    if (dist > 0.001f) {
        invDist = 1.0f / dist;
        camLook[0] = dx * invDist;
        camLook[1] = dy * invDist;
        camLook[2] = dz * invDist;
    }

    /* Update up vector (keep mostly vertical) */
    camUp[0] = 0.0f;
    camUp[1] = 1.0f;
    camUp[2] = 0.0f;

    /* Check for collision and apply shake */
    func_800BDE78(camera);
}

/*

 * func_800BDE78 (1596 bytes)
 * Camera collision avoidance
 *
 * Prevents camera from clipping through geometry
 */
void func_800BDE78(void *camera) {
    f32 *camPos, *camTarget;
    f32 dx, dy, dz, dist;
    f32 minDist;

    if (camera == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);

    /* Calculate distance to target */
    dx = camTarget[0] - camPos[0];
    dy = camTarget[1] - camPos[1];
    dz = camTarget[2] - camPos[2];
    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    /* Minimum distance check */
    minDist = 2.0f;
    if (dist < minDist && dist > 0.001f) {
        /* Push camera back */
        f32 scale = minDist / dist;
        camPos[0] = camTarget[0] - dx * scale;
        camPos[1] = camTarget[1] - dy * scale;
        camPos[2] = camTarget[2] - dz * scale;
    }

    /* Keep camera above ground (simple Y check) */
    if (camPos[1] < 1.0f) {
        camPos[1] = 1.0f;
    }
}

/*

 * func_800BE44C (872 bytes)
 * Camera smooth follow
 *
 * Smoothly interpolates camera position toward target
 */
void func_800BE44C(void *camera, f32 *targetPos, f32 smoothing) {
    f32 *camPos;
    f32 t;

    if (camera == NULL || targetPos == NULL) {
        return;
    }

    camPos = (f32 *)camera;

    /* Clamp smoothing factor */
    if (smoothing < 0.0f) smoothing = 0.0f;
    if (smoothing > 1.0f) smoothing = 1.0f;
    t = 1.0f - smoothing;

    /* Lerp position */
    camPos[0] = camPos[0] * smoothing + targetPos[0] * t;
    camPos[1] = camPos[1] * smoothing + targetPos[1] * t;
    camPos[2] = camPos[2] * smoothing + targetPos[2] * t;
}

/*

 * func_800BEC9C (1156 bytes)
 * Camera mode switch
 *
 * Switches between camera modes (chase, first-person, orbit, etc.)
 * Mode values: 0=chase, 1=first-person, 2=orbit, 3=cinematic
 */
void func_800BEC9C(void *camera, s32 mode) {
    s32 *camMode;
    f32 *distance, *yaw, *pitch;

    if (camera == NULL) {
        return;
    }

    camMode = (s32 *)((u8 *)camera + 0x48);
    distance = (f32 *)((u8 *)camera + 0x50);
    yaw = (f32 *)((u8 *)camera + 0x54);
    pitch = (f32 *)((u8 *)camera + 0x58);

    *camMode = mode;

    /* Set default values based on mode */
    switch (mode) {
        case 0:  /* Chase cam */
            *distance = 8.0f;
            *pitch = 0.2f;  /* Slight look-down angle */
            break;

        case 1:  /* First person */
            *distance = 0.0f;
            *pitch = 0.0f;
            break;

        case 2:  /* Orbit */
            *distance = 12.0f;
            break;

        case 3:  /* Cinematic */
            *distance = 20.0f;
            break;

        default:
            break;
    }
}

/*

 * func_800BF120 (1780 bytes)
 * Camera orbit control
 *
 * Orbits camera around target at given yaw/pitch angles
 */
void func_800BF120(void *camera, f32 yaw, f32 pitch) {
    f32 *camPos, *camTarget;
    f32 *storedYaw, *storedPitch, *distance;
    f32 sinYaw, cosYaw, sinPitch, cosPitch;
    f32 x, y, z;

    if (camera == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);
    storedYaw = (f32 *)((u8 *)camera + 0x54);
    storedPitch = (f32 *)((u8 *)camera + 0x58);
    distance = (f32 *)((u8 *)camera + 0x50);

    /* Update stored angles */
    *storedYaw = yaw;
    *storedPitch = pitch;

    /* Clamp pitch to avoid gimbal lock */
    if (pitch > 1.4f) pitch = 1.4f;
    if (pitch < -1.4f) pitch = -1.4f;

    /* Calculate orbital position */
    sinYaw = sinf(yaw);
    cosYaw = cosf(yaw);
    sinPitch = sinf(pitch);
    cosPitch = cosf(pitch);

    x = *distance * cosPitch * sinYaw;
    y = *distance * sinPitch;
    z = *distance * cosPitch * cosYaw;

    /* Set camera position relative to target */
    camPos[0] = camTarget[0] + x;
    camPos[1] = camTarget[1] + y;
    camPos[2] = camTarget[2] + z;
}

/*

 * func_800BF814 (948 bytes)
 * Camera zoom control
 *
 * Adjusts camera distance from target
 */
void func_800BF814(void *camera, f32 zoom) {
    f32 *distance;
    f32 minDist, maxDist;

    if (camera == NULL) {
        return;
    }

    distance = (f32 *)((u8 *)camera + 0x50);

    /* Clamp zoom distance */
    minDist = 2.0f;
    maxDist = 50.0f;

    *distance = zoom;
    if (*distance < minDist) *distance = minDist;
    if (*distance > maxDist) *distance = maxDist;
}

/*

 * func_800BFBC8 (420 bytes)
 * Camera FOV set
 *
 * Sets camera field of view in radians
 */
void func_800BFBC8(void *camera, f32 fov) {
    f32 *camFov;
    f32 minFov, maxFov;

    if (camera == NULL) {
        return;
    }

    camFov = (f32 *)((u8 *)camera + 0x3C);

    /* Clamp FOV (typical range: 30-120 degrees, in radians) */
    minFov = 0.5f;   /* ~30 degrees */
    maxFov = 2.1f;   /* ~120 degrees */

    *camFov = fov;
    if (*camFov < minFov) *camFov = minFov;
    if (*camFov > maxFov) *camFov = maxFov;
}

/*

 * func_800BFD6C (1392 bytes)
 * Camera look-at
 *
 * Points camera at target position, calculating look direction
 */
void func_800BFD6C(void *camera, f32 *target) {
    f32 *camPos, *camLook, *camUp, *camRight;
    f32 dx, dy, dz, dist, invDist;
    f32 rightX, rightZ, rightLen;

    if (camera == NULL || target == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camLook = (f32 *)((u8 *)camera + 0x18);
    camUp = (f32 *)((u8 *)camera + 0x24);
    camRight = (f32 *)((u8 *)camera + 0x30);

    /* Calculate look direction */
    dx = target[0] - camPos[0];
    dy = target[1] - camPos[1];
    dz = target[2] - camPos[2];
    dist = sqrtf(dx * dx + dy * dy + dz * dz);

    if (dist < 0.001f) {
        return;  /* Target at camera position */
    }

    invDist = 1.0f / dist;
    camLook[0] = dx * invDist;
    camLook[1] = dy * invDist;
    camLook[2] = dz * invDist;

    /* Calculate right vector (cross product: up x look) */
    /* Assuming world up is (0, 1, 0) */
    rightX = camLook[2];
    rightZ = -camLook[0];
    rightLen = sqrtf(rightX * rightX + rightZ * rightZ);

    if (rightLen > 0.001f) {
        camRight[0] = rightX / rightLen;
        camRight[1] = 0.0f;
        camRight[2] = rightZ / rightLen;
    }

    /* Calculate up vector (cross product: look x right) */
    camUp[0] = camLook[1] * camRight[2] - camLook[2] * camRight[1];
    camUp[1] = camLook[2] * camRight[0] - camLook[0] * camRight[2];
    camUp[2] = camLook[0] * camRight[1] - camLook[1] * camRight[0];
}

/*

 * func_800C0288 (2124 bytes)
 * Camera path follow
 *
 * Follows a predefined camera path using interpolation
 * Path structure: array of control points with position and look-at
 */
void camera_path_follow(void *camera, void *path, f32 t) {
    f32 *camPos, *camTarget;
    f32 *pathData;
    s32 numPoints, idx0, idx1;
    f32 localT;

    if (camera == NULL || path == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);

    /* Path format: [numPoints, pos0[3], look0[3], pos1[3], look1[3], ...] */
    pathData = (f32 *)path;
    numPoints = (s32)pathData[0];

    if (numPoints < 2) {
        return;
    }

    /* Clamp t to [0, 1] */
    if (t < 0.0f) t = 0.0f;
    if (t > 1.0f) t = 1.0f;

    /* Find segment indices */
    idx0 = (s32)(t * (numPoints - 1));
    idx1 = idx0 + 1;
    if (idx1 >= numPoints) {
        idx1 = numPoints - 1;
        idx0 = idx1 - 1;
    }

    /* Local t within segment */
    localT = t * (numPoints - 1) - idx0;

    /* Interpolate position (points start at offset 1, stride = 6 floats) */
    {
        f32 *p0 = &pathData[1 + idx0 * 6];
        f32 *p1 = &pathData[1 + idx1 * 6];

        camPos[0] = p0[0] + (p1[0] - p0[0]) * localT;
        camPos[1] = p0[1] + (p1[1] - p0[1]) * localT;
        camPos[2] = p0[2] + (p1[2] - p0[2]) * localT;

        camTarget[0] = p0[3] + (p1[3] - p0[3]) * localT;
        camTarget[1] = p0[4] + (p1[4] - p0[4]) * localT;
        camTarget[2] = p0[5] + (p1[5] - p0[5]) * localT;
    }

    /* Update look direction */
    func_800BFD6C(camera, camTarget);
}

/*

 * camera_transition (func_800C0AC4)
 * Size: 1736 bytes
 *
 * Blends between two camera states over time
 */
void camera_transition(void *camera, void *targetCamera, f32 duration) {
    /* Transition - stub */
}

/*

 * camera_matrix_build (func_800C1188)
 * Size: 876 bytes
 */
void camera_matrix_build(void *camera, f32 *matrix) {
    /* Matrix build - stub */
}

/*

 * camera_frustum_extract (func_800C14F4)
 * Size: 768 bytes
 */
void camera_frustum_extract(void *camera, f32 *frustum) {
    f32 *camPos, *camLook, *camUp, *camRight;
    f32 *fov, *aspect, *nearPlane, *farPlane;
    f32 tanHalfFov;
    f32 nearH, nearW, farH, farW;

    if (camera == NULL || frustum == NULL) {
        return;
    }

    /* Camera structure offsets */
    camPos = (f32 *)camera;
    camLook = (f32 *)((u8 *)camera + 0x18);
    camUp = (f32 *)((u8 *)camera + 0x24);
    camRight = (f32 *)((u8 *)camera + 0x30);
    fov = (f32 *)((u8 *)camera + 0x40);
    aspect = (f32 *)((u8 *)camera + 0x44);
    nearPlane = (f32 *)((u8 *)camera + 0x48);
    farPlane = (f32 *)((u8 *)camera + 0x4C);

    /* Calculate frustum dimensions */
    tanHalfFov = sinf(*fov * 0.5f) / cosf(*fov * 0.5f);
    nearH = (*nearPlane) * tanHalfFov;
    nearW = nearH * (*aspect);
    farH = (*farPlane) * tanHalfFov;
    farW = farH * (*aspect);

    /* Frustum planes: left, right, top, bottom, near, far */
    /* Each plane is 4 floats: normal (x,y,z) + distance */

    /* Left plane */
    frustum[0] = camRight[0] + camLook[0] * nearW;
    frustum[1] = camRight[1] + camLook[1] * nearW;
    frustum[2] = camRight[2] + camLook[2] * nearW;
    frustum[3] = -(frustum[0] * camPos[0] + frustum[1] * camPos[1] + frustum[2] * camPos[2]);

    /* Right plane */
    frustum[4] = -camRight[0] + camLook[0] * nearW;
    frustum[5] = -camRight[1] + camLook[1] * nearW;
    frustum[6] = -camRight[2] + camLook[2] * nearW;
    frustum[7] = -(frustum[4] * camPos[0] + frustum[5] * camPos[1] + frustum[6] * camPos[2]);

    /* Top plane */
    frustum[8] = -camUp[0] + camLook[0] * nearH;
    frustum[9] = -camUp[1] + camLook[1] * nearH;
    frustum[10] = -camUp[2] + camLook[2] * nearH;
    frustum[11] = -(frustum[8] * camPos[0] + frustum[9] * camPos[1] + frustum[10] * camPos[2]);

    /* Bottom plane */
    frustum[12] = camUp[0] + camLook[0] * nearH;
    frustum[13] = camUp[1] + camLook[1] * nearH;
    frustum[14] = camUp[2] + camLook[2] * nearH;
    frustum[15] = -(frustum[12] * camPos[0] + frustum[13] * camPos[1] + frustum[14] * camPos[2]);

    /* Near plane */
    frustum[16] = camLook[0];
    frustum[17] = camLook[1];
    frustum[18] = camLook[2];
    frustum[19] = -(camLook[0] * (camPos[0] + camLook[0] * (*nearPlane)) +
                   camLook[1] * (camPos[1] + camLook[1] * (*nearPlane)) +
                   camLook[2] * (camPos[2] + camLook[2] * (*nearPlane)));

    /* Far plane */
    frustum[20] = -camLook[0];
    frustum[21] = -camLook[1];
    frustum[22] = -camLook[2];
    frustum[23] = -(frustum[20] * (camPos[0] + camLook[0] * (*farPlane)) +
                   frustum[21] * (camPos[1] + camLook[1] * (*farPlane)) +
                   frustum[22] * (camPos[2] + camLook[2] * (*farPlane)));
}

/*

 * camera_viewport_setup (func_800C17F4)
 * Size: 1224 bytes
 */
void camera_viewport_setup(void *camera, s32 x, s32 y, s32 w, s32 h) {
    s32 *viewX, *viewY, *viewW, *viewH;
    f32 *aspect;
    Gfx **dlPtr;
    Gfx *dl;

    if (camera == NULL) {
        return;
    }

    /* Store viewport in camera structure */
    viewX = (s32 *)((u8 *)camera + 0x60);
    viewY = (s32 *)((u8 *)camera + 0x64);
    viewW = (s32 *)((u8 *)camera + 0x68);
    viewH = (s32 *)((u8 *)camera + 0x6C);
    aspect = (f32 *)((u8 *)camera + 0x44);

    *viewX = x;
    *viewY = y;
    *viewW = w;
    *viewH = h;

    /* Update aspect ratio */
    if (h > 0) {
        *aspect = (f32)w / (f32)h;
    }

    /* Set up RDP viewport */
    dlPtr = (Gfx **)0x80149438;
    dl = *dlPtr;

    /* gSPViewport equivalent */
    dl->words.w0 = 0xDA380007;  /* G_MOVEMEM viewport */
    dl->words.w1 = 0x80155000;  /* Viewport data address */
    dl++;

    /* Store viewport parameters */
    {
        s16 *vpData = (s16 *)0x80155000;
        vpData[0] = (w * 2) << 1;   /* vscale x */
        vpData[1] = (h * 2) << 1;   /* vscale y */
        vpData[2] = 0x1FF << 1;     /* vscale z */
        vpData[3] = 0;
        vpData[4] = ((x * 2) + w) << 1;  /* vtrans x */
        vpData[5] = ((y * 2) + h) << 1;  /* vtrans y */
        vpData[6] = 0x1FF << 1;     /* vtrans z */
        vpData[7] = 0;
    }

    /* gDPSetScissor equivalent */
    dl->words.w0 = 0xED000000 | ((x << 2) << 12) | (y << 2);
    dl->words.w1 = (((x + w) << 2) << 12) | ((y + h) << 2);
    dl++;

    *dlPtr = dl;
}

/*

 * camera_split_screen_setup (func_800C1CBC)
 * Size: 2392 bytes
 */
void camera_split_screen_setup(s32 playerCount) {
    void **cameras;
    s32 screenW, screenH;
    s32 i;

    /* Camera array at 0x80158000 */
    cameras = (void **)0x80158000;
    screenW = 320;
    screenH = 240;

    if (playerCount <= 0 || playerCount > 4) {
        return;
    }

    switch (playerCount) {
        case 1:
            /* Full screen for single player */
            camera_viewport_setup(cameras[0], 0, 0, screenW, screenH);
            break;

        case 2:
            /* Top/bottom split for 2 players */
            camera_viewport_setup(cameras[0], 0, 0, screenW, screenH / 2);
            camera_viewport_setup(cameras[1], 0, screenH / 2, screenW, screenH / 2);
            break;

        case 3:
            /* Top full, bottom split for 3 players */
            camera_viewport_setup(cameras[0], 0, 0, screenW, screenH / 2);
            camera_viewport_setup(cameras[1], 0, screenH / 2, screenW / 2, screenH / 2);
            camera_viewport_setup(cameras[2], screenW / 2, screenH / 2, screenW / 2, screenH / 2);
            break;

        case 4:
            /* Quad split for 4 players */
            camera_viewport_setup(cameras[0], 0, 0, screenW / 2, screenH / 2);
            camera_viewport_setup(cameras[1], screenW / 2, 0, screenW / 2, screenH / 2);
            camera_viewport_setup(cameras[2], 0, screenH / 2, screenW / 2, screenH / 2);
            camera_viewport_setup(cameras[3], screenW / 2, screenH / 2, screenW / 2, screenH / 2);
            break;
    }

    /* Update camera FOV for smaller viewports */
    for (i = 0; i < playerCount; i++) {
        f32 *fov = (f32 *)((u8 *)cameras[i] + 0x40);
        if (playerCount >= 2) {
            *fov = 1.2f;  /* Wider FOV for split screen */
        } else {
            *fov = 0.9f;  /* Normal FOV */
        }
    }
}

/*

 * func_800C2614 (1092 bytes)
 * Rear view camera
 */
void func_800C2614(void *camera, void *car) {
    f32 *camPos, *camTarget, *camUp;
    f32 *carPos, *carForward;
    f32 rearOffset, upOffset;
    f32 mirrorFwd[3];

    if (camera == NULL || car == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);
    camUp = (f32 *)((u8 *)camera + 0x24);
    carPos = (f32 *)((u8 *)car + 0x24);      /* Car position */
    carForward = (f32 *)((u8 *)car + 0x60);  /* Car forward from rotation matrix */

    /* Rear view offset */
    rearOffset = 3.0f;
    upOffset = 1.5f;

    /* Mirror forward direction */
    mirrorFwd[0] = -carForward[0];
    mirrorFwd[1] = carForward[1];  /* Keep Y same */
    mirrorFwd[2] = -carForward[2];

    /* Position camera behind car, looking back */
    camPos[0] = carPos[0] + carForward[0] * rearOffset;
    camPos[1] = carPos[1] + upOffset;
    camPos[2] = carPos[2] + carForward[2] * rearOffset;

    /* Look behind */
    camTarget[0] = carPos[0] + mirrorFwd[0] * 20.0f;
    camTarget[1] = carPos[1] + upOffset;
    camTarget[2] = carPos[2] + mirrorFwd[2] * 20.0f;

    /* Up vector */
    camUp[0] = 0.0f;
    camUp[1] = 1.0f;
    camUp[2] = 0.0f;

    /* Set narrow FOV for rear mirror effect */
    {
        f32 *fov = (f32 *)((u8 *)camera + 0x40);
        *fov = 0.5f;  /* Narrow FOV */
    }
}

/*

 * func_800C2A58 (1648 bytes)
 * Cinematic camera
 */
void func_800C2A58(void *camera, void *scene) {
    f32 *camPos, *camTarget;
    f32 *sceneTime, *sceneDuration;
    s32 *sceneType;
    f32 *sceneStart, *sceneEnd, *sceneLookStart, *sceneLookEnd;
    f32 t;

    if (camera == NULL || scene == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);

    /* Scene structure:
     * 0x00: scene type (0=pan, 1=orbit, 2=dolly, 3=crane)
     * 0x04: current time
     * 0x08: duration
     * 0x0C: start position [3]
     * 0x18: end position [3]
     * 0x24: start look [3]
     * 0x30: end look [3]
     */
    sceneType = (s32 *)scene;
    sceneTime = (f32 *)((u8 *)scene + 0x04);
    sceneDuration = (f32 *)((u8 *)scene + 0x08);
    sceneStart = (f32 *)((u8 *)scene + 0x0C);
    sceneEnd = (f32 *)((u8 *)scene + 0x18);
    sceneLookStart = (f32 *)((u8 *)scene + 0x24);
    sceneLookEnd = (f32 *)((u8 *)scene + 0x30);

    /* Calculate normalized time with ease in/out */
    if (*sceneDuration <= 0.0f) {
        t = 1.0f;
    } else {
        t = *sceneTime / *sceneDuration;
    }
    if (t < 0.0f) t = 0.0f;
    if (t > 1.0f) t = 1.0f;

    /* Smooth ease in/out: 3t^2 - 2t^3 */
    t = t * t * (3.0f - 2.0f * t);

    switch (*sceneType) {
        case 0:  /* Linear pan */
            camPos[0] = sceneStart[0] + (sceneEnd[0] - sceneStart[0]) * t;
            camPos[1] = sceneStart[1] + (sceneEnd[1] - sceneStart[1]) * t;
            camPos[2] = sceneStart[2] + (sceneEnd[2] - sceneStart[2]) * t;
            camTarget[0] = sceneLookStart[0] + (sceneLookEnd[0] - sceneLookStart[0]) * t;
            camTarget[1] = sceneLookStart[1] + (sceneLookEnd[1] - sceneLookStart[1]) * t;
            camTarget[2] = sceneLookStart[2] + (sceneLookEnd[2] - sceneLookStart[2]) * t;
            break;

        case 1:  /* Orbit around look target */
            {
                f32 angle = t * 6.283185f;  /* Full circle */
                f32 radius = sqrtf((sceneStart[0] - sceneLookStart[0]) * (sceneStart[0] - sceneLookStart[0]) +
                                  (sceneStart[2] - sceneLookStart[2]) * (sceneStart[2] - sceneLookStart[2]));
                camPos[0] = sceneLookStart[0] + radius * sinf(angle);
                camPos[1] = sceneStart[1];
                camPos[2] = sceneLookStart[2] + radius * cosf(angle);
                camTarget[0] = sceneLookStart[0];
                camTarget[1] = sceneLookStart[1];
                camTarget[2] = sceneLookStart[2];
            }
            break;

        case 2:  /* Dolly zoom */
            {
                f32 *fov = (f32 *)((u8 *)camera + 0x40);
                f32 startFov = 0.6f;
                f32 endFov = 1.2f;
                camPos[0] = sceneStart[0] + (sceneEnd[0] - sceneStart[0]) * t;
                camPos[1] = sceneStart[1] + (sceneEnd[1] - sceneStart[1]) * t;
                camPos[2] = sceneStart[2] + (sceneEnd[2] - sceneStart[2]) * t;
                camTarget[0] = sceneLookStart[0];
                camTarget[1] = sceneLookStart[1];
                camTarget[2] = sceneLookStart[2];
                *fov = startFov + (endFov - startFov) * t;
            }
            break;

        case 3:  /* Crane */
            camPos[0] = sceneStart[0] + (sceneEnd[0] - sceneStart[0]) * t;
            camPos[1] = sceneStart[1] + (sceneEnd[1] - sceneStart[1]) * t;
            camPos[2] = sceneStart[2];
            camTarget[0] = sceneLookStart[0];
            camTarget[1] = sceneLookStart[1] + (sceneLookEnd[1] - sceneLookStart[1]) * t;
            camTarget[2] = sceneLookStart[2];
            break;
    }
}

/*

 * func_800C30D8 (1212 bytes)
 * Finish line camera
 */
void func_800C30D8(void *camera) {
    f32 *camPos, *camTarget, *camUp;
    f32 *finishLine;
    f32 *trackWidth;
    f32 *winnerCar;
    f32 t;
    s32 *cameraState;
    f32 *stateTimer;

    if (camera == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);
    camUp = (f32 *)((u8 *)camera + 0x24);
    cameraState = (s32 *)((u8 *)camera + 0x70);
    stateTimer = (f32 *)((u8 *)camera + 0x74);

    /* Get finish line position from track data */
    finishLine = (f32 *)0x8015A000;  /* Track finish line position */
    trackWidth = (f32 *)0x8015A00C;
    winnerCar = (f32 *)0x80152818;   /* First car in array */

    /* State machine for finish camera */
    switch (*cameraState) {
        case 0:  /* Side view tracking */
            camPos[0] = finishLine[0] + (*trackWidth) * 0.5f;
            camPos[1] = finishLine[1] + 5.0f;
            camPos[2] = finishLine[2];
            camTarget[0] = winnerCar[0];
            camTarget[1] = winnerCar[1] + 1.0f;
            camTarget[2] = winnerCar[2];
            break;

        case 1:  /* Victory fly-around */
            t = *stateTimer;
            camPos[0] = winnerCar[0] + 10.0f * sinf(t * 0.5f);
            camPos[1] = winnerCar[1] + 3.0f + 2.0f * sinf(t * 0.3f);
            camPos[2] = winnerCar[2] + 10.0f * cosf(t * 0.5f);
            camTarget[0] = winnerCar[0];
            camTarget[1] = winnerCar[1] + 1.0f;
            camTarget[2] = winnerCar[2];
            break;

        case 2:  /* Close-up */
            camPos[0] = winnerCar[0] + 3.0f;
            camPos[1] = winnerCar[1] + 1.5f;
            camPos[2] = winnerCar[2];
            camTarget[0] = winnerCar[0];
            camTarget[1] = winnerCar[1] + 0.5f;
            camTarget[2] = winnerCar[2];
            break;
    }

    /* Up vector always world up */
    camUp[0] = 0.0f;
    camUp[1] = 1.0f;
    camUp[2] = 0.0f;
}

/*

 * func_800CC880 (3972 bytes)
 * Menu animation
 */
void func_800CC880(void *menu) {
    s32 *animState;
    f32 *animTime, *animDuration;
    s32 *selectedItem, *numItems;
    f32 *itemPositions;
    f32 *itemAlphas;
    f32 t;
    s32 i;

    if (menu == NULL) {
        return;
    }

    /* Menu structure:
     * 0x00: animation state
     * 0x04: animation time
     * 0x08: animation duration
     * 0x0C: selected item
     * 0x10: num items
     * 0x14: item positions array
     * 0x34: item alphas array
     */
    animState = (s32 *)menu;
    animTime = (f32 *)((u8 *)menu + 0x04);
    animDuration = (f32 *)((u8 *)menu + 0x08);
    selectedItem = (s32 *)((u8 *)menu + 0x0C);
    numItems = (s32 *)((u8 *)menu + 0x10);
    itemPositions = (f32 *)((u8 *)menu + 0x14);
    itemAlphas = (f32 *)((u8 *)menu + 0x34);

    /* Normalize time */
    if (*animDuration > 0.0f) {
        t = *animTime / *animDuration;
        if (t > 1.0f) t = 1.0f;
    } else {
        t = 1.0f;
    }

    switch (*animState) {
        case 0:  /* Idle */
            break;

        case 1:  /* Slide in */
            for (i = 0; i < *numItems && i < 8; i++) {
                f32 delay = (f32)i * 0.1f;
                f32 itemT = t - delay;
                if (itemT < 0.0f) itemT = 0.0f;
                if (itemT > 1.0f) itemT = 1.0f;
                /* Ease out */
                itemT = 1.0f - (1.0f - itemT) * (1.0f - itemT);
                itemPositions[i] = 320.0f - (320.0f * itemT);
                itemAlphas[i] = itemT;
            }
            break;

        case 2:  /* Selection highlight */
            for (i = 0; i < *numItems && i < 8; i++) {
                if (i == *selectedItem) {
                    /* Pulse effect */
                    itemAlphas[i] = 0.8f + 0.2f * sinf(*animTime * 6.0f);
                } else {
                    itemAlphas[i] = 0.6f;
                }
            }
            break;

        case 3:  /* Slide out */
            for (i = 0; i < *numItems && i < 8; i++) {
                f32 delay = (f32)(*numItems - 1 - i) * 0.1f;
                f32 itemT = t - delay;
                if (itemT < 0.0f) itemT = 0.0f;
                if (itemT > 1.0f) itemT = 1.0f;
                itemPositions[i] = -320.0f * itemT;
                itemAlphas[i] = 1.0f - itemT;
            }
            break;
    }
}

/*

 * func_800CD7F8 (7960 bytes)
 * Text rendering
 */
void func_800CD7F8(void *text, s32 x, s32 y) {
    u8 *str;
    u8 *fontData;
    s32 *fontWidth;
    s32 charWidth, charHeight;
    s32 curX;
    Gfx **dlPtr;
    Gfx *dl;
    u8 c;
    u32 *textColor;

    if (text == NULL) {
        return;
    }

    str = (u8 *)text;
    fontData = (u8 *)0x80168000;  /* Font texture data */
    fontWidth = (s32 *)0x80168800;  /* Character width table */
    textColor = (u32 *)0x80168900;  /* Current text color */
    charHeight = 16;
    curX = x;

    dlPtr = (Gfx **)0x80149438;
    dl = *dlPtr;

    /* Set texture mode for font rendering */
    dl->words.w0 = 0xE200001C;  /* G_SETOTHERMODE_L */
    dl->words.w1 = 0x00504240;  /* 1-cycle mode */
    dl++;

    /* Set combiner for text (texture * color) */
    dl->words.w0 = 0xFC119623;  /* G_SETCOMBINE */
    dl->words.w1 = 0xFF2FFFFF;
    dl++;

    /* Set primitive color */
    dl->words.w0 = 0xFA000000;  /* G_SETPRIMCOLOR */
    dl->words.w1 = *textColor;
    dl++;

    while (*str != 0) {
        c = *str;

        /* Handle special characters */
        if (c == '\n') {
            curX = x;
            y += charHeight + 2;
            str++;
            continue;
        }
        if (c == ' ') {
            curX += 6;
            str++;
            continue;
        }

        /* Get character dimensions */
        if (c >= 32 && c < 128) {
            charWidth = fontWidth[c - 32];
            if (charWidth == 0) charWidth = 8;
        } else {
            charWidth = 8;
        }

        /* Set texture for this character */
        {
            s32 texU = ((c - 32) % 16) * 16;
            s32 texV = ((c - 32) / 16) * 16;

            /* G_SETTILESIZE */
            dl->words.w0 = 0xF2000000 | ((texU << 2) << 12) | (texV << 2);
            dl->words.w1 = (((texU + charWidth) << 2) << 12) | ((texV + charHeight) << 2);
            dl++;

            /* G_TEXRECT */
            dl->words.w0 = 0xE4000000 | (((curX + charWidth) << 2) << 12) | ((y + charHeight) << 2);
            dl->words.w1 = ((curX << 2) << 12) | (y << 2);
            dl++;

            /* Texture coordinates */
            dl->words.w0 = (texU << 21) | (texV << 5);
            dl->words.w1 = 0x04000400;  /* 1:1 scale */
            dl++;
        }

        curX += charWidth + 1;
        str++;
    }

    *dlPtr = dl;
}

/*

 * func_800CF7E0 (1792 bytes)
 * Font loading
 */
void func_800CF7E0(s32 fontId) {
    u8 *fontDest;
    u32 *fontRomAddrs;
    s32 *fontWidthTable;
    s32 fontRomAddr, fontSize;
    s32 i;

    /* Font ROM address table at 0x8016A000 */
    fontRomAddrs = (u32 *)0x8016A000;
    fontDest = (u8 *)0x80168000;
    fontWidthTable = (s32 *)0x80168800;

    /* Validate font ID */
    if (fontId < 0 || fontId >= 4) {
        return;
    }

    /* Get ROM address and size for this font */
    fontRomAddr = fontRomAddrs[fontId * 2];
    fontSize = fontRomAddrs[fontId * 2 + 1];

    if (fontRomAddr == 0 || fontSize == 0) {
        return;
    }

    /* DMA font texture data (4KB per font) */
    osPiStartDma(&D_80020000, OS_MESG_PRI_NORMAL, OS_READ,
                 fontRomAddr, fontDest, fontSize, &D_80020010);
    osRecvMesg(&D_80020010, NULL, OS_MESG_BLOCK);

    /* Set up default character widths */
    for (i = 0; i < 96; i++) {
        switch (fontId) {
            case 0:  /* Small font */
                fontWidthTable[i] = 6;
                break;
            case 1:  /* Medium font */
                fontWidthTable[i] = 8;
                break;
            case 2:  /* Large font */
                fontWidthTable[i] = 12;
                break;
            case 3:  /* Title font */
                fontWidthTable[i] = 16;
                break;
        }
    }

    /* Adjust widths for narrow characters */
    fontWidthTable['I' - 32] = fontWidthTable[0] / 2;
    fontWidthTable['l' - 32] = fontWidthTable[0] / 2;
    fontWidthTable['i' - 32] = fontWidthTable[0] / 2;
    fontWidthTable['1' - 32] = fontWidthTable[0] * 2 / 3;
    fontWidthTable['.' - 32] = fontWidthTable[0] / 2;
    fontWidthTable[',' - 32] = fontWidthTable[0] / 2;
    fontWidthTable[':' - 32] = fontWidthTable[0] / 2;

    /* Wide characters */
    fontWidthTable['W' - 32] = fontWidthTable[0] * 3 / 2;
    fontWidthTable['M' - 32] = fontWidthTable[0] * 3 / 2;
    fontWidthTable['@' - 32] = fontWidthTable[0] * 3 / 2;
}

/*

 * func_800CFEDC (892 bytes)
 * String width calculation
 */
s32 func_800CFEDC(u8 *str) {
    s32 *fontWidthTable;
    s32 width, maxWidth;
    u8 c;

    if (str == NULL) {
        return 0;
    }

    fontWidthTable = (s32 *)0x80168800;
    width = 0;
    maxWidth = 0;

    while (*str != 0) {
        c = *str;

        if (c == '\n') {
            /* Track maximum width for multi-line strings */
            if (width > maxWidth) {
                maxWidth = width;
            }
            width = 0;
            str++;
            continue;
        }

        if (c == ' ') {
            width += 6;
            str++;
            continue;
        }

        if (c >= 32 && c < 128) {
            s32 charWidth = fontWidthTable[c - 32];
            if (charWidth == 0) charWidth = 8;
            width += charWidth + 1;
        } else {
            width += 8 + 1;
        }

        str++;
    }

    if (width > maxWidth) {
        maxWidth = width;
    }

    return maxWidth;
}

/*

 * func_800D0258 (460 bytes)
 * Text color set
 */
void func_800D0258(u8 r, u8 g, u8 b, u8 a) {
    u32 *textColor;
    u8 *shadowColor;
    s32 *shadowEnabled;

    textColor = (u32 *)0x80168900;
    shadowColor = (u8 *)0x80168904;
    shadowEnabled = (s32 *)0x80168908;

    /* Pack RGBA into 32-bit color */
    *textColor = (r << 24) | (g << 16) | (b << 8) | a;

    /* Calculate shadow color (darker version) */
    shadowColor[0] = r >> 2;
    shadowColor[1] = g >> 2;
    shadowColor[2] = b >> 2;
    shadowColor[3] = a;

    /* Enable shadow if not fully transparent */
    *shadowEnabled = (a > 128) ? 1 : 0;
}

/*

 * func_800D23A8 (15548 bytes)
 * Full menu render
 */
void func_800D23A8(void *menu) {
    s32 *numItems, *selectedItem;
    u8 **itemLabels;
    f32 *itemPositions, *itemAlphas;
    s32 i;
    s32 x, y;

    if (menu == NULL) {
        return;
    }

    /* Menu structure from func_800CC880 */
    numItems = (s32 *)((u8 *)menu + 0x10);
    selectedItem = (s32 *)((u8 *)menu + 0x0C);
    itemPositions = (f32 *)((u8 *)menu + 0x14);
    itemAlphas = (f32 *)((u8 *)menu + 0x34);
    itemLabels = (u8 **)((u8 *)menu + 0x54);

    /* Render background */
    func_800D0258(0, 0, 0, 180);  /* Semi-transparent black */

    /* Base menu position */
    x = 80;
    y = 60;

    /* Render each item */
    for (i = 0; i < *numItems && i < 8; i++) {
        s32 itemX = x + (s32)itemPositions[i];
        s32 itemY = y + (i * 24);
        u8 alpha = (u8)(itemAlphas[i] * 255.0f);

        /* Set color based on selection */
        if (i == *selectedItem) {
            func_800D0258(255, 200, 0, alpha);  /* Gold for selected */
            /* Draw highlight box */
            func_800DD410(itemX - 4, itemY - 2, 160, 20);
        } else {
            func_800D0258(200, 200, 200, alpha);  /* Gray for others */
        }

        /* Render item text */
        if (itemLabels[i] != NULL) {
            func_800CD7F8(itemLabels[i], itemX, itemY);
        }
    }
}

/*

 * func_800DC8D0 (1100 bytes)
 * Button sprite render
 */
void func_800DC8D0(s32 buttonId, s32 x, s32 y) {
    Gfx **dlPtr;
    Gfx *dl;
    u8 *buttonTextures;
    s32 texU, texV;
    s32 buttonW, buttonH;

    /* Button texture atlas at 0x8016C000 */
    buttonTextures = (u8 *)0x8016C000;
    buttonW = 32;
    buttonH = 16;

    /* Button IDs:
     * 0 = A button, 1 = B button, 2 = Z button, 3 = Start
     * 4 = L trigger, 5 = R trigger, 6 = C-up, 7 = C-down
     * 8 = C-left, 9 = C-right, 10 = D-up, 11 = D-down
     * 12 = D-left, 13 = D-right
     */
    if (buttonId < 0 || buttonId >= 14) {
        return;
    }

    /* Calculate texture coordinates from button ID */
    texU = (buttonId % 4) * buttonW;
    texV = (buttonId / 4) * buttonH;

    dlPtr = (Gfx **)0x80149438;
    dl = *dlPtr;

    /* G_SETTILESIZE */
    dl->words.w0 = 0xF2000000 | ((texU << 2) << 12) | (texV << 2);
    dl->words.w1 = (((texU + buttonW) << 2) << 12) | ((texV + buttonH) << 2);
    dl++;

    /* G_TEXRECT */
    dl->words.w0 = 0xE4000000 | (((x + buttonW) << 2) << 12) | ((y + buttonH) << 2);
    dl->words.w1 = ((x << 2) << 12) | (y << 2);
    dl++;

    /* Texture coordinates */
    dl->words.w0 = (texU << 21) | (texV << 5);
    dl->words.w1 = 0x04000400;
    dl++;

    *dlPtr = dl;
}

/*

 * func_800DCD20 (1760 bytes)
 * Icon sprite render
 */
void func_800DCD20(s32 iconId, s32 x, s32 y) {
    Gfx **dlPtr;
    Gfx *dl;
    s32 texU, texV;
    s32 iconSize;

    /* Icon texture atlas at 0x8016D000 */
    /* Icons are 24x24 pixels, 8 per row */
    iconSize = 24;

    if (iconId < 0 || iconId >= 64) {
        return;
    }

    texU = (iconId % 8) * iconSize;
    texV = (iconId / 8) * iconSize;

    dlPtr = (Gfx **)0x80149438;
    dl = *dlPtr;

    /* Set texture image for icon atlas */
    dl->words.w0 = 0xFD100000;
    dl->words.w1 = 0x8016D000;
    dl++;

    /* G_SETTILESIZE */
    dl->words.w0 = 0xF2000000 | ((texU << 2) << 12) | (texV << 2);
    dl->words.w1 = (((texU + iconSize) << 2) << 12) | ((texV + iconSize) << 2);
    dl++;

    /* G_TEXRECT */
    dl->words.w0 = 0xE4000000 | (((x + iconSize) << 2) << 12) | ((y + iconSize) << 2);
    dl->words.w1 = ((x << 2) << 12) | (y << 2);
    dl++;

    /* Texture coordinates */
    dl->words.w0 = (texU << 21) | (texV << 5);
    dl->words.w1 = 0x04000400;
    dl++;

    *dlPtr = dl;
}

/*

 * func_800DD410 (2340 bytes)
 * Selection highlight
 */
void func_800DD410(s32 x, s32 y, s32 w, s32 h) {
    Gfx **dlPtr;
    Gfx *dl;
    u32 highlightColor;
    f32 *animTime;
    f32 pulse;

    /* Get animation time for pulsing effect */
    animTime = (f32 *)0x80142AFC;
    pulse = 0.7f + 0.3f * sinf(*animTime * 4.0f);

    /* Highlight color: gold with pulse */
    highlightColor = (((u8)(255 * pulse)) << 24) |
                     (((u8)(200 * pulse)) << 16) |
                     (0 << 8) |
                     128;  /* Semi-transparent */

    dlPtr = (Gfx **)0x80149438;
    dl = *dlPtr;

    /* Set blend mode for transparency */
    dl->words.w0 = 0xE200001C;
    dl->words.w1 = 0x00552078;  /* G_RM_XLU_SURF */
    dl++;

    /* Set primitive color */
    dl->words.w0 = 0xFA000000;
    dl->words.w1 = highlightColor;
    dl++;

    /* G_FILLRECT for highlight box */
    dl->words.w0 = 0xF6000000 | (((x + w) << 2) << 12) | ((y + h) << 2);
    dl->words.w1 = ((x << 2) << 12) | (y << 2);
    dl++;

    /* Draw outline */
    /* Top edge */
    dl->words.w0 = 0xFA000000;
    dl->words.w1 = 0xFFFFFFFF;  /* White */
    dl++;
    dl->words.w0 = 0xF6000000 | (((x + w) << 2) << 12) | ((y + 1) << 2);
    dl->words.w1 = ((x << 2) << 12) | (y << 2);
    dl++;

    /* Bottom edge */
    dl->words.w0 = 0xF6000000 | (((x + w) << 2) << 12) | ((y + h) << 2);
    dl->words.w1 = ((x << 2) << 12) | ((y + h - 1) << 2);
    dl++;

    *dlPtr = dl;
}

/*

 * func_800DDD40 (1284 bytes)
 * Menu scroll
 */
void func_800DDD40(void *menu, s32 direction) {
    s32 *selectedItem, *numItems;
    s32 *scrollOffset;
    s32 maxVisible;
    s32 newSelection;

    if (menu == NULL) {
        return;
    }

    selectedItem = (s32 *)((u8 *)menu + 0x0C);
    numItems = (s32 *)((u8 *)menu + 0x10);
    scrollOffset = (s32 *)((u8 *)menu + 0x74);
    maxVisible = 8;

    /* Calculate new selection */
    newSelection = *selectedItem + direction;

    /* Wrap around */
    if (newSelection < 0) {
        newSelection = *numItems - 1;
    } else if (newSelection >= *numItems) {
        newSelection = 0;
    }

    *selectedItem = newSelection;

    /* Adjust scroll offset to keep selection visible */
    if (newSelection < *scrollOffset) {
        *scrollOffset = newSelection;
    } else if (newSelection >= *scrollOffset + maxVisible) {
        *scrollOffset = newSelection - maxVisible + 1;
    }

    /* Play scroll sound */
    func_800B2658(2, 0.8f, 0.0f);  /* Menu tick sound */
}

/*

 * func_800DE244 (1824 bytes)
 * Menu transition effect
 */
void func_800DE244(void *menu, s32 transitionType) {
    s32 *animState;
    f32 *animTime, *animDuration;

    if (menu == NULL) {
        return;
    }

    animState = (s32 *)menu;
    animTime = (f32 *)((u8 *)menu + 0x04);
    animDuration = (f32 *)((u8 *)menu + 0x08);

    /* Reset animation timer */
    *animTime = 0.0f;

    switch (transitionType) {
        case 0:  /* Instant */
            *animState = 0;
            *animDuration = 0.0f;
            break;

        case 1:  /* Slide in from right */
            *animState = 1;
            *animDuration = 0.5f;
            break;

        case 2:  /* Slide out to left */
            *animState = 3;
            *animDuration = 0.3f;
            break;

        case 3:  /* Fade in */
            *animState = 1;
            *animDuration = 0.4f;
            break;

        case 4:  /* Fade out */
            *animState = 3;
            *animDuration = 0.4f;
            break;

        default:
            *animState = 0;
            *animDuration = 0.0f;
            break;
    }

    /* Play transition sound */
    if (transitionType == 1 || transitionType == 3) {
        func_800B2658(3, 1.0f, 0.0f);  /* Menu open sound */
    } else if (transitionType == 2 || transitionType == 4) {
        func_800B2658(4, 1.0f, 0.0f);  /* Menu close sound */
    }
}

/*

 * func_800DE960 (2128 bytes)
 * Popup dialog
 */
void func_800DE960(u8 *message, s32 type) {
    s32 textWidth, textHeight;
    s32 boxX, boxY, boxW, boxH;
    s32 padding;
    Gfx **dlPtr;
    Gfx *dl;

    if (message == NULL) {
        return;
    }

    padding = 16;
    textWidth = func_800CFEDC(message);
    textHeight = 16;  /* Single line assumed */

    /* Center dialog on screen */
    boxW = textWidth + padding * 2;
    boxH = textHeight + padding * 2;
    boxX = (320 - boxW) / 2;
    boxY = (240 - boxH) / 2;

    dlPtr = (Gfx **)0x80149438;
    dl = *dlPtr;

    /* Draw background based on type */
    switch (type) {
        case 0:  /* Info - blue */
            dl->words.w0 = 0xFA000000;
            dl->words.w1 = 0x000080C0;
            break;
        case 1:  /* Warning - yellow */
            dl->words.w0 = 0xFA000000;
            dl->words.w1 = 0x808000C0;
            break;
        case 2:  /* Error - red */
            dl->words.w0 = 0xFA000000;
            dl->words.w1 = 0x800000C0;
            break;
        default:
            dl->words.w0 = 0xFA000000;
            dl->words.w1 = 0x404040C0;
            break;
    }
    dl++;

    /* Draw box */
    dl->words.w0 = 0xF6000000 | (((boxX + boxW) << 2) << 12) | ((boxY + boxH) << 2);
    dl->words.w1 = ((boxX << 2) << 12) | (boxY << 2);
    dl++;

    /* Draw border */
    dl->words.w0 = 0xFA000000;
    dl->words.w1 = 0xFFFFFFFF;
    dl++;

    *dlPtr = dl;

    /* Draw text centered */
    func_800D0258(255, 255, 255, 255);
    func_800CD7F8(message, boxX + padding, boxY + padding);
}

/*

 * func_800DF1B0 (1356 bytes)
 * Confirmation dialog
 */
s32 func_800DF1B0(u8 *message) {
    /* Confirmation - stub */
    return 0;
}

/*

 * func_800DF6FC (2064 bytes)
 * Input prompt
 */
void func_800DF6FC(u8 *prompt, u8 *buffer, s32 maxLen) {
    /* Input prompt - stub */
}

/*

 * func_800DFF0C (1600 bytes)
 * Virtual keyboard
 */
void func_800DFF0C(u8 *buffer, s32 maxLen) {
    /* Virtual keyboard - stub */
}

/*

 * func_800E051C (212 bytes)
 * Keyboard cursor move
 */
void func_800E051C(s32 dx, s32 dy) {
    /* Cursor move - stub */
}

/*

 * func_800EAE90 (2720 bytes)
 * World bounds setup
 */
void func_800EAE90(void *world) {
    f32 *minBounds;
    f32 *maxBounds;
    f32 *worldData;
    s32 i;

    if (world == NULL) {
        return;
    }

    worldData = (f32 *)world;

    /* World bounds at 0x8015B000 */
    minBounds = (f32 *)0x8015B000;
    maxBounds = (f32 *)0x8015B00C;

    /* World format: minX, minY, minZ, maxX, maxY, maxZ */
    for (i = 0; i < 3; i++) {
        minBounds[i] = worldData[i];
        maxBounds[i] = worldData[i + 3];
    }

    /* Calculate world center and size */
    *(f32 *)0x8015B020 = (minBounds[0] + maxBounds[0]) * 0.5f;
    *(f32 *)0x8015B024 = (minBounds[1] + maxBounds[1]) * 0.5f;
    *(f32 *)0x8015B028 = (minBounds[2] + maxBounds[2]) * 0.5f;

    *(f32 *)0x8015B030 = maxBounds[0] - minBounds[0];
    *(f32 *)0x8015B034 = maxBounds[1] - minBounds[1];
    *(f32 *)0x8015B038 = maxBounds[2] - minBounds[2];
}

/*

 * func_800EB920 (1012 bytes)
 * Trigger zone check
 */
s32 func_800EB920(void *entity, void *trigger) {
    f32 *entityPos;
    f32 *triggerMin, *triggerMax;
    s32 *triggerType;

    if (entity == NULL || trigger == NULL) {
        return 0;
    }

    entityPos = (f32 *)((u8 *)entity + 0x24);

    /* Trigger structure:
     * 0x00: type (0=box, 1=sphere, 2=cylinder)
     * 0x04: min bounds [3] or center
     * 0x10: max bounds [3] or radius
     */
    triggerType = (s32 *)trigger;
    triggerMin = (f32 *)((u8 *)trigger + 0x04);
    triggerMax = (f32 *)((u8 *)trigger + 0x10);

    switch (*triggerType) {
        case 0:  /* Box */
            if (entityPos[0] >= triggerMin[0] && entityPos[0] <= triggerMax[0] &&
                entityPos[1] >= triggerMin[1] && entityPos[1] <= triggerMax[1] &&
                entityPos[2] >= triggerMin[2] && entityPos[2] <= triggerMax[2]) {
                return 1;
            }
            break;

        case 1:  /* Sphere */
            {
                f32 dx = entityPos[0] - triggerMin[0];
                f32 dy = entityPos[1] - triggerMin[1];
                f32 dz = entityPos[2] - triggerMin[2];
                f32 distSq = dx * dx + dy * dy + dz * dz;
                f32 radius = triggerMax[0];
                if (distSq <= radius * radius) {
                    return 1;
                }
            }
            break;

        case 2:  /* Cylinder (vertical) */
            {
                f32 dx = entityPos[0] - triggerMin[0];
                f32 dz = entityPos[2] - triggerMin[2];
                f32 distSq = dx * dx + dz * dz;
                f32 radius = triggerMax[0];
                f32 height = triggerMax[1];
                if (distSq <= radius * radius &&
                    entityPos[1] >= triggerMin[1] &&
                    entityPos[1] <= triggerMin[1] + height) {
                    return 1;
                }
            }
            break;
    }

    return 0;
}

/*

 * func_800EBD14 (1708 bytes)
 * Trigger zone callback
 */
void func_800EBD14(void *trigger, void *callback) {
    void (**callbackPtr)(void *);
    s32 *triggerEnabled;
    s32 *triggerOnce;
    s32 *triggerFired;

    if (trigger == NULL) {
        return;
    }

    /* Trigger callback structure at offset 0x20 */
    callbackPtr = (void (**)(void *))((u8 *)trigger + 0x20);
    triggerEnabled = (s32 *)((u8 *)trigger + 0x24);
    triggerOnce = (s32 *)((u8 *)trigger + 0x28);
    triggerFired = (s32 *)((u8 *)trigger + 0x2C);

    /* Set callback function */
    *callbackPtr = (void (*)(void *))callback;
    *triggerEnabled = 1;
    *triggerOnce = 0;
    *triggerFired = 0;
}

/*

 * func_800EC3B0 (2948 bytes)
 * Scripted event
 */
void func_800EC3B0(void *event) {
    s32 *eventType;
    s32 *eventState;
    f32 *eventTime;
    f32 *eventDuration;
    void *eventData;

    if (event == NULL) {
        return;
    }

    /* Event structure:
     * 0x00: type
     * 0x04: state (0=pending, 1=active, 2=complete)
     * 0x08: current time
     * 0x0C: duration
     * 0x10: event-specific data
     */
    eventType = (s32 *)event;
    eventState = (s32 *)((u8 *)event + 0x04);
    eventTime = (f32 *)((u8 *)event + 0x08);
    eventDuration = (f32 *)((u8 *)event + 0x0C);
    eventData = (void *)((u8 *)event + 0x10);

    if (*eventState == 2) {
        return;  /* Already complete */
    }

    /* Activate event */
    if (*eventState == 0) {
        *eventState = 1;
        *eventTime = 0.0f;
    }

    /* Update time */
    *eventTime += 0.0166f;  /* 1/60 second */

    /* Check completion */
    if (*eventTime >= *eventDuration) {
        *eventState = 2;
    }

    /* Process based on event type */
    switch (*eventType) {
        case 0:  /* Camera shake */
            /* Handled by camera system */
            break;
        case 1:  /* Slow motion */
            if (*eventState == 1) {
                *(f32 *)0x80142B00 = 0.5f;  /* Time scale */
            } else {
                *(f32 *)0x80142B00 = 1.0f;
            }
            break;
        case 2:  /* Screen flash */
            /* Handled by render system */
            break;
        case 3:  /* Sound effect */
            if (*eventState == 1 && *eventTime < 0.02f) {
                func_800B2658(0, 1.0f, 0.0f);
            }
            break;
    }
}

/*

 * func_800ECF38 (2188 bytes)
 * Cutscene playback
 */
void func_800ECF38(s32 cutsceneId) {
    s32 *cutsceneActive;
    s32 *currentCutscene;
    f32 *cutsceneTime;
    void **cutsceneData;

    /* Cutscene state at 0x8015C800 */
    cutsceneActive = (s32 *)0x8015C800;
    currentCutscene = (s32 *)0x8015C804;
    cutsceneTime = (f32 *)0x8015C808;
    cutsceneData = (void **)0x8015C810;

    if (cutsceneId < 0 || cutsceneId >= 16) {
        return;
    }

    /* Start cutscene */
    *cutsceneActive = 1;
    *currentCutscene = cutsceneId;
    *cutsceneTime = 0.0f;

    /* Load cutscene data from ROM */
    {
        u32 *cutsceneRomTable = (u32 *)0x8016F000;
        u32 romAddr = cutsceneRomTable[cutsceneId * 2];
        u32 size = cutsceneRomTable[cutsceneId * 2 + 1];

        if (romAddr != 0 && size != 0) {
            *cutsceneData = (void *)0x80178000;  /* Cutscene buffer */
            osPiStartDma(&D_80020000, OS_MESG_PRI_NORMAL, OS_READ,
                        romAddr, *cutsceneData, size, &D_80020010);
            osRecvMesg(&D_80020010, NULL, OS_MESG_BLOCK);
        }
    }

    /* Disable player input during cutscene */
    *(s32 *)0x801147C8 = 0;

    /* Play cutscene music */
    func_800B1B48(1, cutsceneId + 100);
}

/*

 * func_800ED7C0 (2564 bytes)
 * Object spawner
 */
void func_800ED7C0(s32 objectType, f32 *pos, f32 *rot) {
    void *objectPool;
    s32 *objectCount;
    s32 maxObjects;
    void *newObject;
    s32 i;

    if (pos == NULL) {
        return;
    }

    /* Object pool at 0x80157000 */
    objectPool = (void *)0x80157000;
    objectCount = (s32 *)0x80156FF0;
    maxObjects = 128;

    if (*objectCount >= maxObjects) {
        return;  /* Pool full */
    }

    /* Find free slot */
    for (i = 0; i < maxObjects; i++) {
        s32 *slotActive = (s32 *)(0x80157000 + i * 0x100);
        if (*slotActive == 0) {
            newObject = (void *)(0x80157000 + i * 0x100);
            break;
        }
    }

    if (i >= maxObjects) {
        return;
    }

    /* Initialize object */
    *(s32 *)newObject = 1;  /* Active */
    *(s32 *)((u8 *)newObject + 0x04) = objectType;

    /* Position */
    *(f32 *)((u8 *)newObject + 0x24) = pos[0];
    *(f32 *)((u8 *)newObject + 0x28) = pos[1];
    *(f32 *)((u8 *)newObject + 0x2C) = pos[2];

    /* Rotation */
    if (rot != NULL) {
        *(f32 *)((u8 *)newObject + 0x60) = rot[0];
        *(f32 *)((u8 *)newObject + 0x64) = rot[1];
        *(f32 *)((u8 *)newObject + 0x68) = rot[2];
    }

    (*objectCount)++;
}

/*

 * func_800EE1B0 (1516 bytes)
 * Collectible spawn
 */
void func_800EE1B0(s32 collectibleType, f32 *pos) {
    void *collectiblePool;
    s32 *collectibleCount;
    s32 maxCollectibles;
    void *newCollectible;
    s32 i;

    if (pos == NULL) {
        return;
    }

    /* Collectible pool at 0x80159000 */
    collectiblePool = (void *)0x80159000;
    collectibleCount = (s32 *)0x80158FF0;
    maxCollectibles = 64;

    if (*collectibleCount >= maxCollectibles) {
        return;
    }

    /* Find free slot */
    for (i = 0; i < maxCollectibles; i++) {
        s32 *slotActive = (s32 *)(0x80159000 + i * 0x40);
        if (*slotActive == 0) {
            newCollectible = (void *)(0x80159000 + i * 0x40);
            break;
        }
    }

    if (i >= maxCollectibles) {
        return;
    }

    /* Collectible structure:
     * 0x00: active
     * 0x04: type
     * 0x08: position [3]
     * 0x14: rotation (for spin animation)
     * 0x18: respawn timer
     * 0x1C: collected flag
     */
    *(s32 *)newCollectible = 1;
    *(s32 *)((u8 *)newCollectible + 0x04) = collectibleType;
    *(f32 *)((u8 *)newCollectible + 0x08) = pos[0];
    *(f32 *)((u8 *)newCollectible + 0x0C) = pos[1];
    *(f32 *)((u8 *)newCollectible + 0x10) = pos[2];
    *(f32 *)((u8 *)newCollectible + 0x14) = 0.0f;
    *(f32 *)((u8 *)newCollectible + 0x18) = 0.0f;
    *(s32 *)((u8 *)newCollectible + 0x1C) = 0;

    (*collectibleCount)++;
}

/*

 * func_800EE7A8 (228 bytes)
 * Collectible collect
 */
void func_800EE7A8(void *player, void *collectible) {
    s32 *collectibleType;
    s32 *collected;
    s32 *playerScore;
    s32 *playerCoins;

    if (player == NULL || collectible == NULL) {
        return;
    }

    collected = (s32 *)((u8 *)collectible + 0x1C);

    /* Already collected */
    if (*collected != 0) {
        return;
    }

    collectibleType = (s32 *)((u8 *)collectible + 0x04);
    playerScore = (s32 *)((u8 *)player + 0x100);
    playerCoins = (s32 *)((u8 *)player + 0x104);

    /* Mark as collected */
    *collected = 1;

    /* Award based on type */
    switch (*collectibleType) {
        case 0:  /* Coin */
            (*playerCoins)++;
            *playerScore += 100;
            func_800B2658(40, 1.0f, 0.0f);  /* Coin sound */
            break;

        case 1:  /* Nitro can */
            func_800EFD88(player, 0.25f);
            *playerScore += 50;
            break;

        case 2:  /* Time bonus */
            *(s32 *)0x8015A10C += 60;  /* Add 1 second */
            *playerScore += 200;
            func_800B2658(41, 1.0f, 0.0f);  /* Time bonus sound */
            break;

        case 3:  /* Key/unlock */
            *playerScore += 500;
            func_800B2658(42, 1.0f, 0.0f);  /* Key sound */
            break;
    }

    /* Start respawn timer */
    *(f32 *)((u8 *)collectible + 0x18) = 5.0f;  /* 5 second respawn */
}

/*

 * func_800EE8B0 (1780 bytes)
 * Power-up activation
 */
void func_800EE8B0(void *player, s32 powerupType) {
    s32 *activePowerup;
    f32 *powerupTimer;
    f32 *powerupDuration;

    if (player == NULL) {
        return;
    }

    /* Player powerup state at offset 0x130 */
    activePowerup = (s32 *)((u8 *)player + 0x130);
    powerupTimer = (f32 *)((u8 *)player + 0x134);
    powerupDuration = (f32 *)((u8 *)player + 0x138);

    *activePowerup = powerupType;
    *powerupTimer = 0.0f;

    /* Set duration based on type */
    switch (powerupType) {
        case 0:  /* Speed boost */
            *powerupDuration = 5.0f;
            *(f32 *)((u8 *)player + 0xB0) *= 1.25f;  /* Max speed multiplier */
            func_800B2658(50, 1.0f, 0.0f);
            break;

        case 1:  /* Invincibility */
            *powerupDuration = 8.0f;
            *(s32 *)((u8 *)player + 0x13C) = 1;  /* Invincible flag */
            func_800B2658(51, 1.0f, 0.0f);
            break;

        case 2:  /* Magnet (attract collectibles) */
            *powerupDuration = 10.0f;
            *(f32 *)((u8 *)player + 0x140) = 50.0f;  /* Magnet radius */
            func_800B2658(52, 1.0f, 0.0f);
            break;

        case 3:  /* Double points */
            *powerupDuration = 15.0f;
            *(s32 *)((u8 *)player + 0x144) = 2;  /* Score multiplier */
            func_800B2658(53, 1.0f, 0.0f);
            break;

        case 4:  /* Ghost (pass through traffic) */
            *powerupDuration = 6.0f;
            *(s32 *)((u8 *)player + 0x148) = 1;  /* Ghost flag */
            func_800B2658(54, 1.0f, 0.0f);
            break;
    }
}

/*

 * func_800EEFA0 (1556 bytes)
 * Power-up timer
 */
void func_800EEFA0(void *player) {
    s32 *activePowerup;
    f32 *powerupTimer;
    f32 *powerupDuration;
    f32 dt;

    if (player == NULL) {
        return;
    }

    activePowerup = (s32 *)((u8 *)player + 0x130);
    powerupTimer = (f32 *)((u8 *)player + 0x134);
    powerupDuration = (f32 *)((u8 *)player + 0x138);

    /* No active powerup */
    if (*activePowerup < 0) {
        return;
    }

    dt = 0.0166f;  /* 1/60 second */
    *powerupTimer += dt;

    /* Check expiration */
    if (*powerupTimer >= *powerupDuration) {
        /* Deactivate powerup effects */
        switch (*activePowerup) {
            case 0:  /* Speed boost */
                *(f32 *)((u8 *)player + 0xB0) /= 1.25f;  /* Restore speed */
                break;
            case 1:  /* Invincibility */
                *(s32 *)((u8 *)player + 0x13C) = 0;
                break;
            case 2:  /* Magnet */
                *(f32 *)((u8 *)player + 0x140) = 0.0f;
                break;
            case 3:  /* Double points */
                *(s32 *)((u8 *)player + 0x144) = 1;
                break;
            case 4:  /* Ghost */
                *(s32 *)((u8 *)player + 0x148) = 0;
                break;
        }

        /* Clear powerup */
        *activePowerup = -1;
        *powerupTimer = 0.0f;

        /* Powerup end sound */
        func_800B2658(55, 0.8f, 0.0f);
    }
}

/*

 * func_800EF5B4 (2036 bytes)
 * Nitro boost
 */
void func_800EF5B4(void *car) {
    f32 *velocity;
    f32 *nitroAmount;
    f32 *nitroActive;
    f32 *forward;
    f32 boostForce;
    f32 nitroConsume;

    if (car == NULL) {
        return;
    }

    /* Car structure offsets */
    velocity = (f32 *)((u8 *)car + 0x34);
    forward = (f32 *)((u8 *)car + 0x60);
    nitroAmount = (f32 *)((u8 *)car + 0x120);
    nitroActive = (f32 *)((u8 *)car + 0x124);

    /* Check if nitro available */
    if (*nitroAmount <= 0.0f) {
        *nitroActive = 0.0f;
        return;
    }

    /* Activate nitro */
    *nitroActive = 1.0f;
    boostForce = 50.0f;
    nitroConsume = 0.02f;  /* Per frame consumption */

    /* Apply boost force in forward direction */
    velocity[0] += forward[0] * boostForce * 0.0166f;  /* dt = 1/60 */
    velocity[1] += forward[1] * boostForce * 0.0166f;
    velocity[2] += forward[2] * boostForce * 0.0166f;

    /* Consume nitro */
    *nitroAmount -= nitroConsume;
    if (*nitroAmount < 0.0f) {
        *nitroAmount = 0.0f;
        *nitroActive = 0.0f;
    }

    /* Play nitro sound if just started */
    func_800B2658(20, 1.0f, 0.0f);  /* Nitro sound */
}

/*

 * func_800EFD88 (1232 bytes)
 * Nitro refill
 */
void func_800EFD88(void *car, f32 amount) {
    f32 *nitroAmount;
    f32 *nitroMax;

    if (car == NULL || amount <= 0.0f) {
        return;
    }

    nitroAmount = (f32 *)((u8 *)car + 0x120);
    nitroMax = (f32 *)((u8 *)car + 0x128);

    *nitroAmount += amount;
    if (*nitroAmount > *nitroMax) {
        *nitroAmount = *nitroMax;
    }

    /* Play refill sound */
    func_800B2658(21, 0.8f, 0.0f);
}

/*

 * func_800F0258 (1088 bytes)
 * Boost pad trigger
 */
void func_800F0258(void *car, void *pad) {
    f32 *velocity;
    f32 *padDir;
    f32 boostSpeed;
    f32 currentSpeed;

    if (car == NULL || pad == NULL) {
        return;
    }

    velocity = (f32 *)((u8 *)car + 0x34);
    padDir = (f32 *)((u8 *)pad + 0x10);  /* Pad boost direction */
    boostSpeed = *(f32 *)((u8 *)pad + 0x1C);  /* Pad boost amount */

    /* Calculate current speed */
    currentSpeed = sqrtf(velocity[0] * velocity[0] +
                        velocity[1] * velocity[1] +
                        velocity[2] * velocity[2]);

    /* Only boost if moving in pad direction */
    if (currentSpeed > 5.0f) {
        /* Add boost in pad direction */
        velocity[0] += padDir[0] * boostSpeed;
        velocity[1] += padDir[1] * boostSpeed * 0.5f;  /* Less vertical boost */
        velocity[2] += padDir[2] * boostSpeed;

        /* Play boost pad sound */
        func_800B2658(22, 1.0f, 0.0f);
    }
}

/*

 * func_800F0B44 (2264 bytes)
 * Ramp launch
 */
void func_800F0B44(void *car, void *ramp) {
    f32 *velocity;
    f32 *position;
    f32 *rampNormal;
    f32 *rampAngle;
    f32 speed, launchSpeed;
    f32 launchAngle;

    if (car == NULL || ramp == NULL) {
        return;
    }

    position = (f32 *)((u8 *)car + 0x24);
    velocity = (f32 *)((u8 *)car + 0x34);
    rampNormal = (f32 *)((u8 *)ramp + 0x10);
    rampAngle = (f32 *)((u8 *)ramp + 0x1C);

    /* Calculate current horizontal speed */
    speed = sqrtf(velocity[0] * velocity[0] + velocity[2] * velocity[2]);

    /* Only launch if moving fast enough */
    if (speed < 20.0f) {
        return;
    }

    launchAngle = *rampAngle;
    launchSpeed = speed * 1.2f;  /* Slight speed boost */

    /* Calculate launch velocity based on ramp angle */
    /* Preserve horizontal direction, add vertical component */
    if (speed > 0.001f) {
        f32 hNorm = 1.0f / speed;
        velocity[0] *= hNorm * launchSpeed * cosf(launchAngle);
        velocity[2] *= hNorm * launchSpeed * cosf(launchAngle);
    }
    velocity[1] = launchSpeed * sinf(launchAngle);

    /* Set airborne flag */
    *(s32 *)((u8 *)car + 0x1C) = 1;

    /* Play launch sound */
    func_800B2658(23, 1.0f, 0.0f);
}

/*

 * func_80100660 (1748 bytes)
 * Timer init
 */
void func_80100660(void) {
    s32 *timerStartFrame;
    s32 *timerElapsed;
    s32 *timerPaused;
    s32 *timerCountdown;
    s32 i;

    /* Timer state at 0x8015A100 */
    timerStartFrame = (s32 *)0x8015A100;
    timerElapsed = (s32 *)0x8015A104;
    timerPaused = (s32 *)0x8015A108;
    timerCountdown = (s32 *)0x8015A10C;

    /* Get current frame from global counter */
    *timerStartFrame = D_80142AFC;
    *timerElapsed = 0;
    *timerPaused = 0;
    *timerCountdown = 0;

    /* Clear split time arrays */
    for (i = 0; i < 4; i++) {
        *(s32 *)(0x8015A120 + i * 4) = 0;  /* Lap times */
        *(s32 *)(0x8015A130 + i * 4) = 0;  /* Split times */
    }
}

/*

 * func_80100D34 (188 bytes)
 * Timer get elapsed
 */
s32 func_80100D34(void) {
    s32 *timerStartFrame;
    s32 *timerPaused;
    s32 currentFrame;
    s32 elapsed;

    timerStartFrame = (s32 *)0x8015A100;
    timerPaused = (s32 *)0x8015A108;

    if (*timerPaused) {
        /* Return cached elapsed time when paused */
        return *(s32 *)0x8015A104;
    }

    currentFrame = D_80142AFC;
    elapsed = currentFrame - *timerStartFrame;

    /* Convert frames to centiseconds (assuming 60fps) */
    /* elapsed_cs = elapsed_frames * 100 / 60 */
    return (elapsed * 100) / 60;
}

/*

 * func_80100DF0 (244 bytes)
 * Timer reset
 */
void func_80100DF0(void) {
    s32 *timerStartFrame;
    s32 *timerElapsed;
    s32 *timerPaused;

    timerStartFrame = (s32 *)0x8015A100;
    timerElapsed = (s32 *)0x8015A104;
    timerPaused = (s32 *)0x8015A108;

    *timerStartFrame = D_80142AFC;
    *timerElapsed = 0;
    *timerPaused = 0;
}

/*

 * func_80100EE4 (776 bytes)
 * Countdown timer
 */
void func_80100EE4(s32 seconds) {
    s32 *timerCountdown;
    s32 *countdownActive;
    s32 frames;

    timerCountdown = (s32 *)0x8015A10C;
    countdownActive = (s32 *)0x8015A110;

    /* Convert seconds to frames (60fps) */
    frames = seconds * 60;

    *timerCountdown = frames;
    *countdownActive = 1;

    /* Play countdown start sound */
    if (seconds > 0) {
        func_800B2658(30, 1.0f, 0.0f);  /* Countdown beep */
    }
}

/*

 * func_801011DC (1340 bytes)
 * Lap timer split
 */
void func_801011DC(void *player) {
    s32 playerIdx;
    s32 *lapCount;
    s32 *lapTimes;
    s32 *bestLap;
    s32 currentTime;
    s32 lapTime;

    if (player == NULL) {
        return;
    }

    playerIdx = *(s32 *)player;
    lapCount = (s32 *)((u8 *)player + 0x10);
    lapTimes = (s32 *)0x8015A120;
    bestLap = (s32 *)0x8015A044;

    /* Get current race time */
    currentTime = func_80100D34();

    /* Calculate lap time */
    if (*lapCount > 0) {
        lapTime = currentTime - lapTimes[*lapCount - 1];
    } else {
        lapTime = currentTime;
    }

    /* Store lap time */
    if (*lapCount < 4) {
        lapTimes[*lapCount] = currentTime;
    }

    /* Check for best lap */
    if (lapTime < *bestLap) {
        *bestLap = lapTime;
        func_800B2658(31, 1.0f, 0.0f);  /* Best lap sound */
    }

    /* Increment lap count */
    (*lapCount)++;
}

/*

 * func_80101700 (588 bytes)
 * Best time check
 */
s32 func_80101700(s32 trackId, s32 time) {
    s32 *bestTimes;
    s32 i;

    if (trackId < 0 || trackId >= 16) {
        return 0;
    }

    /* Best times array: 16 tracks x 5 positions */
    bestTimes = (s32 *)0x8016E000;

    /* Check if time beats any leaderboard entry */
    for (i = 0; i < 5; i++) {
        s32 entryTime = bestTimes[trackId * 5 + i];
        if (entryTime == 0 || time < entryTime) {
            return i + 1;  /* Return position (1-5) */
        }
    }

    return 0;  /* Didn't place */
}

/*

 * func_8010194C (812 bytes)
 * Record new best
 */
void func_8010194C(s32 trackId, s32 time, u8 *name) {
    s32 *bestTimes;
    u8 *bestNames;
    s32 position;
    s32 i, j;

    if (trackId < 0 || trackId >= 16 || name == NULL) {
        return;
    }

    bestTimes = (s32 *)0x8016E000;
    bestNames = (u8 *)0x8016E200;  /* 16 tracks x 5 names x 4 chars */

    /* Find position for this time */
    position = -1;
    for (i = 0; i < 5; i++) {
        if (bestTimes[trackId * 5 + i] == 0 || time < bestTimes[trackId * 5 + i]) {
            position = i;
            break;
        }
    }

    if (position < 0) {
        return;
    }

    /* Shift lower times down */
    for (i = 4; i > position; i--) {
        bestTimes[trackId * 5 + i] = bestTimes[trackId * 5 + i - 1];
        for (j = 0; j < 4; j++) {
            bestNames[(trackId * 5 + i) * 4 + j] = bestNames[(trackId * 5 + i - 1) * 4 + j];
        }
    }

    /* Insert new time and name */
    bestTimes[trackId * 5 + position] = time;
    for (j = 0; j < 4 && name[j] != 0; j++) {
        bestNames[(trackId * 5 + position) * 4 + j] = name[j];
    }
    for (; j < 4; j++) {
        bestNames[(trackId * 5 + position) * 4 + j] = ' ';
    }

    /* Save to Controller Pak */
    func_800B0580(0, (u8 *)bestNames, sizeof(bestNames));
}

/*

 * func_80101C78 (1472 bytes)
 * Leaderboard display
 */
void func_80101C78(s32 trackId) {
    s32 *bestTimes;
    u8 *bestNames;
    s32 i;
    s32 x, y;
    u8 timeStr[16];
    u8 nameStr[8];

    if (trackId < 0 || trackId >= 16) {
        return;
    }

    bestTimes = (s32 *)0x8016E000;
    bestNames = (u8 *)0x8016E200;

    /* Header */
    func_800D0258(255, 200, 0, 255);  /* Gold */
    func_800CD7F8((u8 *)"BEST TIMES", 120, 40);

    /* Display top 5 times */
    x = 80;
    y = 70;

    for (i = 0; i < 5; i++) {
        s32 entryTime = bestTimes[trackId * 5 + i];
        s32 j;

        /* Copy name */
        for (j = 0; j < 4; j++) {
            nameStr[j] = bestNames[(trackId * 5 + i) * 4 + j];
        }
        nameStr[4] = 0;

        if (entryTime > 0) {
            /* Format time as MM:SS.cc */
            s32 mins = entryTime / 6000;
            s32 secs = (entryTime % 6000) / 100;
            s32 cs = entryTime % 100;

            timeStr[0] = '0' + (mins / 10);
            timeStr[1] = '0' + (mins % 10);
            timeStr[2] = ':';
            timeStr[3] = '0' + (secs / 10);
            timeStr[4] = '0' + (secs % 10);
            timeStr[5] = '.';
            timeStr[6] = '0' + (cs / 10);
            timeStr[7] = '0' + (cs % 10);
            timeStr[8] = 0;

            func_800D0258(255, 255, 255, 255);
            func_800CD7F8(nameStr, x, y);
            func_800CD7F8(timeStr, x + 60, y);
        } else {
            func_800D0258(128, 128, 128, 255);  /* Gray for empty */
            func_800CD7F8((u8 *)"----", x, y);
            func_800CD7F8((u8 *)"--:--.--", x + 60, y);
        }

        y += 20;
    }
}

/*

 * func_80102250 (2084 bytes)
 * Race results screen - displays finish times and positions
 */
void func_80102250(void) {
    s32 i;
    s32 input;
    s32 numPlayers;
    s32 animFrame;
    char timeStr[16];
    char posStr[8];
    s32 y;

    numPlayers = D_80159C18;
    if (numPlayers < 1) numPlayers = 1;

    animFrame = D_8015A420;
    animFrame++;

    input = func_800CB748(D_80158100);

    /* Skip after timeout or button press */
    if (animFrame > 600 || (animFrame > 60 && (input == 1 || input == 2))) {
        D_8015A420 = 0;
        if (D_8015A310 || D_8015A314) {
            /* New record - go to name entry */
            D_801146EC = 9;  /* HISCORE state */
        } else {
            /* Back to menu or next race */
            D_801146EC = 1;  /* TRKSEL */
        }
        return;
    }

    /* Clear screen */
    func_800C6E60(0, 0, 320, 240, 0x101030);

    /* Title */
    draw_text(100, 20, "RACE RESULTS", 0xFFFFFFFF);

    /* Column headers */
    draw_text(40, 50, "POS", 0xFFFFFFB4);
    draw_text(90, 50, "PLAYER", 0xFFFFFFB4);
    draw_text(170, 50, "LAPS", 0xFFFFFFB4);
    draw_text(220, 50, "TIME", 0xFFFFFFB4);

    /* Display each player/racer result */
    for (i = 0; i < 8; i++) {
        s32 position = D_8015A200[i];
        s32 lapCount = D_8015A210[i];
        s32 raceTime = D_8015A230[i];
        s32 finished = D_8015A240[i];
        s32 alpha;

        if (position == 0) continue;  /* Not in race */

        y = 70 + (position - 1) * 20;

        /* Highlight player 1 */
        if (i == 0) {
            alpha = 255;
            func_800C6E60(35, y - 2, 260, 18, 0x304060);
        } else {
            alpha = 180;
        }

        /* Position */
        posStr[0] = '0' + position;
        posStr[1] = '.';
        posStr[2] = '\0';
        draw_text(posStr, 45, y, alpha);

        /* Player name */
        if (i < numPlayers) {
            char pStr[12];
            pStr[0] = 'P';
            pStr[1] = 'L';
            pStr[2] = 'A';
            pStr[3] = 'Y';
            pStr[4] = 'E';
            pStr[5] = 'R';
            pStr[6] = ' ';
            pStr[7] = '1' + i;
            pStr[8] = '\0';
            draw_text(pStr, 90, y, alpha);
        } else {
            draw_text("DRONE", 90, y, alpha - 40);
        }

        /* Laps */
        {
            char lapStr[8];
            lapStr[0] = '0' + lapCount;
            lapStr[1] = '/';
            lapStr[2] = '0' + D_8015A298;
            lapStr[3] = '\0';
            draw_text(lapStr, 175, y, alpha);
        }

        /* Time */
        if (finished) {
            s32 m = raceTime / 6000;
            s32 s = (raceTime / 100) % 60;
            s32 h = raceTime % 100;
            timeStr[0] = '0' + m;
            timeStr[1] = ':';
            timeStr[2] = '0' + (s / 10);
            timeStr[3] = '0' + (s % 10);
            timeStr[4] = '.';
            timeStr[5] = '0' + (h / 10);
            timeStr[6] = '0' + (h % 10);
            timeStr[7] = '\0';
            draw_text(timeStr, 215, y, alpha);
        } else {
            draw_text("DNF", 230, y, 120);
        }
    }

    /* New record indicator */
    if (D_8015A310) {
        s32 flash = ((animFrame / 10) & 1) ? 255 : 180;
        draw_text(110, 195, "NEW RECORD!", flash);
    }
    if (D_8015A314) {
        s32 flash = ((animFrame / 10) & 1) ? 255 : 180;
        draw_text(105, 210, "NEW BEST LAP!", flash);
    }

    /* Continue prompt */
    if (animFrame > 60) {
        draw_text(85, 225, "PRESS A TO CONTINUE", 0xFFFFFF96);
    }

    D_8015A420 = animFrame;
}

/*
 * func_80102A74 (1524 bytes)
 * Award ceremony - Displays race results and trophies
 *
 * Shows podium positions, times, and animates trophy presentation.
 * Called after race completion.
 */
extern s32 D_8015A458[4];   /* Player placing (1st-4th) */
extern s32 D_8015A468[4];   /* Player finish times */

void func_80102A74(void) {
    s32 state;
    s32 frame;
    s32 input;
    s32 i;
    s32 yPos;
    s32 alpha;
    char timeStr[12];

    state = D_8015A450;
    frame = D_8015A454;
    input = func_800CB748(D_80158100);

    frame++;

    switch (state) {
        case 0:  /* Fade in */
            alpha = (frame * 255) / 60;
            if (alpha > 255) alpha = 255;

            /* Draw background */
            func_800C6E60(40, 30, 240, 180, (alpha << 24) | 0x101030);

            if (frame >= 60) {
                state = 1;
                frame = 0;
            }
            break;

        case 1:  /* Show results */
            /* Background */
            func_800C6E60(40, 30, 240, 180, 0xFF101030);

            /* Title */
            draw_text(100, 45, "RACE COMPLETE", 0xFFFFFFFF);

            /* Results list */
            yPos = 70;
            for (i = 0; i < 4; i++) {
                s32 placing = D_8015A458[i];
                if (placing > 0 && placing <= 4) {
                    s32 time = D_8015A468[i];
                    s32 mins, secs, ms;

                    /* Format time */
                    mins = time / 3600;
                    secs = (time / 60) % 60;
                    ms = ((time % 60) * 100) / 60;

                    sprintf(timeStr, "%d:%02d.%02d", mins, secs, ms);

                    /* Draw placing */
                    if (placing == 1) {
                        draw_text("1ST", 60, yPos, 255);
                    } else if (placing == 2) {
                        draw_text("2ND", 60, yPos, 200);
                    } else if (placing == 3) {
                        draw_text("3RD", 60, yPos, 150);
                    } else {
                        draw_text("4TH", 60, yPos, 100);
                    }

                    /* Draw time */
                    draw_text(timeStr, 120, yPos, 200);

                    yPos += 25;
                }
            }

            /* Trophy animation for winner */
            if (frame > 30) {
                func_8010306C(1);  /* Show 1st place trophy */
            }

            /* Skip on input or timeout */
            if (frame > 300 || (frame > 60 && (input == 1 || input == 2))) {
                state = 2;
                frame = 0;
            }
            break;

        case 2:  /* Fade out */
            alpha = 255 - (frame * 255) / 30;
            if (alpha < 0) alpha = 0;

            func_800C6E60(40, 30, 240, 180, (alpha << 24) | 0x101030);

            if (frame >= 30) {
                D_8015A450 = 0;
                D_8015A454 = 0;
                return;
            }
            break;
    }

    D_8015A450 = state;
    D_8015A454 = frame;
}

/*
 * func_8010306C (876 bytes)
 * Trophy animation - Renders animated trophy for race winner
 *
 * Draws a rotating 3D trophy model at the specified position.
 * Uses simple vertex transforms and triangle rendering.
 *
 * @param place Placing (1=gold, 2=silver, 3=bronze)
 */
extern f32 D_8015A47C;      /* Trophy Y offset (bobbing) */
extern void *D_8012D000;    /* Trophy model data */

void func_8010306C(s32 place) {
    u32 *dlPtr;
    f32 rotAngle;
    f32 yOffset;
    f32 scale;
    u32 color;
    s32 frame;

    frame = D_8015A478;
    frame++;

    /* Rotation: 2 degrees per frame */
    rotAngle = (f32)frame * 0.035f;  /* ~2 deg in radians */

    /* Bobbing animation */
    yOffset = sinf((f32)frame * 0.08f) * 5.0f;

    /* Color based on placing */
    switch (place) {
        case 1:  /* Gold */
            color = 0xFFD700FF;
            scale = 1.2f;
            break;
        case 2:  /* Silver */
            color = 0xC0C0C0FF;
            scale = 1.0f;
            break;
        case 3:  /* Bronze */
            color = 0xCD7F32FF;
            scale = 0.9f;
            break;
        default:
            D_8015A478 = frame;
            return;
    }

    /* Set up display list commands */
    dlPtr = *(u32 **)0x80149438;

    /* G_GEOMETRYMODE - enable lighting and culling */
    *dlPtr++ = 0xB7000000;
    *dlPtr++ = 0x00022000;

    /* Set primitive color */
    *dlPtr++ = 0xFA000000;
    *dlPtr++ = color;

    /* Push matrix */
    *dlPtr++ = 0xDA380001;
    *dlPtr++ = 0x00000000;

    /* Build transformation matrix at stack */
    {
        f32 cosR = cosf(rotAngle);
        f32 sinR = sinf(rotAngle);
        s32 *mtx = (s32 *)0x80170400;

        /* Rotation around Y axis with scale and translation */
        /* Row 0: cos*scale, 0, sin*scale, 0 */
        mtx[0] = (s32)(cosR * scale * 65536.0f);
        mtx[1] = 0;
        mtx[2] = (s32)(sinR * scale * 65536.0f);
        mtx[3] = 0;

        /* Row 1: 0, scale, 0, yOffset */
        mtx[4] = 0;
        mtx[5] = (s32)(scale * 65536.0f);
        mtx[6] = 0;
        mtx[7] = (s32)(yOffset * 4.0f);

        /* Row 2: -sin*scale, 0, cos*scale, 0 */
        mtx[8] = (s32)(-sinR * scale * 65536.0f);
        mtx[9] = 0;
        mtx[10] = (s32)(cosR * scale * 65536.0f);
        mtx[11] = 0;

        /* Row 3: translation */
        mtx[12] = (s32)(200.0f * 4.0f);  /* X center */
        mtx[13] = (s32)((50.0f + yOffset) * 4.0f);  /* Y */
        mtx[14] = 0;
        mtx[15] = 0x00010000;  /* W = 1 */
    }

    /* Load matrix */
    *dlPtr++ = 0xDA380007;
    *dlPtr++ = 0x80170400;

    /* Draw trophy shape - simplified cup */
    /* Base rectangle */
    *dlPtr++ = 0x06000204;  /* Vertex load */
    *dlPtr++ = 0x80170500;

    /* Simple triangles for cup shape */
    *dlPtr++ = 0x05000102;
    *dlPtr++ = 0x00000000;

    /* Pop matrix */
    *dlPtr++ = 0xD8380040;
    *dlPtr++ = 0x00000040;

    *(u32 **)0x80149438 = dlPtr;
    D_8015A478 = frame;
}

/*

 * func_801033D8 (1616 bytes)
 * Continue prompt - ask player to continue or quit
 */
s32 func_801033D8(void) {
    s32 input;
    s32 countdown;
    s32 selection;
    char countStr[4];

    countdown = D_8015A430;
    selection = D_8015A434;

    if (countdown == 0) {
        /* Initialize */
        countdown = 10 * 60;  /* 10 seconds at 60fps */
        selection = 0;  /* Default: Continue */
    }

    input = func_800CB748(D_80158100);

    /* Navigate selection */
    if (input == 6 || input == 7) {  /* Left/Right */
        selection = !selection;
        sound_play_menu(12);
    }

    /* Confirm selection */
    if (input == 1) {  /* A */
        D_8015A430 = 0;
        D_8015A434 = 0;
        sound_play_menu(10);
        return selection;  /* 0 = continue, 1 = quit */
    }

    /* Countdown */
    countdown--;
    if (countdown <= 0) {
        D_8015A430 = 0;
        D_8015A434 = 0;
        return 1;  /* Time's up - quit */
    }

    /* Render */
    func_800C6E60(60, 80, 200, 80, 0x202040);
    func_800C6E60(62, 82, 196, 76, 0x303060);

    draw_text(120, 95, "CONTINUE?", 0xFFFFFFFF);

    /* Countdown number */
    {
        s32 secs = (countdown / 60) + 1;
        countStr[0] = '0' + secs;
        countStr[1] = '\0';
        draw_text(countStr, 155, 115, 200);
    }

    /* Options */
    draw_text("YES", 100, 140, selection == 0 ? 255 : 150);
    draw_text("NO", 190, 140, selection == 1 ? 255 : 150);

    /* Selection indicator */
    if (selection == 0) {
        draw_text(85, 140, ">", 0xFFFFFFFF);
    } else {
        draw_text(175, 140, ">", 0xFFFFFFFF);
    }

    D_8015A430 = countdown;
    D_8015A434 = selection;

    return -1;  /* Still waiting */
}

/*

 * func_80103A08 (2328 bytes)
 * Game over screen - displays final stats and options
 */
void func_80103A08(void) {
    s32 input;
    s32 animFrame;
    s32 alpha;
    s32 i;

    animFrame = D_8015A440;
    animFrame++;

    input = func_800CB748(D_80158100);

    /* Exit after timeout or button press */
    if (animFrame > 480 || (animFrame > 120 && (input == 1 || input == 2))) {
        D_8015A440 = 0;
        D_801146EC = 0;  /* ATTRACT */
        return;
    }

    /* Fade in */
    if (animFrame < 60) {
        alpha = (animFrame * 255) / 60;
    } else {
        alpha = 255;
    }

    /* Clear screen with fade */
    func_800C6E60(0, 0, 320, 240, 0x100000 + ((alpha / 4) << 16));

    /* "GAME OVER" text - large and centered */
    {
        s32 textY = 60;
        s32 scale;

        if (animFrame < 30) {
            scale = 200 - (animFrame * 100 / 30);  /* Shrink from 200% to 100% */
        } else {
            scale = 100;
        }

        draw_text("GAME OVER", 95, textY, alpha);
    }

    /* Display final statistics */
    if (animFrame > 30) {
        s32 statsAlpha = alpha;
        if (animFrame < 90) {
            statsAlpha = ((animFrame - 30) * 255) / 60;
        }

        draw_text(110, 100, "FINAL STATS", statsAlpha);

        /* Total races */
        draw_text("RACES:", 80, 125, statsAlpha - 40);
        {
            char numStr[8];
            s32 val = D_8015A330;
            numStr[0] = '0' + (val / 100);
            numStr[1] = '0' + ((val / 10) % 10);
            numStr[2] = '0' + (val % 10);
            numStr[3] = '\0';
            draw_text(numStr, 180, 125, statsAlpha);
        }

        /* Wins */
        draw_text("WINS:", 80, 145, statsAlpha - 40);
        {
            char numStr[8];
            s32 val = D_8015A334;
            numStr[0] = '0' + (val / 100);
            numStr[1] = '0' + ((val / 10) % 10);
            numStr[2] = '0' + (val % 10);
            numStr[3] = '\0';
            draw_text(numStr, 180, 145, statsAlpha);
        }

        /* Best finish */
        draw_text("BEST FINISH:", 80, 165, statsAlpha - 40);
        {
            char posStr[4];
            s32 bestPos = D_8015A448;
            if (bestPos > 0 && bestPos <= 8) {
                posStr[0] = '0' + bestPos;
                if (bestPos == 1) {
                    posStr[1] = 'S'; posStr[2] = 'T';
                } else if (bestPos == 2) {
                    posStr[1] = 'N'; posStr[2] = 'D';
                } else if (bestPos == 3) {
                    posStr[1] = 'R'; posStr[2] = 'D';
                } else {
                    posStr[1] = 'T'; posStr[2] = 'H';
                }
                posStr[3] = '\0';
                draw_text(posStr, 200, 165, statsAlpha);
            } else {
                draw_text(200, 165, "---", statsAlpha);
            }
        }
    }

    /* Thanks message */
    if (animFrame > 90) {
        s32 thanksAlpha = alpha;
        if (animFrame < 150) {
            thanksAlpha = ((animFrame - 90) * 255) / 60;
        }
        draw_text(75, 200, "THANKS FOR PLAYING!", thanksAlpha);
    }

    /* Press button prompt */
    if (animFrame > 120) {
        s32 flash = ((animFrame / 15) & 1) ? 200 : 120;
        draw_text(90, 225, "PRESS ANY BUTTON", flash);
    }

    D_8015A440 = animFrame;
}

/*

 * func_80104320 (1844 bytes)
 * Name entry screen - enter initials for high score
 */
void func_80104320(u8 *name) {
    s32 input;
    s32 cursorPos;
    s32 selectedChar;
    s32 i;
    char charSet[40];
    s32 charCount;
    s32 blinkPhase;

    /* Character set: A-Z, 0-9, space, end */
    charSet[0] = 'A';
    for (i = 1; i < 26; i++) {
        charSet[i] = 'A' + i;
    }
    for (i = 0; i < 10; i++) {
        charSet[26 + i] = '0' + i;
    }
    charSet[36] = ' ';
    charSet[37] = '.';
    charSet[38] = '!';
    charSet[39] = '\0';  /* END marker */
    charCount = 40;

    cursorPos = D_8015A450;
    selectedChar = D_8015A454;
    blinkPhase = D_80142AFC & 0x10;

    input = func_800CB748(D_80158100);

    /* Navigate character selection */
    if (input == 4) {  /* Up */
        selectedChar = selectedChar - 10;
        if (selectedChar < 0) selectedChar = selectedChar + charCount;
        sound_play_menu(12);
    } else if (input == 5) {  /* Down */
        selectedChar = selectedChar + 10;
        if (selectedChar >= charCount) selectedChar = selectedChar - charCount;
        sound_play_menu(12);
    } else if (input == 6) {  /* Left */
        selectedChar--;
        if (selectedChar < 0) selectedChar = charCount - 1;
        sound_play_menu(12);
    } else if (input == 7) {  /* Right */
        selectedChar++;
        if (selectedChar >= charCount) selectedChar = 0;
        sound_play_menu(12);
    } else if (input == 1) {  /* A - select */
        if (selectedChar == 39) {
            /* END selected */
            D_8015A450 = 0;
            D_8015A454 = 0;
            D_8015A458[0] = 1;  /* Done flag */
            sound_play_menu(10);
            return;
        } else {
            /* Add character to name */
            if (cursorPos < 3) {
                name[cursorPos] = charSet[selectedChar];
                cursorPos++;
                if (cursorPos >= 3) {
                    /* Auto-advance to END */
                    selectedChar = 39;
                }
                sound_play_menu(12);
            }
        }
    } else if (input == 2) {  /* B - backspace */
        if (cursorPos > 0) {
            cursorPos--;
            name[cursorPos] = '_';
            sound_play_menu(11);
        }
    }

    /* Render */
    func_800C6E60(0, 0, 320, 240, 0x101030);

    draw_text(75, 25, "ENTER YOUR INITIALS", 0xFFFFFFFF);

    /* Current name display */
    {
        char nameDisplay[8];
        for (i = 0; i < 3; i++) {
            if (i < cursorPos) {
                nameDisplay[i * 2] = name[i];
            } else if (i == cursorPos && blinkPhase) {
                nameDisplay[i * 2] = '_';
            } else {
                nameDisplay[i * 2] = '_';
            }
            nameDisplay[i * 2 + 1] = ' ';
        }
        nameDisplay[6] = '\0';
        draw_text(nameDisplay, 130, 55, 255);
    }

    /* Character grid */
    for (i = 0; i < charCount; i++) {
        s32 gridX = 60 + (i % 10) * 22;
        s32 gridY = 90 + (i / 10) * 25;
        s32 alpha;
        char charBuf[2];

        if (i == selectedChar) {
            alpha = 255;
            func_800C6E60(gridX - 3, gridY - 3, 18, 18, 0x404080);
        } else {
            alpha = 160;
        }

        if (i == 39) {
            draw_text("END", gridX - 5, gridY, alpha);
        } else {
            charBuf[0] = charSet[i];
            charBuf[1] = '\0';
            draw_text(charBuf, gridX, gridY, alpha);
        }
    }

    /* Instructions */
    draw_text(80, 210, "A:SELECT  B:DELETE", 0xFFFFFF96);

    D_8015A450 = cursorPos;
    D_8015A454 = selectedChar;
}

/*
 * func_80104A58 (1036 bytes)
 * High score entry animation - Animates the new high score entry effect
 *
 * Shows fireworks, flashing, and sparkles around the new entry.
 *
 * @param position Leaderboard position (1-10)
 */
extern s32 D_8015A4A0;  /* HS animation frame */
extern s32 D_8015A4A4;  /* Sparkle positions */

void func_80104A58(s32 position) {
    s32 frame;
    s32 i;
    s32 xPos, yPos;
    f32 sparkleAngle;
    s32 sparkleRadius;
    u32 color;

    frame = D_8015A4A0;
    frame++;

    /* Position based on ranking */
    yPos = 80 + (position - 1) * 20;
    xPos = 160;

    /* Flash effect */
    if ((frame / 5) & 1) {
        color = 0xFFFFFFFF;
    } else {
        color = 0xFFFF00FF;
    }

    /* Highlight bar */
    {
        s32 barAlpha = 128 + (s32)(sinf((f32)frame * 0.15f) * 64.0f);
        func_800C6E60(50, yPos - 5, 220, 18, (barAlpha << 24) | 0x404000);
    }

    /* Sparkle effect - 8 sparkles orbiting */
    for (i = 0; i < 8; i++) {
        sparkleAngle = (f32)frame * 0.08f + (f32)i * 0.785f;  /* 2*PI/8 */
        sparkleRadius = 30 + (s32)(sinf((f32)frame * 0.2f + (f32)i) * 10.0f);

        {
            s32 sx = xPos + (s32)(cosf(sparkleAngle) * (f32)sparkleRadius);
            s32 sy = yPos + (s32)(sinf(sparkleAngle) * (f32)sparkleRadius * 0.5f);
            s32 sparkleSize = 2 + (frame + i * 7) % 3;

            func_800C6E60(sx - sparkleSize/2, sy - sparkleSize/2,
                         sparkleSize, sparkleSize, color);
        }
    }

    /* "NEW RECORD!" text with wobble */
    if (position == 1) {
        s32 wobbleX = (s32)(sinf((f32)frame * 0.3f) * 3.0f);
        draw_text("NEW RECORD!", xPos - 40 + wobbleX, yPos - 25, 255);
    }

    D_8015A4A0 = frame;
}

/*
 * func_80104E84 (2464 bytes)
 * Statistics display - Shows player game statistics
 *
 * Displays various lifetime stats like races, wins, etc.
 *
 * @param stats Pointer to player statistics structure
 */
extern s32 D_8015A4B0;      /* Stats display state */
extern s32 D_8015A4B4;      /* Stats scroll position */

void func_80104E84(void *stats) {
    s32 *statData;
    s32 state;
    s32 scrollY;
    s32 input;
    s32 i;
    char valueStr[16];

    if (stats == NULL) {
        return;
    }

    statData = (s32 *)stats;
    state = D_8015A4B0;
    scrollY = D_8015A4B4;
    input = func_800CB748(D_80158100);

    /* Navigation */
    if (input == 4) {  /* Up */
        scrollY -= 20;
        if (scrollY < 0) scrollY = 0;
    } else if (input == 5) {  /* Down */
        scrollY += 20;
        if (scrollY > 200) scrollY = 200;
    } else if (input == 2 || input == 1) {  /* B or A - exit */
        D_8015A4B0 = 0;
        D_8015A4B4 = 0;
        return;
    }

    /* Background */
    func_800C6E60(30, 20, 260, 200, 0xE0202040);

    /* Title */
    draw_text(115, 30, "STATISTICS", 0xFFFFFFFF);

    /* Stats list */
    {
        s32 baseY = 60 - scrollY;
        s32 yPos;

        /* Races completed */
        yPos = baseY;
        if (yPos >= 50 && yPos <= 200) {
            sprintf(valueStr, "%d", statData[0]);
            draw_text("RACES:", 50, yPos, 200);
            draw_text(valueStr, 180, yPos, 255);
        }

        /* Wins */
        yPos = baseY + 25;
        if (yPos >= 50 && yPos <= 200) {
            sprintf(valueStr, "%d", statData[1]);
            draw_text("WINS:", 50, yPos, 200);
            draw_text(valueStr, 180, yPos, 255);
        }

        /* Podium finishes */
        yPos = baseY + 50;
        if (yPos >= 50 && yPos <= 200) {
            sprintf(valueStr, "%d", statData[2]);
            draw_text("PODIUMS:", 50, yPos, 200);
            draw_text(valueStr, 180, yPos, 255);
        }

        /* Total time */
        yPos = baseY + 75;
        if (yPos >= 50 && yPos <= 200) {
            s32 hours = statData[3] / 3600;
            s32 mins = (statData[3] / 60) % 60;
            sprintf(valueStr, "%d:%02d", hours, mins);
            draw_text("TIME PLAYED:", 50, yPos, 200);
            draw_text(valueStr, 180, yPos, 255);
        }

        /* Best lap */
        yPos = baseY + 100;
        if (yPos >= 50 && yPos <= 200) {
            s32 secs = statData[4] / 60;
            s32 ms = ((statData[4] % 60) * 100) / 60;
            sprintf(valueStr, "%d.%02d", secs, ms);
            draw_text("BEST LAP:", 50, yPos, 200);
            draw_text(valueStr, 180, yPos, 255);
        }

        /* Miles driven */
        yPos = baseY + 125;
        if (yPos >= 50 && yPos <= 200) {
            sprintf(valueStr, "%d", statData[5] / 1000);
            draw_text("MILES:", 50, yPos, 200);
            draw_text(valueStr, 180, yPos, 255);
        }

        /* Crashes */
        yPos = baseY + 150;
        if (yPos >= 50 && yPos <= 200) {
            sprintf(valueStr, "%d", statData[6]);
            draw_text("CRASHES:", 50, yPos, 200);
            draw_text(valueStr, 180, yPos, 255);
        }

        /* Stunt points */
        yPos = baseY + 175;
        if (yPos >= 50 && yPos <= 200) {
            sprintf(valueStr, "%d", statData[7]);
            draw_text("STUNT PTS:", 50, yPos, 200);
            draw_text(valueStr, 180, yPos, 255);
        }
    }

    /* Scroll indicator */
    if (scrollY > 0) {
        draw_text(155, 45, "^", 0xFFFFFF96);
    }
    if (scrollY < 200) {
        draw_text(155, 205, "v", 0xFFFFFF96);
    }

    D_8015A4B0 = state;
    D_8015A4B4 = scrollY;
}

/*
 * func_80105858 (1692 bytes)
 * Achievements check - Checks and unlocks achievements based on player progress
 *
 * Evaluates player stats against achievement thresholds and triggers unlocks.
 *
 * @param player Pointer to player data structure
 */

/* Achievement IDs */
#define ACH_FIRST_WIN       0
#define ACH_10_WINS         1
#define ACH_50_WINS         2
#define ACH_FIRST_STUNT     3
#define ACH_100K_STUNT      4
#define ACH_NO_CRASH        5
#define ACH_ALL_TRACKS      6
#define ACH_ALL_CARS        7
#define ACH_SPEEDSTER       8
#define ACH_VETERAN         9
#define ACH_COUNT           10

extern void func_80105EF4(s32 achievementId); /* Unlock notification */

void func_80105858(void *player) {
    s32 *playerStats;
    u16 unlocked;
    s32 wins, stuntPts, crashes, races, trackFlags, carFlags;
    s32 bestLap;

    if (player == NULL) {
        return;
    }

    playerStats = (s32 *)player;
    unlocked = D_8015A500;

    /* Extract stats */
    races = playerStats[0];
    wins = playerStats[1];
    stuntPts = playerStats[7];
    crashes = playerStats[6];
    bestLap = playerStats[4];
    trackFlags = playerStats[10];
    carFlags = playerStats[11];

    /* Check each achievement */

    /* First Win */
    if (!(unlocked & (1 << ACH_FIRST_WIN)) && wins >= 1) {
        unlocked |= (1 << ACH_FIRST_WIN);
        func_80105EF4(ACH_FIRST_WIN);
    }

    /* 10 Wins */
    if (!(unlocked & (1 << ACH_10_WINS)) && wins >= 10) {
        unlocked |= (1 << ACH_10_WINS);
        func_80105EF4(ACH_10_WINS);
    }

    /* 50 Wins */
    if (!(unlocked & (1 << ACH_50_WINS)) && wins >= 50) {
        unlocked |= (1 << ACH_50_WINS);
        func_80105EF4(ACH_50_WINS);
    }

    /* First Stunt Score */
    if (!(unlocked & (1 << ACH_FIRST_STUNT)) && stuntPts >= 1000) {
        unlocked |= (1 << ACH_FIRST_STUNT);
        func_80105EF4(ACH_FIRST_STUNT);
    }

    /* 100K Stunt Points */
    if (!(unlocked & (1 << ACH_100K_STUNT)) && stuntPts >= 100000) {
        unlocked |= (1 << ACH_100K_STUNT);
        func_80105EF4(ACH_100K_STUNT);
    }

    /* No Crash Race - checked elsewhere when race ends */

    /* All Tracks Unlocked */
    if (!(unlocked & (1 << ACH_ALL_TRACKS)) && trackFlags == 0xFFFF) {
        unlocked |= (1 << ACH_ALL_TRACKS);
        func_80105EF4(ACH_ALL_TRACKS);
    }

    /* All Cars Unlocked */
    if (!(unlocked & (1 << ACH_ALL_CARS)) && carFlags == 0xFFFF) {
        unlocked |= (1 << ACH_ALL_CARS);
        func_80105EF4(ACH_ALL_CARS);
    }

    /* Speedster - best lap under threshold */
    if (!(unlocked & (1 << ACH_SPEEDSTER)) && bestLap > 0 && bestLap < 1800) {
        unlocked |= (1 << ACH_SPEEDSTER);
        func_80105EF4(ACH_SPEEDSTER);
    }

    /* Veteran - 100 races */
    if (!(unlocked & (1 << ACH_VETERAN)) && races >= 100) {
        unlocked |= (1 << ACH_VETERAN);
        func_80105EF4(ACH_VETERAN);
    }

    D_8015A500 = unlocked;
}

/*
 * func_80105EF4 (876 bytes)
 * Achievement unlock - Shows unlock notification popup
 *
 * Queues an achievement unlock notification to display on screen.
 * Uses a notification queue to avoid overlapping popups.
 *
 * @param achievementId ID of the unlocked achievement
 */
extern s32 D_8015A544;      /* Notification display timer */

/* Achievement names */
static const char *achievementNames[ACH_COUNT] = {
    "FIRST VICTORY",
    "ROAD WARRIOR (10 WINS)",
    "CHAMPION (50 WINS)",
    "STUNT BEGINNER",
    "STUNT MASTER (100K)",
    "PERFECT RACE",
    "TRACK COLLECTOR",
    "CAR COLLECTOR",
    "SPEEDSTER",
    "VETERAN RACER"
};

void func_80105EF4(s32 achievementId) {
    s32 queueHead;
    s32 i;

    if (achievementId < 0 || achievementId >= ACH_COUNT) {
        return;
    }

    queueHead = D_8015A520;

    /* Find empty slot in queue */
    for (i = 0; i < 8; i++) {
        s32 slot = (queueHead + i) % 8;
        if (D_8015A524[slot] == -1) {
            D_8015A524[slot] = achievementId;
            break;
        }
    }

    /* Play unlock sound */
    sound_play_menu(20);  /* Achievement unlock jingle */

    /* Start display timer if not already showing */
    if (D_8015A544 <= 0) {
        D_8015A544 = 180;  /* 3 seconds */
    }
}

/*
 * func_80106260 (1484 bytes)
 * Achievement display - Renders achievement popup on screen
 *
 * Shows the current achievement notification with icon and text.
 *
 * @param achievementId ID of achievement to display
 */
extern s32 D_8015A548;      /* Display animation frame */

void func_80106260(s32 achievementId) {
    s32 timer;
    s32 frame;
    s32 slideY;
    s32 alpha;
    const char *name;

    timer = D_8015A544;
    frame = D_8015A548;

    if (timer <= 0) {
        return;
    }

    frame++;

    /* Slide in from top */
    if (frame < 15) {
        slideY = -50 + (frame * 60 / 15);
    } else if (timer < 30) {
        slideY = 10 + ((30 - timer) * 50 / 30);
    } else {
        slideY = 10;
    }

    /* Fade alpha */
    if (frame < 10) {
        alpha = (frame * 255) / 10;
    } else if (timer < 20) {
        alpha = (timer * 255) / 20;
    } else {
        alpha = 255;
    }

    /* Background box */
    func_800C6E60(60, slideY, 200, 40, (alpha << 24) | 0x204080);
    func_800C6E60(62, slideY + 2, 196, 36, (alpha << 24) | 0x306090);

    /* Trophy icon (simplified) */
    func_800C6E60(70, slideY + 10, 15, 20, (alpha << 24) | 0xFFD700);
    func_800C6E60(72, slideY + 8, 11, 5, (alpha << 24) | 0xFFD700);

    /* "ACHIEVEMENT UNLOCKED" text */
    draw_text(95, slideY + 8, "ACHIEVEMENT", alpha);

    /* Achievement name */
    if (achievementId >= 0 && achievementId < ACH_COUNT) {
        name = achievementNames[achievementId];
        draw_text(95, slideY + 24, name, alpha);
    }

    D_8015A544 = timer - 1;
    D_8015A548 = frame;

    /* When done, advance queue */
    if (timer <= 1) {
        s32 nextSlot = (D_8015A520 + 1) % 8;
        D_8015A524[D_8015A520] = -1;
        D_8015A520 = nextSlot;
        D_8015A548 = 0;

        /* Check if more in queue */
        if (D_8015A524[nextSlot] != -1) {
            D_8015A544 = 180;
        }
    }
}

/*
 * func_801068F4 (2144 bytes)
 * Profile stats update - Updates player profile with race results
 *
 * Accumulates race statistics into the player's lifetime profile.
 *
 * @param profile Player profile data structure
 * @param raceStats Current race statistics to add
 */
void func_801068F4(void *profile, void *raceStats) {
    s32 *profileData;
    s32 *raceData;
    s32 placing;
    s32 lapTime;
    s32 distance;
    s32 crashes;
    s32 stuntPts;

    if (profile == NULL || raceStats == NULL) {
        return;
    }

    profileData = (s32 *)profile;
    raceData = (s32 *)raceStats;

    /* Extract race stats */
    placing = raceData[0];
    lapTime = raceData[1];
    distance = raceData[2];
    crashes = raceData[3];
    stuntPts = raceData[4];

    /* Update profile */

    /* Increment race count */
    profileData[0]++;

    /* Increment wins if first place */
    if (placing == 1) {
        profileData[1]++;
    }

    /* Increment podium if top 3 */
    if (placing >= 1 && placing <= 3) {
        profileData[2]++;
    }

    /* Add race time to total time played */
    profileData[3] += raceData[5];  /* Race duration */

    /* Update best lap if better */
    if (lapTime > 0 && (profileData[4] == 0 || lapTime < profileData[4])) {
        profileData[4] = lapTime;
    }

    /* Add distance */
    profileData[5] += distance;

    /* Add crashes */
    profileData[6] += crashes;

    /* Add stunt points */
    profileData[7] += stuntPts;

    /* No-crash achievement check */
    if (crashes == 0 && placing <= 3) {
        if (!(D_8015A500 & (1 << ACH_NO_CRASH))) {
            D_8015A500 |= (1 << ACH_NO_CRASH);
            func_80105EF4(ACH_NO_CRASH);
        }
    }

    /* Mark profile as dirty (needs save) */
    profileData[15] = 1;
}

/*

 * func_80107110 (1248 bytes)
 * Difficulty scaling
 */
void func_80107110(s32 difficulty) {
    f32 *aiSpeedMult;
    f32 *aiReactionTime;
    f32 *playerDamageMult;
    f32 *timeBonusMult;

    /* Difficulty settings at 0x80159300 */
    aiSpeedMult = (f32 *)0x80159300;
    aiReactionTime = (f32 *)0x80159304;
    playerDamageMult = (f32 *)0x80159308;
    timeBonusMult = (f32 *)0x8015930C;

    D_8015933C = difficulty;

    switch (difficulty) {
        case 0:  /* Easy */
            *aiSpeedMult = 0.85f;
            *aiReactionTime = 0.5f;
            *playerDamageMult = 0.5f;
            *timeBonusMult = 1.5f;
            break;

        case 1:  /* Normal */
            *aiSpeedMult = 1.0f;
            *aiReactionTime = 0.3f;
            *playerDamageMult = 1.0f;
            *timeBonusMult = 1.0f;
            break;

        case 2:  /* Hard */
            *aiSpeedMult = 1.1f;
            *aiReactionTime = 0.15f;
            *playerDamageMult = 1.5f;
            *timeBonusMult = 0.75f;
            break;

        case 3:  /* Expert */
            *aiSpeedMult = 1.2f;
            *aiReactionTime = 0.05f;
            *playerDamageMult = 2.0f;
            *timeBonusMult = 0.5f;
            break;
    }
}

/*

 * func_80107600 (924 bytes)
 * AI difficulty adjust
 */
void func_80107600(void *ai, s32 difficulty) {
    f32 *aiMaxSpeed;
    f32 *aiAccel;
    f32 *aiSteering;
    f32 *aiAggression;
    f32 baseMult;

    if (ai == NULL) {
        return;
    }

    /* AI car parameters at offset 0x240 */
    aiMaxSpeed = (f32 *)((u8 *)ai + 0x250);
    aiAccel = (f32 *)((u8 *)ai + 0x254);
    aiSteering = (f32 *)((u8 *)ai + 0x258);
    aiAggression = (f32 *)((u8 *)ai + 0x25C);

    /* Get global speed multiplier */
    baseMult = *(f32 *)0x80159300;

    switch (difficulty) {
        case 0:  /* Easy */
            *aiMaxSpeed = 80.0f * baseMult;
            *aiAccel = 15.0f;
            *aiSteering = 0.6f;
            *aiAggression = 0.2f;
            break;

        case 1:  /* Normal */
            *aiMaxSpeed = 95.0f * baseMult;
            *aiAccel = 20.0f;
            *aiSteering = 0.8f;
            *aiAggression = 0.5f;
            break;

        case 2:  /* Hard */
            *aiMaxSpeed = 105.0f * baseMult;
            *aiAccel = 25.0f;
            *aiSteering = 0.95f;
            *aiAggression = 0.7f;
            break;

        case 3:  /* Expert */
            *aiMaxSpeed = 115.0f * baseMult;
            *aiAccel = 30.0f;
            *aiSteering = 1.0f;
            *aiAggression = 0.9f;
            break;
    }
}

/*

 * func_801079AC (1768 bytes)
 * Rubber banding
 */
void func_801079AC(void *race) {
    void *leaderCar;
    void *aiCars;
    s32 numAI;
    s32 i;
    f32 leaderDist;
    f32 *aiDist;
    f32 gap;
    f32 speedBoost;

    if (race == NULL) {
        return;
    }

    /* Get leader car (player or AI in first) */
    leaderCar = (void *)0x80152818;  /* First car slot */
    aiCars = (void *)0x80153000;     /* AI car pool */
    numAI = *(s32 *)0x8015A280;

    leaderDist = *(f32 *)((u8 *)leaderCar + 0x230);  /* Track distance */

    for (i = 0; i < numAI; i++) {
        void *ai = (void *)((u8 *)aiCars + i * 0x300);
        f32 *aiMaxSpeed = (f32 *)((u8 *)ai + 0x250);
        f32 baseSpeed = *aiMaxSpeed;

        aiDist = (f32 *)((u8 *)ai + 0x230);
        gap = leaderDist - *aiDist;

        /* Rubber band based on gap */
        if (gap > 100.0f) {
            /* Far behind - speed boost */
            speedBoost = 1.0f + (gap - 100.0f) * 0.002f;
            if (speedBoost > 1.3f) speedBoost = 1.3f;
            *aiMaxSpeed = baseSpeed * speedBoost;
        } else if (gap < -50.0f) {
            /* Too far ahead - slow down slightly */
            speedBoost = 1.0f + gap * 0.001f;
            if (speedBoost < 0.9f) speedBoost = 0.9f;
            *aiMaxSpeed = baseSpeed * speedBoost;
        } else {
            *aiMaxSpeed = baseSpeed;
        }
    }
}

/*

 * func_80108098 (2356 bytes)
 * Dynamic difficulty
 */
void func_80108098(void *player) {
    s32 *playerPosition;
    s32 *crashCount;
    s32 *raceCount;
    s32 *winCount;
    f32 *difficultyFactor;
    f32 performanceScore;

    if (player == NULL) {
        return;
    }

    playerPosition = (s32 *)((u8 *)player + 0x200);
    crashCount = (s32 *)((u8 *)player + 0x204);
    raceCount = (s32 *)0x80159340;
    winCount = (s32 *)0x80159344;
    difficultyFactor = (f32 *)0x80159348;

    /* Calculate performance score */
    performanceScore = 0.5f;

    /* Adjust based on recent finishes */
    if (*raceCount > 0) {
        performanceScore = (f32)(*winCount) / (f32)(*raceCount);
    }

    /* Adjust based on crash frequency */
    if (*crashCount > 5) {
        performanceScore -= 0.1f;
    }

    /* Adjust based on position */
    if (*playerPosition == 1) {
        performanceScore += 0.1f;
    } else if (*playerPosition > 4) {
        performanceScore -= 0.1f;
    }

    /* Clamp performance score */
    if (performanceScore < 0.2f) performanceScore = 0.2f;
    if (performanceScore > 0.9f) performanceScore = 0.9f;

    /* Set difficulty factor (used by AI) */
    *difficultyFactor = performanceScore;
}

/*

 * func_801089CC (1432 bytes)
 * Catch-up logic
 */
void func_801089CC(void *ai, void *leader) {
    /* Catch-up - stub */
}

/*

 * func_80108F6C (876 bytes)
 * Skill rating update
 */
void func_80108F6C(void *player, s32 result) {
    /* Skill rating - stub */
}

/*

 * func_801092D8 (1984 bytes)
 * Matchmaking
 */
void func_801092D8(void *players) {
    /* Matchmaking - stub */
}

/*
 * func_80109A98 (1124 bytes)
 * Session host - Initializes a multiplayer session as host
 *
 * Sets up session state and allocates player slots.
 * For N64, this is local split-screen multiplayer.
 *
 * @return Session ID or -1 on failure
 */
extern s32 D_8015961C;      /* Host player index */

s32 func_80109A98(void) {
    s32 i;

    /* Check if already in session */
    if (D_80159600 != 0) {
        return -1;
    }

    /* Initialize session */
    D_80159600 = 1;  /* Hosting */
    D_80159604 = D_80142AFC & 0xFFFF;  /* Session ID from frame counter */
    D_80159608 = 1;  /* Start with host only */
    D_8015961C = 0;  /* Host is player 0 */

    /* Initialize player slots */
    D_8015960C[0] = 1;  /* Host active */
    for (i = 1; i < 4; i++) {
        D_8015960C[i] = 0;  /* Empty */
    }

    /* Play session start sound */
    sound_play_menu(15);

    return D_80159604;
}

/*
 * func_80109EFC (1476 bytes)
 * Session join - Joins an existing multiplayer session
 *
 * Finds an empty player slot and registers the player.
 *
 * @param sessionId Session to join (ignored for local)
 * @return Assigned player index or -1 on failure
 */
s32 func_80109EFC(s32 sessionId) {
    s32 i;
    s32 slot = -1;

    /* Must have a hosted session */
    if (D_80159600 != 1) {
        return -1;
    }

    /* Already full */
    if (D_80159608 >= 4) {
        return -1;
    }

    /* Find empty slot */
    for (i = 1; i < 4; i++) {
        if (D_8015960C[i] == 0) {
            slot = i;
            break;
        }
    }

    if (slot < 0) {
        return -1;
    }

    /* Assign slot */
    D_8015960C[slot] = 1;
    D_80159608++;

    /* Play join sound */
    sound_play_menu(16);

    return slot;
}

/*
 * func_8010A4C0 (892 bytes)
 * Session leave - Removes a player from the session
 *
 * Called when a player disconnects or leaves.
 */
void func_8010A4C0(void) {
    s32 i;

    if (D_80159600 == 0) {
        return;
    }

    /* Clear session */
    D_80159600 = 0;
    D_80159604 = 0;
    D_80159608 = 0;

    for (i = 0; i < 4; i++) {
        D_8015960C[i] = 0;
    }

    /* Play leave sound */
    sound_play_menu(17);
}

/*
 * func_8010A83C (2648 bytes)
 * Network sync full - Synchronizes game state between players
 *
 * For local multiplayer, ensures all player states are consistent.
 * Copies relevant state between player structures.
 */

void func_8010A83C(void) {
    s32 numPlayers;
    s32 i, j;
    u8 *carBase;
    s32 *lapCount;
    s32 *position;
    s32 *checkpoint;

    if (D_80159600 == 0) {
        return;
    }

    numPlayers = D_80159608;
    carBase = (u8 *)&D_80152818;

    /* Sync race positions and checkpoints */
    for (i = 0; i < numPlayers; i++) {
        if (D_8015960C[i] == 0) {
            continue;
        }

        lapCount = (s32 *)(carBase + i * 0x400 + 0x1A0);
        position = (s32 *)(carBase + i * 0x400 + 0x1A4);
        checkpoint = (s32 *)(carBase + i * 0x400 + 0x1A8);

        /* Calculate race position based on progress */
        s32 myProgress = (*lapCount * 100) + *checkpoint;
        s32 myPosition = 1;

        for (j = 0; j < numPlayers; j++) {
            if (i == j || D_8015960C[j] == 0) {
                continue;
            }

            s32 *otherLap = (s32 *)(carBase + j * 0x400 + 0x1A0);
            s32 *otherCP = (s32 *)(carBase + j * 0x400 + 0x1A8);
            s32 otherProgress = (*otherLap * 100) + *otherCP;

            if (otherProgress > myProgress) {
                myPosition++;
            }
        }

        *position = myPosition;
    }
}

/*
 * func_8010B284 (676 bytes)
 * Ping measurement - Measures input lag/response time
 *
 * For local multiplayer, returns 0 (no network latency).
 * Could be used for controller response testing.
 *
 * @return Ping time in frames (0 for local)
 */
s32 func_8010B284(void) {
    /* Local multiplayer has no network latency */
    return 0;
}

/*
 * func_8010B874 (1548 bytes)
 * Disconnection handling - Handles player disconnect
 *
 * Called when a controller is unplugged or player leaves.
 *
 * @param playerId Player index that disconnected
 */
void func_8010B874(s32 playerId) {
    u8 *carBase;

    if (playerId < 0 || playerId >= 4) {
        return;
    }

    if (D_8015960C[playerId] == 0) {
        return;  /* Already disconnected */
    }

    /* Mark slot as empty */
    D_8015960C[playerId] = 0;
    D_80159608--;

    /* Set car to AI control or remove */
    carBase = (u8 *)&D_80152818;
    *(s32 *)(carBase + playerId * 0x400 + 0x240) = 2;  /* AI_CONTROLLED */

    /* Show disconnect message */
    /* func_800C734C would show "PLAYER X DISCONNECTED" */

    /* If host disconnected, end session */
    if (playerId == D_8015961C) {
        func_8010A4C0();
    }
}

/*
 * func_8010BE7C (1152 bytes)
 * Reconnection attempt - Attempts to reconnect a player
 *
 * Checks if a disconnected player's controller is active again.
 *
 * @return Player index if reconnected, -1 otherwise
 */
s32 func_8010BE7C(void) {
    s32 i;
    s32 controllerState;

    /* Check all controller ports */
    for (i = 0; i < 4; i++) {
        /* Skip active players */
        if (D_8015960C[i] != 0) {
            continue;
        }

        /* Check if controller is connected */
        controllerState = func_800CB748(i);
        if (controllerState != 0) {
            /* Controller active, rejoin */
            return func_80109EFC(D_80159604);
        }
    }

    return -1;
}

/*
 * func_8010C2FC (2084 bytes)
 * Final cleanup - Performs end-of-game cleanup
 *
 * Frees resources, saves state, and resets for next game.
 */
void func_8010C2FC(void) {
    s32 i;

    /* End any active session */
    if (D_80159600 != 0) {
        func_8010A4C0();
    }

    /* Stop all sounds */
    for (i = 0; i < 16; i++) {
        func_800B362C(i, 0.0f);
    }

    /* Clear particle systems */
    func_800B9130(1);

    /* Save any pending data */
    if (D_80158FCC != 0) {
        /* Trigger save */
        func_80096240(NULL, 0);
        D_80158FCC = 0;
    }

    /* Reset game state */
    D_801146EC = 0;  /* ATTRACT mode */

    /* Clear car states */
    for (i = 0; i < 4; i++) {
        u8 *carBase = (u8 *)&D_80152818 + i * 0x400;
        *(s32 *)(carBase + 0x00) = 0;  /* Inactive */
    }

    /* Reset timers */
    D_80142AFC = 0;
}

/*

 * func_800B7440 (88 bytes)
 * Audio queue add
 */
void func_800B7440(s32 sndId) {
    extern u32 D_801547C4;
    s32 *ptr;

    if (D_801547C4 != 0) {
        func_800B73E4();
    }
    for (ptr = &D_801551E8[0]; ptr < &D_801551E8[10]; ptr++) {
        if (*ptr == 0) {
            *ptr = sndId;
            return;
        }
    }
}

/*

 * func_800B78F8 (324 bytes)
 * Audio channel setup
 *
 * Configures an audio channel for playback
 * N64 uses 16 software-mixed channels via the audio library
 */
void func_800B78F8(s32 channel, s32 param) {
    if (channel < 0 || channel >= 16) {
        return;
    }

    /* Initialize channel parameters */
    D_80160000[channel] = 0;         /* Clear state */
    D_80160040[channel] = param;     /* Set param flags */
    D_80160080[channel] = 1.0f;      /* Default volume */
    D_801600C0[channel] = 0.0f;      /* Center pan */
    D_80160100[channel] = 1.0f;      /* Normal pitch */
}

/*

 * func_800B7A40 (192 bytes)
 * Audio volume control
 *
 * Sets volume for a channel (0.0 to 1.0)
 */
void func_800B7A40(s32 channel, f32 volume) {

    if (channel < 0 || channel >= 16) {
        return;
    }

    /* Clamp volume */
    if (volume < 0.0f) volume = 0.0f;
    if (volume > 1.0f) volume = 1.0f;

    D_80160080[channel] = volume;
}

/*

 * func_800B8000 (200 bytes)
 * Audio pan control
 *
 * Sets stereo pan for a channel (-1.0 = left, 0.0 = center, 1.0 = right)
 */
void func_800B8000(s32 channel, f32 pan) {

    if (channel < 0 || channel >= 16) {
        return;
    }

    /* Clamp pan */
    if (pan < -1.0f) pan = -1.0f;
    if (pan > 1.0f) pan = 1.0f;

    D_801600C0[channel] = pan;
}

/*

 * func_800B821C (340 bytes)
 * Audio pitch control
 *
 * Sets pitch multiplier for a channel (0.5 = octave down, 2.0 = octave up)
 */
void func_800B821C(s32 channel, f32 pitch) {
    extern u32 D_80160140[16];  /* Sample rate overrides */

    if (channel < 0 || channel >= 16) {
        return;
    }

    /* Clamp pitch to reasonable range */
    if (pitch < 0.25f) pitch = 0.25f;
    if (pitch > 4.0f) pitch = 4.0f;

    D_80160100[channel] = pitch;

    /* Calculate effective sample rate */
    D_80160140[channel] = (u32)(22050.0f * pitch);  /* Base rate * pitch */
}

/*

 * func_800B8374 (724 bytes)
 * Audio 3D position
 *
 * Sets 3D position for spatial audio effects
 * Calculates distance attenuation and stereo panning from listener
 */
extern f32 D_8016018C[3];   /* Listener forward */
extern f32 D_80160198[3];   /* Listener right */
void func_800B8374(s32 channel, f32 *pos) {
    f32 dx, dy, dz;
    f32 dist, invDist;
    f32 rightDot;
    f32 attenuation;

    if (channel < 0 || channel >= 16 || pos == NULL) {
        return;
    }

    /* Vector from listener to source */
    dx = pos[0] - D_80160180[0];
    dy = pos[1] - D_80160180[1];
    dz = pos[2] - D_80160180[2];

    /* Calculate distance */
    dist = sqrtf(dx*dx + dy*dy + dz*dz);

    if (dist < 1.0f) {
        /* Very close - full volume, center pan */
        D_80160080[channel] = 1.0f;
        D_801600C0[channel] = 0.0f;
        return;
    }

    /* Distance attenuation (inverse square falloff with min distance) */
    attenuation = 100.0f / (100.0f + dist);
    if (attenuation > 1.0f) attenuation = 1.0f;
    D_80160080[channel] = attenuation;

    /* Calculate pan from dot product with listener right vector */
    invDist = 1.0f / dist;
    rightDot = (dx * D_80160198[0] + dy * D_80160198[1] + dz * D_80160198[2]) * invDist;

    /* Clamp and apply pan */
    if (rightDot < -1.0f) rightDot = -1.0f;
    if (rightDot > 1.0f) rightDot = 1.0f;
    D_801600C0[channel] = rightDot;
}

/*

 * func_800B8650 (464 bytes)
 * Audio doppler effect
 *
 * Applies doppler pitch shift based on relative velocity
 * v_rel = (v_listener - v_source) dot (source_to_listener normalized)
 */
void func_800B8650(s32 channel, f32 *velocity) {
    extern f32 D_801601A4[3];   /* Listener velocity */
    extern f32 D_801601B0[16][3]; /* Source positions (cached) */
    f32 dx, dy, dz, dist, invDist;
    f32 relVel;
    f32 dopplerFactor;
    f32 soundSpeed = 343.0f;  /* Speed of sound in m/s */

    if (channel < 0 || channel >= 16 || velocity == NULL) {
        return;
    }

    /* Direction from source to listener */
    dx = D_80160180[0] - D_801601B0[channel][0];
    dy = D_80160180[1] - D_801601B0[channel][1];
    dz = D_80160180[2] - D_801601B0[channel][2];

    dist = sqrtf(dx*dx + dy*dy + dz*dz);
    if (dist < 0.1f) {
        return;  /* Too close for meaningful doppler */
    }

    invDist = 1.0f / dist;
    dx *= invDist;
    dy *= invDist;
    dz *= invDist;

    /* Relative velocity along line of sight */
    /* Positive = approaching, negative = receding */
    relVel = (D_801601A4[0] - velocity[0]) * dx +
             (D_801601A4[1] - velocity[1]) * dy +
             (D_801601A4[2] - velocity[2]) * dz;

    /* Doppler formula: f' = f * (c + v_listener) / (c + v_source) */
    /* Simplified: f' = f * (1 + relVel/c) */
    dopplerFactor = 1.0f + (relVel / soundSpeed);

    /* Clamp to prevent extreme shifts */
    if (dopplerFactor < 0.5f) dopplerFactor = 0.5f;
    if (dopplerFactor > 2.0f) dopplerFactor = 2.0f;

    D_80160100[channel] *= dopplerFactor;
}

/*

 * func_800B8820 (368 bytes)
 * Audio reverb setup
 *
 * Configures reverb effect for spatial ambience
 * Types: 0=None, 1=Small Room, 2=Large Room, 3=Hall, 4=Cave, 5=Outdoor
 */
void func_800B8820(s32 reverbType, f32 amount) {
    /* Clamp amount */
    if (amount < 0.0f) amount = 0.0f;
    if (amount > 1.0f) amount = 1.0f;

    D_80160300 = reverbType;
    D_80160304 = amount;

    /* Set reverb parameters based on type */
    switch (reverbType) {
        case 0:  /* None */
            D_80160308 = 0.0f;
            D_8016030C = 0.0f;
            D_80160310 = 0.0f;
            break;

        case 1:  /* Small Room */
            D_80160308 = 0.3f;
            D_8016030C = 0.01f;
            D_80160310 = 0.5f;
            break;

        case 2:  /* Large Room */
            D_80160308 = 0.8f;
            D_8016030C = 0.02f;
            D_80160310 = 0.6f;
            break;

        case 3:  /* Hall */
            D_80160308 = 1.5f;
            D_8016030C = 0.03f;
            D_80160310 = 0.7f;
            break;

        case 4:  /* Cave */
            D_80160308 = 2.0f;
            D_8016030C = 0.05f;
            D_80160310 = 0.9f;
            break;

        case 5:  /* Outdoor */
            D_80160308 = 0.5f;
            D_8016030C = 0.0f;
            D_80160310 = 0.3f;
            break;

        default:
            break;
    }
}

/*

 * func_800B9194 (528 bytes)
 * Audio sample load
 *
 * Loads audio sample from ROM into RAM audio buffer
 * Returns handle for playback, or -1 on failure
 */
s32 func_800B9194(s32 sampleId) {
    extern u32 D_80160608;       /* Sample ROM offset table */
    u32 romOffset, sampleSize;
    void *destPtr;

    if (sampleId < 0 || sampleId >= 64) {
        return -1;
    }

    /* Check if already loaded */
    if (D_80160408[sampleId] != NULL) {
        return sampleId;  /* Already in memory */
    }

    /* Get ROM offset and size from table */
    romOffset = *(u32 *)(D_80160608 + sampleId * 8);
    sampleSize = *(u32 *)(D_80160608 + sampleId * 8 + 4);

    /* Check heap space */
    if (sampleSize > D_80160404) {
        return -1;  /* Not enough memory */
    }

    /* Allocate from audio heap */
    destPtr = (void *)D_80160400;
    D_80160400 += (sampleSize + 15) & ~15;  /* Align to 16 bytes */
    D_80160404 -= (sampleSize + 15) & ~15;

    /* DMA from ROM */
    osPiStartDma(&D_80086A70, OS_MESG_PRI_NORMAL, OS_READ,
                 romOffset, destPtr, sampleSize, &D_80086A88);
    osRecvMesg(&D_80086A88, NULL, OS_MESG_BLOCK);

    /* Store pointer and size */
    D_80160408[sampleId] = destPtr;
    D_80160508[sampleId] = sampleSize;

    return sampleId;
}

/*

 * func_800B93A8 (972 bytes)
 * Audio stream init
 *
 * Initializes streaming audio playback (for music)
 * Uses double buffering to stream from ROM
 */
s32 func_800B93A8(s32 streamId) {
    u32 tableEntry;

    if (streamId < 0 || streamId >= 16) {
        return -1;
    }

    /* Get stream info from table */
    tableEntry = D_80160720 + streamId * 12;
    D_80160700 = *(u32 *)tableEntry;        /* ROM offset */
    D_80160704 = *(u32 *)(tableEntry + 4);  /* Total size */
    D_80160708 = 0;                          /* Reset read position */

    /* Allocate double buffers if not already */
    D_8016071C = 0x2000;  /* 8KB per buffer */
    if (D_8016070C[0] == NULL) {
        D_8016070C[0] = func_800BA644(D_8016071C);
        D_8016070C[1] = func_800BA644(D_8016071C);
    }

    if (D_8016070C[0] == NULL || D_8016070C[1] == NULL) {
        return -1;  /* Allocation failed */
    }

    /* Fill first buffer */
    D_80160714 = 0;
    func_800B9A0C(D_8016070C[0], D_8016071C);

    D_80160718 = 1;  /* Start playing */

    return streamId;
}

/*

 * func_800B9774 (664 bytes)
 * Audio stream update
 *
 * Called each frame to manage streaming buffer refills
 */
void func_800B9774(void) {
    extern s32 D_80160724;       /* Buffer consumed flag */
    s32 nextBuffer;
    u32 remaining;

    /* Skip if not playing */
    if (D_80160718 != 1) {
        return;
    }

    /* Check if current buffer consumed */
    if (!D_80160724) {
        return;
    }

    /* Switch to next buffer */
    nextBuffer = (D_80160714 + 1) & 1;
    D_80160714 = nextBuffer;
    D_80160724 = 0;

    /* Start filling the now-inactive buffer */
    remaining = D_80160704 - D_80160708;
    if (remaining > 0) {
        u32 toRead = (remaining < D_8016071C) ? remaining : D_8016071C;
        s32 fillBuffer = (nextBuffer + 1) & 1;
        func_800B9A0C(D_8016070C[fillBuffer], toRead);
    } else {
        /* Stream ended - loop or stop */
        D_80160708 = 0;  /* Loop back to start */
        func_800B9A0C(D_8016070C[(nextBuffer + 1) & 1], D_8016071C);
    }
}

/*

 * func_800B9A0C (860 bytes)
 * Audio stream buffer fill
 *
 * Fills a stream buffer from ROM asynchronously
 */
void func_800B9A0C(void *buffer, s32 size) {
    extern OSMesgQueue D_80160730;  /* Stream DMA queue */
    extern OSIoMesg D_80160748;     /* Stream IO message */
    u32 romAddr;

    if (buffer == NULL || size <= 0) {
        return;
    }

    /* Calculate ROM address */
    romAddr = D_80160700 + D_80160708;

    /* Initiate async DMA */
    osPiStartDma(&D_80160748, OS_MESG_PRI_NORMAL, OS_READ,
                 romAddr, buffer, size, &D_80160730);

    /* Update read position */
    D_80160708 += size;

    /* Invalidate data cache for DMA destination */
    osInvalDCache(buffer, size);
}

/*

 * func_800B9D68 (676 bytes)
 * Music sequence control
 *
 * Controls MIDI-style music sequence playback
 * Commands: 0=Stop, 1=Play, 2=Pause, 3=Resume, 4=SetPosition
 */
void func_800B9D68(s32 seqCmd) {
    /* Note: D_80160800-D_8016080C declared globally */

    switch (seqCmd & 0xFF) {
        case 0:  /* Stop */
            D_80160800 = 0;
            D_80160808 = 0;
            break;

        case 1:  /* Play */
            D_80160804 = (seqCmd >> 8) & 0xFF;
            D_80160800 = 1;
            D_80160808 = 0;
            break;

        case 2:  /* Pause */
            if (D_80160800 == 1) {
                D_80160800 = 2;
            }
            break;

        case 3:  /* Resume */
            if (D_80160800 == 2) {
                D_80160800 = 1;
            }
            break;

        case 4:  /* Set position */
            D_80160808 = (seqCmd >> 8) & 0xFFFFFF;
            break;

        default:
            break;
    }
}

/*

 * func_800BA00C (732 bytes)
 * Music tempo control
 *
 * Sets tempo multiplier (1.0 = normal, 2.0 = double speed)
 */
void func_800BA00C(f32 tempo) {
    extern u32 D_80160810;   /* Tick rate (microseconds per tick) */
    u32 baseTick = 10000;    /* 100 ticks per second at 1.0x */

    /* Clamp tempo */
    if (tempo < 0.1f) tempo = 0.1f;
    if (tempo > 4.0f) tempo = 4.0f;

    D_8016080C = tempo;
    D_80160810 = (u32)(baseTick / tempo);
}

/*

 * func_800BA2E8 (388 bytes)
 * Music fade in/out
 *
 * Initiates a volume fade for music
 */
void func_800BA2E8(f32 duration, s32 fadeIn) {
    extern f32 D_80160820;   /* Music master volume */
    extern f32 D_80160824;   /* Fade target volume */
    extern f32 D_80160828;   /* Fade rate per frame */
    extern s32 D_8016082C;   /* Fade direction (1=up, -1=down) */

    if (duration <= 0.0f) {
        /* Instant change */
        D_80160820 = fadeIn ? 1.0f : 0.0f;
        D_80160828 = 0.0f;
        return;
    }

    /* Calculate fade rate (assuming 60fps) */
    D_80160828 = 1.0f / (duration * 60.0f);

    if (fadeIn) {
        D_80160824 = 1.0f;
        D_8016082C = 1;
    } else {
        D_80160824 = 0.0f;
        D_8016082C = -1;
    }
}

/*

 * func_800BA46C (472 bytes)
 * Audio priority system
 *
 * Finds a channel for a sound with given priority
 * Higher priority sounds can steal channels from lower
 */
s32 func_800BA46C(s32 priority) {
    extern s32 D_80160840[16];  /* Channel priorities */
    s32 i;
    s32 freeChannel = -1;
    s32 lowestPri = priority;
    s32 stealChannel = -1;

    /* First, look for an idle channel */
    for (i = 0; i < 16; i++) {
        if (D_80160000[i] == 0) {
            freeChannel = i;
            break;
        }
    }

    if (freeChannel >= 0) {
        D_80160840[freeChannel] = priority;
        return freeChannel;
    }

    /* No free channels - try to steal lowest priority */
    for (i = 0; i < 16; i++) {
        if (D_80160840[i] < lowestPri) {
            lowestPri = D_80160840[i];
            stealChannel = i;
        }
    }

    if (stealChannel >= 0) {
        /* Stop current sound and steal channel */
        D_80160000[stealChannel] = 0;
        D_80160840[stealChannel] = priority;
        return stealChannel;
    }

    return -1;  /* Could not allocate channel */
}

/*

 * func_800BA644 (380 bytes)
 * Audio memory manager
 *
 * Allocates memory from audio heap
 */
void *func_800BA644(s32 size) {
    void *ptr;

    if (size <= 0) {
        return NULL;
    }

    /* Align to 16 bytes */
    size = (size + 15) & ~15;

    if ((u32)size > D_80160404) {
        return NULL;  /* Not enough space */
    }

    ptr = (void *)D_80160400;
    D_80160400 += size;
    D_80160404 -= size;

    return ptr;
}

/*

 * func_800BA7C4 (1996 bytes)
 * Audio main mixer
 *
 * Mixes all active audio channels into output buffer
 * Called by audio thread each frame
 */
void func_800BA7C4(void) {
    extern s32 D_80160860[16];  /* Channel sample IDs */
    extern u32 D_801608A0[16];  /* Channel sample positions */
    /* Note: D_801608E0-D_801608E8 declared globally */
    s32 i, j;
    s32 sampleId;
    s16 *sampleData;
    u32 samplePos, sampleLen;
    f32 vol, pan, pitch;
    f32 leftVol, rightVol;
    s32 sampleValue;

    /* Clear output buffers */
    for (i = 0; i < D_801608E8; i++) {
        D_801608E0[i] = 0;
        D_801608E4[i] = 0;
    }

    /* Mix each active channel */
    for (i = 0; i < 16; i++) {
        if (D_80160000[i] == 0) {
            continue;  /* Channel not active */
        }

        sampleId = D_80160860[i];
        if (sampleId < 0 || D_80160408[sampleId] == NULL) {
            D_80160000[i] = 0;  /* Invalid sample - stop channel */
            continue;
        }

        sampleData = (s16 *)D_80160408[sampleId];
        samplePos = D_801608A0[i];
        sampleLen = D_80160508[sampleId] / 2;  /* Bytes to samples */

        vol = D_80160080[i];
        pan = D_801600C0[i];
        pitch = D_80160100[i];

        /* Calculate stereo volumes */
        leftVol = vol * (1.0f - pan) * 0.5f;
        rightVol = vol * (1.0f + pan) * 0.5f;

        /* Mix samples into output */
        for (j = 0; j < D_801608E8; j++) {
            if (samplePos >= sampleLen) {
                D_80160000[i] = 0;  /* Sample ended */
                break;
            }

            sampleValue = sampleData[samplePos];
            D_801608E0[j] += (s16)(sampleValue * leftVol);
            D_801608E4[j] += (s16)(sampleValue * rightVol);

            /* Advance sample position by pitch */
            samplePos += (u32)(pitch * 256.0f);
            samplePos >>= 8;  /* Fixed point */
        }

        D_801608A0[i] = samplePos;
    }
}

/*

 * func_800BAF98 (172 bytes)
 * Audio effect apply
 *
 * Applies an audio effect to the output
 */
void func_800BAF98(s32 effectId) {
    extern u32 D_80160900;  /* Active effects bitfield */

    if (effectId < 0 || effectId >= 32) {
        return;
    }

    D_80160900 |= (1 << effectId);
}

/*

 * func_800BB044 (252 bytes)
 * Audio effect remove
 *
 * Removes an audio effect
 */
void func_800BB044(s32 effectId) {

    if (effectId < 0 || effectId >= 32) {
        return;
    }

    D_80160900 &= ~(1 << effectId);
}

/*

 * func_800BB140 (1372 bytes)
 * Audio DSP process
 *
 * Processes audio through effects chain (reverb, EQ, etc.)
 */
void func_800BB140(void *dspBuffer) {
    extern s16 D_80160910[512]; /* Reverb delay buffer */
    extern s32 D_80160B10;   /* Delay buffer write position */
    s16 *buf = (s16 *)dspBuffer;
    s32 bufferSize = 184;  /* N64 audio frame size in samples */
    s32 i, delayIdx;
    s32 sample, delayed;
    f32 wet, dry;

    if (dspBuffer == NULL) {
        return;
    }

    /* Apply reverb if active (effect bit 0) */
    if (D_80160900 & 0x01) {
        wet = D_80160304;
        dry = 1.0f - wet;

        for (i = 0; i < bufferSize; i++) {
            sample = buf[i];

            /* Read from delay buffer */
            delayIdx = (D_80160B10 - 200 + 512) & 511;
            delayed = D_80160910[delayIdx];

            /* Mix dry and wet (delayed) signals */
            buf[i] = (s16)(sample * dry + delayed * wet);

            /* Write to delay buffer with decay */
            D_80160910[D_80160B10] = (s16)(sample + delayed * D_80160308);
            D_80160B10 = (D_80160B10 + 1) & 511;
        }
    }
}

/*

 * func_800BB69C (408 bytes)
 * Audio output setup
 *
 * Configures audio output mode (mono, stereo, surround)
 */
void func_800BB69C(s32 outputMode) {
    extern s32 D_80160920;  /* Output mode */
    extern s32 D_80160924;  /* Sample rate */
    extern s32 D_80160928;  /* Buffer size */

    D_80160920 = outputMode;

    switch (outputMode) {
        case 0:  /* Mono */
            D_80160924 = 22050;
            D_80160928 = 368;  /* ~60fps at 22kHz */
            break;

        case 1:  /* Stereo */
            D_80160924 = 22050;
            D_80160928 = 368;
            break;

        case 2:  /* Surround (simulated via phase) */
            D_80160924 = 22050;
            D_80160928 = 368;
            break;

        default:
            D_80160920 = 1;  /* Default to stereo */
            break;
    }

    /* Configure AI output */
    osAiSetFrequency(D_80160924);
}

/*

 * func_800BB834 (392 bytes)
 * Audio hardware sync
 *
 * Syncs audio buffer submission with hardware
 */
void func_800BB834(void) {
    extern void *D_80160930; /* DMA buffer */
    s32 i;
    s16 *dmaOut;

    /* Interleave L/R into DMA buffer for AI */
    dmaOut = (s16 *)D_80160930;
    for (i = 0; i < D_80160928; i++) {
        dmaOut[i * 2] = D_801608E0[i];
        dmaOut[i * 2 + 1] = D_801608E4[i];
    }

    /* Submit to audio interface */
    osAiSetNextBuffer(D_80160930, D_80160928 * 4);
}

/*

 * func_800BB9BC (756 bytes)
 * Audio interrupt handler
 *
 * Called when audio DMA completes - triggers next buffer
 */
void func_800BB9BC(void) {

    /* Signal audio thread to mix next buffer */
    osSendMesg(&D_80086A88, (OSMesg)1, OS_MESG_NOBLOCK);

    /* Update stream buffers if streaming */
    func_800B9774();
}

/*

 * func_800BC2BC (292 bytes)
 * Camera reset
 *
 * Resets camera to default state
 * Camera structure offsets:
 *   0x00: position[3]
 *   0x0C: target[3]
 *   0x18: up[3]
 *   0x24: fov
 *   0x28: near plane
 *   0x2C: far plane
 *   0x30: aspect
 *   0x34: mode
 *   0x38: shake intensity
 *   0x3C: shake timer
 */
void func_800BC2BC(void *camera) {
    f32 *pos, *target, *up;
    f32 *fov, *near, *far, *aspect;
    s32 *mode;

    if (camera == NULL) {
        return;
    }

    pos = (f32 *)camera;
    target = (f32 *)((u8 *)camera + 0x0C);
    up = (f32 *)((u8 *)camera + 0x18);
    fov = (f32 *)((u8 *)camera + 0x24);
    near = (f32 *)((u8 *)camera + 0x28);
    far = (f32 *)((u8 *)camera + 0x2C);
    aspect = (f32 *)((u8 *)camera + 0x30);
    mode = (s32 *)((u8 *)camera + 0x34);

    /* Default position (behind and above origin) */
    pos[0] = 0.0f;
    pos[1] = 100.0f;
    pos[2] = -200.0f;

    /* Default target (origin) */
    target[0] = 0.0f;
    target[1] = 0.0f;
    target[2] = 0.0f;

    /* Default up (world Y) */
    up[0] = 0.0f;
    up[1] = 1.0f;
    up[2] = 0.0f;

    /* Default projection */
    *fov = 60.0f;
    *near = 10.0f;
    *far = 10000.0f;
    *aspect = 4.0f / 3.0f;  /* N64 4:3 */

    *mode = 0;  /* Default mode */
}

/*

 * func_800BCBB8 (808 bytes)
 * Camera lerp position
 *
 * Smoothly interpolates camera position toward target
 */
void func_800BCBB8(void *camera, f32 *targetPos, f32 t) {
    f32 *pos;

    if (camera == NULL || targetPos == NULL) {
        return;
    }

    /* Clamp t */
    if (t < 0.0f) t = 0.0f;
    if (t > 1.0f) t = 1.0f;

    pos = (f32 *)camera;

    /* Linear interpolation */
    pos[0] = pos[0] + (targetPos[0] - pos[0]) * t;
    pos[1] = pos[1] + (targetPos[1] - pos[1]) * t;
    pos[2] = pos[2] + (targetPos[2] - pos[2]) * t;
}

/*

 * func_800BCEE4 (548 bytes)
 * Camera orbit control
 *
 * Orbits camera around its current target
 */
void func_800BCEE4(void *camera, f32 yaw, f32 pitch) {
    f32 *pos, *target;
    f32 dx, dy, dz;
    f32 dist, hDist;
    f32 currentYaw, currentPitch;
    f32 newYaw, newPitch;
    f32 sinY, cosY, sinP, cosP;

    if (camera == NULL) {
        return;
    }

    pos = (f32 *)camera;
    target = (f32 *)((u8 *)camera + 0x0C);

    /* Vector from target to camera */
    dx = pos[0] - target[0];
    dy = pos[1] - target[1];
    dz = pos[2] - target[2];

    /* Calculate current angles and distance */
    dist = sqrtf(dx*dx + dy*dy + dz*dz);
    if (dist < 0.001f) return;

    hDist = sqrtf(dx*dx + dz*dz);
    currentYaw = atan2f(dx, dz);
    currentPitch = atan2f(dy, hDist);

    /* Apply deltas */
    newYaw = currentYaw + yaw;
    newPitch = currentPitch + pitch;

    /* Clamp pitch to avoid gimbal lock */
    if (newPitch > 1.5f) newPitch = 1.5f;
    if (newPitch < -1.5f) newPitch = -1.5f;

    /* Calculate new position */
    sinY = sinf(newYaw);
    cosY = cosf(newYaw);
    sinP = sinf(newPitch);
    cosP = cosf(newPitch);

    pos[0] = target[0] + dist * cosP * sinY;
    pos[1] = target[1] + dist * sinP;
    pos[2] = target[2] + dist * cosP * cosY;
}

/*

 * func_800BD104 (460 bytes)
 * Camera dolly
 *
 * Moves camera along view direction (zoom in/out)
 */
void func_800BD104(void *camera, f32 distance) {
    f32 *pos, *target;
    f32 dx, dy, dz, len;

    if (camera == NULL) {
        return;
    }

    pos = (f32 *)camera;
    target = (f32 *)((u8 *)camera + 0x0C);

    /* Direction from camera to target */
    dx = target[0] - pos[0];
    dy = target[1] - pos[1];
    dz = target[2] - pos[2];

    len = sqrtf(dx*dx + dy*dy + dz*dz);
    if (len < 0.001f) return;

    /* Normalize */
    dx /= len;
    dy /= len;
    dz /= len;

    /* Move camera along direction */
    pos[0] += dx * distance;
    pos[1] += dy * distance;
    pos[2] += dz * distance;

    /* Clamp minimum distance */
    dx = target[0] - pos[0];
    dy = target[1] - pos[1];
    dz = target[2] - pos[2];
    len = sqrtf(dx*dx + dy*dy + dz*dz);
    if (len < 10.0f) {
        pos[0] = target[0] - dx * 10.0f / len;
        pos[1] = target[1] - dy * 10.0f / len;
        pos[2] = target[2] - dz * 10.0f / len;
    }
}

/*

 * func_800BD2D0 (1976 bytes)
 * Camera collision avoidance
 *
 * Prevents camera from clipping through world geometry
 * Uses raycasting from target to camera position
 */
void func_800BD2D0(void *camera) {
    f32 *pos, *target;
    f32 dx, dy, dz, len;
    f32 hitDist;
    s32 hit;

    if (camera == NULL) {
        return;
    }

    pos = (f32 *)camera;
    target = (f32 *)((u8 *)camera + 0x0C);

    /* Direction from target to camera */
    dx = pos[0] - target[0];
    dy = pos[1] - target[1];
    dz = pos[2] - target[2];
    len = sqrtf(dx*dx + dy*dy + dz*dz);

    if (len < 0.001f) return;

    /* Raycast from target toward camera */
    func_800A7DF0();  /* TODO: stub - actual raycast needs args */
    hit = 0;

    if (hit && hitDist < len) {
        /* Move camera to just before hit point */
        f32 safeDist = hitDist - 5.0f;  /* 5 unit buffer */
        if (safeDist < 10.0f) safeDist = 10.0f;

        pos[0] = target[0] + (dx / len) * safeDist;
        pos[1] = target[1] + (dy / len) * safeDist;
        pos[2] = target[2] + (dz / len) * safeDist;
    }
}

/*

 * func_800BDAA8 (852 bytes)
 * Camera shake effect
 *
 * Initiates a camera shake effect (impacts, explosions, etc.)
 */
void func_800BDAA8(f32 intensity, f32 duration) {
    /* Note: D_80170000-D_80170008 declared globally */
    D_80170000 = intensity;
    D_80170004 = duration;

    /* Calculate decay rate */
    if (duration > 0.0f) {
        D_80170008 = intensity / (duration * 60.0f);  /* Per-frame decay */
    } else {
        D_80170008 = intensity;
    }
}

/*

 * func_800BDDFC (192 bytes)
 * Camera shake update
 *
 * Updates camera shake each frame
 */
void func_800BDDFC(void *camera) {
    extern u32 D_80143500;  /* Random seed */
    f32 *pos;
    f32 offsetX, offsetY;

    if (camera == NULL || D_80170000 <= 0.0f) {
        return;
    }

    pos = (f32 *)camera;

    /* Random offsets */
    D_80143500 = D_80143500 * 1103515245 + 12345;
    offsetX = ((f32)(D_80143500 & 0xFFFF) / 65535.0f - 0.5f) * D_80170000;
    D_80143500 = D_80143500 * 1103515245 + 12345;
    offsetY = ((f32)(D_80143500 & 0xFFFF) / 65535.0f - 0.5f) * D_80170000;

    /* Apply shake offset */
    pos[0] += offsetX;
    pos[1] += offsetY;

    /* Decay shake */
    D_80170000 -= D_80170008;
    D_80170004 -= 0.0166f;

    if (D_80170004 <= 0.0f || D_80170000 <= 0.0f) {
        D_80170000 = 0.0f;
        D_80170004 = 0.0f;
    }
}

/*

 * func_800BDEBC (444 bytes)
 * Camera zoom control
 *
 * Adjusts camera FOV for zoom effect
 */
void func_800BDEBC(void *camera, f32 zoom) {
    f32 *fov;
    f32 baseFOV = 60.0f;

    if (camera == NULL) {
        return;
    }

    fov = (f32 *)((u8 *)camera + 0x24);

    /* Clamp zoom factor */
    if (zoom < 0.5f) zoom = 0.5f;
    if (zoom > 2.0f) zoom = 2.0f;

    /* FOV inversely proportional to zoom */
    *fov = baseFOV / zoom;

    /* Clamp FOV */
    if (*fov < 20.0f) *fov = 20.0f;
    if (*fov > 120.0f) *fov = 120.0f;
}

/*

 * func_800BE078 (1136 bytes)
 * Camera auto-follow
 *
 * Smoothly follows a target (car) with spring physics
 */
void func_800BE078(void *camera, void *target) {
    f32 *camPos, *camTarget;
    f32 *targetPos, *targetVel, *targetForward;
    f32 desiredPos[3];
    f32 dx, dz;
    f32 behind = 200.0f;
    f32 above = 80.0f;
    f32 lookAhead = 50.0f;
    f32 smoothFactor = 0.1f;

    if (camera == NULL || target == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);
    targetPos = (f32 *)((u8 *)target + 0x24);
    targetVel = (f32 *)((u8 *)target + 0x34);
    targetForward = (f32 *)((u8 *)target + 0x60);

    /* Desired position: behind and above target */
    desiredPos[0] = targetPos[0] - targetForward[0] * behind;
    desiredPos[1] = targetPos[1] + above;
    desiredPos[2] = targetPos[2] - targetForward[2] * behind;

    /* Smooth interpolation to desired position */
    camPos[0] += (desiredPos[0] - camPos[0]) * smoothFactor;
    camPos[1] += (desiredPos[1] - camPos[1]) * smoothFactor;
    camPos[2] += (desiredPos[2] - camPos[2]) * smoothFactor;

    /* Look ahead of target based on velocity */
    dx = targetVel[0] * lookAhead * 0.1f;
    dz = targetVel[2] * lookAhead * 0.1f;

    camTarget[0] = targetPos[0] + dx;
    camTarget[1] = targetPos[1] + 20.0f;
    camTarget[2] = targetPos[2] + dz;
}

/*

 * func_800BE4F8 (936 bytes)
 * Camera cinematic mode
 *
 * Sets up camera for cinematic sequences
 */
void func_800BE4F8(s32 cinematicId) {
    extern s32 D_80170024;    /* Cinematic state */
    extern s32 D_80170028;    /* Cinematic frame */
    extern f32 D_8017002C[32][6];  /* Keyframe data (pos + target) */
    s32 *mode;

    if (D_80170020 == NULL) {
        return;
    }

    mode = (s32 *)((u8 *)D_80170020 + 0x34);
    *mode = 4;  /* Cinematic mode */

    D_80170024 = cinematicId;
    D_80170028 = 0;

    /* Load keyframes for this cinematic */
    /* (Would load from ROM in real implementation) */
}

/*

 * func_800BEAA0 (908 bytes)
 * Camera cut to
 *
 * Instantly moves camera to new position and target
 */
void func_800BEAA0(void *camera, f32 *pos, f32 *look) {
    f32 *camPos, *camTarget;

    if (camera == NULL || pos == NULL || look == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);

    /* Instant cut */
    camPos[0] = pos[0];
    camPos[1] = pos[1];
    camPos[2] = pos[2];

    camTarget[0] = look[0];
    camTarget[1] = look[1];
    camTarget[2] = look[2];
}

/*

 * func_800BEE2C (924 bytes)
 * Camera blend between
 *
 * Blends between two camera states
 */
void func_800BEE2C(void *cam1, void *cam2, f32 t) {
    f32 *pos1, *pos2, *target1, *target2;
    f32 *outPos, *outTarget;

    if (cam1 == NULL || cam2 == NULL || D_80170020 == NULL) {
        return;
    }

    /* Clamp t */
    if (t < 0.0f) t = 0.0f;
    if (t > 1.0f) t = 1.0f;

    pos1 = (f32 *)cam1;
    target1 = (f32 *)((u8 *)cam1 + 0x0C);
    pos2 = (f32 *)cam2;
    target2 = (f32 *)((u8 *)cam2 + 0x0C);

    outPos = (f32 *)D_80170020;
    outTarget = (f32 *)((u8 *)D_80170020 + 0x0C);

    /* Linear interpolation */
    outPos[0] = pos1[0] + (pos2[0] - pos1[0]) * t;
    outPos[1] = pos1[1] + (pos2[1] - pos1[1]) * t;
    outPos[2] = pos1[2] + (pos2[2] - pos1[2]) * t;

    outTarget[0] = target1[0] + (target2[0] - target1[0]) * t;
    outTarget[1] = target1[1] + (target2[1] - target1[1]) * t;
    outTarget[2] = target1[2] + (target2[2] - target1[2]) * t;
}

/*

 * func_800BF1C8 (236 bytes)
 * Camera FOV control
 *
 * Sets camera field of view
 */
void func_800BF1C8(void *camera, f32 fov) {
    f32 *camFov;

    if (camera == NULL) {
        return;
    }

    camFov = (f32 *)((u8 *)camera + 0x24);

    /* Clamp FOV */
    if (fov < 20.0f) fov = 20.0f;
    if (fov > 120.0f) fov = 120.0f;

    *camFov = fov;
}

/*

 * func_800BF2B8 (220 bytes)
 * Camera near/far planes
 *
 * Sets camera clipping planes
 */
void func_800BF2B8(void *camera, f32 nearVal, f32 farVal) {
    f32 *camNear, *camFar;

    if (camera == NULL) {
        return;
    }

    camNear = (f32 *)((u8 *)camera + 0x28);
    camFar = (f32 *)((u8 *)camera + 0x2C);

    /* Validate values */
    if (nearVal < 1.0f) nearVal = 1.0f;
    if (farVal < nearVal + 100.0f) farVal = nearVal + 100.0f;

    *camNear = nearVal;
    *camFar = farVal;
}

/*

 * func_800BF394 (200 bytes)
 * Camera aspect ratio
 *
 * Sets camera aspect ratio
 */
void func_800BF394(void *camera, f32 aspect) {
    f32 *camAspect;

    if (camera == NULL) {
        return;
    }

    camAspect = (f32 *)((u8 *)camera + 0x30);

    /* Clamp aspect */
    if (aspect < 0.5f) aspect = 0.5f;
    if (aspect > 3.0f) aspect = 3.0f;

    *camAspect = aspect;
}

/*

 * func_800BF45C (988 bytes)
 * Camera look at
 *
 * Orients camera to look at target point
 */
void func_800BF45C(void *camera, f32 *target) {
    f32 *camTarget;

    if (camera == NULL || target == NULL) {
        return;
    }

    camTarget = (f32 *)((u8 *)camera + 0x0C);

    camTarget[0] = target[0];
    camTarget[1] = target[1];
    camTarget[2] = target[2];
}

/*

 * func_800BF838 (948 bytes)
 * Camera first person
 *
 * First person view from inside vehicle
 */
void func_800BF838(void *camera, void *player) {
    f32 *camPos, *camTarget;
    f32 *playerPos, *playerForward;
    s32 *mode;

    if (camera == NULL || player == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);
    mode = (s32 *)((u8 *)camera + 0x34);

    playerPos = (f32 *)((u8 *)player + 0x24);
    playerForward = (f32 *)((u8 *)player + 0x60);

    /* Camera at driver's head position */
    camPos[0] = playerPos[0];
    camPos[1] = playerPos[1] + 30.0f;  /* Eye height */
    camPos[2] = playerPos[2];

    /* Look forward */
    camTarget[0] = camPos[0] + playerForward[0] * 100.0f;
    camTarget[1] = camPos[1] + playerForward[1] * 100.0f;
    camTarget[2] = camPos[2] + playerForward[2] * 100.0f;

    *mode = 1;  /* First person mode */
}

/*

 * func_800BFBEC (380 bytes)
 * Camera third person
 *
 * Third person chase camera behind vehicle
 */
void func_800BFBEC(void *camera, void *player) {
    s32 *mode;

    if (camera == NULL || player == NULL) {
        return;
    }

    mode = (s32 *)((u8 *)camera + 0x34);
    *mode = 2;  /* Third person mode */

    /* Use auto-follow for actual positioning */
    func_800BE078(camera, player);
}

/*

 * func_800BFD94 (844 bytes)
 * Camera top down
 *
 * Top-down overhead view
 */
void func_800BFD94(void *camera) {
    f32 *camPos, *camTarget;
    f32 *playerPos;
    s32 *mode;

    if (camera == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);
    mode = (s32 *)((u8 *)camera + 0x34);

    playerPos = (f32 *)((u8 *)&D_80152818 + 0x24);

    /* Position directly above player */
    camPos[0] = playerPos[0];
    camPos[1] = playerPos[1] + 500.0f;
    camPos[2] = playerPos[2];

    /* Look straight down */
    camTarget[0] = playerPos[0];
    camTarget[1] = playerPos[1];
    camTarget[2] = playerPos[2];

    *mode = 3;  /* Top down mode */
}

/*

 * camera_free_look (func_800C00E0)
 * Size: 444 bytes
 *
 * Free camera controlled by player input
 */
void camera_free_look(void *camera, s32 input) {
    f32 *camPos;
    f32 moveSpeed = 10.0f;
    f32 rotSpeed = 0.05f;
    s32 *mode;

    if (camera == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    mode = (s32 *)((u8 *)camera + 0x34);
    *mode = 5;  /* Free look mode */

    /* Movement controls */
    if (input & 0x0800) {  /* Up */
        camPos[2] += moveSpeed;
    }
    if (input & 0x0400) {  /* Down */
        camPos[2] -= moveSpeed;
    }
    if (input & 0x0200) {  /* Left */
        camPos[0] -= moveSpeed;
    }
    if (input & 0x0100) {  /* Right */
        camPos[0] += moveSpeed;
    }
    if (input & 0x0020) {  /* L trigger - up */
        camPos[1] += moveSpeed;
    }
    if (input & 0x0010) {  /* R trigger - down */
        camPos[1] -= moveSpeed;
    }

    /* Rotation controls via C-buttons */
    if (input & 0x0008) {  /* C-up */
        func_800BCEE4(camera, 0.0f, rotSpeed);
    }
    if (input & 0x0004) {  /* C-down */
        func_800BCEE4(camera, 0.0f, -rotSpeed);
    }
    if (input & 0x0002) {  /* C-left */
        func_800BCEE4(camera, -rotSpeed, 0.0f);
    }
    if (input & 0x0001) {  /* C-right */
        func_800BCEE4(camera, rotSpeed, 0.0f);
    }
}

/*

 * camera_replay_mode (func_800C02A0)
 * Size: 556 bytes
 *
 * Playback camera from recorded replay data
 */
void camera_replay_mode(void *camera, s32 frame) {
    extern f32 D_80170100[3600][6];  /* Replay camera data (60 sec @ 60fps) */
    f32 *camPos, *camTarget;
    s32 *mode;

    if (camera == NULL || frame < 0 || frame >= 3600) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);
    mode = (s32 *)((u8 *)camera + 0x34);

    *mode = 6;  /* Replay mode */

    /* Load position from replay data */
    camPos[0] = D_80170100[frame][0];
    camPos[1] = D_80170100[frame][1];
    camPos[2] = D_80170100[frame][2];

    camTarget[0] = D_80170100[frame][3];
    camTarget[1] = D_80170100[frame][4];
    camTarget[2] = D_80170100[frame][5];
}

/*

 * camera_track_spline (func_800C04CC)
 * Size: 912 bytes
 *
 * Moves camera along a spline path
 */
void camera_track_spline(void *camera, void *spline, f32 t) {
    f32 *camPos, *camTarget;
    f32 *points;
    s32 numPoints;
    s32 seg;
    f32 localT;
    f32 p0[3], p1[3], p2[3], p3[3];

    if (camera == NULL || spline == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);

    /* Spline structure: [numPoints, point0[3], point1[3], ...] */
    numPoints = *(s32 *)spline;
    points = (f32 *)((u8 *)spline + 4);

    if (numPoints < 4) return;

    /* Clamp and find segment */
    if (t < 0.0f) t = 0.0f;
    if (t > 1.0f) t = 1.0f;

    seg = (s32)(t * (numPoints - 3));
    if (seg > numPoints - 4) seg = numPoints - 4;
    localT = (t * (numPoints - 3)) - seg;

    /* Get 4 control points for Catmull-Rom */
    p0[0] = points[seg*3];     p0[1] = points[seg*3+1];     p0[2] = points[seg*3+2];
    p1[0] = points[(seg+1)*3]; p1[1] = points[(seg+1)*3+1]; p1[2] = points[(seg+1)*3+2];
    p2[0] = points[(seg+2)*3]; p2[1] = points[(seg+2)*3+1]; p2[2] = points[(seg+2)*3+2];
    p3[0] = points[(seg+3)*3]; p3[1] = points[(seg+3)*3+1]; p3[2] = points[(seg+3)*3+2];

    /* Catmull-Rom interpolation */
    {
        f32 t2 = localT * localT;
        f32 t3 = t2 * localT;

        camPos[0] = 0.5f * ((2*p1[0]) + (-p0[0]+p2[0])*localT + (2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2 + (-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3);
        camPos[1] = 0.5f * ((2*p1[1]) + (-p0[1]+p2[1])*localT + (2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2 + (-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3);
        camPos[2] = 0.5f * ((2*p1[2]) + (-p0[2]+p2[2])*localT + (2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t2 + (-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t3);
    }

    /* Target slightly ahead on spline */
    {
        f32 aheadT = t + 0.05f;
        if (aheadT > 1.0f) aheadT = 1.0f;
        s32 aSeg = (s32)(aheadT * (numPoints - 3));
        if (aSeg > numPoints - 4) aSeg = numPoints - 4;

        camTarget[0] = points[(aSeg+1)*3];
        camTarget[1] = points[(aSeg+1)*3+1];
        camTarget[2] = points[(aSeg+1)*3+2];
    }
}

/*

 * func_800C085C (612 bytes)
 * camera_build_view_matrix (func_800C085C)
 *
 * Builds view matrix from camera state
 */
void camera_build_view_matrix(void *camera, f32 *matrix) {
    f32 *pos, *target, *up;
    f32 forward[3], right[3], newUp[3];
    f32 len;

    if (camera == NULL || matrix == NULL) {
        return;
    }

    pos = (f32 *)camera;
    target = (f32 *)((u8 *)camera + 0x0C);
    up = (f32 *)((u8 *)camera + 0x18);

    /* Forward vector (target - pos, normalized) */
    forward[0] = target[0] - pos[0];
    forward[1] = target[1] - pos[1];
    forward[2] = target[2] - pos[2];
    len = sqrtf(forward[0]*forward[0] + forward[1]*forward[1] + forward[2]*forward[2]);
    if (len > 0.001f) {
        forward[0] /= len;
        forward[1] /= len;
        forward[2] /= len;
    }

    /* Right vector (forward x up) */
    right[0] = forward[1] * up[2] - forward[2] * up[1];
    right[1] = forward[2] * up[0] - forward[0] * up[2];
    right[2] = forward[0] * up[1] - forward[1] * up[0];
    len = sqrtf(right[0]*right[0] + right[1]*right[1] + right[2]*right[2]);
    if (len > 0.001f) {
        right[0] /= len;
        right[1] /= len;
        right[2] /= len;
    }

    /* Recalculate up (right x forward) */
    newUp[0] = right[1] * forward[2] - right[2] * forward[1];
    newUp[1] = right[2] * forward[0] - right[0] * forward[2];
    newUp[2] = right[0] * forward[1] - right[1] * forward[0];

    /* Build 4x4 view matrix (column-major for N64) */
    matrix[0] = right[0];   matrix[4] = right[1];   matrix[8]  = right[2];   matrix[12] = -(right[0]*pos[0] + right[1]*pos[1] + right[2]*pos[2]);
    matrix[1] = newUp[0];   matrix[5] = newUp[1];   matrix[9]  = newUp[2];   matrix[13] = -(newUp[0]*pos[0] + newUp[1]*pos[1] + newUp[2]*pos[2]);
    matrix[2] = forward[0]; matrix[6] = forward[1]; matrix[10] = forward[2]; matrix[14] = -(forward[0]*pos[0] + forward[1]*pos[1] + forward[2]*pos[2]);
    matrix[3] = 0.0f;       matrix[7] = 0.0f;       matrix[11] = 0.0f;       matrix[15] = 1.0f;
}

/*

 * camera_update (func_800C0AC0)
 * Size: 2884 bytes
 *
 * Main camera update - calls appropriate mode handler
 */
void camera_update(void *camera) {
    s32 *mode;

    if (camera == NULL) {
        return;
    }

    mode = (s32 *)((u8 *)camera + 0x34);

    switch (*mode) {
        case 0:  /* Default/Attract */
            /* No movement */
            break;

        case 1:  /* First person */
            func_800BF838(camera, &D_80152818);
            break;

        case 2:  /* Third person */
            func_800BE078(camera, &D_80152818);
            func_800BD2D0(camera);  /* Collision avoidance */
            break;

        case 3:  /* Top down */
            func_800BFD94(camera);
            break;

        case 4:  /* Cinematic */
            /* Handled by cinematic system */
            break;

        case 5:  /* Free look */
            /* Handled by input */
            break;

        case 6:  /* Replay */
            /* Handled by replay system */
            break;

        default:
            break;
    }

    /* Apply camera shake if active */
    func_800BDDFC(camera);
}

/*

 * camera_process_input (func_800C1604)
 * Size: 1416 bytes
 *
 * Processes player input for camera control
 * Handles C-button camera rotation, L/R shoulder zoom
 */
void camera_process_input(void *camera, void *input) {
    s32 *inputState;
    s32 *mode;
    f32 yawDelta = 0.0f;
    f32 pitchDelta = 0.0f;
    f32 zoomDelta = 0.0f;

    if (camera == NULL || input == NULL) {
        return;
    }

    inputState = (s32 *)input;
    mode = (s32 *)((u8 *)camera + 0x34);

    /* Skip if in cinematic or replay mode */
    if (*mode == 4 || *mode == 6) {
        return;
    }

    /* C-button camera rotation */
    if (*inputState & 0x0001) {  /* C-Right */
        yawDelta = 0.03f;
    }
    if (*inputState & 0x0002) {  /* C-Left */
        yawDelta = -0.03f;
    }
    if (*inputState & 0x0004) {  /* C-Down */
        pitchDelta = 0.02f;
    }
    if (*inputState & 0x0008) {  /* C-Up */
        pitchDelta = -0.02f;
    }

    /* L/R shoulder zoom */
    if (*inputState & 0x0010) {  /* R trigger */
        zoomDelta = 0.05f;
    }
    if (*inputState & 0x0020) {  /* L trigger */
        zoomDelta = -0.05f;
    }

    /* Apply rotations */
    if (yawDelta != 0.0f || pitchDelta != 0.0f) {
        func_800BCEE4(camera, yawDelta, pitchDelta);
    }

    /* Apply zoom */
    if (zoomDelta != 0.0f) {
        f32 *zoom = (f32 *)((u8 *)camera + 0x40);
        *zoom += zoomDelta;
        if (*zoom < 0.5f) *zoom = 0.5f;
        if (*zoom > 2.0f) *zoom = 2.0f;
        func_800BDEBC(camera, *zoom);
    }
}

/*

 * camera_check_constraints (func_800C1B8C)
 * Size: 1172 bytes
 *
 * Enforces camera position constraints
 * Keeps camera within world bounds and above terrain
 */
void camera_check_constraints(void *camera) {
    f32 *pos;
    f32 terrainHeight;
    f32 minHeight = 20.0f;

    if (camera == NULL) {
        return;
    }

    pos = (f32 *)camera;

    /* World boundary constraints */
    if (pos[0] < -5000.0f) pos[0] = -5000.0f;
    if (pos[0] > 5000.0f) pos[0] = 5000.0f;
    if (pos[2] < -5000.0f) pos[2] = -5000.0f;
    if (pos[2] > 5000.0f) pos[2] = 5000.0f;

    /* Height constraint - stay above terrain */
    terrainHeight = func_800A7E50(pos[0], pos[2]);  /* Get terrain height */
    if (pos[1] < terrainHeight + minHeight) {
        pos[1] = terrainHeight + minHeight;
    }

    /* Maximum height constraint */
    if (pos[1] > 2000.0f) {
        pos[1] = 2000.0f;
    }
}

/*

 * camera_debug_display (func_800C2020)
 * Size: 520 bytes
 *
 * Shows camera debug information (position, target, mode)
 */
void camera_debug_display(void *camera) {
    f32 *pos, *target;
    s32 *mode;
    char buf[32];

    if (!D_80159E00 || camera == NULL) {
        return;
    }

    pos = (f32 *)camera;
    target = (f32 *)((u8 *)camera + 0x0C);
    mode = (s32 *)((u8 *)camera + 0x34);

    /* Display camera position */
    draw_text(10, 180, "CAM:", 0xFFFFFFC8);

    /* X position */
    {
        s32 x = (s32)pos[0];
        buf[0] = 'X';
        buf[1] = ':';
        buf[2] = (x < 0) ? '-' : ' ';
        if (x < 0) x = -x;
        buf[3] = '0' + ((x / 1000) % 10);
        buf[4] = '0' + ((x / 100) % 10);
        buf[5] = '0' + ((x / 10) % 10);
        buf[6] = '0' + (x % 10);
        buf[7] = '\0';
        draw_text(buf, 45, 180, 180);
    }

    /* Mode indicator */
    {
        char *modeNames[] = {"DEF", "FP", "TP", "TOP", "CIN", "FREE", "REP"};
        if (*mode >= 0 && *mode < 7) {
            draw_text(modeNames[*mode], 130, 180, 180);
        }
    }
}

/*

 * camera_save_state (func_800C2228)
 * Size: 548 bytes
 *
 * Saves camera state for replay or undo
 */
void camera_save_state(void *camera, void *state) {
    f32 *src, *dst;
    s32 i;

    if (camera == NULL || state == NULL) {
        return;
    }

    src = (f32 *)camera;
    dst = (f32 *)state;

    /* Copy camera structure (position, target, up, fov, planes, aspect, mode) */
    for (i = 0; i < 16; i++) {
        dst[i] = src[i];
    }
}

/*

 * camera_restore_state (func_800C244C)
 * Size: 660 bytes
 *
 * Restores camera state from saved data
 */
void camera_restore_state(void *camera, void *state) {
    f32 *src, *dst;
    s32 i;

    if (camera == NULL || state == NULL) {
        return;
    }

    src = (f32 *)state;
    dst = (f32 *)camera;

    /* Restore camera structure */
    for (i = 0; i < 16; i++) {
        dst[i] = src[i];
    }
}

/*

 * camera_multi_view_setup (func_800C26E0)
 * Size: 644 bytes
 *
 * Sets up camera for multi-view (split screen) rendering
 */
void camera_multi_view_setup(s32 viewIndex, void *camera) {
    f32 *aspect;
    s32 viewportX, viewportY, viewportW, viewportH;

    if (camera == NULL || viewIndex < 0 || viewIndex >= 4) {
        return;
    }

    aspect = (f32 *)((u8 *)camera + 0x30);

    /* Calculate viewport based on view count and index */
    switch (D_80159020) {
        case 1:
            /* Full screen */
            viewportX = 0;
            viewportY = 0;
            viewportW = 320;
            viewportH = 240;
            *aspect = 4.0f / 3.0f;
            break;

        case 2:
            /* Horizontal split */
            viewportX = 0;
            viewportY = viewIndex * 120;
            viewportW = 320;
            viewportH = 120;
            *aspect = 8.0f / 3.0f;
            break;

        case 3:
        case 4:
            /* Quad split */
            viewportX = (viewIndex & 1) * 160;
            viewportY = (viewIndex / 2) * 120;
            viewportW = 160;
            viewportH = 120;
            *aspect = 4.0f / 3.0f;
            break;

        default:
            return;
    }

    /* Store viewport in camera */
    *(s32 *)((u8 *)camera + 0x44) = viewportX;
    *(s32 *)((u8 *)camera + 0x48) = viewportY;
    *(s32 *)((u8 *)camera + 0x4C) = viewportW;
    *(s32 *)((u8 *)camera + 0x50) = viewportH;
}

/*

 * camera_split_screen_config (func_800C2960)
 * Size: 644 bytes
 *
 * Configures split screen mode for multiplayer
 */
void camera_split_screen_config(s32 numPlayers) {
    s32 i;

    if (numPlayers < 1) numPlayers = 1;
    if (numPlayers > 4) numPlayers = 4;

    D_80159020 = numPlayers;

    /* Setup each player's camera */
    for (i = 0; i < numPlayers; i++) {
        if (D_80159024[i] != NULL) {
            camera_multi_view_setup(i, D_80159024[i]);
        }
    }
}

/*

 * camera_scene_manager (func_800C2BE0)
 * Size: 5664 bytes
 *
 * Manages camera state transitions between game states
 */
void camera_scene_manager(void) {
    static s32 lastGState = -1;

    if (D_80170020 == NULL) {
        return;
    }

    /* Detect state change */
    if (D_801146EC != lastGState) {
        lastGState = D_801146EC;

        switch (D_801146EC) {
            case 0:  /* ATTRACT */
                func_800BC2BC(D_80170020);  /* Reset camera */
                *(s32 *)((u8 *)D_80170020 + 0x34) = 0;  /* Default mode */
                break;

            case 1:  /* TRKSEL */
            case 2:  /* CARSEL */
                /* Menu camera - fixed position */
                func_800BC2BC(D_80170020);
                break;

            case 5:  /* COUNTDOWN */
                /* Starting grid camera */
                *(s32 *)((u8 *)D_80170020 + 0x34) = 4;  /* Cinematic */
                camera_play_script(0);  /* Start sequence */
                break;

            case 6:  /* PLAYGAME */
                /* Switch to chase camera */
                *(s32 *)((u8 *)D_80170020 + 0x34) = 2;  /* Third person */
                break;

            case 7:  /* ENDGAME */
                /* Victory camera */
                camera_victory(D_80170020, 1);
                break;

            default:
                break;
        }
    }

    /* Update active camera */
    camera_update(D_80170020);
}

/*

 * camera_trigger_check (func_800C4200)
 * Size: 1232 bytes
 *
 * Checks if camera has entered any trigger zones
 * Used for cinematic triggers and camera mode switches
 */
void camera_trigger_check(void *camera, void *triggers) {
    f32 *camPos;
    s32 numTriggers;
    s32 i;
    f32 *triggerData;
    f32 dx, dy, dz, dist;

    if (camera == NULL || triggers == NULL) {
        return;
    }

    camPos = (f32 *)camera;
    numTriggers = *(s32 *)triggers;
    triggerData = (f32 *)((u8 *)triggers + 4);

    /* Check each trigger */
    for (i = 0; i < numTriggers && i < 32; i++) {
        f32 *trig = &triggerData[i * 5];  /* x, y, z, radius, action */

        dx = camPos[0] - trig[0];
        dy = camPos[1] - trig[1];
        dz = camPos[2] - trig[2];
        dist = sqrtf(dx*dx + dy*dy + dz*dz);

        if (dist < trig[3]) {
            /* Inside trigger - execute action */
            s32 action = (s32)trig[4];
            switch (action) {
                case 1:  /* Switch to cinematic */
                    camera_play_script(i);
                    break;
                case 2:  /* Camera shake */
                    func_800BDAA8(5.0f, 0.5f);
                    break;
                case 3:  /* Zoom in */
                    func_800BDEBC(camera, 1.5f);
                    break;
                default:
                    break;
            }
        }
    }
}

/*

 * camera_follow_path (func_800C46D0)
 * Size: 3956 bytes
 *
 * Makes camera follow a predefined path
 */
void camera_follow_path(void *camera, void *path) {
    f32 t;

    if (camera == NULL || path == NULL) {
        return;
    }

    t = D_80159040;

    /* Advance along path */
    t += D_80159044 * 0.0166f;  /* dt = 1/60 */

    if (t > 1.0f) {
        t = 1.0f;  /* Clamp at end */
    }

    D_80159040 = t;

    /* Interpolate camera along path spline */
    camera_track_spline(camera, path, t);
}

/*

 * camera_play_script (func_800C5644)
 * Size: 3516 bytes
 *
 * Plays a scripted camera sequence (intro, finish, replay)
 */
void camera_play_script(s32 scriptId) {
    extern f32 D_80159058[16][6]; /* Script keyframes */
    s32 *mode;
    f32 *camPos, *camTarget;
    s32 frame;
    s32 keyframe, nextKeyframe;
    f32 t;

    if (D_80170020 == NULL) {
        return;
    }

    mode = (s32 *)((u8 *)D_80170020 + 0x34);
    *mode = 4;  /* Cinematic mode */

    D_80159050 = scriptId;
    D_80159054++;
    frame = D_80159054;

    /* Find keyframe */
    keyframe = frame / 60;  /* 60 frames per keyframe */
    nextKeyframe = keyframe + 1;
    if (nextKeyframe > 15) nextKeyframe = 15;
    t = (f32)(frame % 60) / 60.0f;

    camPos = (f32 *)D_80170020;
    camTarget = (f32 *)((u8 *)D_80170020 + 0x0C);

    /* Interpolate between keyframes */
    camPos[0] = D_80159058[keyframe][0] + (D_80159058[nextKeyframe][0] - D_80159058[keyframe][0]) * t;
    camPos[1] = D_80159058[keyframe][1] + (D_80159058[nextKeyframe][1] - D_80159058[keyframe][1]) * t;
    camPos[2] = D_80159058[keyframe][2] + (D_80159058[nextKeyframe][2] - D_80159058[keyframe][2]) * t;

    camTarget[0] = D_80159058[keyframe][3] + (D_80159058[nextKeyframe][3] - D_80159058[keyframe][3]) * t;
    camTarget[1] = D_80159058[keyframe][4] + (D_80159058[nextKeyframe][4] - D_80159058[keyframe][4]) * t;
    camTarget[2] = D_80159058[keyframe][5] + (D_80159058[nextKeyframe][5] - D_80159058[keyframe][5]) * t;
}

/*

 * camera_victory (func_800C6404)
 * Size: 780 bytes
 *
 * Victory camera for race finish
 */
void camera_victory(void *camera, s32 placing) {
    f32 *camPos, *camTarget;
    f32 *carPos;
    f32 orbitAngle;
    s32 *mode;

    if (camera == NULL) {
        return;
    }

    mode = (s32 *)((u8 *)camera + 0x34);
    *mode = 4;  /* Cinematic mode */

    camPos = (f32 *)camera;
    camTarget = (f32 *)((u8 *)camera + 0x0C);
    carPos = (f32 *)((u8 *)&D_80152818 + 0x24);

    /* Orbit around the car */
    orbitAngle = (f32)D_80142AFC * 0.02f;  /* Slow rotation */

    camPos[0] = carPos[0] + sinf(orbitAngle) * 150.0f;
    camPos[1] = carPos[1] + 50.0f + (placing == 1 ? 30.0f : 0.0f);  /* Higher for 1st place */
    camPos[2] = carPos[2] + cosf(orbitAngle) * 150.0f;

    /* Look at car */
    camTarget[0] = carPos[0];
    camTarget[1] = carPos[1] + 20.0f;
    camTarget[2] = carPos[2];
}

/*

 * draw_ui_element(572 bytes, 0, 0, 0, 0, 0)
 * HUD element draw
 *
 * Draws a HUD element (icon/graphic) at the specified position.
 * Uses N64 RDP for 2D sprite rendering.
 *
 * Element IDs:
 *   0 = Speedometer background
 *   1 = Tachometer background
 *   2 = Lap indicator icon
 *   3 = Position indicator
 *   4 = Timer background
 *   5 = Nitro bar background
 *   6 = Minimap frame
 *   7-15 = Number sprites 0-9
 *   16-25 = Letter sprites (for position: 1st, 2nd, etc.)
 */
extern void render_entity(void *entity); /* func_80099BFC - Render entity */

void draw_ui_element(s32 elementId, s32 x, s32 y, s32 w, s32 h, s32 alpha) {
    void **spriteTable;
    void *sprite;

    if (D_80159010 == NULL || D_80159014 == NULL) {
        return;
    }

    /* Validate element ID */
    if (elementId < 0 || elementId > 63) {
        return;
    }

    /* Get sprite from table */
    spriteTable = (void **)D_80159010;
    sprite = spriteTable[elementId];

    if (sprite == NULL) {
        return;
    }

    /* Render sprite to display list with specified size and alpha */
    draw_ui_element((s32)(long)sprite, x, y, w, h, alpha);
}

/*

 * draw_text (func_800C734C)
 * Size: 700 bytes
 *
 * Draws text string at specified position using HUD font.
 * Supports uppercase letters, numbers, and basic punctuation.
 */

void draw_text(s32 x, s32 y, char *text, u32 color) {
    s32 charX;
    s32 charIndex;
    char c;
    s32 i;
    s32 alpha;

    if (text == NULL) {
        return;
    }

    charX = x;
    alpha = (color >> 24) & 0xFF;

    for (i = 0; text[i] != '\0' && i < 64; i++) {
        c = text[i];

        /* Map character to font index */
        if (c >= '0' && c <= '9') {
            charIndex = c - '0';  /* 0-9 */
        } else if (c >= 'A' && c <= 'Z') {
            charIndex = 10 + (c - 'A');  /* 10-35 */
        } else if (c >= 'a' && c <= 'z') {
            charIndex = 10 + (c - 'a');  /* 10-35 (lowercase = uppercase) */
        } else if (c == ':') {
            charIndex = 36;
        } else if (c == '.') {
            charIndex = 37;
        } else if (c == '-') {
            charIndex = 38;
        } else if (c == '/') {
            charIndex = 39;
        } else if (c == '!') {
            charIndex = 40;
        } else if (c == ' ') {
            /* Space - just advance position */
            charX += D_8015901C;
            continue;
        } else {
            /* Unknown character - skip */
            charX += D_8015901C;
            continue;
        }

        /* Draw character */
        draw_ui_element(charIndex + 64, charX, y, D_8015901C, D_80159020, alpha);

        /* Advance position */
        charX += D_8015901C;
    }
}

/*

 * draw_number (func_800C760C)
 * Size: 524 bytes
 *
 * Draws a numeric value at specified position.
 * Leading zeros shown based on digits parameter.
 *
 * value: Number to display
 * digits: Minimum digits to show (pads with leading zeros)
 * x, y: Screen position
 */
void draw_number(s32 value, s32 digits, s32 x, s32 y) {
    char buffer[12];
    s32 i, len, startPos;
    s32 absValue;
    s32 negative;

    /* Handle negative numbers */
    if (value < 0) {
        negative = 1;
        absValue = -value;
    } else {
        negative = 0;
        absValue = value;
    }

    /* Convert to string (reverse order) */
    len = 0;
    if (absValue == 0) {
        buffer[len++] = '0';
    } else {
        while (absValue > 0 && len < 10) {
            buffer[len++] = '0' + (absValue % 10);
            absValue /= 10;
        }
    }

    /* Pad with leading zeros if needed */
    while (len < digits && len < 10) {
        buffer[len++] = '0';
    }

    /* Add negative sign if needed */
    if (negative) {
        buffer[len++] = '-';
    }

    /* Reverse the string */
    buffer[len] = '\0';
    for (i = 0; i < len / 2; i++) {
        char temp = buffer[i];
        buffer[i] = buffer[len - 1 - i];
        buffer[len - 1 - i] = temp;
    }

    /* Draw using text function */
    draw_text(buffer, x, y, 255);
}

/*

 * draw_speedometer (func_800C7818)
 * Size: 1724 bytes
 *
 * Draws the speedometer dial with needle showing current speed.
 * Speed in game units, converted to MPH for display.
 *
 * Speedometer layout:
 *   - Background dial at fixed position
 *   - Rotating needle based on speed
 *   - Digital readout below
 */

void draw_speedometer(f32 speed) {
    s32 speedMph;
    s32 needleAngle;
    s32 dialX, dialY;
    s32 digitalX, digitalY;

    /* Convert speed to MPH */
    speedMph = (s32)(speed * D_8015902C);
    if (speedMph < 0) speedMph = 0;
    if (speedMph > 200) speedMph = 200;

    /* Get dial position */
    dialX = D_80159024;
    dialY = D_80159028;

    /* Draw speedometer background */
    draw_ui_element(0, dialX, dialY, 16, 16, 255);  /* Element 0 = speedometer bg */

    /* Calculate needle angle (0-180 degrees mapped to 0-200 mph) */
    /* Needle rotates from 7 o'clock (0 mph) to 5 o'clock (200 mph) */
    needleAngle = (speedMph * 180) / 200;

    /* Draw needle (element varies by angle) */
    /* Needle sprites: elements 128-143 for 16 angle positions */
    s32 needleElement = 128 + (needleAngle / 12);  /* 180/16 = ~11.25 degrees per sprite */
    if (needleElement > 143) needleElement = 143;
    draw_ui_element(needleElement, dialX + 24, dialY + 24, 255, 0, 0);  /* Center of dial */

    /* Draw digital speed readout */
    digitalX = dialX + 12;
    digitalY = dialY + 50;
    draw_number(speedMph, 3, digitalX, digitalY);

    /* Draw "MPH" label */
    draw_text("MPH", digitalX + 30, digitalY, 255);
}

/*

 * draw_lap_counter (func_800C7ED4)
 * Size: 2540 bytes
 *
 * Displays current lap / total laps.
 * Shows "FINAL LAP" text when on last lap.
 */

void draw_lap_counter(s32 currentLap, s32 totalLaps) {
    s32 x, y;
    char lapText[16];

    x = D_80159030;
    y = D_80159034;

    /* Draw lap icon/background */
    draw_ui_element(2, x, y, 16, 16, 255);  /* Element 2 = lap indicator */

    /* Check for final lap */
    if (currentLap == totalLaps) {
        /* Flash "FINAL LAP" */
        draw_text("FINAL", x + 40, y, 255);
        draw_text("LAP", x + 40, y + 12, 255);
    } else {
        /* Show "LAP X/Y" */
        draw_text("LAP", x + 40, y, 255);

        /* Draw current lap number */
        draw_number(currentLap, 1, x + 40, y + 12);

        /* Draw separator */
        draw_text("/", x + 52, y + 12, 255);

        /* Draw total laps */
        draw_number(totalLaps, 1, x + 60, y + 12);
    }
}

/*

 * draw_position (func_800C8864)
 * Size: 188 bytes
 *
 * Shows race position (1st, 2nd, 3rd, etc.)
 */

void draw_position(s32 position) {
    s32 x, y;
    char *suffix;

    x = D_80159038;
    y = D_8015903C;

    /* Draw position background */
    draw_ui_element(3, x, y, 16, 16, 255);  /* Element 3 = position indicator */

    /* Draw position number */
    draw_number(position + 1, 1, x + 8, y + 4);  /* +1 because internal 0 = 1st place */

    /* Draw suffix (st, nd, rd, th) */
    switch (position) {
        case 0:
            suffix = "ST";
            break;
        case 1:
            suffix = "ND";
            break;
        case 2:
            suffix = "RD";
            break;
        default:
            suffix = "TH";
            break;
    }
    draw_text(suffix, x + 20, y + 4, 255);
}

/*

 * draw_timer (func_800C8920)
 * Size: 228 bytes
 *
 * Shows race time in MM:SS.ms format.
 * timeMs is in milliseconds.
 */

void draw_timer(s32 timeMs) {
    s32 x, y;
    s32 minutes, seconds, ms;
    char timeStr[16];

    x = D_80159040;
    y = D_80159044;

    /* Draw timer background */
    draw_ui_element(4, x, y, 16, 16, 255);  /* Element 4 = timer background */

    /* Convert milliseconds to M:SS.ms */
    if (timeMs < 0) timeMs = 0;

    minutes = timeMs / 60000;
    seconds = (timeMs / 1000) % 60;
    ms = (timeMs / 10) % 100;  /* Centiseconds */

    /* Clamp minutes */
    if (minutes > 99) minutes = 99;

    /* Draw minutes */
    draw_number(minutes, 1, x + 8, y + 4);

    /* Draw colon */
    draw_text(":", x + 16, y + 4, 255);

    /* Draw seconds (2 digits with leading zero) */
    draw_number(seconds, 2, x + 22, y + 4);

    /* Draw decimal point */
    draw_text(".", x + 38, y + 4, 255);

    /* Draw centiseconds */
    draw_number(ms, 2, x + 44, y + 4);
}

/*

 * draw_minimap (func_800C9404)
 * Size: 300 bytes
 *
 * Draws a minimap showing track outline and car positions.
 */

void draw_minimap(void *player) {
    s32 x, y;
    f32 *playerPos;
    f32 mapX, mapY;
    s32 dotX, dotY;

    x = D_80159048;
    y = D_8015904C;

    /* Draw minimap frame/background */
    draw_ui_element(6, x, y, 16, 16, 255);  /* Element 6 = minimap frame */

    if (player == NULL) {
        return;
    }

    /* Get player position */
    playerPos = (f32 *)((u8 *)player + 0x24);

    /* Convert world position to minimap coordinates */
    mapX = playerPos[0] * D_80159050;
    mapY = playerPos[2] * D_80159050;  /* Use Z for top-down view */

    /* Clamp to minimap bounds */
    dotX = x + 24 + (s32)mapX;
    dotY = y + 24 + (s32)mapY;

    if (dotX < x + 4) dotX = x + 4;
    if (dotX > x + 44) dotX = x + 44;
    if (dotY < y + 4) dotY = y + 4;
    if (dotY > y + 44) dotY = y + 44;

    /* Draw player dot (blinking) */
    draw_ui_element(144, dotX - 2, dotY - 2, 255, 0, 0);  /* Element 144 = player dot */
}

/*

 * func_800CA308 (172 bytes)
 * HUD message display
 *
 * Shows a centered message on screen (checkpoint, wrong way, etc.)
 *
 * Message IDs:
 *   0 = "CHECKPOINT!"
 *   1 = "WRONG WAY!"
 *   2 = "FINAL LAP!"
 *   3 = "GO!"
 *   4 = "READY"
 *   5 = "SET"
 *   6 = "FINISH!"
 *   7 = "NEW RECORD!"
 */
static char *hudMessages[] = {
    "CHECKPOINT!",
    "WRONG WAY!",
    "FINAL LAP!",
    "GO!",
    "READY",
    "SET",
    "FINISH!",
    "NEW RECORD!"
};

void draw_message(s32 messageId) {
    s32 x, y;
    char *message;
    s32 msgLen, charWidth;

    if (messageId < 0 || messageId > 7) {
        return;
    }

    message = hudMessages[messageId];

    /* Calculate message length for centering */
    msgLen = 0;
    while (message[msgLen] != '\0') {
        msgLen++;
    }

    /* Center horizontally */
    charWidth = D_8015901C;
    x = D_80159058 - (msgLen * charWidth) / 2;
    y = D_8015905C;

    /* Draw message */
    draw_text(message, x, y, 255);
}

/*

 * hud_render (func_800CADA4)
 * Size: 2468 bytes
 *
 * Main HUD rendering function - draws all HUD elements.
 * Called every frame during gameplay.
 */

void hud_render(void) {
    void *player;
    f32 *velocity;
    f32 speed;
    s32 currentLap, position;

    /* Check if HUD is enabled */
    if (D_80159060 == 0) {
        return;
    }

    /* Get player car */
    player = D_801582C0[0];
    if (player == NULL) {
        return;
    }

    /* Calculate speed from velocity */
    velocity = (f32 *)((u8 *)player + 0x34);
    speed = sqrtf(velocity[0] * velocity[0] + velocity[2] * velocity[2]);

    /* Get player lap and position */
    currentLap = *(s32 *)((u8 *)player + 0x58);
    position = *(s32 *)((u8 *)player + 0x5C);

    /* Draw speedometer */
    draw_speedometer(speed);

    /* Draw lap counter */
    draw_lap_counter(currentLap, D_801582E8);

    /* Draw position */
    draw_position(position);

    /* Draw timer */
    draw_timer(D_801582B0);

    /* Draw minimap */
    draw_minimap(player);

    /* Draw any active message */
    if (D_80159064 >= 0 && D_80159068 > 0) {
        draw_message(D_80159064);
        D_80159068--;

        if (D_80159068 <= 0) {
            D_80159064 = -1;  /* Clear message */
        }
    }
}

/*

 * menu_process_input (func_800CB748)
 * Size: 628 bytes
 * Handles controller input for menu navigation
 */
s32 menu_process_input(s32 input) {
    s32 result;
    s32 buttons;
    s32 stickX;
    s32 stickY;
    s32 repeatDelay;

    result = 0;
    buttons = input & 0xFFFF;
    stickX = (input >> 16) & 0xFF;
    stickY = (input >> 24) & 0xFF;

    /* Convert signed stick values */
    if (stickX > 127) {
        stickX = stickX - 256;
    }
    if (stickY > 127) {
        stickY = stickY - 256;
    }

    /* Check for A button - select */
    if (buttons & 0x8000) {
        if ((D_80159200 & 0x8000) == 0) {
            result = 1;  /* Select pressed */
            sound_play_menu(10);  /* Menu select sound */
        }
    }

    /* Check for B button - back */
    if (buttons & 0x4000) {
        if ((D_80159200 & 0x4000) == 0) {
            result = 2;  /* Back pressed */
            sound_play_menu(11);  /* Menu back sound */
        }
    }

    /* Check for Start button - pause/confirm */
    if (buttons & 0x1000) {
        if ((D_80159200 & 0x1000) == 0) {
            result = 3;  /* Start pressed */
        }
    }

    /* Check D-pad up or stick up */
    if ((buttons & 0x0800) || stickY > 50) {
        repeatDelay = D_80159204;
        if (repeatDelay == 0 || repeatDelay > 15) {
            result = 4;  /* Up */
            sound_play_menu(12);  /* Menu move sound */
            if (repeatDelay == 0) {
                D_80159204 = 1;
            }
        }
        if (repeatDelay > 0) {
            D_80159204 = repeatDelay + 1;
        }
    }
    /* Check D-pad down or stick down */
    else if ((buttons & 0x0400) || stickY < -50) {
        repeatDelay = D_80159204;
        if (repeatDelay == 0 || repeatDelay > 15) {
            result = 5;  /* Down */
            sound_play_menu(12);  /* Menu move sound */
            if (repeatDelay == 0) {
                D_80159204 = 1;
            }
        }
        if (repeatDelay > 0) {
            D_80159204 = repeatDelay + 1;
        }
    }
    else {
        D_80159204 = 0;  /* Reset repeat counter */
    }

    /* Check D-pad left or stick left */
    if ((buttons & 0x0200) || stickX < -50) {
        repeatDelay = D_80159208;
        if (repeatDelay == 0 || repeatDelay > 10) {
            result = 6;  /* Left */
            if (repeatDelay == 0) {
                D_80159208 = 1;
            }
        }
        if (repeatDelay > 0) {
            D_80159208 = repeatDelay + 1;
        }
    }
    /* Check D-pad right or stick right */
    else if ((buttons & 0x0100) || stickX > 50) {
        repeatDelay = D_80159208;
        if (repeatDelay == 0 || repeatDelay > 10) {
            result = 7;  /* Right */
            if (repeatDelay == 0) {
                D_80159208 = 1;
            }
        }
        if (repeatDelay > 0) {
            D_80159208 = repeatDelay + 1;
        }
    }
    else {
        D_80159208 = 0;  /* Reset repeat counter */
    }

    /* Check L trigger - page up */
    if (buttons & 0x0020) {
        if ((D_80159200 & 0x0020) == 0) {
            result = 8;  /* L trigger */
        }
    }

    /* Check R trigger - page down */
    if (buttons & 0x0010) {
        if ((D_80159200 & 0x0010) == 0) {
            result = 9;  /* R trigger */
        }
    }

    /* Store previous button state */
    D_80159200 = buttons;

    return result;
}

/*

 * menu_cursor_move (func_800CB9D0)
 * Size: 516 bytes
 * Navigates between menu items
 */
void menu_cursor_move(s32 direction) {
    s32 currentIndex;
    s32 newIndex;
    s32 itemCount;
    s32 *menuItems;
    s32 itemFlags;
    s32 wrapAround;
    s32 i;

    currentIndex = D_80159210;
    itemCount = D_80159214;
    menuItems = (s32 *)D_80159218;
    wrapAround = D_8015921C;

    if (itemCount <= 0) {
        return;
    }

    newIndex = currentIndex;

    /* Direction: 4=up, 5=down, 6=left, 7=right */
    if (direction == 4) {
        /* Move up */
        newIndex = currentIndex - 1;
        if (newIndex < 0) {
            if (wrapAround) {
                newIndex = itemCount - 1;
            } else {
                newIndex = 0;
            }
        }
        /* Skip disabled items */
        for (i = 0; i < itemCount; i++) {
            if (menuItems != NULL) {
                itemFlags = menuItems[newIndex * 4 + 3];  /* Flag offset in menu item struct */
                if ((itemFlags & 1) == 0) {
                    break;  /* Item is enabled */
                }
            } else {
                break;
            }
            newIndex = newIndex - 1;
            if (newIndex < 0) {
                if (wrapAround) {
                    newIndex = itemCount - 1;
                } else {
                    newIndex = currentIndex;
                    break;
                }
            }
        }
    }
    else if (direction == 5) {
        /* Move down */
        newIndex = currentIndex + 1;
        if (newIndex >= itemCount) {
            if (wrapAround) {
                newIndex = 0;
            } else {
                newIndex = itemCount - 1;
            }
        }
        /* Skip disabled items */
        for (i = 0; i < itemCount; i++) {
            if (menuItems != NULL) {
                itemFlags = menuItems[newIndex * 4 + 3];
                if ((itemFlags & 1) == 0) {
                    break;
                }
            } else {
                break;
            }
            newIndex = newIndex + 1;
            if (newIndex >= itemCount) {
                if (wrapAround) {
                    newIndex = 0;
                } else {
                    newIndex = currentIndex;
                    break;
                }
            }
        }
    }
    else if (direction == 6 || direction == 7) {
        /* Left/right handled by individual items (sliders, etc.) */
        /* Pass to item handler */
        if (menuItems != NULL) {
            s32 itemType;
            itemType = menuItems[currentIndex * 4 + 2];  /* Type offset */
            if (itemType == 2) {  /* Slider type */
                /* Slider adjusts via func_800CCE5C */
                s32 value;
                s32 minVal;
                s32 maxVal;
                value = menuItems[currentIndex * 4 + 1];  /* Current value */
                minVal = 0;
                maxVal = 100;
                if (direction == 6) {
                    value = value - 5;
                } else {
                    value = value + 5;
                }
                menuItems[currentIndex * 4 + 1] = func_800CCE5C(value, minVal, maxVal);
            }
        }
        return;  /* No cursor movement */
    }

    if (newIndex != currentIndex) {
        /* Update highlight */
        func_800CC8C8(newIndex);
        D_80159210 = newIndex;
    }
}

/*

 * menu_item_select (func_800CBBD4)
 * Size: 564 bytes
 * Handles selection action for current menu item
 */
void menu_item_select(s32 itemIndex) {
    s32 *menuItems;
    s32 itemType;
    s32 itemAction;
    s32 itemValue;
    s32 itemFlags;
    s32 targetMenu;
    void (*callback)(s32);

    menuItems = (s32 *)D_80159218;
    if (menuItems == NULL) {
        return;
    }

    if (itemIndex < 0 || itemIndex >= D_80159214) {
        return;
    }

    /* Get item properties */
    itemAction = menuItems[itemIndex * 4];      /* Action ID */
    itemValue = menuItems[itemIndex * 4 + 1];   /* Current value */
    itemType = menuItems[itemIndex * 4 + 2];    /* Type */
    itemFlags = menuItems[itemIndex * 4 + 3];   /* Flags */

    /* Check if item is disabled */
    if (itemFlags & 1) {
        sound_play_menu(13);  /* Error sound */
        return;
    }

    /* Handle by item type */
    switch (itemType) {
        case 0:  /* Action button */
            /* Execute action */
            switch (itemAction) {
                case 1:  /* Start race */
                    D_801146EC = 3;  /* PREPLAY state */
                    menu_transition(-1);  /* Close menu */
                    break;
                case 2:  /* Options */
                    menu_transition(2);  /* Go to options menu */
                    break;
                case 3:  /* Track select */
                    menu_transition(3);  /* Go to track select */
                    break;
                case 4:  /* Car select */
                    menu_transition(4);  /* Go to car select */
                    break;
                case 5:  /* Exit */
                    D_801146EC = 0;  /* ATTRACT state */
                    menu_transition(-1);
                    break;
                case 6:  /* Controller Pak */
                    menu_transition(5);  /* Go to save menu */
                    break;
                case 7:  /* Sound test */
                    menu_transition(6);
                    break;
                case 8:  /* Credits */
                    menu_transition(7);
                    break;
                default:
                    break;
            }
            break;

        case 1:  /* Toggle */
            /* Flip value */
            itemValue = (itemValue == 0) ? 1 : 0;
            menuItems[itemIndex * 4 + 1] = itemValue;
            sound_play_menu(14);  /* Toggle sound */
            /* Apply setting immediately */
            if (itemAction == 10) {  /* Music toggle */
                D_80159300 = itemValue;
            } else if (itemAction == 11) {  /* SFX toggle */
                D_80159304 = itemValue;
            } else if (itemAction == 12) {  /* Vibration */
                D_80159308 = itemValue;
            } else if (itemAction == 13) {  /* Widescreen */
                D_8015930C = itemValue;
            }
            break;

        case 2:  /* Slider - handled by left/right */
            /* A button on slider doesn't do anything special */
            break;

        case 3:  /* Submenu */
            targetMenu = itemAction;
            menu_transition(targetMenu);
            break;

        case 4:  /* Multi-choice */
            /* Cycle through options */
            itemValue = itemValue + 1;
            if (itemValue > itemFlags >> 8) {  /* Max stored in upper flags */
                itemValue = 0;
            }
            menuItems[itemIndex * 4 + 1] = itemValue;
            sound_play_menu(14);
            break;

        case 5:  /* Callback */
            /* Call function pointer stored in value */
            callback = (void (*)(s32))itemValue;
            if (callback != NULL) {
                callback(itemIndex);
            }
            break;
    }
}

/*

 * menu_back (func_800CBE08)
 * Size: 132 bytes
 * Returns to previous menu in stack
 */
void menu_back(void) {
    s32 prevMenu;
    s32 stackDepth;

    stackDepth = D_80159220;
    if (stackDepth <= 0) {
        /* At root menu, back returns to game */
        D_80159230 = 0;  /* Hide menu */
        return;
    }

    /* Pop menu from stack */
    stackDepth = stackDepth - 1;
    D_80159220 = stackDepth;

    /* Get previous menu ID */
    prevMenu = D_80159224[stackDepth];

    /* Transition to previous menu */
    menu_transition(prevMenu);
    sound_play_menu(11);  /* Back sound */
}

/*

 * menu_transition (func_800CBE8C)
 * Size: 340 bytes
 * Switches to a new menu with animation
 */
void menu_transition(s32 toMenuId) {
    s32 currentMenu;
    s32 stackDepth;

    currentMenu = D_80159234;

    /* Special case: close menu */
    if (toMenuId < 0) {
        D_80159230 = 0;  /* Hide menu */
        D_80159238 = 1;  /* Transition state: closing */
        D_8015923C = 0;  /* Animation frame */
        D_80159220 = 0;  /* Clear stack */
        return;
    }

    /* Push current menu to stack if navigating forward */
    if (toMenuId != currentMenu && currentMenu >= 0) {
        stackDepth = D_80159220;
        if (stackDepth < 8) {  /* Max stack depth */
            D_80159224[stackDepth] = currentMenu;
            D_80159220 = stackDepth + 1;
        }
    }

    /* Start transition animation */
    D_80159238 = 2;  /* Transition state: switching */
    D_8015923C = 0;  /* Animation frame */
    D_80159240 = toMenuId;  /* Target menu */

    /* Load menu data */
    switch (toMenuId) {
        case 0:  /* Main menu */
            D_80159218 = (u32)&D_80159400;  /* Main menu items */
            D_80159214 = 5;  /* Item count */
            break;
        case 1:  /* Pause menu */
            D_80159218 = (u32)&D_80159480;  /* Pause menu items */
            D_80159214 = 4;
            break;
        case 2:  /* Options menu */
            D_80159218 = (u32)&D_80159500;  /* Options items */
            D_80159214 = 8;
            break;
        case 3:  /* Track select */
            D_80159218 = (u32)&D_80159600;  /* Track items */
            D_80159214 = 8;
            break;
        case 4:  /* Car select */
            D_80159218 = (u32)&D_80159700;  /* Car items */
            D_80159214 = 12;
            break;
        case 5:  /* Save/load menu */
            D_80159218 = (u32)&D_80159800;
            D_80159214 = 4;
            break;
        default:
            D_80159218 = 0;
            D_80159214 = 0;
            break;
    }

    /* Reset cursor */
    D_80159210 = 0;
    D_80159234 = toMenuId;
}

/*

 * menu_animation_update (func_800CC040)
 * Size: 900 bytes
 * Handles menu transitions and element animations
 */
void menu_animation_update(void) {
    s32 transitionState;
    s32 animFrame;
    s32 targetFrame;
    f32 t;
    f32 easedT;
    s32 i;
    s32 *menuItems;
    s32 itemCount;
    f32 itemY;
    f32 targetY;
    f32 highlightX;
    f32 highlightWidth;

    transitionState = D_80159238;
    animFrame = D_8015923C;

    /* No animation needed */
    if (transitionState == 0) {
        return;
    }

    animFrame = animFrame + 1;
    D_8015923C = animFrame;

    /* Transition: closing */
    if (transitionState == 1) {
        targetFrame = 15;
        if (animFrame >= targetFrame) {
            D_80159238 = 0;
            D_8015923C = 0;
            return;
        }
        /* Slide out animation */
        t = (f32)animFrame / (f32)targetFrame;
        easedT = t * t;  /* Ease in (accelerate) */
        D_80159244 = (s32)(320.0f * easedT);  /* X offset slides right */
        D_80159248 = (s32)(255.0f * (1.0f - t));  /* Fade out */
    }
    /* Transition: switching */
    else if (transitionState == 2) {
        targetFrame = 20;
        if (animFrame >= targetFrame) {
            D_80159238 = 0;
            D_8015923C = 0;
            D_80159244 = 0;
            D_80159248 = 255;
            return;
        }
        /* Two-phase: slide out then slide in */
        if (animFrame < 10) {
            /* Phase 1: slide out */
            t = (f32)animFrame / 10.0f;
            easedT = t * t;
            D_80159244 = (s32)(-320.0f * easedT);  /* Slide left */
            D_80159248 = (s32)(255.0f * (1.0f - t * 0.5f));
        } else {
            /* Phase 2: slide in */
            t = (f32)(animFrame - 10) / 10.0f;
            easedT = 1.0f - (1.0f - t) * (1.0f - t);  /* Ease out */
            D_80159244 = (s32)(320.0f * (1.0f - easedT));  /* Slide from right */
            D_80159248 = (s32)(128.0f + 127.0f * easedT);
        }
    }
    /* Transition: opening */
    else if (transitionState == 3) {
        targetFrame = 15;
        if (animFrame >= targetFrame) {
            D_80159238 = 0;
            D_8015923C = 0;
            D_80159244 = 0;
            D_80159248 = 255;
            D_80159230 = 1;  /* Menu now visible */
            return;
        }
        t = (f32)animFrame / (f32)targetFrame;
        easedT = 1.0f - (1.0f - t) * (1.0f - t);  /* Ease out */
        D_80159244 = (s32)(-320.0f * (1.0f - easedT));  /* Slide from left */
        D_80159248 = (s32)(255.0f * easedT);
    }

    /* Animate menu items (staggered entry) */
    menuItems = (s32 *)D_80159218;
    itemCount = D_80159214;
    if (menuItems != NULL && transitionState != 1) {
        for (i = 0; i < itemCount; i++) {
            /* Calculate staggered delay */
            s32 itemDelay;
            s32 itemFrame;
            itemDelay = i * 2;
            itemFrame = animFrame - itemDelay;
            if (itemFrame < 0) {
                itemFrame = 0;
            }
            if (itemFrame > 10) {
                itemFrame = 10;
            }
            /* Store per-item animation state */
            t = (f32)itemFrame / 10.0f;
            easedT = 1.0f - (1.0f - t) * (1.0f - t);
            /* Item Y positions stored in global array */
            D_8015924C[i] = (s32)(255.0f * easedT);  /* Per-item alpha */
        }
    }

    /* Animate highlight bar */
    highlightX = D_80159260;
    targetY = (f32)(D_80159210 * 24 + 80);  /* 24px per item, 80px top offset */
    if (D_80159264 != targetY) {
        f32 diff;
        diff = targetY - D_80159264;
        if (diff > 0) {
            if (diff > 8.0f) diff = 8.0f;
        } else {
            if (diff < -8.0f) diff = -8.0f;
        }
        D_80159264 = D_80159264 + diff;
    }
    /* Pulse highlight width */
    D_80159268 = 150.0f + 10.0f * sinf((f32)D_80159270 * 0.1f);
    D_80159270 = D_80159270 + 1;
}

/*

 * sound_play_menu (func_800CC3C0)
 * Size: 380 bytes
 * Plays menu sound effects
 */
void sound_play_menu(s32 soundId) {
    s32 actualSoundId;
    s32 volume;
    s32 pitch;
    u32 handle;

    /* Check if SFX enabled */
    if (D_80159304 == 0) {
        return;
    }

    /* Map menu sound ID to actual sound bank ID */
    volume = 100;  /* Default volume */
    pitch = 0x1000;  /* Normal pitch */

    switch (soundId) {
        case 10:  /* Select/confirm */
            actualSoundId = 200;
            volume = 110;
            break;
        case 11:  /* Back/cancel */
            actualSoundId = 201;
            break;
        case 12:  /* Cursor move */
            actualSoundId = 202;
            volume = 80;
            break;
        case 13:  /* Error/disabled */
            actualSoundId = 203;
            pitch = 0x0C00;  /* Lower pitch */
            break;
        case 14:  /* Toggle */
            actualSoundId = 204;
            break;
        case 15:  /* Slider tick */
            actualSoundId = 205;
            volume = 60;
            break;
        case 16:  /* Dialog open */
            actualSoundId = 206;
            volume = 90;
            break;
        case 17:  /* Dialog close */
            actualSoundId = 207;
            volume = 90;
            break;
        case 18:  /* Menu open */
            actualSoundId = 208;
            volume = 100;
            break;
        case 19:  /* Menu close */
            actualSoundId = 209;
            volume = 100;
            break;
        case 20:  /* Countdown beep */
            actualSoundId = 210;
            volume = 127;
            break;
        case 21:  /* Countdown go */
            actualSoundId = 211;
            volume = 127;
            pitch = 0x1400;
            break;
        default:
            /* Play raw sound ID */
            actualSoundId = soundId;
            break;
    }

    /* Play via audio system */
    handle = func_80090284(actualSoundId, 0);
    if (handle != 0) {
        sound_update_channel(handle, volume);
        if (pitch != 0x1000) {
            func_800B3FA4(handle, pitch, 0.0f);
        }
    }
}

/*

 * menu_text_scroll (func_800CC540)
 * Size: 904 bytes
 * Scrolls long text horizontally
 */
void menu_text_scroll(char *text, s32 maxWidth) {
    s32 textLen;
    s32 textWidth;
    s32 charWidth;
    s32 scrollOffset;
    s32 scrollSpeed;
    s32 scrollDelay;
    s32 scrollState;
    s32 visibleChars;
    char *src;
    char *dst;
    s32 i;
    s32 pauseFrames;

    if (text == NULL) {
        return;
    }

    /* Calculate text length */
    textLen = 0;
    src = text;
    while (*src != '\0') {
        textLen++;
        src++;
    }

    /* Assume 8 pixels per character */
    charWidth = 8;
    textWidth = textLen * charWidth;
    visibleChars = maxWidth / charWidth;

    /* Get current scroll state for this text */
    scrollState = D_80159280;
    scrollOffset = D_80159284;
    scrollDelay = D_80159288;
    pauseFrames = D_8015928C;

    /* If text fits, no scrolling needed */
    if (textWidth <= maxWidth) {
        /* Just render the text as-is */
        D_80159290 = 0;  /* No scroll offset */
        D_80159280 = 0;
        return;
    }

    /* State machine for text scrolling */
    switch (scrollState) {
        case 0:  /* Idle/initial pause */
            pauseFrames++;
            if (pauseFrames > 60) {  /* 1 second at 60fps */
                scrollState = 1;
                pauseFrames = 0;
            }
            break;

        case 1:  /* Scrolling left */
            scrollDelay++;
            if (scrollDelay >= 3) {  /* Scroll every 3 frames */
                scrollDelay = 0;
                scrollOffset++;
                if (scrollOffset >= (textLen - visibleChars + 3)) {
                    scrollState = 2;
                    pauseFrames = 0;
                }
            }
            break;

        case 2:  /* End pause */
            pauseFrames++;
            if (pauseFrames > 45) {  /* 0.75 second pause */
                scrollState = 3;
                pauseFrames = 0;
            }
            break;

        case 3:  /* Scrolling back (fast) */
            scrollDelay++;
            if (scrollDelay >= 1) {  /* Scroll every frame */
                scrollDelay = 0;
                scrollOffset = scrollOffset - 2;
                if (scrollOffset <= 0) {
                    scrollOffset = 0;
                    scrollState = 0;
                    pauseFrames = 0;
                }
            }
            break;
    }

    /* Store state */
    D_80159280 = scrollState;
    D_80159284 = scrollOffset;
    D_80159288 = scrollDelay;
    D_8015928C = pauseFrames;
    D_80159290 = scrollOffset * charWidth;  /* Pixel offset for rendering */

    /* Copy visible portion to render buffer */
    dst = (char *)D_80159294;
    src = text + scrollOffset;
    for (i = 0; i < visibleChars && *src != '\0'; i++) {
        *dst = *src;
        dst++;
        src++;
    }
    *dst = '\0';
}

/*

 * menu_highlight_set (func_800CC8C8)
 * Size: 316 bytes
 * Sets highlight state for menu item
 */
void menu_highlight_set(s32 itemIndex) {
    s32 prevIndex;
    s32 itemCount;
    s32 targetY;
    f32 startY;

    prevIndex = D_80159210;
    itemCount = D_80159214;

    /* Bounds check */
    if (itemIndex < 0 || itemIndex >= itemCount) {
        return;
    }

    /* Clear previous highlight animation state */
    if (prevIndex >= 0 && prevIndex < 16) {
        D_801592A0[prevIndex] = 0;  /* Reset highlight pulse */
    }

    /* Set new highlight */
    if (itemIndex >= 0 && itemIndex < 16) {
        D_801592A0[itemIndex] = 1;  /* Start highlight animation */
    }

    /* Calculate target Y position for highlight bar */
    targetY = itemIndex * 24 + 80;  /* 24 pixels per item, 80 top offset */

    /* If jumping multiple items, start smooth transition */
    startY = D_80159264;
    if (startY == 0.0f) {
        /* First time, snap to position */
        D_80159264 = (f32)targetY;
    }
    /* Otherwise animation update will smooth it */

    /* Store target for animation */
    D_801592C0 = targetY;

    /* Reset highlight pulse phase */
    D_80159270 = 0;

    /* Reset text scroll state for new item */
    D_80159280 = 0;
    D_80159284 = 0;
    D_80159288 = 0;
    D_8015928C = 0;
}

/*

 * menu_list_render (func_800CCA04)
 * Size: 1112 bytes
 * Renders entire menu with items
 */
void menu_list_render(void *list, s32 count) {
    s32 i;
    s32 *items;
    s32 itemAction;
    s32 itemValue;
    s32 itemType;
    s32 itemFlags;
    s32 x, y;
    s32 baseX, baseY;
    s32 itemAlpha;
    s32 highlightAlpha;
    s32 offsetX;
    s32 globalAlpha;
    char *labelPtr;
    char valueBuf[32];
    s32 isHighlighted;
    s32 isDisabled;
    f32 highlightY;
    s32 sliderWidth;
    s32 sliderFill;

    if (list == NULL || count <= 0) {
        return;
    }

    items = (s32 *)list;
    baseX = 85 + D_80159244;  /* Base X with transition offset */
    baseY = 80;
    globalAlpha = D_80159248;
    highlightY = D_80159264;

    /* Draw highlight bar first (behind items) */
    if (D_80159210 >= 0) {
        highlightAlpha = (globalAlpha * 180) / 255;
        /* func_800C7110 draws HUD elements */
        /* Draw stretched highlight sprite at position */
        x = baseX - 5;
        y = (s32)highlightY - 2;
        draw_ui_element(50, x, y, 16, 16, highlightAlpha);
    }

    /* Draw each menu item */
    for (i = 0; i < count; i++) {
        itemAction = items[i * 4];
        itemValue = items[i * 4 + 1];
        itemType = items[i * 4 + 2];
        itemFlags = items[i * 4 + 3];

        x = baseX;
        y = baseY + i * 24;

        isHighlighted = (i == D_80159210);
        isDisabled = (itemFlags & 1);

        /* Get per-item alpha from animation */
        if (i < 16) {
            itemAlpha = D_8015924C[i];
        } else {
            itemAlpha = 255;
        }
        itemAlpha = (itemAlpha * globalAlpha) / 255;

        /* Dim disabled items */
        if (isDisabled) {
            itemAlpha = itemAlpha / 2;
        }

        /* Get label text pointer (stored after main data) */
        labelPtr = (char *)(items + count * 4 + i * 16);

        /* Draw item based on type */
        switch (itemType) {
            case 0:  /* Action button */
            case 3:  /* Submenu link */
                /* Just draw the label */
                draw_text(labelPtr, x, y, itemAlpha);
                /* Draw arrow for submenu */
                if (itemType == 3) {
                    draw_ui_element(51, x + 140, y + 4, 8, 8, itemAlpha);  /* Arrow icon */
                }
                break;

            case 1:  /* Toggle */
                /* Draw label */
                draw_text(labelPtr, x, y, itemAlpha);
                /* Draw on/off indicator */
                if (itemValue) {
                    draw_text("ON", x + 120, y, itemAlpha);
                } else {
                    draw_text("OFF", x + 120, y, itemAlpha);
                }
                break;

            case 2:  /* Slider */
                /* Draw label */
                draw_text(labelPtr, x, y, itemAlpha);
                /* Draw slider bar background */
                sliderWidth = 80;
                draw_ui_element(52, x + 70, y + 6, sliderWidth, 8, itemAlpha / 2);  /* Slider bg */
                /* Draw slider fill */
                sliderFill = (itemValue * sliderWidth) / 100;
                draw_ui_element(53, x + 70, y + 6, sliderFill, 8, itemAlpha);  /* Slider fill */
                /* Draw value */
                valueBuf[0] = '0' + (itemValue / 100);
                valueBuf[1] = '0' + ((itemValue / 10) % 10);
                valueBuf[2] = '0' + (itemValue % 10);
                valueBuf[3] = '\0';
                draw_text(valueBuf, x + 155, y, itemAlpha);
                break;

            case 4:  /* Multi-choice */
                /* Draw label */
                draw_text(labelPtr, x, y, itemAlpha);
                /* Draw current choice (stored in extra data area) */
                {
                    char *choices;
                    s32 choiceOffset;
                    choices = (char *)(items + count * 4 + count * 16 + i * 64);
                    choiceOffset = itemValue * 16;  /* 16 chars per choice */
                    draw_text(choices + choiceOffset, x + 100, y, itemAlpha);
                    /* Draw arrows if highlighted */
                    if (isHighlighted) {
                        draw_ui_element(54, x + 90, y + 4, 8, 8, itemAlpha);   /* Left arrow */
                        draw_ui_element(55, x + 170, y + 4, 8, 8, itemAlpha);  /* Right arrow */
                    }
                }
                break;

            case 5:  /* Callback/special */
                /* Draw label only */
                draw_text(labelPtr, x, y, itemAlpha);
                break;
        }

        /* Draw selection indicator for highlighted item */
        if (isHighlighted && !isDisabled) {
            /* Pulsing cursor */
            s32 cursorAlpha;
            cursorAlpha = 200 + (s32)(55.0f * sinf((f32)D_80159270 * 0.15f));
            draw_ui_element(56, x - 20, y + 2, 12, 12, cursorAlpha);  /* Cursor icon */
        }
    }
}

/*

 * func_800CCE5C (716 bytes)
 * Menu slider control - handles slider value adjustment
 */
s32 func_800CCE5C(s32 current, s32 min, s32 max) {
    s32 value;
    s32 range;
    s32 step;
    s32 snapValue;
    s32 prevValue;

    value = current;
    prevValue = current;

    /* Clamp to range */
    if (value < min) {
        value = min;
    }
    if (value > max) {
        value = max;
    }

    /* Calculate step size based on range */
    range = max - min;
    if (range <= 10) {
        step = 1;
    } else if (range <= 50) {
        step = 5;
    } else if (range <= 100) {
        step = 5;
    } else {
        step = 10;
    }

    /* Snap to step increments */
    snapValue = ((value - min + step / 2) / step) * step + min;
    if (snapValue > max) {
        snapValue = max;
    }
    if (snapValue < min) {
        snapValue = min;
    }

    /* Play tick sound if value changed */
    if (snapValue != prevValue) {
        sound_play_menu(15);  /* Slider tick sound */
    }

    /* Store for visual feedback */
    D_801592D0 = snapValue;
    D_801592D4 = min;
    D_801592D8 = max;

    /* Calculate fill percentage for rendering */
    if (range > 0) {
        D_801592DC = ((snapValue - min) * 100) / range;
    } else {
        D_801592DC = 0;
    }

    return snapValue;
}

/*

 * menu_dialog_display (func_800CD104)
 * Size: 1088 bytes
 * Shows modal dialog box
 */
void menu_dialog_display(s32 dialogId) {
    s32 dialogX, dialogY;
    s32 dialogW, dialogH;
    s32 titleY, messageY;
    s32 buttonY;
    s32 alpha;
    s32 animFrame;
    f32 scale;
    char *title;
    char *message;
    char *button1;
    char *button2;
    s32 buttonCount;
    s32 selectedButton;

    /* Check if dialog is active */
    if (D_801592E0 == 0) {
        return;
    }

    animFrame = D_801592E4;
    selectedButton = D_801592E8;

    /* Dialog dimensions */
    dialogW = 200;
    dialogH = 120;
    dialogX = (320 - dialogW) / 2;
    dialogY = (240 - dialogH) / 2;

    /* Animation: scale in */
    if (animFrame < 10) {
        scale = (f32)animFrame / 10.0f;
        scale = 1.0f - (1.0f - scale) * (1.0f - scale);  /* Ease out */
        dialogW = (s32)((f32)dialogW * scale);
        dialogH = (s32)((f32)dialogH * scale);
        dialogX = (320 - dialogW) / 2;
        dialogY = (240 - dialogH) / 2;
        alpha = (s32)(255.0f * scale);
    } else {
        alpha = 255;
    }

    /* Get dialog content based on ID */
    switch (dialogId) {
        case 0:  /* Generic confirm */
            title = "CONFIRM";
            message = "Are you sure?";
            button1 = "YES";
            button2 = "NO";
            buttonCount = 2;
            break;
        case 1:  /* Save game */
            title = "SAVE GAME";
            message = "Save progress to\nController Pak?";
            button1 = "SAVE";
            button2 = "CANCEL";
            buttonCount = 2;
            break;
        case 2:  /* Load game */
            title = "LOAD GAME";
            message = "Load saved data?";
            button1 = "LOAD";
            button2 = "CANCEL";
            buttonCount = 2;
            break;
        case 3:  /* Delete save */
            title = "DELETE";
            message = "Delete this save?\nThis cannot be undone.";
            button1 = "DELETE";
            button2 = "CANCEL";
            buttonCount = 2;
            break;
        case 4:  /* No Controller Pak */
            title = "ERROR";
            message = "No Controller Pak\nfound.";
            button1 = "OK";
            button2 = NULL;
            buttonCount = 1;
            break;
        case 5:  /* Pak full */
            title = "ERROR";
            message = "Controller Pak is\nfull.";
            button1 = "OK";
            button2 = NULL;
            buttonCount = 1;
            break;
        case 6:  /* Quit race */
            title = "QUIT RACE";
            message = "Quit current race?";
            button1 = "QUIT";
            button2 = "RESUME";
            buttonCount = 2;
            break;
        case 7:  /* Restart race */
            title = "RESTART";
            message = "Restart this race?";
            button1 = "RESTART";
            button2 = "CANCEL";
            buttonCount = 2;
            break;
        default:
            title = "DIALOG";
            message = "";
            button1 = "OK";
            button2 = NULL;
            buttonCount = 1;
            break;
    }

    /* Draw dialog background */
    /* Dark overlay behind dialog */
    draw_ui_element(57, 0, 0, 320, 240, alpha / 2);  /* Screen darken */

    /* Dialog box */
    draw_ui_element(58, dialogX, dialogY, dialogW, dialogH, alpha);  /* Dialog bg */

    /* Draw border */
    draw_ui_element(59, dialogX, dialogY, dialogW, 3, alpha);  /* Top border */
    draw_ui_element(59, dialogX, dialogY + dialogH - 3, dialogW, 3, alpha);  /* Bottom */
    draw_ui_element(59, dialogX, dialogY, 3, dialogH, alpha);  /* Left */
    draw_ui_element(59, dialogX + dialogW - 3, dialogY, 3, dialogH, alpha);  /* Right */

    /* Skip text rendering during scale animation */
    if (animFrame < 10) {
        D_801592E4 = animFrame + 1;
        return;
    }

    /* Draw title */
    titleY = dialogY + 10;
    draw_text(title, dialogX + 10, titleY, alpha);

    /* Draw message */
    messageY = dialogY + 35;
    draw_text(message, dialogX + 10, messageY, alpha);

    /* Draw buttons */
    buttonY = dialogY + dialogH - 30;
    if (buttonCount == 1) {
        /* Single centered button */
        s32 btnX = dialogX + dialogW / 2 - 20;
        s32 btnAlpha = (selectedButton == 0) ? alpha : alpha * 2 / 3;
        if (selectedButton == 0) {
            draw_ui_element(60, btnX - 5, buttonY - 2, 50, 20, alpha);  /* Highlight */
        }
        draw_text(button1, btnX, buttonY, btnAlpha);
    } else {
        /* Two buttons */
        s32 btn1X = dialogX + 30;
        s32 btn2X = dialogX + dialogW - 70;
        s32 btn1Alpha = (selectedButton == 0) ? alpha : alpha * 2 / 3;
        s32 btn2Alpha = (selectedButton == 1) ? alpha : alpha * 2 / 3;
        if (selectedButton == 0) {
            draw_ui_element(60, btn1X - 5, buttonY - 2, 50, 20, alpha);
        } else {
            draw_ui_element(60, btn2X - 5, buttonY - 2, 50, 20, alpha);
        }
        draw_text(button1, btn1X, buttonY, btn1Alpha);
        draw_text(button2, btn2X, buttonY, btn2Alpha);
    }

    D_801592E4 = animFrame + 1;
}

/*

 * func_800CD544 (412 bytes)
 * Menu confirm dialog - shows confirmation and handles input
 */
s32 func_800CD544(char *message) {
    s32 result;
    s32 input;
    s32 buttonAction;
    s32 selectedButton;
    s32 buttonCount;

    result = -1;  /* -1 = still waiting, 0 = no, 1 = yes */

    /* Check if dialog is not yet open */
    if (D_801592E0 == 0) {
        /* Open dialog */
        D_801592E0 = 1;
        D_801592EC = (u32)message;  /* Store custom message pointer */
        D_801592E4 = 0;  /* Reset animation */
        D_801592E8 = 0;  /* Default to first button (YES) */
        D_801592F0 = 2;  /* Two buttons */
        sound_play_menu(16);  /* Dialog open sound */
        return result;
    }

    /* Wait for animation to complete */
    if (D_801592E4 < 10) {
        return result;
    }

    selectedButton = D_801592E8;
    buttonCount = D_801592F0;

    /* Handle input */
    input = func_800CB748(D_80158100);

    /* Left/right to switch buttons */
    if (input == 6) {  /* Left */
        if (selectedButton > 0) {
            selectedButton--;
            D_801592E8 = selectedButton;
            sound_play_menu(12);
        }
    }
    else if (input == 7) {  /* Right */
        if (selectedButton < buttonCount - 1) {
            selectedButton++;
            D_801592E8 = selectedButton;
            sound_play_menu(12);
        }
    }
    /* A button to confirm */
    else if (input == 1) {
        result = (selectedButton == 0) ? 1 : 0;
        menu_dialog_close();  /* Close dialog */
    }
    /* B button to cancel */
    else if (input == 2) {
        result = 0;
        menu_dialog_close();
    }

    return result;
}

/*

 * menu_dialog_close (func_800CD6E0)
 * Size: 184 bytes
 * Closes active dialog with animation
 */
void menu_dialog_close(void) {
    /* Start close animation */
    D_801592F4 = 1;  /* Closing state */
    D_801592F8 = 0;  /* Animation frame */
    sound_play_menu(17);  /* Dialog close sound */

    /* Actually close after short delay */
    D_801592E0 = 0;  /* Dialog inactive */
    D_801592EC = 0;  /* Clear message pointer */
    D_801592E8 = 0;  /* Reset selection */
    D_801592F0 = 0;  /* Reset button count */

    /* Return focus to menu */
    D_801592FC = 1;  /* Flag that dialog just closed */
}

/*

 * keyboard_init (func_800CD798)
 * Size: 340 bytes
 * Initializes on-screen keyboard for text entry
 */
void keyboard_init(void) {
    s32 i;

    /* Keyboard layout - 6x7 grid */
    /* Row 0: A B C D E F G */
    /* Row 1: H I J K L M N */
    /* Row 2: O P Q R S T U */
    /* Row 3: V W X Y Z . _ */
    /* Row 4: 0 1 2 3 4 5 6 */
    /* Row 5: 7 8 9 SPACE BACK OK */

    D_80159900 = 0;  /* Current column */
    D_80159904 = 0;  /* Current row */
    D_80159908 = 6;  /* Columns per row */
    D_8015990C = 6;  /* Number of rows */
    D_80159910 = 0;  /* Keyboard visible */
    D_80159914 = 0;  /* Current cursor position in text buffer */
    D_80159918 = 0;  /* Animation frame */

    /* Clear preview buffer */
    for (i = 0; i < 16; i++) {
        D_8015991C[i] = '\0';
    }

    /* Set keyboard character map */
    D_80159940 = (u32)"ABCDEFG";
    D_80159944 = (u32)"HIJKLMN";
    D_80159948 = (u32)"OPQRSTU";
    D_8015994C = (u32)"VWXYZ._";
    D_80159950 = (u32)"0123456";
    D_80159954 = (u32)"789 <OK";
}

/*

 * keyboard_input_process (func_800CD8EC)
 * Size: 500 bytes
 * Handles navigation and character selection
 */
char keyboard_input_process(s32 input) {
    s32 col, row;
    s32 maxCol, maxRow;
    char selectedChar;
    char *rowStr;

    col = D_80159900;
    row = D_80159904;
    maxCol = D_80159908;
    maxRow = D_8015990C;
    selectedChar = '\0';

    /* Handle directional input */
    switch (input) {
        case 4:  /* Up */
            row = row - 1;
            if (row < 0) {
                row = maxRow - 1;
            }
            sound_play_menu(12);
            break;

        case 5:  /* Down */
            row = row + 1;
            if (row >= maxRow) {
                row = 0;
            }
            sound_play_menu(12);
            break;

        case 6:  /* Left */
            col = col - 1;
            if (col < 0) {
                col = maxCol - 1;
            }
            sound_play_menu(12);
            break;

        case 7:  /* Right */
            col = col + 1;
            if (col >= maxCol) {
                col = 0;
            }
            sound_play_menu(12);
            break;

        case 1:  /* A button - select character */
            /* Get character at current position */
            switch (row) {
                case 0: rowStr = (char *)D_80159940; break;
                case 1: rowStr = (char *)D_80159944; break;
                case 2: rowStr = (char *)D_80159948; break;
                case 3: rowStr = (char *)D_8015994C; break;
                case 4: rowStr = (char *)D_80159950; break;
                case 5: rowStr = (char *)D_80159954; break;
                default: rowStr = NULL; break;
            }
            if (rowStr != NULL && col < 7) {
                selectedChar = rowStr[col];
                /* Handle special characters */
                if (selectedChar == '<') {
                    selectedChar = '\b';  /* Backspace */
                } else if (selectedChar == ' ' && row == 5 && col == 3) {
                    selectedChar = ' ';  /* Space */
                } else if (row == 5 && col >= 5) {
                    selectedChar = '\n';  /* OK/Enter */
                }
                sound_play_menu(10);  /* Select sound */
            }
            break;

        case 2:  /* B button - backspace */
            selectedChar = '\b';
            sound_play_menu(11);
            break;
    }

    D_80159900 = col;
    D_80159904 = row;

    return selectedChar;
}

/*

 * func_800CDAE0 (460 bytes)
 * Menu text input - handles full text entry with on-screen keyboard
 */
void func_800CDAE0(char *buffer, s32 maxLen) {
    s32 input;
    char c;
    s32 cursorPos;
    s32 i;

    /* Initialize if not already active */
    if (D_80159910 == 0) {
        func_800CD798();  /* Init keyboard */
        D_80159910 = 1;
        D_80159914 = 0;
        /* Copy existing buffer content to preview */
        for (i = 0; i < maxLen && i < 16 && buffer[i] != '\0'; i++) {
            D_8015991C[i] = buffer[i];
            D_80159914 = i + 1;
        }
        return;
    }

    /* Get input */
    input = func_800CB748(D_80158100);
    cursorPos = D_80159914;

    /* Process keyboard input */
    c = func_800CD8EC(input);

    if (c == '\n') {
        /* OK pressed - copy preview to buffer and close */
        for (i = 0; i < maxLen && i < 16; i++) {
            buffer[i] = D_8015991C[i];
        }
        if (maxLen > 0) {
            buffer[maxLen - 1] = '\0';
        }
        D_80159910 = 0;  /* Close keyboard */
        sound_play_menu(10);  /* Confirm sound */
    }
    else if (c == '\b') {
        /* Backspace */
        if (cursorPos > 0) {
            cursorPos--;
            D_8015991C[cursorPos] = '\0';
            D_80159914 = cursorPos;
        }
    }
    else if (c != '\0' && cursorPos < maxLen - 1 && cursorPos < 15) {
        /* Add character */
        D_8015991C[cursorPos] = c;
        cursorPos++;
        D_8015991C[cursorPos] = '\0';
        D_80159914 = cursorPos;
    }

    /* Update animation frame */
    D_80159918 = D_80159918 + 1;
}

/*

 * func_800CDCAC (576 bytes)
 * Menu option toggle - toggles a game option and applies it immediately
 */
void func_800CDCAC(s32 optionId) {
    s32 currentValue;
    s32 newValue;

    /* Get current value based on option ID */
    switch (optionId) {
        case 0:  /* Music */
            currentValue = D_80159300;
            newValue = (currentValue == 0) ? 1 : 0;
            D_80159300 = newValue;
            /* Apply: mute/unmute music channel */
            if (newValue == 0) {
                func_800B4DAC(1);  /* Mute music */
            } else {
                func_800B4E70(1);  /* Unmute music */
            }
            break;

        case 1:  /* Sound effects */
            currentValue = D_80159304;
            newValue = (currentValue == 0) ? 1 : 0;
            D_80159304 = newValue;
            break;

        case 2:  /* Vibration/rumble */
            currentValue = D_80159308;
            newValue = (currentValue == 0) ? 1 : 0;
            D_80159308 = newValue;
            /* Test vibration when enabled */
            if (newValue == 1) {
                func_800CFE74();  /* Short rumble test */
            }
            break;

        case 3:  /* Widescreen mode */
            currentValue = D_8015930C;
            newValue = (currentValue == 0) ? 1 : 0;
            D_8015930C = newValue;
            break;

        case 4:  /* HUD display */
            currentValue = D_80159060;
            newValue = (currentValue == 0) ? 1 : 0;
            D_80159060 = newValue;
            break;

        case 5:  /* Minimap */
            currentValue = D_80159310;
            newValue = (currentValue == 0) ? 1 : 0;
            D_80159310 = newValue;
            break;

        case 6:  /* Speedometer units (mph/kph) */
            currentValue = D_80159314;
            newValue = (currentValue == 0) ? 1 : 0;
            D_80159314 = newValue;
            break;

        case 7:  /* Camera auto-center */
            currentValue = D_80159318;
            newValue = (currentValue == 0) ? 1 : 0;
            D_80159318 = newValue;
            break;

        case 8:  /* Subtitles */
            currentValue = D_8015931C;
            newValue = (currentValue == 0) ? 1 : 0;
            D_8015931C = newValue;
            break;

        default:
            return;
    }

    sound_play_menu(14);  /* Toggle sound */
}

/*

 * func_800CDEEC (764 bytes)
 * Menu save options - saves game options to Controller Pak
 */
void func_800CDEEC(void) {
    u8 saveData[64];
    s32 i;
    s32 result;
    u8 checksum;

    /* Pack options into save data */
    saveData[0] = 0x52;  /* Magic byte 'R' */
    saveData[1] = 0x32;  /* Magic byte '2' */
    saveData[2] = 0x30;  /* Version 0 */
    saveData[3] = 0x00;  /* Reserved */

    /* Audio settings */
    saveData[4] = (u8)D_80159300;   /* Music on/off */
    saveData[5] = (u8)D_80159304;   /* SFX on/off */
    saveData[6] = (u8)D_80159320;   /* Music volume */
    saveData[7] = (u8)D_80159324;   /* SFX volume */

    /* Video settings */
    saveData[8] = (u8)D_8015930C;   /* Widescreen */
    saveData[9] = (u8)D_80159060;   /* HUD enabled */
    saveData[10] = (u8)D_80159310;  /* Minimap */
    saveData[11] = (u8)D_80159314;  /* Speed units */

    /* Control settings */
    saveData[12] = (u8)D_80159308;  /* Vibration */
    saveData[13] = (u8)D_80159318;  /* Camera auto */
    saveData[14] = (u8)D_80159328;  /* Steering sensitivity */
    saveData[15] = (u8)D_8015932C;  /* Invert Y */

    /* Controller mapping (8 bytes) */
    for (i = 0; i < 8; i++) {
        saveData[16 + i] = (u8)D_80159330[i];
    }

    /* Misc settings */
    saveData[24] = (u8)D_8015931C;  /* Subtitles */
    saveData[25] = (u8)D_80159334;  /* Difficulty */
    saveData[26] = (u8)D_80159338;  /* Laps count */
    saveData[27] = (u8)D_8015933C;  /* AI difficulty */

    /* Pad remaining with zeros */
    for (i = 28; i < 63; i++) {
        saveData[i] = 0;
    }

    /* Calculate checksum */
    checksum = 0;
    for (i = 0; i < 63; i++) {
        checksum = checksum + saveData[i];
    }
    saveData[63] = checksum;

    /* Write to Controller Pak */
    result = func_800AEB54(0);  /* Slot 0 for options */
    if (result == 0) {
        /* Success */
        sound_play_menu(10);
    } else {
        /* Error - show dialog */
        func_800CD104(4);  /* No Controller Pak */
    }
}

/*

 * func_800CE1EC (364 bytes)
 * Menu load options - loads game options from Controller Pak
 */
void func_800CE1EC(void) {
    u8 saveData[64];
    s32 i;
    s32 result;
    u8 checksum;
    u8 calcChecksum;

    /* Read from Controller Pak */
    func_800AED64(0, NULL, 0);  /* Slot 0 for options */
    result = 0;
    if (result != 0) {
        /* Error or no save - use defaults */
        return;
    }

    /* Verify magic bytes */
    if (saveData[0] != 0x52 || saveData[1] != 0x32) {
        return;  /* Invalid save */
    }

    /* Verify checksum */
    calcChecksum = 0;
    for (i = 0; i < 63; i++) {
        calcChecksum = calcChecksum + saveData[i];
    }
    if (calcChecksum != saveData[63]) {
        return;  /* Corrupted save */
    }

    /* Unpack options */
    D_80159300 = saveData[4];   /* Music on/off */
    D_80159304 = saveData[5];   /* SFX on/off */
    D_80159320 = saveData[6];   /* Music volume */
    D_80159324 = saveData[7];   /* SFX volume */

    D_8015930C = saveData[8];   /* Widescreen */
    D_80159060 = saveData[9];   /* HUD enabled */
    D_80159310 = saveData[10];  /* Minimap */
    D_80159314 = saveData[11];  /* Speed units */

    D_80159308 = saveData[12];  /* Vibration */
    D_80159318 = saveData[13];  /* Camera auto */
    D_80159328 = saveData[14];  /* Steering sensitivity */
    D_8015932C = saveData[15];  /* Invert Y */

    /* Controller mapping */
    for (i = 0; i < 8; i++) {
        D_80159330[i] = saveData[16 + i];
    }

    D_8015931C = saveData[24];  /* Subtitles */
    D_80159334 = saveData[25];  /* Difficulty */
    D_80159338 = saveData[26];  /* Laps count */
    D_8015933C = saveData[27];  /* AI difficulty */
}

/*

 * func_800CE358 (2532 bytes)
 * Menu options screen - main options menu handler
 */
void func_800CE358(void) {
    s32 input;
    s32 action;
    s32 selectedItem;

    /* Update menu animations */
    func_800CC040();

    /* Handle dialog if active */
    if (D_801592E0 != 0) {
        func_800CD104(D_80159340);
        return;
    }

    /* Get input */
    input = func_800CB748(D_80158100);
    selectedItem = D_80159210;

    /* Handle navigation */
    if (input >= 4 && input <= 7) {
        func_800CB9D0(input);
    }
    /* Handle selection */
    else if (input == 1) {
        action = D_80159344[selectedItem];
        switch (action) {
            case 0:  /* Audio settings */
                menu_transition(10);  /* Go to audio submenu */
                break;
            case 1:  /* Video settings */
                menu_transition(11);  /* Go to video submenu */
                break;
            case 2:  /* Control settings */
                menu_transition(12);  /* Go to controls submenu */
                break;
            case 3:  /* Save options */
                D_80159340 = 1;  /* Save confirm dialog */
                D_801592E0 = 1;
                D_801592E4 = 0;
                D_801592E8 = 0;
                break;
            case 4:  /* Load options */
                D_80159340 = 2;  /* Load confirm dialog */
                D_801592E0 = 1;
                D_801592E4 = 0;
                D_801592E8 = 0;
                break;
            case 5:  /* Reset defaults */
                /* Reset all options to defaults */
                D_80159300 = 1;  /* Music on */
                D_80159304 = 1;  /* SFX on */
                D_80159320 = 80; /* Music volume */
                D_80159324 = 100; /* SFX volume */
                D_8015930C = 0;  /* Widescreen off */
                D_80159060 = 1;  /* HUD on */
                D_80159310 = 1;  /* Minimap on */
                D_80159308 = 1;  /* Vibration on */
                sound_play_menu(10);
                break;
            case 6:  /* Back */
                menu_back();
                break;
        }
    }
    /* Handle back button */
    else if (input == 2) {
        menu_back();
    }

    /* Render menu */
    func_800CCA04(NULL, 0);
}

/*

 * func_800CED3C (1364 bytes)
 * Menu audio settings - audio options submenu
 */
void func_800CED3C(void) {
    s32 input;
    s32 selectedItem;
    s32 itemType;
    s32 *menuItems;

    /* Update animations */
    func_800CC040();

    /* Get input */
    input = func_800CB748(D_80158100);
    selectedItem = D_80159210;
    menuItems = (s32 *)D_80159218;

    /* Handle navigation */
    if (input >= 4 && input <= 7) {
        func_800CB9D0(input);
    }
    /* Handle selection */
    else if (input == 1) {
        if (menuItems != NULL) {
            itemType = menuItems[selectedItem * 4 + 2];
            if (itemType == 1) {
                /* Toggle item */
                if (selectedItem == 0) {
                    func_800CDCAC(0);  /* Toggle music */
                } else if (selectedItem == 1) {
                    func_800CDCAC(1);  /* Toggle SFX */
                }
            } else if (selectedItem == 4) {
                /* Back */
                menu_back();
            }
        }
    }
    /* Handle left/right for sliders */
    else if (input == 6 || input == 7) {
        if (menuItems != NULL) {
            itemType = menuItems[selectedItem * 4 + 2];
            if (itemType == 2) {  /* Slider */
                s32 value = menuItems[selectedItem * 4 + 1];
                s32 delta = (input == 6) ? -5 : 5;
                value = func_800CCE5C(value + delta, 0, 100);
                menuItems[selectedItem * 4 + 1] = value;
                /* Apply volume change */
                if (selectedItem == 2) {
                    D_80159320 = value;  /* Music volume */
                    sound_update_channel(D_80158140, value);  /* Apply to music */
                } else if (selectedItem == 3) {
                    D_80159324 = value;  /* SFX volume */
                }
            }
        }
    }
    /* Handle back button */
    else if (input == 2) {
        menu_back();
    }

    /* Render menu */
    func_800CCA04(NULL, 0);

    /* Draw title */
    draw_text(100, 40, "AUDIO SETTINGS", 0xFFFFFFFF);
}

/*

 * func_800CF290 (228 bytes)
 * Menu video settings - video options submenu
 */
void func_800CF290(void) {
    s32 input;
    s32 selectedItem;

    func_800CC040();

    input = func_800CB748(D_80158100);
    selectedItem = D_80159210;

    if (input >= 4 && input <= 7) {
        func_800CB9D0(input);
    }
    else if (input == 1) {
        switch (selectedItem) {
            case 0:  /* Widescreen */
                func_800CDCAC(3);
                break;
            case 1:  /* HUD */
                func_800CDCAC(4);
                break;
            case 2:  /* Minimap */
                func_800CDCAC(5);
                break;
            case 3:  /* Back */
                menu_back();
                break;
        }
    }
    else if (input == 2) {
        menu_back();
    }

    func_800CCA04(NULL, 0);
    draw_text(100, 40, "VIDEO SETTINGS", 0xFFFFFFFF);
}

/*

 * func_800CF374 (808 bytes)
 * Menu control settings - controller options submenu
 */
void func_800CF374(void) {
    s32 input;
    s32 selectedItem;
    s32 *menuItems;
    s32 itemType;

    func_800CC040();

    input = func_800CB748(D_80158100);
    selectedItem = D_80159210;
    menuItems = (s32 *)D_80159218;

    if (input >= 4 && input <= 7) {
        func_800CB9D0(input);
    }
    else if (input == 1) {
        switch (selectedItem) {
            case 0:  /* Vibration */
                func_800CDCAC(2);
                break;
            case 1:  /* Camera auto-center */
                func_800CDCAC(7);
                break;
            case 2:  /* Invert Y axis */
                D_8015932C = (D_8015932C == 0) ? 1 : 0;
                sound_play_menu(14);
                break;
            case 3:  /* Remap controls */
                menu_transition(13);  /* Go to remap screen */
                break;
            case 4:  /* Test vibration */
                func_800CFE74();
                break;
            case 5:  /* Back */
                menu_back();
                break;
        }
    }
    /* Handle left/right for sensitivity slider */
    else if (input == 6 || input == 7) {
        if (menuItems != NULL && selectedItem == 6) {  /* Sensitivity slider */
            itemType = menuItems[selectedItem * 4 + 2];
            if (itemType == 2) {
                s32 value = menuItems[selectedItem * 4 + 1];
                s32 delta = (input == 6) ? -5 : 5;
                value = func_800CCE5C(value + delta, 0, 100);
                menuItems[selectedItem * 4 + 1] = value;
                D_80159328 = value;  /* Steering sensitivity */
            }
        }
    }
    else if (input == 2) {
        menu_back();
    }

    func_800CCA04(NULL, 0);
    draw_text(90, 40, "CONTROL SETTINGS", 0xFFFFFFFF);
}

/*

 * func_800CF69C (1976 bytes)
 * Menu controller remap - controller button remapping screen
 */
void func_800CF69C(void) {
    s32 input;
    s32 selectedItem;
    s32 remapState;
    s32 buttons;
    s32 i;
    char *actionNames[8];
    char *buttonNames[10];

    /* Action names */
    actionNames[0] = "ACCELERATE";
    actionNames[1] = "BRAKE";
    actionNames[2] = "HANDBRAKE";
    actionNames[3] = "LOOK BACK";
    actionNames[4] = "CHANGE VIEW";
    actionNames[5] = "HORN";
    actionNames[6] = "RESET CAR";
    actionNames[7] = "PAUSE";

    /* Button names */
    buttonNames[0] = "A";
    buttonNames[1] = "B";
    buttonNames[2] = "Z";
    buttonNames[3] = "START";
    buttonNames[4] = "L";
    buttonNames[5] = "R";
    buttonNames[6] = "C-UP";
    buttonNames[7] = "C-DOWN";
    buttonNames[8] = "C-LEFT";
    buttonNames[9] = "C-RIGHT";

    func_800CC040();

    remapState = D_80159350;
    selectedItem = D_80159210;

    if (remapState == 0) {
        /* Normal navigation */
        input = func_800CB748(D_80158100);

        if (input >= 4 && input <= 5) {
            func_800CB9D0(input);
        }
        else if (input == 1) {
            if (selectedItem < 8) {
                /* Start remapping this action */
                remapState = 1;
                D_80159350 = 1;
                D_80159354 = selectedItem;  /* Action being remapped */
                D_80159358 = 60;  /* Timeout frames */
                sound_play_menu(10);
            } else if (selectedItem == 8) {
                /* Reset to defaults */
                D_80159330[0] = 0;  /* A = accelerate */
                D_80159330[1] = 1;  /* B = brake */
                D_80159330[2] = 2;  /* Z = handbrake */
                D_80159330[3] = 5;  /* R = look back */
                D_80159330[4] = 4;  /* L = change view */
                D_80159330[5] = 6;  /* C-UP = horn */
                D_80159330[6] = 7;  /* C-DOWN = reset */
                D_80159330[7] = 3;  /* START = pause */
                sound_play_menu(10);
            } else if (selectedItem == 9) {
                /* Back */
                menu_back();
            }
        }
        else if (input == 2) {
            menu_back();
        }
    }
    else {
        /* Waiting for button press */
        buttons = (s32)(long)D_80158100[0] & 0xFFFF;
        D_80159358 = D_80159358 - 1;

        if (D_80159358 <= 0) {
            /* Timeout - cancel remap */
            D_80159350 = 0;
            sound_play_menu(13);
        }
        else if (buttons != 0) {
            /* Button pressed - find which one */
            s32 buttonId = -1;
            if (buttons & 0x8000) buttonId = 0;       /* A */
            else if (buttons & 0x4000) buttonId = 1;  /* B */
            else if (buttons & 0x2000) buttonId = 2;  /* Z */
            else if (buttons & 0x1000) buttonId = 3;  /* START */
            else if (buttons & 0x0020) buttonId = 4;  /* L */
            else if (buttons & 0x0010) buttonId = 5;  /* R */
            else if (buttons & 0x0008) buttonId = 6;  /* C-UP */
            else if (buttons & 0x0004) buttonId = 7;  /* C-DOWN */
            else if (buttons & 0x0002) buttonId = 8;  /* C-LEFT */
            else if (buttons & 0x0001) buttonId = 9;  /* C-RIGHT */

            if (buttonId >= 0) {
                /* Assign button to action */
                D_80159330[D_80159354] = buttonId;
                D_80159350 = 0;
                sound_play_menu(10);
            }
        }
    }

    /* Render */
    draw_text(85, 40, "CONTROLLER REMAP", 0xFFFFFFFF);

    for (i = 0; i < 8; i++) {
        s32 y = 80 + i * 20;
        s32 alpha = (i == selectedItem) ? 255 : 180;
        s32 buttonIdx = D_80159330[i];
        draw_text(actionNames[i], 60, y, alpha);
        if (buttonIdx >= 0 && buttonIdx < 10) {
            draw_text(buttonNames[buttonIdx], 200, y, alpha);
        }
        if (i == selectedItem) {
            draw_ui_element(56, 40, y + 2, 12, 12, 255);
        }
    }

    /* Draw reset/back options */
    draw_text("RESET DEFAULTS", 60, 260, (selectedItem == 8) ? 255 : 180);
    draw_text("BACK", 60, 280, (selectedItem == 9) ? 255 : 180);

    /* Draw prompt if remapping */
    if (remapState == 1) {
        draw_ui_element(57, 0, 0, 320, 240, 128);  /* Darken */
        draw_text(95, 120, "PRESS A BUTTON", 0xFFFFFFFF);
    }
}

/*

 * func_800CFE74 (404 bytes)
 * Menu vibration test - tests controller rumble feature
 */
void func_800CFE74(void) {
    s32 vibeState;
    s32 vibeTimer;
    s32 vibePattern;
    s32 controller;

    vibeState = D_80159360;
    vibeTimer = D_80159364;
    controller = 0;  /* Player 1 controller */

    if (vibeState == 0) {
        /* Start vibration sequence */
        vibeState = 1;
        vibeTimer = 0;
        vibePattern = 0;
        D_80159368 = 0;
        osMotorStart(&D_80159370[controller]);  /* Start motor */
    }

    vibeTimer = vibeTimer + 1;

    /* Vibration pattern: short-short-long */
    vibePattern = D_80159368;
    switch (vibePattern) {
        case 0:  /* First short pulse */
            if (vibeTimer >= 10) {
                osMotorStop(&D_80159370[controller]);
                vibeTimer = 0;
                D_80159368 = 1;
            }
            break;
        case 1:  /* First pause */
            if (vibeTimer >= 5) {
                osMotorStart(&D_80159370[controller]);
                vibeTimer = 0;
                D_80159368 = 2;
            }
            break;
        case 2:  /* Second short pulse */
            if (vibeTimer >= 10) {
                osMotorStop(&D_80159370[controller]);
                vibeTimer = 0;
                D_80159368 = 3;
            }
            break;
        case 3:  /* Second pause */
            if (vibeTimer >= 5) {
                osMotorStart(&D_80159370[controller]);
                vibeTimer = 0;
                D_80159368 = 4;
            }
            break;
        case 4:  /* Long pulse */
            if (vibeTimer >= 30) {
                osMotorStop(&D_80159370[controller]);
                vibeTimer = 0;
                D_80159368 = 5;
                vibeState = 0;  /* Done */
            }
            break;
        default:
            vibeState = 0;
            osMotorStop(&D_80159370[controller]);
            break;
    }

    D_80159360 = vibeState;
    D_80159364 = vibeTimer;
}

/*

 * func_800D000C (2264 bytes)
 * Track select screen - main track selection menu
 */
void func_800D000C(void) {
    s32 input;
    s32 selectedTrack;
    s32 numTracks;
    s32 i;
    s32 trackUnlocked;
    s32 scrollOffset;
    s32 visibleTracks;
    char *trackNames[16];

    /* Track names */
    trackNames[0] = "MARINA";
    trackNames[1] = "HAIGHT";
    trackNames[2] = "SOMA";
    trackNames[3] = "MISSION";
    trackNames[4] = "NOB HILL";
    trackNames[5] = "CHINATOWN";
    trackNames[6] = "FISHERMAN'S WHARF";
    trackNames[7] = "ALCATRAZ";
    trackNames[8] = "BONUS 1";
    trackNames[9] = "BONUS 2";
    trackNames[10] = "BONUS 3";
    trackNames[11] = "STUNT ARENA";
    trackNames[12] = NULL;

    numTracks = 12;
    visibleTracks = 6;
    selectedTrack = D_80159A00;
    scrollOffset = D_80159A04;

    func_800CC040();  /* Update animations */

    input = func_800CB748(D_80158100);

    /* Navigation */
    if (input == 4) {  /* Up */
        selectedTrack--;
        if (selectedTrack < 0) {
            selectedTrack = numTracks - 1;
        }
        /* Update scroll offset */
        if (selectedTrack < scrollOffset) {
            scrollOffset = selectedTrack;
        }
        sound_play_menu(12);
    }
    else if (input == 5) {  /* Down */
        selectedTrack++;
        if (selectedTrack >= numTracks) {
            selectedTrack = 0;
        }
        if (selectedTrack >= scrollOffset + visibleTracks) {
            scrollOffset = selectedTrack - visibleTracks + 1;
        }
        sound_play_menu(12);
    }
    else if (input == 1) {  /* Select */
        trackUnlocked = func_800D1248(selectedTrack);
        if (trackUnlocked) {
            D_80159A08 = selectedTrack;  /* Store selected track */
            menu_transition(4);  /* Go to car select */
            sound_play_menu(10);
        } else {
            sound_play_menu(13);  /* Locked sound */
        }
    }
    else if (input == 2) {  /* Back */
        menu_back();
    }

    D_80159A00 = selectedTrack;
    D_80159A04 = scrollOffset;

    /* Render */
    draw_text(100, 30, "SELECT TRACK", 0xFFFFFFFF);

    /* Render track list */
    for (i = 0; i < visibleTracks && (scrollOffset + i) < numTracks; i++) {
        s32 trackIdx = scrollOffset + i;
        s32 y = 70 + i * 28;
        s32 alpha;
        s32 unlocked;

        unlocked = func_800D1248(trackIdx);
        alpha = (trackIdx == selectedTrack) ? 255 : 180;
        if (!unlocked) {
            alpha = alpha / 2;
        }

        draw_text(trackNames[trackIdx], 80, y, alpha);

        /* Lock icon for locked tracks */
        if (!unlocked) {
            draw_ui_element(61, 55, y + 2, 16, 16, alpha);  /* Lock icon */
        }

        /* Selection cursor */
        if (trackIdx == selectedTrack) {
            draw_ui_element(56, 40, y + 2, 12, 12, 255);
        }
    }

    /* Scroll indicators */
    if (scrollOffset > 0) {
        draw_ui_element(62, 160, 55, 16, 12, 180);  /* Up arrow */
    }
    if (scrollOffset + visibleTracks < numTracks) {
        draw_ui_element(63, 160, 235, 16, 12, 180);  /* Down arrow */
    }

    /* Render track preview */
    func_800D08E4(selectedTrack);

    /* Render track info */
    func_800D0BA0(selectedTrack);
}

/*

 * func_800D08E4 (692 bytes)
 * Track preview render - renders track thumbnail/preview image
 */
void func_800D08E4(s32 trackId) {
    s32 previewX, previewY;
    s32 previewW, previewH;
    s32 textureId;
    s32 unlocked;

    previewX = 180;
    previewY = 70;
    previewW = 120;
    previewH = 90;

    unlocked = func_800D1248(trackId);

    /* Draw preview frame */
    draw_ui_element(64, previewX - 2, previewY - 2, previewW + 4, previewH + 4, 255);  /* Border */

    /* Get track preview texture ID */
    if (unlocked) {
        textureId = 100 + trackId;  /* Track preview textures start at 100 */
    } else {
        textureId = 99;  /* Locked track placeholder */
    }

    /* Draw track preview image */
    draw_ui_element(textureId, previewX, previewY, previewW, previewH, unlocked ? 255 : 128);

    /* Draw track number */
    {
        char numBuf[4];
        numBuf[0] = '0' + ((trackId + 1) / 10);
        numBuf[1] = '0' + ((trackId + 1) % 10);
        numBuf[2] = '\0';
        draw_text(numBuf, previewX + 5, previewY + 5, 255);
    }
}

/*

 * func_800D0BA0 (1192 bytes)
 * Track info display - shows track statistics and info
 */
void func_800D0BA0(s32 trackId) {
    s32 infoX, infoY;
    s32 unlocked;
    char timeBuf[16];
    s32 bestTime;
    s32 minutes, seconds, hundredths;

    infoX = 180;
    infoY = 170;

    unlocked = func_800D1248(trackId);

    if (!unlocked) {
        draw_text("LOCKED", infoX + 30, infoY + 20, 180);
        draw_text("Complete previous", infoX, infoY + 45, 120);
        draw_text("tracks to unlock", infoX, infoY + 60, 120);
        return;
    }

    /* Track difficulty */
    draw_text("DIFFICULTY:", infoX, infoY, 200);
    switch (trackId) {
        case 0: case 1:
            draw_text("EASY", infoX + 70, infoY, 255);
            break;
        case 2: case 3: case 4:
            draw_text("MEDIUM", infoX + 70, infoY, 255);
            break;
        case 5: case 6: case 7:
            draw_text("HARD", infoX + 70, infoY, 255);
            break;
        default:
            draw_text("EXPERT", infoX + 70, infoY, 255);
            break;
    }

    /* Track length */
    draw_text("LENGTH:", infoX, infoY + 20, 200);
    switch (trackId) {
        case 0: draw_text("2.1 mi", infoX + 50, infoY + 20, 255); break;
        case 1: draw_text("2.4 mi", infoX + 50, infoY + 20, 255); break;
        case 2: draw_text("2.8 mi", infoX + 50, infoY + 20, 255); break;
        case 3: draw_text("3.2 mi", infoX + 50, infoY + 20, 255); break;
        case 4: draw_text("2.9 mi", infoX + 50, infoY + 20, 255); break;
        case 5: draw_text("3.5 mi", infoX + 50, infoY + 20, 255); break;
        case 6: draw_text("3.8 mi", infoX + 50, infoY + 20, 255); break;
        case 7: draw_text("4.2 mi", infoX + 50, infoY + 20, 255); break;
        default: draw_text("2.0 mi", infoX + 50, infoY + 20, 255); break;
    }

    /* Best time */
    draw_text("BEST:", infoX, infoY + 40, 200);
    bestTime = D_80159A10[trackId];  /* Best times array */
    if (bestTime > 0) {
        minutes = bestTime / 6000;
        seconds = (bestTime / 100) % 60;
        hundredths = bestTime % 100;
        timeBuf[0] = '0' + (minutes / 10);
        timeBuf[1] = '0' + (minutes % 10);
        timeBuf[2] = ':';
        timeBuf[3] = '0' + (seconds / 10);
        timeBuf[4] = '0' + (seconds % 10);
        timeBuf[5] = '.';
        timeBuf[6] = '0' + (hundredths / 10);
        timeBuf[7] = '0' + (hundredths % 10);
        timeBuf[8] = '\0';
        draw_text(timeBuf, infoX + 40, infoY + 40, 255);
    } else {
        draw_text("--:--.--", infoX + 40, infoY + 40, 180);
    }
}

/*

 * func_800D1248 (324 bytes)
 * Track unlock check - checks if track is unlocked
 */
s32 func_800D1248(s32 trackId) {
    s32 unlockedTracks;
    s32 i;

    /* Get unlock state from save data */
    unlockedTracks = D_80159A40;

    /* First 4 tracks always unlocked */
    if (trackId < 4) {
        return 1;
    }

    /* Check unlock bits */
    if (unlockedTracks & (1 << trackId)) {
        return 1;
    }

    /* Check if previous track has been completed */
    if (trackId > 0) {
        /* Check if player has a best time on previous track */
        if (D_80159A10[trackId - 1] > 0) {
            return 1;
        }
    }

    /* Bonus tracks need special unlock conditions */
    if (trackId >= 8 && trackId <= 10) {
        /* Unlock if all regular tracks completed */
        s32 allCompleted = 1;
        for (i = 0; i < 8; i++) {
            if (D_80159A10[i] == 0) {
                allCompleted = 0;
                break;
            }
        }
        return allCompleted;
    }

    /* Stunt arena unlocked with any 5 tracks completed */
    if (trackId == 11) {
        s32 completedCount = 0;
        for (i = 0; i < 8; i++) {
            if (D_80159A10[i] > 0) {
                completedCount++;
            }
        }
        return (completedCount >= 5) ? 1 : 0;
    }

    return 0;
}

/*

 * func_800D138C (804 bytes)
 * Car select screen - main car selection menu
 */
void func_800D138C(void) {
    s32 input;
    s32 selectedCar;
    s32 numCars;
    s32 carUnlocked;
    char *carNames[12];

    /* Car names from Rush 2049 */
    carNames[0] = "CRUSHER";
    carNames[1] = "DOMINATOR";
    carNames[2] = "VELOCITY";
    carNames[3] = "ROCKET";
    carNames[4] = "PANTHER";
    carNames[5] = "BRUISER";
    carNames[6] = "SPEEDSTER";
    carNames[7] = "RAMPAGE";
    carNames[8] = "NITRO";
    carNames[9] = "BLAZE";
    carNames[10] = "PHANTOM";
    carNames[11] = "PROTOTYPE";

    numCars = 12;
    selectedCar = D_80159A50;

    func_800CC040();

    input = func_800CB748(D_80158100);

    /* Navigation left/right to cycle cars */
    if (input == 6) {  /* Left */
        selectedCar--;
        if (selectedCar < 0) {
            selectedCar = numCars - 1;
        }
        sound_play_menu(12);
    }
    else if (input == 7) {  /* Right */
        selectedCar++;
        if (selectedCar >= numCars) {
            selectedCar = 0;
        }
        sound_play_menu(12);
    }
    else if (input == 1) {  /* Select */
        carUnlocked = func_800D197C(selectedCar);
        if (carUnlocked) {
            D_80159A54 = selectedCar;  /* Store selected car */
            menu_transition(5);  /* Go to color select or race setup */
            sound_play_menu(10);
        } else {
            sound_play_menu(13);
        }
    }
    else if (input == 2) {  /* Back */
        menu_back();
    }
    /* Up/down for color selection */
    else if (input == 4 || input == 5) {
        s32 colorIdx = D_80159A58;
        if (input == 4) {
            colorIdx--;
            if (colorIdx < 0) colorIdx = 7;
        } else {
            colorIdx++;
            if (colorIdx > 7) colorIdx = 0;
        }
        D_80159A58 = colorIdx;
        func_800D1AB8(colorIdx);
        sound_play_menu(12);
    }

    D_80159A50 = selectedCar;

    /* Render */
    draw_text(110, 30, "SELECT CAR", 0xFFFFFFFF);

    /* Render car preview (3D model rotating) */
    func_800D16B0(selectedCar);

    /* Render car name */
    draw_text(carNames[selectedCar], 110, 200, 255);

    /* Render car stats */
    func_800D18E4(selectedCar);

    /* Render left/right arrows */
    draw_ui_element(54, 30, 110, 20, 20, 255);   /* Left */
    draw_ui_element(55, 270, 110, 20, 20, 255);  /* Right */

    /* Render lock if not unlocked */
    if (!func_800D197C(selectedCar)) {
        draw_ui_element(61, 145, 100, 32, 32, 200);  /* Lock icon centered */
    }
}

/*

 * func_800D16B0 (564 bytes)
 * Car preview render - renders rotating 3D car model
 */
void func_800D16B0(s32 carId) {
    s32 previewX, previewY;
    s32 rotation;
    f32 scale;
    s32 modelId;
    s32 unlocked;

    previewX = 160;  /* Center of screen */
    previewY = 120;
    scale = 1.5f;

    /* Get current rotation angle (animated) */
    rotation = D_80159A5C;
    D_80159A5C = (rotation + 2) % 360;  /* Rotate 2 degrees per frame */

    unlocked = func_800D197C(carId);

    /* Get car model ID */
    modelId = 200 + carId;  /* Car models start at 200 */

    /* Render car model */
    if (unlocked) {
        /* Setup viewport for car preview */
        /* Set camera position for preview */
        f32 camDist = 5.0f;
        f32 camAngle = (f32)rotation * 3.14159f / 180.0f;
        f32 camX = camDist * sinf(camAngle);
        f32 camZ = camDist * cosf(camAngle);

        /* Call 3D model render with rotation */
        /* This would normally set up the RCP and render the model */
        /* For now, just draw a placeholder sprite */
        s32 spriteId = 120 + carId;  /* Car preview sprite */
        draw_ui_element(spriteId, previewX - 60, previewY - 40, 120, 80, 255);
    } else {
        /* Silhouette for locked cars */
        s32 spriteId = 119;  /* Locked car silhouette */
        draw_ui_element(spriteId, previewX - 60, previewY - 40, 120, 80, 128);
    }

    /* Draw color swatch */
    {
        s32 colorIdx = D_80159A58;
        s32 swatchX = previewX - 50;
        s32 swatchY = previewY + 50;
        s32 swatchSize = 12;
        s32 i;

        for (i = 0; i < 8; i++) {
            s32 x = swatchX + i * (swatchSize + 4);
            s32 alpha = (i == colorIdx) ? 255 : 150;
            draw_ui_element(140 + i, x, swatchY, swatchSize, swatchSize, alpha);
            if (i == colorIdx) {
                /* Draw selection box */
                draw_ui_element(65, x - 2, swatchY - 2, swatchSize + 4, swatchSize + 4, 255);
            }
        }
    }
}

/*

 * func_800D18E4 (152 bytes)
 * Car stats display - shows car performance stats
 */
void func_800D18E4(s32 carId) {
    s32 statX, statY;
    s32 speed, accel, handling, weight;
    s32 barWidth;

    statX = 20;
    statY = 180;
    barWidth = 50;

    /* Get car stats (0-10 scale) */
    switch (carId) {
        case 0:  /* Crusher */ speed = 6; accel = 5; handling = 4; weight = 8; break;
        case 1:  /* Dominator */ speed = 7; accel = 6; handling = 5; weight = 7; break;
        case 2:  /* Velocity */ speed = 9; accel = 7; handling = 6; weight = 4; break;
        case 3:  /* Rocket */ speed = 10; accel = 8; handling = 5; weight = 3; break;
        case 4:  /* Panther */ speed = 7; accel = 6; handling = 8; weight = 5; break;
        case 5:  /* Bruiser */ speed = 5; accel = 4; handling = 4; weight = 10; break;
        case 6:  /* Speedster */ speed = 8; accel = 9; handling = 7; weight = 4; break;
        case 7:  /* Rampage */ speed = 6; accel = 5; handling = 5; weight = 9; break;
        case 8:  /* Nitro */ speed = 9; accel = 10; handling = 6; weight = 5; break;
        case 9:  /* Blaze */ speed = 8; accel = 7; handling = 9; weight = 4; break;
        case 10: /* Phantom */ speed = 10; accel = 8; handling = 8; weight = 3; break;
        case 11: /* Prototype */ speed = 10; accel = 10; handling = 10; weight = 5; break;
        default: speed = 5; accel = 5; handling = 5; weight = 5; break;
    }

    /* Draw stat bars */
    draw_text("SPD", statX, statY, 180);
    draw_ui_element(66, statX + 25, statY + 2, barWidth, 10, 100);  /* Background */
    draw_ui_element(67, statX + 25, statY + 2, (speed * barWidth, 0, 0) / 10, 10, 255);  /* Fill */

    draw_text("ACC", statX, statY + 14, 180);
    draw_ui_element(66, statX + 25, statY + 16, barWidth, 10, 100);
    draw_ui_element(67, statX + 25, statY + 16, (accel * barWidth, 0, 0) / 10, 10, 255);

    draw_text("HND", statX, statY + 28, 180);
    draw_ui_element(66, statX + 25, statY + 30, barWidth, 10, 100);
    draw_ui_element(67, statX + 25, statY + 30, (handling * barWidth, 0, 0) / 10, 10, 255);

    draw_text("WGT", statX, statY + 42, 180);
    draw_ui_element(66, statX + 25, statY + 44, barWidth, 10, 100);
    draw_ui_element(67, statX + 25, statY + 44, (weight * barWidth, 0, 0) / 10, 10, 255);
}

/*

 * func_800D197C (316 bytes)
 * Car unlock check - checks if car is unlocked
 */
s32 func_800D197C(s32 carId) {
    s32 unlockedCars;
    s32 tracksCompleted;
    s32 i;

    unlockedCars = D_80159A60;

    /* First 4 cars always unlocked */
    if (carId < 4) {
        return 1;
    }

    /* Check unlock bits from save data */
    if (unlockedCars & (1 << carId)) {
        return 1;
    }

    /* Count completed tracks */
    tracksCompleted = 0;
    for (i = 0; i < 12; i++) {
        if (D_80159A10[i] > 0) {
            tracksCompleted++;
        }
    }

    /* Unlock cars based on track completion */
    /* Car 4-5: 2 tracks completed */
    if (carId >= 4 && carId <= 5 && tracksCompleted >= 2) {
        return 1;
    }
    /* Car 6-7: 4 tracks completed */
    if (carId >= 6 && carId <= 7 && tracksCompleted >= 4) {
        return 1;
    }
    /* Car 8-9: 6 tracks completed */
    if (carId >= 8 && carId <= 9 && tracksCompleted >= 6) {
        return 1;
    }
    /* Car 10: 8 tracks completed */
    if (carId == 10 && tracksCompleted >= 8) {
        return 1;
    }
    /* Car 11 (Prototype): All tracks completed with gold time */
    if (carId == 11) {
        s32 goldCount = 0;
        for (i = 0; i < 8; i++) {
            s32 goldTime = D_80159A70[i];  /* Gold times array */
            if (D_80159A10[i] > 0 && D_80159A10[i] <= goldTime) {
                goldCount++;
            }
        }
        if (goldCount >= 8) {
            return 1;
        }
    }

    return 0;
}

/*

 * func_800D1AB8 (552 bytes)
 * Car color select - applies selected color to car preview
 */
void func_800D1AB8(s32 colorId) {
    u32 primaryColor;
    u32 secondaryColor;

    /* Define color palette (RGB packed as 0xRRGGBB) */
    switch (colorId) {
        case 0:  /* Red */
            primaryColor = 0xFF2020;
            secondaryColor = 0x800000;
            break;
        case 1:  /* Blue */
            primaryColor = 0x2020FF;
            secondaryColor = 0x000080;
            break;
        case 2:  /* Green */
            primaryColor = 0x20FF20;
            secondaryColor = 0x008000;
            break;
        case 3:  /* Yellow */
            primaryColor = 0xFFFF20;
            secondaryColor = 0x808000;
            break;
        case 4:  /* Orange */
            primaryColor = 0xFF8020;
            secondaryColor = 0x804000;
            break;
        case 5:  /* Purple */
            primaryColor = 0x8020FF;
            secondaryColor = 0x400080;
            break;
        case 6:  /* White */
            primaryColor = 0xE0E0E0;
            secondaryColor = 0x808080;
            break;
        case 7:  /* Black */
            primaryColor = 0x404040;
            secondaryColor = 0x202020;
            break;
        default:
            primaryColor = 0xFFFFFF;
            secondaryColor = 0x808080;
            break;
    }

    /* Store selected colors */
    D_80159A80 = primaryColor;
    D_80159A84 = secondaryColor;
    D_80159A58 = colorId;

    /* Update car model material colors */
    /* This would normally update the RDP combiner or vertex colors */
    /* For now just store the values for when the car is rendered */
}

/*

 * func_800D1CE0 (1960 bytes)
 * Race setup screen - configure race options before starting
 */
void func_800D1CE0(void) {
    s32 input;
    s32 selectedItem;
    s32 numItems;
    char *modeNames[4];
    char *lapOptions[5];
    char *difficultyNames[4];

    modeNames[0] = "CIRCUIT";
    modeNames[1] = "TIME ATTACK";
    modeNames[2] = "STUNT";
    modeNames[3] = "BATTLE";

    lapOptions[0] = "1";
    lapOptions[1] = "3";
    lapOptions[2] = "5";
    lapOptions[3] = "7";
    lapOptions[4] = "10";

    difficultyNames[0] = "EASY";
    difficultyNames[1] = "NORMAL";
    difficultyNames[2] = "HARD";
    difficultyNames[3] = "EXPERT";

    numItems = 7;  /* Mode, Laps, Difficulty, Mirror, Weather, Time, Start */
    selectedItem = D_80159B00;

    func_800CC040();

    input = func_800CB748(D_80158100);

    /* Navigation */
    if (input == 4) {
        selectedItem--;
        if (selectedItem < 0) selectedItem = numItems - 1;
        sound_play_menu(12);
    }
    else if (input == 5) {
        selectedItem++;
        if (selectedItem >= numItems) selectedItem = 0;
        sound_play_menu(12);
    }
    else if (input == 6 || input == 7) {
        /* Left/right to change option value */
        s32 delta = (input == 6) ? -1 : 1;
        switch (selectedItem) {
            case 0:  /* Mode */
                D_80159B04 = (D_80159B04 + delta + 4) % 4;
                func_800D24C8(D_80159B04);
                break;
            case 1:  /* Laps */
                D_80159B08 = (D_80159B08 + delta + 5) % 5;
                func_800D2928(D_80159B08);
                break;
            case 2:  /* Difficulty */
                D_80159B0C = (D_80159B0C + delta + 4) % 4;
                func_800D2A74(D_80159B0C);
                break;
            case 3:  /* Mirror */
                func_800D2C2C();
                break;
            case 4:  /* Weather */
                D_80159B14 = (D_80159B14 + delta + 4) % 4;
                func_800D2CDC(D_80159B14);
                break;
            case 5:  /* Time of day */
                D_80159B18 = (D_80159B18 + delta + 3) % 3;
                func_800D2DCC(D_80159B18);
                break;
        }
        sound_play_menu(14);
    }
    else if (input == 1) {
        if (selectedItem == 6) {
            /* Start race */
            D_801146EC = 7;  /* PREPLAY state */
            menu_transition(-1);  /* Close menu */
            sound_play_menu(10);
        }
    }
    else if (input == 2) {
        menu_back();
    }

    D_80159B00[0][0] = selectedItem;

    /* Render */
    draw_text(105, 30, "RACE SETUP", 0xFFFFFFFF);

    /* Mode */
    draw_text("MODE:", 50, 70, (selectedItem == 0) ? 255 : 180);
    draw_text(modeNames[D_80159B04], 120, 70, 255);

    /* Laps */
    draw_text("LAPS:", 50, 95, (selectedItem == 1) ? 255 : 180);
    draw_text(lapOptions[D_80159B08], 120, 95, 255);

    /* Difficulty */
    draw_text("DIFFICULTY:", 50, 120, (selectedItem == 2) ? 255 : 180);
    draw_text(difficultyNames[D_80159B0C], 140, 120, 255);

    /* Mirror mode */
    draw_text("MIRROR:", 50, 145, (selectedItem == 3) ? 255 : 180);
    draw_text(D_80159B10 ? "ON" : "OFF", 120, 145, 255);

    /* Weather */
    draw_text("WEATHER:", 50, 170, (selectedItem == 4) ? 255 : 180);
    {
        char *weatherNames[4] = {"CLEAR", "RAIN", "FOG", "NIGHT"};
        draw_text(weatherNames[D_80159B14], 130, 170, 255);
    }

    /* Time of day */
    draw_text("TIME:", 50, 195, (selectedItem == 5) ? 255 : 180);
    {
        char *timeNames[3] = {"MORNING", "NOON", "EVENING"};
        draw_text(timeNames[D_80159B18], 100, 195, 255);
    }

    /* Start button */
    draw_text("START RACE", 100, 225, (selectedItem == 6) ? 255 : 180);
    if (selectedItem == 6) {
        draw_ui_element(56, 80, 227, 12, 12, 255);
    }

    /* Draw cursor */
    s32 cursorY = 70 + selectedItem * 25;
    if (selectedItem == 6) cursorY = 227;
    draw_ui_element(56, 30, cursorY, 12, 12, 255);
}

/*

 * func_800D24C8 (1120 bytes)
 * Race mode select - configures race mode settings
 */
void func_800D24C8(s32 modeId) {
    /* Store selected mode */
    D_80159B04 = modeId;

    /* Configure mode-specific defaults */
    switch (modeId) {
        case 0:  /* Circuit */
            D_80159B1C = 1;  /* Enable opponents */
            D_80159B20 = 1;  /* Enable checkpoints */
            D_80159B24 = 0;  /* Disable stunt scoring */
            D_80159B28 = 0;  /* Disable battle mode */
            break;
        case 1:  /* Time Attack */
            D_80159B1C = 0;  /* No opponents */
            D_80159B20 = 1;  /* Enable checkpoints */
            D_80159B24 = 0;  /* No stunt scoring */
            D_80159B28 = 0;
            break;
        case 2:  /* Stunt */
            D_80159B1C = 0;  /* No opponents */
            D_80159B20 = 0;  /* No checkpoints */
            D_80159B24 = 1;  /* Enable stunt scoring */
            D_80159B28 = 0;
            break;
        case 3:  /* Battle */
            D_80159B1C = 1;  /* Enable opponents */
            D_80159B20 = 0;  /* No checkpoints */
            D_80159B24 = 0;
            D_80159B28 = 1;  /* Enable battle mode */
            break;
    }
}

/*

 * func_800D2928 (332 bytes)
 * Lap count select - sets number of laps for race
 */
void func_800D2928(s32 laps) {
    s32 lapCounts[5] = {1, 3, 5, 7, 10};

    D_80159B08 = laps;
    if (laps >= 0 && laps < 5) {
        D_801582E8 = lapCounts[laps];  /* Store actual lap count */
    }
}

/*

 * func_800D2A74 (440 bytes)
 * Difficulty select - sets AI difficulty and rubber-banding
 */
void func_800D2A74(s32 difficulty) {
    D_80159B0C = difficulty;

    /* Configure AI based on difficulty */
    switch (difficulty) {
        case 0:  /* Easy */
            D_80159B2C = 70;   /* AI max speed % */
            D_80159B30 = 50;   /* AI aggression */
            D_80159B34 = 1;    /* Heavy rubber-banding */
            break;
        case 1:  /* Normal */
            D_80159B2C = 85;
            D_80159B30 = 70;
            D_80159B34 = 1;
            break;
        case 2:  /* Hard */
            D_80159B2C = 95;
            D_80159B30 = 85;
            D_80159B34 = 0;
            break;
        case 3:  /* Expert */
            D_80159B2C = 100;
            D_80159B30 = 100;
            D_80159B34 = 0;
            break;
    }
}

/*

 * func_800D2C2C (176 bytes)
 * Mirror mode toggle - flips track left-right
 */
void func_800D2C2C(void) {
    D_80159B10 = (D_80159B10 == 0) ? 1 : 0;

    /* Set mirror transform flag */
    D_80159B38 = D_80159B10;
}

/*

 * func_800D2CDC (240 bytes)
 * Weather select - sets weather conditions
 */
void func_800D2CDC(s32 weather) {
    D_80159B14 = weather;

    switch (weather) {
        case 0:  /* Clear */
            D_80159B3C = 0;     /* No rain */
            D_80159B40 = 1000;  /* Max visibility */
            D_80159B44 = 255;   /* Full brightness */
            break;
        case 1:  /* Rain */
            D_80159B3C = 1;     /* Rain enabled */
            D_80159B40 = 600;   /* Reduced visibility */
            D_80159B44 = 200;   /* Dimmer */
            break;
        case 2:  /* Fog */
            D_80159B3C = 0;
            D_80159B40 = 300;   /* Low visibility */
            D_80159B44 = 180;
            break;
        case 3:  /* Night */
            D_80159B3C = 0;
            D_80159B40 = 400;   /* Limited visibility */
            D_80159B44 = 80;    /* Dark */
            break;
    }
}

/*

 * func_800D2DCC (200 bytes)
 * Time of day select - sets lighting conditions
 */
void func_800D2DCC(s32 timeOfDay) {
    D_80159B18 = timeOfDay;

    switch (timeOfDay) {
        case 0:  /* Morning */
            D_80159B48 = 0x90A0C0;  /* Cool blue light */
            D_80159B4C = 0.7f;      /* Sun angle */
            break;
        case 1:  /* Noon */
            D_80159B48 = 0xFFFFE0;  /* Bright yellow */
            D_80159B4C = 1.0f;      /* Sun directly above */
            break;
        case 2:  /* Evening */
            D_80159B48 = 0xFFA060;  /* Orange sunset */
            D_80159B4C = 0.3f;      /* Low sun angle */
            break;
    }
}

/*

 * func_800D2E94 (1544 bytes)
 * Multiplayer setup - configures multiplayer game options
 */
void func_800D2E94(void) {
    s32 input;
    s32 selectedItem;
    s32 numPlayers;
    s32 i;

    selectedItem = D_80159C00;
    numPlayers = D_80159C04;

    func_800CC040();

    input = func_800CB748(D_80158100);

    /* Navigation */
    if (input == 4) {
        selectedItem--;
        if (selectedItem < 0) selectedItem = 5;
        sound_play_menu(12);
    }
    else if (input == 5) {
        selectedItem++;
        if (selectedItem > 5) selectedItem = 0;
        sound_play_menu(12);
    }
    else if (input == 6 || input == 7) {
        s32 delta = (input == 6) ? -1 : 1;
        switch (selectedItem) {
            case 0:  /* Player count */
                numPlayers = numPlayers + delta;
                if (numPlayers < 2) numPlayers = 4;
                if (numPlayers > 4) numPlayers = 2;
                D_80159C04 = numPlayers;
                break;
            case 1:  /* Split screen mode */
                D_80159C08 = (D_80159C08 + delta + 3) % 3;  /* Horizontal/Vertical/Quad */
                break;
            case 2:  /* Handicap */
                D_80159C0C = (D_80159C0C == 0) ? 1 : 0;
                break;
            case 3:  /* Team mode */
                D_80159C10 = (D_80159C10 == 0) ? 1 : 0;
                break;
        }
        sound_play_menu(14);
    }
    else if (input == 1) {
        if (selectedItem == 4) {
            /* Continue to player join */
            menu_transition(20);  /* Player join screen */
            sound_play_menu(10);
        } else if (selectedItem == 5) {
            /* Back */
            menu_back();
        }
    }
    else if (input == 2) {
        menu_back();
    }

    D_80159C00[0] = selectedItem;

    /* Render */
    draw_text(80, 30, "MULTIPLAYER SETUP", 0xFFFFFFFF);

    /* Player count */
    {
        char numBuf[2];
        numBuf[0] = '0' + numPlayers;
        numBuf[1] = '\0';
        draw_text("PLAYERS:", 50, 70, (selectedItem == 0) ? 255 : 180);
        draw_text(numBuf, 140, 70, 255);
    }

    /* Split screen mode */
    draw_text("SCREEN:", 50, 95, (selectedItem == 1) ? 255 : 180);
    {
        char *splitModes[3] = {"HORIZONTAL", "VERTICAL", "QUAD"};
        draw_text(splitModes[D_80159C08], 130, 95, 255);
    }

    /* Handicap */
    draw_text("HANDICAP:", 50, 120, (selectedItem == 2) ? 255 : 180);
    draw_text(D_80159C0C ? "ON" : "OFF", 145, 120, 255);

    /* Team mode */
    draw_text("TEAMS:", 50, 145, (selectedItem == 3) ? 255 : 180);
    draw_text(D_80159C10 ? "ON" : "OFF", 120, 145, 255);

    /* Continue */
    draw_text("CONTINUE", 100, 180, (selectedItem == 4) ? 255 : 180);

    /* Back */
    draw_text("BACK", 100, 205, (selectedItem == 5) ? 255 : 180);

    /* Player preview boxes */
    for (i = 0; i < numPlayers; i++) {
        s32 boxX = 200 + (i % 2) * 55;
        s32 boxY = 70 + (i / 2) * 55;
        draw_ui_element(68, boxX, boxY, 50, 50, 200);  /* Player box */
        {
            char pNum[3];
            pNum[0] = 'P';
            pNum[1] = '1' + i;
            pNum[2] = '\0';
            draw_text(pNum, boxX + 18, boxY + 18, 255);
        }
    }

    /* Draw cursor */
    s32 cursorY = 70 + selectedItem * 25;
    if (selectedItem >= 4) cursorY = 180 + (selectedItem - 4) * 25;
    draw_ui_element(56, 30, cursorY, 12, 12, 255);
}

/*

 * func_800D349C (1676 bytes)
 * Player join screen - players press start to join
 */
void func_800D349C(void) {
    s32 i;
    s32 numPlayers;
    s32 joinedPlayers;
    s32 allReady;
    u32 controllerInput[4];

    numPlayers = D_80159C04;
    joinedPlayers = 0;
    allReady = 1;

    func_800CC040();

    /* Read all controller inputs */
    controllerInput[0] = D_80158100;
    controllerInput[1] = D_80158104;
    controllerInput[2] = D_80158108;
    controllerInput[3] = D_8015810C;

    /* Check each player slot */
    for (i = 0; i < numPlayers; i++) {
        s32 buttons = controllerInput[i] & 0xFFFF;

        /* Check for Start button to join */
        if (buttons & 0x1000) {
            if (D_80159C20[i] == 0) {
                /* Player joining */
                D_80159C20[i] = 1;
                sound_play_menu(10);
            } else if (D_80159C20[i] == 1) {
                /* Player ready */
                D_80159C20[i] = 2;
                sound_play_menu(10);
            }
        }

        /* Check for B button to leave */
        if (buttons & 0x4000) {
            if (D_80159C20[i] == 2) {
                D_80159C20[i] = 1;  /* Unready */
                sound_play_menu(11);
            } else if (D_80159C20[i] == 1) {
                D_80159C20[i] = 0;  /* Leave */
                sound_play_menu(11);
            }
        }

        /* Count joined and check ready */
        if (D_80159C20[i] >= 1) {
            joinedPlayers++;
        }
        if (D_80159C20[i] != 2) {
            allReady = 0;
        }
    }

    /* Check if all required players are ready */
    if (joinedPlayers >= 2 && allReady) {
        D_80159C14 = D_80159C14 + 1;  /* Countdown timer */
        if (D_80159C14 >= 90) {  /* 1.5 seconds */
            /* Start game */
            D_80159C18 = joinedPlayers;
            D_801146EC = 7;  /* PREPLAY state */
            menu_transition(-1);
        }
    } else {
        D_80159C14 = 0;
    }

    /* Player 1 can press B to go back if no one joined */
    if ((controllerInput[0] & 0x4000) && joinedPlayers == 0) {
        menu_back();
    }

    /* Render */
    draw_text(70, 30, "PRESS START TO JOIN", 0xFFFFFFFF);

    /* Render player slots */
    for (i = 0; i < numPlayers; i++) {
        s32 slotX = 40 + (i % 2) * 140;
        s32 slotY = 70 + (i / 2) * 90;
        s32 state = D_80159C20[i];
        s32 alpha;
        char playerStr[12];

        /* Draw slot background */
        if (state == 0) {
            alpha = 100;  /* Empty */
        } else if (state == 1) {
            alpha = 180;  /* Joined */
        } else {
            alpha = 255;  /* Ready */
        }
        draw_ui_element(69, slotX, slotY, 120, 75, alpha);

        /* Draw player number */
        playerStr[0] = 'P';
        playerStr[1] = 'L';
        playerStr[2] = 'A';
        playerStr[3] = 'Y';
        playerStr[4] = 'E';
        playerStr[5] = 'R';
        playerStr[6] = ' ';
        playerStr[7] = '1' + i;
        playerStr[8] = '\0';
        draw_text(playerStr, slotX + 20, slotY + 10, alpha);

        /* Draw status */
        if (state == 0) {
            draw_text("PRESS START", slotX + 10, slotY + 40, alpha);
        } else if (state == 1) {
            draw_text("JOINED", slotX + 30, slotY + 40, alpha);
            draw_text("START=READY", slotX + 8, slotY + 55, 150);
        } else {
            draw_text("READY!", slotX + 35, slotY + 40, 255);
        }
    }

    /* Show countdown if all ready */
    if (joinedPlayers >= 2 && allReady) {
        s32 countdown = 3 - (D_80159C14 / 30);
        char countBuf[2];
        countBuf[0] = '0' + countdown;
        countBuf[1] = '\0';
        draw_text(100, 200, "STARTING IN", 0xFFFFFFFF);
        draw_text(countBuf, 155, 220, 255);
    } else if (joinedPlayers < 2) {
        draw_text(90, 210, "NEED 2+ PLAYERS", 0xFFFFFFB4);
    }
}

/*

 * func_800D3B28 (5068 bytes)
 * Stunt mode setup - configure stunt arena and scoring
 */
void func_800D3B28(void) {
    s32 input;
    s32 menuState;
    s32 selectedOption;
    s32 selectedArena;
    s32 timeLimit;
    s32 targetScore;
    s32 wingEnabled;
    s32 i;
    char *arenaNames[8];
    s32 arenaUnlocked[8];
    s32 targetScores[6];
    s32 timeLimits[5];
    char scoreStr[16];
    char timeStr[16];

    arenaNames[0] = "ALCATRAZ";
    arenaNames[1] = "METRO";
    arenaNames[2] = "PIER 39";
    arenaNames[3] = "GOLDEN GATE";
    arenaNames[4] = "TWIN PEAKS";
    arenaNames[5] = "DOWNTOWN";
    arenaNames[6] = "OBSTACLE";
    arenaNames[7] = "FREEFORM";

    targetScores[0] = 10000;
    targetScores[1] = 25000;
    targetScores[2] = 50000;
    targetScores[3] = 100000;
    targetScores[4] = 250000;
    targetScores[5] = 0;  /* No limit */

    timeLimits[0] = 60;   /* 1 minute */
    timeLimits[1] = 120;  /* 2 minutes */
    timeLimits[2] = 180;  /* 3 minutes */
    timeLimits[3] = 300;  /* 5 minutes */
    timeLimits[4] = 0;    /* No limit */

    menuState = D_80159E00;
    selectedOption = D_80159E04;
    selectedArena = D_80159E08;
    timeLimit = D_80159E0C;
    targetScore = D_80159E10;
    wingEnabled = D_80159E14;

    func_800CC040();

    /* Check arena unlock status */
    for (i = 0; i < 8; i++) {
        arenaUnlocked[i] = func_800D3430(i, 0, NULL, NULL, 0);
    }

    input = func_800CB748(D_80158100);

    if (menuState == 0) {
        /* Main stunt setup menu */
        if (input == 4) {  /* Up */
            selectedOption--;
            if (selectedOption < 0) selectedOption = 5;
            sound_play_menu(12);
        } else if (input == 5) {  /* Down */
            selectedOption++;
            if (selectedOption > 5) selectedOption = 0;
            sound_play_menu(12);
        } else if (input == 6 || input == 7) {  /* Left/Right */
            /* Adjust option value */
            if (selectedOption == 0) {
                /* Arena selection */
                if (input == 6) {
                    selectedArena--;
                    if (selectedArena < 0) selectedArena = 7;
                } else {
                    selectedArena++;
                    if (selectedArena > 7) selectedArena = 0;
                }
                /* Skip locked arenas */
                while (!arenaUnlocked[selectedArena]) {
                    if (input == 6) {
                        selectedArena--;
                        if (selectedArena < 0) selectedArena = 7;
                    } else {
                        selectedArena++;
                        if (selectedArena > 7) selectedArena = 0;
                    }
                }
            } else if (selectedOption == 1) {
                /* Time limit */
                if (input == 6) {
                    timeLimit--;
                    if (timeLimit < 0) timeLimit = 4;
                } else {
                    timeLimit++;
                    if (timeLimit > 4) timeLimit = 0;
                }
            } else if (selectedOption == 2) {
                /* Target score */
                if (input == 6) {
                    targetScore--;
                    if (targetScore < 0) targetScore = 5;
                } else {
                    targetScore++;
                    if (targetScore > 5) targetScore = 0;
                }
            } else if (selectedOption == 3) {
                /* Wings enabled */
                wingEnabled = !wingEnabled;
            }
            sound_play_menu(12);
        } else if (input == 1) {  /* A - select */
            if (selectedOption == 4) {
                /* Start stunt mode */
                if (arenaUnlocked[selectedArena]) {
                    D_80159E08 = selectedArena;
                    D_80159E0C = timeLimit;
                    D_80159E10 = targetScore;
                    D_80159E14 = wingEnabled;
                    D_80159A08 = selectedArena + 100;  /* Stunt arena IDs */
                    D_801146EC = 7;  /* PREPLAY */
                    menu_transition(-1);
                }
            } else if (selectedOption == 5) {
                /* Stunt tutorial */
                menuState = 1;
            }
        } else if (input == 2) {  /* B - back */
            menu_back();
        }

        /* Render stunt setup menu */
        draw_text(105, 20, "STUNT MODE", 0xFFFFFFFF);

        /* Arena selection */
        draw_text("ARENA", 40, 55, selectedOption == 0 ? 255 : 180);
        draw_text(arenaNames[selectedArena], 140, 55, arenaUnlocked[selectedArena] ? 255 : 100);
        if (!arenaUnlocked[selectedArena]) {
            draw_ui_element(61, 230, 53, 16, 16, 180);  /* Lock icon */
        }
        /* Arrow indicators */
        draw_text("<", 125, 55, selectedOption == 0 ? 200 : 100);
        draw_text(">", 250, 55, selectedOption == 0 ? 200 : 100);

        /* Time limit */
        draw_text("TIME LIMIT", 40, 80, selectedOption == 1 ? 255 : 180);
        if (timeLimits[timeLimit] == 0) {
            draw_text(160, 80, "UNLIMITED", 0xFFFFFFFF);
        } else {
            s32 mins = timeLimits[timeLimit] / 60;
            s32 secs = timeLimits[timeLimit] % 60;
            timeStr[0] = '0' + mins;
            timeStr[1] = ':';
            timeStr[2] = '0' + (secs / 10);
            timeStr[3] = '0' + (secs % 10);
            timeStr[4] = '\0';
            draw_text(timeStr, 175, 80, 255);
        }
        draw_text("<", 145, 80, selectedOption == 1 ? 200 : 100);
        draw_text(">", 220, 80, selectedOption == 1 ? 200 : 100);

        /* Target score */
        draw_text("TARGET SCORE", 40, 105, selectedOption == 2 ? 255 : 180);
        if (targetScores[targetScore] == 0) {
            draw_text(180, 105, "NONE", 0xFFFFFFFF);
        } else {
            func_800A2CE4((void**)scoreStr);  /* TODO: stub */
            draw_text(scoreStr, 165, 105, 255);
        }
        draw_text("<", 150, 105, selectedOption == 2 ? 200 : 100);
        draw_text(">", 225, 105, selectedOption == 2 ? 200 : 100);

        /* Wings toggle */
        draw_text("WINGS", 40, 130, selectedOption == 3 ? 255 : 180);
        draw_text(wingEnabled ? "ON" : "OFF", 180, 130, wingEnabled ? 200 : 150);

        /* Start button */
        draw_text("START STUNT MODE", 75, 165, selectedOption == 4 ? 255 : 180);

        /* Tutorial button */
        draw_text("STUNT TUTORIAL", 85, 190, selectedOption == 5 ? 255 : 180);

        /* Arena preview */
        func_800D3E50(selectedArena);

    } else if (menuState == 1) {
        /* Stunt tutorial screen */
        input = func_800CB748(D_80158100);

        if (input == 2 || input == 1) {  /* B or A to go back */
            menuState = 0;
        }

        draw_text(95, 20, "STUNT TUTORIAL", 0xFFFFFFFF);
        draw_text(60, 50, "TRICKS AND SCORING:", 0xFFFFFFFF);

        draw_text(40, 75, "BARREL ROLL", 0xFFFFFFDC);
        draw_text(40, 88, "- Spin car while airborne", 0xFFFFFFB4);
        draw_text(40, 101, "- 500 pts per rotation", 0xFFFFFFB4);

        draw_text(40, 120, "FLIP", 0xFFFFFFDC);
        draw_text(40, 133, "- Front/back flip in air", 0xFFFFFFB4);
        draw_text(40, 146, "- 750 pts per flip", 0xFFFFFFB4);

        draw_text(40, 165, "WING GLIDE", 0xFFFFFFDC);
        draw_text(40, 178, "- Hold Z to deploy wings", 0xFFFFFFB4);
        draw_text(40, 191, "- 100 pts per second", 0xFFFFFFB4);

        draw_text(40, 210, "COMBO BONUS", 0xFFFFFFDC);
        draw_text(40, 223, "- Chain tricks for 2x-5x", 0xFFFFFFB4);

        draw_text(85, 250, "PRESS B TO RETURN", 0xFFFFFF96);
    }

    D_80159E00 = menuState;
    D_80159E04 = selectedOption;
    D_80159E08 = selectedArena;
    D_80159E0C = timeLimit;
    D_80159E10 = targetScore;
    D_80159E14 = wingEnabled;
}

/*

 * func_800D3E50 (384 bytes)
 * Render stunt arena preview
 */
void func_800D3E50(s32 arenaId) {
    s32 previewX = 160;
    s32 previewY = 160;
    s32 previewW = 100;
    s32 previewH = 60;

    /* Draw preview frame */
    draw_ui_element(70, previewX - 2, previewY - 2, previewW + 4, previewH + 4, 200);

    /* Load arena preview texture */
    func_800C7454(arenaId + 200, previewX, previewY, previewW, previewH, 255);

    /* Arena difficulty indicator */
    draw_text(165, 225, "DIFF:", 0xFFFFFFB4);
    if (arenaId < 2) {
        draw_text(205, 225, "EASY", 0xFFFFFF64);
    } else if (arenaId < 5) {
        draw_text(205, 225, "MEDIUM", 0xFFFFFFC8);
    } else {
        draw_text(205, 225, "HARD", 0xFFFFFFFF);
    }
}

/*

 * func_800D4EF4 (532 bytes)
 * Battle mode setup - configure battle arena and rules
 */
void func_800D4EF4(void) {
    s32 input;
    s32 selectedOption;
    s32 selectedArena;
    s32 fragLimit;
    s32 timeLimit;
    s32 weaponsEnabled;
    char *arenaNames[4];
    s32 fragLimits[5];
    s32 timeLimits[4];
    char fragStr[8];
    char timeStr[8];

    arenaNames[0] = "WAREHOUSE";
    arenaNames[1] = "ROOFTOPS";
    arenaNames[2] = "DOCKS";
    arenaNames[3] = "FACTORY";

    fragLimits[0] = 5;
    fragLimits[1] = 10;
    fragLimits[2] = 15;
    fragLimits[3] = 20;
    fragLimits[4] = 0;  /* No limit */

    timeLimits[0] = 180;   /* 3 minutes */
    timeLimits[1] = 300;   /* 5 minutes */
    timeLimits[2] = 600;   /* 10 minutes */
    timeLimits[3] = 0;     /* No limit */

    selectedOption = D_80159E20;
    selectedArena = D_80159E24;
    fragLimit = D_80159E28;
    timeLimit = D_80159E2C;
    weaponsEnabled = D_80159E30;

    func_800CC040();

    input = func_800CB748(D_80158100);

    if (input == 4) {  /* Up */
        selectedOption--;
        if (selectedOption < 0) selectedOption = 5;
        sound_play_menu(12);
    } else if (input == 5) {  /* Down */
        selectedOption++;
        if (selectedOption > 5) selectedOption = 0;
        sound_play_menu(12);
    } else if (input == 6 || input == 7) {  /* Left/Right */
        if (selectedOption == 0) {
            /* Arena selection */
            if (input == 6) {
                selectedArena--;
                if (selectedArena < 0) selectedArena = 3;
            } else {
                selectedArena++;
                if (selectedArena > 3) selectedArena = 0;
            }
        } else if (selectedOption == 1) {
            /* Frag limit */
            if (input == 6) {
                fragLimit--;
                if (fragLimit < 0) fragLimit = 4;
            } else {
                fragLimit++;
                if (fragLimit > 4) fragLimit = 0;
            }
        } else if (selectedOption == 2) {
            /* Time limit */
            if (input == 6) {
                timeLimit--;
                if (timeLimit < 0) timeLimit = 3;
            } else {
                timeLimit++;
                if (timeLimit > 3) timeLimit = 0;
            }
        } else if (selectedOption == 3) {
            /* Weapons */
            weaponsEnabled = !weaponsEnabled;
        }
        sound_play_menu(12);
    } else if (input == 1) {  /* A - select */
        if (selectedOption == 4) {
            /* Player count check */
            if (D_80159C18 >= 2) {
                D_80159E24 = selectedArena;
                D_80159E28 = fragLimit;
                D_80159E2C = timeLimit;
                D_80159E30 = weaponsEnabled;
                D_80159A08 = selectedArena + 200;  /* Battle arena IDs */
                D_801146EC = 7;  /* PREPLAY */
                menu_transition(-1);
            } else {
                sound_play_menu(13);  /* Error sound */
            }
        } else if (selectedOption == 5) {
            /* Go to player join */
            menu_transition(15);
        }
    } else if (input == 2) {  /* B - back */
        menu_back();
    }

    /* Render */
    draw_text(100, 20, "BATTLE MODE", 0xFFFFFFFF);

    /* Arena */
    draw_text("ARENA", 40, 55, selectedOption == 0 ? 255 : 180);
    draw_text(arenaNames[selectedArena], 150, 55, 255);
    draw_text("<", 135, 55, selectedOption == 0 ? 200 : 100);
    draw_text(">", 240, 55, selectedOption == 0 ? 200 : 100);

    /* Frag limit */
    draw_text("FRAG LIMIT", 40, 80, selectedOption == 1 ? 255 : 180);
    if (fragLimits[fragLimit] == 0) {
        draw_text(160, 80, "UNLIMITED", 0xFFFFFFFF);
    } else {
        fragStr[0] = '0' + (fragLimits[fragLimit] / 10);
        fragStr[1] = '0' + (fragLimits[fragLimit] % 10);
        fragStr[2] = '\0';
        draw_text(fragStr, 185, 80, 255);
    }
    draw_text("<", 145, 80, selectedOption == 1 ? 200 : 100);
    draw_text(">", 215, 80, selectedOption == 1 ? 200 : 100);

    /* Time limit */
    draw_text("TIME LIMIT", 40, 105, selectedOption == 2 ? 255 : 180);
    if (timeLimits[timeLimit] == 0) {
        draw_text(160, 105, "UNLIMITED", 0xFFFFFFFF);
    } else {
        s32 mins = timeLimits[timeLimit] / 60;
        timeStr[0] = '0' + (mins / 10);
        timeStr[1] = '0' + (mins % 10);
        timeStr[2] = ':';
        timeStr[3] = '0';
        timeStr[4] = '0';
        timeStr[5] = '\0';
        draw_text(timeStr, 170, 105, 255);
    }
    draw_text("<", 155, 105, selectedOption == 2 ? 200 : 100);
    draw_text(">", 225, 105, selectedOption == 2 ? 200 : 100);

    /* Weapons toggle */
    draw_text("WEAPONS", 40, 130, selectedOption == 3 ? 255 : 180);
    draw_text(weaponsEnabled ? "ON" : "OFF", 180, 130, weaponsEnabled ? 200 : 150);

    /* Start button */
    draw_text("START BATTLE", 90, 165, selectedOption == 4 ? 255 : 180);
    if (D_80159C18 < 2) {
        draw_text(75, 180, "(NEED 2+ PLAYERS)", 0xFFFFFF78);
    }

    /* Player select */
    draw_text("SELECT PLAYERS", 85, 200, selectedOption == 5 ? 255 : 180);

    D_80159E20 = selectedOption;
    D_80159E24 = selectedArena;
    D_80159E28 = fragLimit;
    D_80159E2C = timeLimit;
    D_80159E30 = weaponsEnabled;
}

/*

 * func_800D510C (716 bytes)
 * Ghost race setup - race against saved ghosts
 */
void func_800D510C(void) {
    s32 input;
    s32 selectedOption;
    s32 selectedTrack;
    s32 selectedGhost;
    s32 ghostCount;
    s32 i;
    char *trackNames[12];
    char *ghostNames[4];
    s32 ghostTimes[4];
    char timeStr[12];

    trackNames[0] = "MARINA";
    trackNames[1] = "HAIGHT";
    trackNames[2] = "SOMA";
    trackNames[3] = "MISSION";
    trackNames[4] = "NOB HILL";
    trackNames[5] = "EMBARCADERO";
    trackNames[6] = "PRESIDIO";
    trackNames[7] = "SUNSET";
    trackNames[8] = "RICHMOND";
    trackNames[9] = "BAY BRIDGE";
    trackNames[10] = "GOLDEN GATE";
    trackNames[11] = "ALCATRAZ";

    selectedOption = D_80159E40;
    selectedTrack = D_80159E44;
    selectedGhost = D_80159E48;

    func_800CC040();

    /* Get available ghosts for selected track */
    ghostCount = func_800D5430(selectedTrack, ghostNames, ghostTimes);

    input = func_800CB748(D_80158100);

    if (input == 4) {  /* Up */
        selectedOption--;
        if (selectedOption < 0) selectedOption = 3;
        sound_play_menu(12);
    } else if (input == 5) {  /* Down */
        selectedOption++;
        if (selectedOption > 3) selectedOption = 0;
        sound_play_menu(12);
    } else if (input == 6 || input == 7) {  /* Left/Right */
        if (selectedOption == 0) {
            /* Track selection */
            if (input == 6) {
                selectedTrack--;
                if (selectedTrack < 0) selectedTrack = 11;
            } else {
                selectedTrack++;
                if (selectedTrack > 11) selectedTrack = 0;
            }
            selectedGhost = 0;  /* Reset ghost selection */
        } else if (selectedOption == 1) {
            /* Ghost selection */
            if (ghostCount > 0) {
                if (input == 6) {
                    selectedGhost--;
                    if (selectedGhost < 0) selectedGhost = ghostCount - 1;
                } else {
                    selectedGhost++;
                    if (selectedGhost >= ghostCount) selectedGhost = 0;
                }
            }
        }
        sound_play_menu(12);
    } else if (input == 1) {  /* A - select */
        if (selectedOption == 2) {
            /* Start ghost race */
            if (ghostCount > 0) {
                D_80159E44 = selectedTrack;
                D_80159E48 = selectedGhost;
                D_80159A08 = selectedTrack;
                D_80159A14[0] = 1;  /* Ghost mode enabled */
                D_801146EC = 7;  /* PREPLAY */
                menu_transition(-1);
            } else {
                sound_play_menu(13);  /* Error - no ghost */
            }
        } else if (selectedOption == 3) {
            /* Delete ghost */
            if (ghostCount > 0) {
                func_800D55A0(selectedTrack, selectedGhost);
                sound_play_menu(14);
                if (selectedGhost >= ghostCount - 1) {
                    selectedGhost = 0;
                }
            }
        }
    } else if (input == 2) {  /* B - back */
        menu_back();
    }

    /* Render */
    draw_text(105, 20, "GHOST RACE", 0xFFFFFFFF);

    /* Track selection */
    draw_text("TRACK", 40, 55, selectedOption == 0 ? 255 : 180);
    draw_text(trackNames[selectedTrack], 140, 55, 255);
    draw_text("<", 125, 55, selectedOption == 0 ? 200 : 100);
    draw_text(">", 240, 55, selectedOption == 0 ? 200 : 100);

    /* Ghost selection */
    draw_text("GHOST", 40, 80, selectedOption == 1 ? 255 : 180);
    if (ghostCount > 0) {
        draw_text(ghostNames[selectedGhost], 140, 80, 255);

        /* Format ghost time */
        s32 ghostTime = ghostTimes[selectedGhost];
        s32 mins = ghostTime / 6000;
        s32 secs = (ghostTime / 100) % 60;
        s32 cents = ghostTime % 100;
        timeStr[0] = '0' + mins;
        timeStr[1] = ':';
        timeStr[2] = '0' + (secs / 10);
        timeStr[3] = '0' + (secs % 10);
        timeStr[4] = '.';
        timeStr[5] = '0' + (cents / 10);
        timeStr[6] = '0' + (cents % 10);
        timeStr[7] = '\0';
        draw_text(timeStr, 140, 95, 200);

        draw_text("<", 125, 80, selectedOption == 1 ? 200 : 100);
        draw_text(">", 240, 80, selectedOption == 1 ? 200 : 100);
    } else {
        draw_text(120, 80, "NO GHOSTS SAVED", 0xFFFFFF78);
    }

    /* Start button */
    draw_text("START RACE", 95, 130, selectedOption == 2 ? 255 : 180);
    if (ghostCount == 0) {
        draw_text(100, 145, "(NO GHOST)", 0xFFFFFF78);
    }

    /* Delete button */
    draw_text("DELETE GHOST", 90, 165, selectedOption == 3 ? 255 : 180);

    /* Ghost count indicator */
    draw_text(40, 200, "SAVED GHOSTS:", 0xFFFFFFB4);
    {
        char countStr[4];
        countStr[0] = '0' + ghostCount;
        countStr[1] = '/';
        countStr[2] = '4';
        countStr[3] = '\0';
        draw_text(countStr, 160, 200, 200);
    }

    D_80159E40 = selectedOption;
    D_80159E44 = selectedTrack;
    D_80159E48 = selectedGhost;
}

/*

 * func_800D5430 (164 bytes)
 * Get saved ghosts for track
 */
s32 func_800D5430(s32 trackId, char **names, s32 *times) {
    s32 count = 0;
    s32 i;

    /* Read ghost data from controller pak */
    for (i = 0; i < 4; i++) {
        s32 ghostData = D_80159F00[trackId * 4 + i];
        if (ghostData != 0) {
            /* Ghost exists */
            times[count] = ghostData & 0xFFFFFF;  /* Time in lower 24 bits */
            names[count] = "GHOST";  /* Default name */
            count++;
        }
    }

    return count;
}

/*

 * func_800D55A0 (96 bytes)
 * Delete saved ghost
 */
void func_800D55A0(s32 trackId, s32 ghostIndex) {
    s32 i;
    s32 baseIdx = trackId * 4;

    /* Shift ghosts down */
    for (i = ghostIndex; i < 3; i++) {
        D_80159F00[baseIdx + i] = D_80159F00[baseIdx + i + 1];
    }
    D_80159F00[baseIdx + 3] = 0;  /* Clear last slot */
}

/*

 * func_800D58CC (740 bytes)
 * Records screen - displays best times and high scores
 */
void func_800D58CC(void) {
    s32 input;
    s32 selectedTab;
    s32 selectedTrack;

    selectedTab = D_80159D00;
    selectedTrack = D_80159D04;

    func_800CC040();

    input = func_800CB748(D_80158100);

    /* Tab navigation with L/R */
    if (input == 8) {  /* L */
        selectedTab = (selectedTab + 2) % 3;  /* Times, Scores, Stats */
        sound_play_menu(12);
    }
    else if (input == 9) {  /* R */
        selectedTab = (selectedTab + 1) % 3;
        sound_play_menu(12);
    }
    /* Track selection */
    else if (input == 4) {
        selectedTrack--;
        if (selectedTrack < 0) selectedTrack = 11;
        sound_play_menu(12);
    }
    else if (input == 5) {
        selectedTrack++;
        if (selectedTrack > 11) selectedTrack = 0;
        sound_play_menu(12);
    }
    else if (input == 2) {
        menu_back();
    }

    D_80159D00[0] = selectedTab;
    D_80159D04 = selectedTrack;

    /* Render tabs */
    draw_text("TIMES", 50, 30, (selectedTab == 0) ? 255 : 150);
    draw_text("SCORES", 130, 30, (selectedTab == 1) ? 255 : 150);
    draw_text("STATS", 220, 30, (selectedTab == 2) ? 255 : 150);

    /* Render content based on tab */
    switch (selectedTab) {
        case 0:
            func_800D5BB0(selectedTrack);
            break;
        case 1:
            func_800D5C90(selectedTrack);
            break;
        case 2:
            func_800D616C();
            break;
    }

    draw_text(80, 220, "L/R: CHANGE TAB", 0xFFFFFF96);
}

/*

 * func_800D5BB0 (224 bytes)
 * Best times display - shows best lap and race times
 */
void func_800D5BB0(s32 trackId) {
    char *trackNames[12];
    char timeBuf[16];
    s32 bestTime;
    s32 bestLap;
    s32 i;

    trackNames[0] = "MARINA";
    trackNames[1] = "HAIGHT";
    trackNames[2] = "SOMA";
    trackNames[3] = "MISSION";
    trackNames[4] = "NOB HILL";
    trackNames[5] = "CHINATOWN";
    trackNames[6] = "FISHERMAN'S";
    trackNames[7] = "ALCATRAZ";
    trackNames[8] = "BONUS 1";
    trackNames[9] = "BONUS 2";
    trackNames[10] = "BONUS 3";
    trackNames[11] = "STUNT ARENA";

    draw_text(105, 55, "BEST TIMES", 0xFFFFFFFF);
    draw_text(trackNames[trackId], 100, 80, 255);

    /* Best race time */
    bestTime = D_80159A10[trackId];
    draw_text(60, 110, "RACE:", 0xFFFFFFC8);
    if (bestTime > 0) {
        s32 m = bestTime / 6000;
        s32 s = (bestTime / 100) % 60;
        s32 h = bestTime % 100;
        timeBuf[0] = '0' + m / 10; timeBuf[1] = '0' + m % 10;
        timeBuf[2] = ':';
        timeBuf[3] = '0' + s / 10; timeBuf[4] = '0' + s % 10;
        timeBuf[5] = '.';
        timeBuf[6] = '0' + h / 10; timeBuf[7] = '0' + h % 10;
        timeBuf[8] = '\0';
        draw_text(timeBuf, 120, 110, 255);
    } else {
        draw_text(120, 110, "--:--.--", 0xFFFFFF96);
    }

    /* Best lap time */
    bestLap = D_80159D10[trackId];
    draw_text(60, 135, "LAP:", 0xFFFFFFC8);
    if (bestLap > 0) {
        s32 m = bestLap / 6000;
        s32 s = (bestLap / 100) % 60;
        s32 h = bestLap % 100;
        timeBuf[0] = '0' + m / 10; timeBuf[1] = '0' + m % 10;
        timeBuf[2] = ':';
        timeBuf[3] = '0' + s / 10; timeBuf[4] = '0' + s % 10;
        timeBuf[5] = '.';
        timeBuf[6] = '0' + h / 10; timeBuf[7] = '0' + h % 10;
        timeBuf[8] = '\0';
        draw_text(timeBuf, 110, 135, 255);
    } else {
        draw_text(110, 135, "--:--.--", 0xFFFFFF96);
    }

    /* Navigation hint */
    draw_text(85, 180, "UP/DOWN: TRACK", 0xFFFFFF96);
}

/*

 * func_800D5C90 (220 bytes)
 * High scores display - shows stunt high scores
 */
void func_800D5C90(s32 trackId) {
    s32 i;
    s32 score;
    char scoreBuf[12];
    char nameBuf[8];

    draw_text(100, 55, "HIGH SCORES", 0xFFFFFFFF);

    /* Display top 5 scores */
    for (i = 0; i < 5; i++) {
        s32 y = 90 + i * 22;
        char rankBuf[3];

        rankBuf[0] = '1' + i;
        rankBuf[1] = '.';
        rankBuf[2] = '\0';
        draw_text(rankBuf, 50, y, 200);

        /* Get name and score from save data */
        score = D_80159D40[trackId * 5 + i];
        if (score > 0) {
            /* Format score */
            s32 tmp = score;
            s32 j;
            for (j = 7; j >= 0; j--) {
                scoreBuf[j] = '0' + (tmp % 10);
                tmp = tmp / 10;
            }
            scoreBuf[8] = '\0';
            draw_text(scoreBuf, 130, y, 255);

            /* Name would be stored elsewhere */
            draw_text("---", 80, y, 200);
        } else {
            draw_text("---", 80, y, 150);
            draw_text("--------", 130, y, 150);
        }
    }
}

/*

 * func_800D616C (452 bytes)
 * Stats display - shows player statistics
 */
void func_800D616C(void) {
    s32 totalRaces;
    s32 totalWins;
    s32 totalStunts;
    s32 totalDistance;
    char numBuf[12];

    totalRaces = D_80159D80;
    totalWins = D_80159D84;
    totalStunts = D_80159D88;
    totalDistance = D_80159D8C;  /* In meters */

    draw_text(105, 55, "STATISTICS", 0xFFFFFFFF);

    /* Total races */
    draw_text(60, 90, "RACES:", 0xFFFFFFC8);
    {
        s32 tmp = totalRaces;
        s32 i;
        for (i = 5; i >= 0; i--) {
            numBuf[i] = '0' + (tmp % 10);
            tmp = tmp / 10;
        }
        numBuf[6] = '\0';
        draw_text(numBuf, 140, 90, 255);
    }

    /* Wins */
    draw_text(60, 115, "WINS:", 0xFFFFFFC8);
    {
        s32 tmp = totalWins;
        s32 i;
        for (i = 5; i >= 0; i--) {
            numBuf[i] = '0' + (tmp % 10);
            tmp = tmp / 10;
        }
        numBuf[6] = '\0';
        draw_text(numBuf, 130, 115, 255);
    }

    /* Win percentage */
    if (totalRaces > 0) {
        s32 pct = (totalWins * 100) / totalRaces;
        numBuf[0] = '0' + (pct / 10);
        numBuf[1] = '0' + (pct % 10);
        numBuf[2] = '%';
        numBuf[3] = '\0';
        draw_text(numBuf, 210, 115, 255);
    }

    /* Stunts */
    draw_text(60, 140, "STUNTS:", 0xFFFFFFC8);
    {
        s32 tmp = totalStunts;
        s32 i;
        for (i = 5; i >= 0; i--) {
            numBuf[i] = '0' + (tmp % 10);
            tmp = tmp / 10;
        }
        numBuf[6] = '\0';
        draw_text(numBuf, 150, 140, 255);
    }

    /* Distance */
    draw_text(60, 165, "DISTANCE:", 0xFFFFFFC8);
    {
        s32 km = totalDistance / 1000;
        s32 i;
        for (i = 5; i >= 0; i--) {
            numBuf[i] = '0' + (km % 10);
            km = km / 10;
        }
        numBuf[6] = ' ';
        numBuf[7] = 'K';
        numBuf[8] = 'M';
        numBuf[9] = '\0';
        draw_text(numBuf, 165, 165, 255);
    }
}

/*

 * func_800D63F4 (676 bytes)
 * Achievements screen - shows unlocked achievements
 */
void func_800D63F4(void) {
    s32 input;
    s32 scrollOffset;
    s32 i;
    s32 numAchievements;
    char *achievementNames[16];
    s32 unlocked;

    achievementNames[0] = "FIRST RACE";
    achievementNames[1] = "SPEED DEMON";
    achievementNames[2] = "PERFECT LAP";
    achievementNames[3] = "STUNT MASTER";
    achievementNames[4] = "TRACK CHAMPION";
    achievementNames[5] = "CAR COLLECTOR";
    achievementNames[6] = "GOLD RUSH";
    achievementNames[7] = "ENDURANCE";
    achievementNames[8] = "TRICK SHOT";
    achievementNames[9] = "AIRBORNE";
    achievementNames[10] = "BATTLE WINNER";
    achievementNames[11] = "COMPLETIONIST";
    achievementNames[12] = NULL;

    numAchievements = 12;
    scrollOffset = D_80159DA0;

    func_800CC040();

    input = func_800CB748(D_80158100);

    if (input == 4) {
        scrollOffset--;
        if (scrollOffset < 0) scrollOffset = 0;
        sound_play_menu(12);
    }
    else if (input == 5) {
        scrollOffset++;
        if (scrollOffset > numAchievements - 6) scrollOffset = numAchievements - 6;
        sound_play_menu(12);
    }
    else if (input == 2) {
        menu_back();
    }

    D_80159DA0 = scrollOffset;

    draw_text(95, 30, "ACHIEVEMENTS", 0xFFFFFFFF);

    /* Display achievements */
    for (i = 0; i < 6 && (scrollOffset + i) < numAchievements; i++) {
        s32 achIdx = scrollOffset + i;
        s32 y = 65 + i * 25;

        unlocked = D_80159DA4 & (1 << achIdx);

        if (unlocked) {
            draw_ui_element(70, 50, y, 16, 16, 255);  /* Trophy icon */
            draw_text(achievementNames[achIdx], 75, y, 255);
        } else {
            draw_ui_element(71, 50, y, 16, 16, 100);  /* Locked icon */
            draw_text("???", 75, y, 100);
        }
    }

    /* Scroll indicators */
    if (scrollOffset > 0) {
        draw_ui_element(62, 160, 55, 16, 12, 180);
    }
    if (scrollOffset < numAchievements - 6) {
        draw_ui_element(63, 160, 220, 16, 12, 180);
    }
}

/*

 * func_800D6698 (296 bytes)
 * Credits screen - displays game credits
 */
void func_800D6698(void) {
    s32 input;

    func_800CC040();
    func_800D67C0();  /* Update scroll */

    input = func_800CB748(D_80158100);

    /* Any button to exit */
    if (input == 1 || input == 2) {
        menu_back();
    }

    /* Title */
    draw_text(120, 20, "CREDITS", 0xFFFFFFFF);
}

/*

 * func_800D67C0 (348 bytes)
 * Credits scroll - scrolls credits text
 */
void func_800D67C0(void) {
    s32 scrollY;
    s32 i;
    char *credits[20];

    credits[0] = "SAN FRANCISCO RUSH 2049";
    credits[1] = "";
    credits[2] = "DEVELOPED BY";
    credits[3] = "ATARI GAMES";
    credits[4] = "";
    credits[5] = "LEAD PROGRAMMER";
    credits[6] = "JOHN DOE";
    credits[7] = "";
    credits[8] = "GRAPHICS";
    credits[9] = "JANE SMITH";
    credits[10] = "";
    credits[11] = "SOUND";
    credits[12] = "AUDIO TEAM";
    credits[13] = "";
    credits[14] = "SPECIAL THANKS";
    credits[15] = "PLAYERS LIKE YOU";
    credits[16] = "";
    credits[17] = "DECOMPILATION BY";
    credits[18] = "THE COMMUNITY";
    credits[19] = NULL;

    scrollY = D_80159DC0;
    D_80159DC0 = scrollY + 1;

    /* Reset scroll when done */
    if (scrollY > 500) {
        D_80159DC0 = -200;
    }

    /* Render visible credits */
    for (i = 0; credits[i] != NULL; i++) {
        s32 y = 50 + i * 20 - scrollY;
        if (y > 20 && y < 230) {
            s32 alpha = 255;
            /* Fade at edges */
            if (y < 60) {
                alpha = (y - 20) * 255 / 40;
            } else if (y > 190) {
                alpha = (230 - y) * 255 / 40;
            }
            draw_text(credits[i], 80, y, alpha);
        }
    }
}

/*
 * func_800D691C (1376 bytes)
 * Loading screen - Displays loading progress bar
 *
 * @param percent Loading progress (0-100)
 */
extern s32 D_8015A700;      /* Loading animation frame */
extern s32 D_8015A704;      /* Last percent shown */

void func_800D691C(s32 percent) {
    s32 frame;
    s32 barWidth;
    s32 dotPhase;

    frame = D_8015A700;
    frame++;

    /* Clamp percent */
    if (percent < 0) percent = 0;
    if (percent > 100) percent = 100;

    /* Clear screen */
    func_800C6E60(0, 0, 320, 240, 0xFF000020);

    /* Game logo area */
    func_800C6E60(80, 40, 160, 60, 0xFF202040);

    /* "LOADING" text */
    draw_text(125, 120, "LOADING", 0xFFFFFFFF);

    /* Animated dots */
    dotPhase = (frame / 20) % 4;
    if (dotPhase >= 1) draw_text(185, 120, ".", 0xFFFFFFFF);
    if (dotPhase >= 2) draw_text(195, 120, ".", 0xFFFFFFFF);
    if (dotPhase >= 3) draw_text(205, 120, ".", 0xFFFFFFFF);

    /* Progress bar background */
    func_800C6E60(60, 150, 200, 20, 0xFF404040);
    func_800C6E60(62, 152, 196, 16, 0xFF202020);

    /* Progress bar fill */
    barWidth = (percent * 192) / 100;
    if (barWidth > 0) {
        func_800C6E60(64, 154, barWidth, 12, 0xFF00AA00);
    }

    /* Percent text */
    {
        char percentStr[8];
        sprintf(percentStr, "%d%%", percent);
        draw_text(percentStr, 145, 180, 200);
    }

    D_8015A700 = frame;
    D_8015A704 = percent;
}

/*
 * func_800D6E7C (852 bytes)
 * Loading tips - Shows random gameplay tip during loading
 */
static const char *loadingTips[] = {
    "Use the handbrake for tight corners!",
    "Collect coins to unlock new cars.",
    "Try different shortcuts on each track.",
    "Wings help with big jumps!",
    "Draft behind other cars for speed.",
    "Hit ramps at full speed for stunts.",
    "Master the tracks in practice mode.",
    "Battle mode: Grab weapons first!"
};
#define NUM_TIPS 8

void func_800D6E7C(void) {
    s32 tipIndex;
    const char *tip;

    /* Select tip based on frame counter */
    tipIndex = (D_80142AFC / 60) % NUM_TIPS;
    tip = loadingTips[tipIndex];

    /* Display tip */
    func_800C6E60(40, 200, 240, 25, 0xC0303050);
    draw_text(50, 207, "TIP:", 0xFFFFFFFF);
    draw_text(90, 207, tip, 0xFFFFFFFF);
}

/*
 * func_800D71D0 (3256 bytes)
 * Pause menu - Full pause menu with options
 */
extern s32 D_8015A710;      /* Pause menu state */
extern s32 D_8015A714;      /* Selected option */
extern s32 D_8015A718;      /* Pause active flag */

void func_800D71D0(void) {
    s32 input;
    s32 selection;
    s32 i;
    const char *options[] = {"RESUME", "RESTART", "OPTIONS", "QUIT"};
    s32 numOptions = 4;

    if (!D_8015A718) {
        return;
    }

    selection = D_8015A714;
    input = func_800CB748(D_80158100);

    /* Navigation */
    if (input == 4) {  /* Up */
        selection--;
        if (selection < 0) selection = numOptions - 1;
        sound_play_menu(12);
    } else if (input == 5) {  /* Down */
        selection++;
        if (selection >= numOptions) selection = 0;
        sound_play_menu(12);
    } else if (input == 1) {  /* A - select */
        sound_play_menu(10);
        switch (selection) {
            case 0:  /* Resume */
                func_800D7E88();
                return;
            case 1:  /* Restart */
                func_800D8184();
                return;
            case 2:  /* Options */
                /* func_800DXXXX(); */
                break;
            case 3:  /* Quit */
                func_800D8C58();
                return;
        }
    } else if (input == 8) {  /* Start - also resume */
        func_800D7E88();
        return;
    }

    /* Draw pause overlay */
    func_800C6E60(0, 0, 320, 240, 0x80000000);  /* Dim background */

    /* Menu box */
    func_800C6E60(90, 60, 140, 120, 0xE0202050);
    func_800C6E60(92, 62, 136, 116, 0xE0303070);

    /* Title */
    draw_text(130, 70, "PAUSED", 0xFFFFFFFF);

    /* Options */
    for (i = 0; i < numOptions; i++) {
        s32 yPos = 100 + i * 25;
        s32 alpha = (i == selection) ? 255 : 150;

        if (i == selection) {
            func_800C6E60(100, yPos - 3, 120, 20, 0x80404080);
            draw_text(105, yPos, ">", 255);
        }

        draw_text(115, yPos, (char*)options[i], alpha);
    }

    D_8015A714 = selection;
}

/*
 * func_800D7E88 (788 bytes)
 * Pause resume - Resumes game from pause
 */
void func_800D7E88(void) {
    D_8015A718 = 0;  /* Clear pause flag */

    /* Resume audio */
    func_800B37E8(0, 0, NULL, 0);  /* Restore audio state */

    /* Resume timers */
    /* D_8015A720 = osGetTime(); */

    /* Play resume sound */
    sound_play_menu(11);
}

/*
 * func_800D8184 (2772 bytes)
 * Pause restart - Restarts current race
 */
void func_800D8184(void) {
    s32 i;
    u8 *carBase;

    D_8015A718 = 0;  /* Clear pause */

    /* Reset all cars to start positions */
    carBase = (u8 *)&D_80152818;
    for (i = 0; i < 4; i++) {
        f32 *pos = (f32 *)(carBase + i * 0x400 + 0x24);
        f32 *vel = (f32 *)(carBase + i * 0x400 + 0x34);
        f32 *rot = (f32 *)(carBase + i * 0x400 + 0x60);

        /* Reset to start grid position */
        pos[0] = *(f32 *)(0x8015C200 + i * 12);
        pos[1] = *(f32 *)(0x8015C204 + i * 12);
        pos[2] = *(f32 *)(0x8015C208 + i * 12);

        /* Clear velocity */
        vel[0] = 0.0f;
        vel[1] = 0.0f;
        vel[2] = 0.0f;

        /* Reset rotation to track start direction */
        rot[0] = 0.0f;
        rot[1] = *(f32 *)0x8015C230;  /* Start heading */
        rot[2] = 0.0f;

        /* Reset race progress */
        *(s32 *)(carBase + i * 0x400 + 0x1A0) = 0;  /* Lap count */
        *(s32 *)(carBase + i * 0x400 + 0x1A8) = 0;  /* Checkpoint */
        *(s32 *)(carBase + i * 0x400 + 0x1AC) = 0;  /* Race time */
    }

    /* Reset race timer */
    D_80142AFC = 0;

    /* Go to countdown state */
    D_801146EC = 5;  /* COUNTDOWN */

    sound_play_menu(14);  /* Restart sound */
}

/*
 * func_800D8C58 (1032 bytes)
 * Pause quit - Quits to main menu
 */
void func_800D8C58(void) {
    D_8015A718 = 0;  /* Clear pause */

    /* Stop all game sounds */
    func_800B557C();

    /* Clear race state */
    func_8010C2FC();

    /* Return to attract mode */
    D_801146EC = 0;  /* ATTRACT */

    sound_play_menu(17);  /* Quit sound */
}

/*
 * func_800D9060 (4204 bytes)
 * Results screen - Displays race results
 */
extern s32 D_8015A730;      /* Results state */
extern s32 D_8015A734;      /* Results timer */

void func_800D9060(void) {
    s32 state;
    s32 timer;
    s32 input;
    s32 i;
    u8 *carBase;

    state = D_8015A730;
    timer = D_8015A734;
    input = func_800CB748(D_80158100);

    timer++;

    /* Exit on input or timeout */
    if (timer > 600 || (timer > 120 && (input == 1 || input == 2))) {
        D_8015A730 = 0;
        D_8015A734 = 0;
        /* Move to next state */
        func_80102A74();  /* Award ceremony */
        return;
    }

    /* Background */
    func_800C6E60(0, 0, 320, 240, 0xFF101030);

    /* Title */
    draw_text(100, 30, "RACE RESULTS", 0xFFFFFFFF);

    /* Results list */
    carBase = (u8 *)&D_80152818;
    for (i = 0; i < 4; i++) {
        s32 position = *(s32 *)(carBase + i * 0x400 + 0x1A4);
        s32 raceTime = *(s32 *)(carBase + i * 0x400 + 0x1AC);
        s32 yPos = 70 + i * 35;

        if (position > 0 && position <= 4) {
            func_800DA0CC(position);  /* Show position */
            func_800DA174(raceTime);  /* Show time */
        }
    }

    /* Points awarded */
    if (timer > 60) {
        func_800DA2D0();
    }

    /* Continue prompt */
    if (timer > 180) {
        s32 blink = (timer / 30) & 1;
        if (blink) {
            draw_text(80, 210, "PRESS A TO CONTINUE", 0xFFFFFFC8);
        }
    }

    D_8015A730 = state;
    D_8015A734 = timer;
}

/*
 * func_800DA0CC (168 bytes)
 * Position result - Displays finishing position
 */
void func_800DA0CC(s32 position) {
    char posStr[8];
    s32 color;

    switch (position) {
        case 1:
            sprintf(posStr, "1ST");
            color = 0xFFD700;  /* Gold */
            break;
        case 2:
            sprintf(posStr, "2ND");
            color = 0xC0C0C0;  /* Silver */
            break;
        case 3:
            sprintf(posStr, "3RD");
            color = 0xCD7F32;  /* Bronze */
            break;
        default:
            sprintf(posStr, "%dTH", position);
            color = 0xFFFFFF;
            break;
    }

    draw_text(posStr, 60, 70 + (position - 1) * 35, (color >> 16) & 0xFF);
}

/*
 * func_800DA174 (348 bytes)
 * Time result - Displays race time
 */
void func_800DA174(s32 timeMs) {
    char timeStr[16];
    s32 mins, secs, ms;

    mins = timeMs / 3600;
    secs = (timeMs / 60) % 60;
    ms = ((timeMs % 60) * 100) / 60;

    sprintf(timeStr, "%d:%02d.%02d", mins, secs, ms);
    draw_text(timeStr, 150, 70, 255);
}

/*
 * func_800DA2D0 (2316 bytes)
 * Points award - Calculates and displays points earned
 */
extern s32 D_8015A740[4];   /* Points per player */
static const s32 positionPoints[] = {10, 6, 4, 2, 1, 0, 0, 0};

void func_800DA2D0(void) {
    s32 i;
    u8 *carBase;
    char pointsStr[16];

    carBase = (u8 *)&D_80152818;

    draw_text(220, 50, "POINTS", 0xFFFFFFC8);

    for (i = 0; i < 4; i++) {
        s32 position = *(s32 *)(carBase + i * 0x400 + 0x1A4);
        s32 points = 0;

        if (position >= 1 && position <= 8) {
            points = positionPoints[position - 1];
        }

        D_8015A740[i] += points;

        sprintf(pointsStr, "+%d", points);
        draw_text(pointsStr, 220, 70 + i * 35, 255);
    }
}

/*
 * func_800DABDC (2940 bytes)
 * Replay save prompt - Asks user to save replay
 */
extern s32 D_8015A750;      /* Replay prompt state */
extern s32 D_8015A754;      /* Replay selection */

void func_800DABDC(void) {
    s32 input;
    s32 selection;

    selection = D_8015A754;
    input = func_800CB748(D_80158100);

    /* Navigation */
    if (input == 6 || input == 7) {  /* Left/Right */
        selection = !selection;
        sound_play_menu(12);
    } else if (input == 1) {  /* A - confirm */
        if (selection == 0) {
            /* Save replay */
            /* func_800DXXXX(); */
            sound_play_menu(10);
        }
        D_8015A750 = 0;
        D_8015A754 = 0;
        return;
    } else if (input == 2) {  /* B - cancel */
        D_8015A750 = 0;
        D_8015A754 = 0;
        return;
    }

    /* Draw prompt */
    func_800C6E60(60, 90, 200, 60, 0xE0202050);
    func_800C6E60(62, 92, 196, 56, 0xE0303070);

    draw_text(110, 100, "SAVE REPLAY?", 0xFFFFFFFF);

    draw_text("YES", 100, 130, selection == 0 ? 255 : 150);
    draw_text("NO", 190, 130, selection == 1 ? 255 : 150);

    if (selection == 0) {
        draw_text(85, 130, ">", 0xFFFFFFFF);
    } else {
        draw_text(175, 130, ">", 0xFFFFFFFF);
    }

    D_8015A754 = selection;
}

/*
 * func_800DB758 (196 bytes)
 * Continue prompt - Quick continue/quit choice
 */
extern s32 D_8015A760;      /* Continue countdown */

s32 func_800DB758(void) {
    s32 input;
    s32 countdown;
    char countStr[4];

    countdown = D_8015A760;
    if (countdown == 0) {
        countdown = 10 * 60;  /* 10 seconds */
    }

    input = func_800CB748(D_80158100);

    if (input == 1) {  /* A - continue */
        D_8015A760 = 0;
        return 1;
    } else if (input == 2) {  /* B - quit */
        D_8015A760 = 0;
        return 0;
    }

    countdown--;
    if (countdown <= 0) {
        D_8015A760 = 0;
        return 0;  /* Time out = quit */
    }

    /* Display */
    draw_text(120, 120, "CONTINUE?", 0xFFFFFFFF);
    sprintf(countStr, "%d", (countdown / 60) + 1);
    draw_text(countStr, 155, 145, 200);

    D_8015A760 = countdown;
    return -1;  /* Still waiting */
}

/*
 * func_800DC248 (432 bytes)
 * Championship standings - Shows championship points
 */
extern s32 D_8015A770[4];   /* Championship points per player */

void func_800DC248(void) {
    s32 i;
    char pointsStr[16];
    s32 sorted[4] = {0, 1, 2, 3};
    s32 j, temp;

    /* Sort by points */
    for (i = 0; i < 3; i++) {
        for (j = i + 1; j < 4; j++) {
            if (D_8015A770[sorted[j]] > D_8015A770[sorted[i]]) {
                temp = sorted[i];
                sorted[i] = sorted[j];
                sorted[j] = temp;
            }
        }
    }

    /* Display */
    func_800C6E60(50, 50, 220, 140, 0xE0202050);
    draw_text(70, 60, "CHAMPIONSHIP STANDINGS", 0xFFFFFFFF);

    for (i = 0; i < 4; i++) {
        s32 playerIdx = sorted[i];
        s32 yPos = 90 + i * 25;

        sprintf(pointsStr, "PLAYER %d: %d PTS", playerIdx + 1, D_8015A770[playerIdx]);
        draw_text(pointsStr, 70, yPos, 200);
    }
}

/*
 * func_800DC3F8 (924 bytes)
 * Trophy award - Awards championship trophy
 */
void func_800DC3F8(s32 placing) {
    char placeStr[16];

    func_800C6E60(80, 60, 160, 120, 0xE0303060);

    draw_text(105, 70, "CHAMPIONSHIP", 0xFFFFFFFF);

    switch (placing) {
        case 1:
            draw_text(125, 100, "WINNER!", 0xFFFFFFFF);
            func_8010306C(1);  /* Gold trophy */
            break;
        case 2:
            draw_text(115, 100, "2ND PLACE", 0xFFFFFFC8);
            func_8010306C(2);  /* Silver trophy */
            break;
        case 3:
            draw_text(115, 100, "3RD PLACE", 0xFFFFFF96);
            func_8010306C(3);  /* Bronze trophy */
            break;
        default:
            sprintf(placeStr, "%dTH PLACE", placing);
            draw_text(placeStr, 110, 100, 150);
            break;
    }
}

/*
 * func_800DC794 (248 bytes)
 * Unlock notification - Shows unlock popup
 */
static const char *unlockNames[] = {
    "NEW CAR UNLOCKED!",
    "NEW TRACK UNLOCKED!",
    "BONUS MODE UNLOCKED!",
    "SECRET UNLOCKED!"
};

void func_800DC794(s32 unlockId) {
    const char *msg;

    if (unlockId < 0 || unlockId >= 4) {
        unlockId = 3;
    }

    msg = unlockNames[unlockId];

    func_800C6E60(60, 100, 200, 40, 0xE0FFD700);
    func_800C6E60(62, 102, 196, 36, 0xE0604000);
    draw_text(80, 112, msg, 0xFFFFFFFF);

    sound_play_menu(20);  /* Unlock jingle */
}

/*
 * func_800DC88C (1272 bytes)
 * Attract mode start - Initializes attract mode demo
 */
extern s32 D_8015A780;      /* Attract state */
extern s32 D_8015A784;      /* Attract timer */
extern s32 D_8015A788;      /* Demo replay index */

void func_800DC88C(void) {
    s32 state;
    s32 timer;
    s32 input;

    state = D_8015A780;
    timer = D_8015A784;
    input = func_800CB748(D_80158100);

    /* Any input exits attract mode */
    if (input != 0) {
        D_8015A780 = 0;
        D_8015A784 = 0;
        D_801146EC = 1;  /* Go to title/menu */
        return;
    }

    timer++;

    switch (state) {
        case 0:  /* Title screen */
            func_800C6E60(0, 0, 320, 240, 0xFF000020);
            draw_text(85, 80, "SAN FRANCISCO", 0xFFFFFFFF);
            draw_text(105, 110, "RUSH 2049", 0xFFFFFFFF);

            if ((timer / 60) & 1) {
                draw_text(100, 180, "PRESS START", 0xFFFFFFC8);
            }

            if (timer > 300) {
                state = 1;
                timer = 0;
            }
            break;

        case 1:  /* Demo playback */
            /* Play back recorded demo */
            D_8015A788 = (D_8015A788 + 1) % 3;  /* Cycle through demos */
            /* func_800DXXXX(D_8015A788); */

            if (timer > 900) {  /* 15 seconds demo */
                state = 2;
                timer = 0;
            }
            break;

        case 2:  /* High scores */
            func_800C6E60(0, 0, 320, 240, 0xFF101030);
            draw_text(105, 40, "HIGH SCORES", 0xFFFFFFFF);
            /* func_800AXXXX(); display high score table */

            if (timer > 300) {
                state = 0;
                timer = 0;
            }
            break;
    }

    D_8015A780 = state;
    D_8015A784 = timer;
}

/*
 * func_800DC99C (1016 bytes)
 * Attract demo play - Plays back recorded demo race
 */
extern s32 D_8015A790;      /* Demo playback frame */
extern s32 D_8015A794;      /* Demo input buffer index */
extern u8 *D_8015A798;      /* Demo input data pointer */

void func_800DC99C(void) {
    s32 frame;
    u8 *inputData;
    u8 demoInput;

    frame = D_8015A790;
    inputData = D_8015A798;

    if (inputData == NULL) {
        return;
    }

    /* Read demo input for this frame */
    demoInput = inputData[frame];

    /* Apply to player 0 car */
    {
        u8 *carBase = (u8 *)&D_80152818;
        f32 *steering = (f32 *)(carBase + 0xC0);
        f32 *throttle = (f32 *)(carBase + 0xC4);
        f32 *brake = (f32 *)(carBase + 0xC8);

        /* Decode demo input byte */
        *throttle = ((demoInput >> 4) & 0x0F) / 15.0f;
        *steering = (((demoInput & 0x0F) - 8) / 7.0f);
        *brake = (demoInput & 0x80) ? 1.0f : 0.0f;
    }

    frame++;
    D_8015A790 = frame;

    /* Check for demo end (0xFF marker) */
    if (inputData[frame] == 0xFF) {
        D_8015A790 = 0;
        D_801146EC = 0;  /* Back to attract */
    }
}

/*
 * func_800DCD94 (96 bytes)
 * Attract idle check - Returns 1 if no input for idle timeout
 */
extern s32 D_8015A7A0;      /* Idle frame counter */
#define IDLE_TIMEOUT (30 * 60)  /* 30 seconds */

s32 func_800DCD94(void) {
    s32 input;

    input = func_800CB748(D_80158100);

    if (input != 0) {
        D_8015A7A0 = 0;
        return 0;
    }

    D_8015A7A0++;

    if (D_8015A7A0 >= IDLE_TIMEOUT) {
        D_8015A7A0 = 0;
        return 1;  /* Idle timeout reached */
    }

    return 0;
}

/*
 * func_800DCDF4 (732 bytes)
 * Attract video play - Plays FMV or pre-rendered video sequence
 */
extern s32 D_8015A7A8;      /* Video playback frame */
extern s32 D_8015A7AC;      /* Video duration */

void func_800DCDF4(s32 videoId) {
    s32 frame;
    s32 duration;

    frame = D_8015A7A8;
    frame++;

    /* Get video duration based on ID */
    switch (videoId) {
        case 0:  /* Intro video */
            duration = 300;
            break;
        case 1:  /* Credits */
            duration = 600;
            break;
        default:
            duration = 180;
            break;
    }

    D_8015A7AC = duration;

    /* Draw "playing" indicator (actual video decode would go here) */
    func_800C6E60(0, 0, 320, 240, 0xFF000000);

    if (frame >= duration) {
        D_8015A7A8 = 0;
        return;
    }

    D_8015A7A8 = frame;
}

/*
 * func_800DD0D0 (988 bytes)
 * Attract sequence update - Updates attract mode state machine
 */
void func_800DD0D0(void) {
    s32 state;
    s32 timer;

    state = D_8015A780;
    timer = D_8015A784;

    timer++;

    /* Handle state transitions */
    switch (state) {
        case 0:  /* Title */
            if (timer > 300) {
                state = 1;
                timer = 0;
            }
            break;

        case 1:  /* Demo */
            func_800DC99C();
            if (timer > 900) {
                state = 2;
                timer = 0;
            }
            break;

        case 2:  /* High scores */
            if (timer > 300) {
                state = 0;
                timer = 0;
            }
            break;
    }

    D_8015A780 = state;
    D_8015A784 = timer;
}

/*
 * func_800DD4AC (2816 bytes)
 * Title screen - Main title screen display
 */
extern s32 D_8015A7B0;      /* Title animation frame */
extern s32 D_8015A7B4;      /* Title state */

void func_800DD4AC(void) {
    s32 frame;
    s32 input;
    s32 logoY;
    s32 alpha;

    frame = D_8015A7B0;
    frame++;
    input = func_800CB748(D_80158100);

    /* Any button goes to menu */
    if (input != 0) {
        D_8015A7B0 = 0;
        D_801146EC = 1;  /* TRKSEL or menu */
        sound_play_menu(10);
        return;
    }

    /* Background */
    func_800DE4DC();

    /* Logo animation - drop in from top */
    if (frame < 60) {
        logoY = -100 + (frame * 180 / 60);
        alpha = (frame * 255) / 60;
    } else {
        logoY = 80;
        alpha = 255;
    }

    func_800DDFAC();  /* Animate logo */

    /* Draw title text */
    draw_text("SAN FRANCISCO", 85, logoY - 20, alpha);
    draw_text("RUSH 2049", 105, logoY + 10, alpha);

    /* Button prompt after logo settles */
    if (frame > 90) {
        func_800DE20C();
    }

    /* Copyright */
    draw_text(80, 220, "(C) 1999 ATARI GAMES", 0xFFFFFF96);

    D_8015A7B0 = frame;
}

/*
 * func_800DDFAC (608 bytes)
 * Title logo animate - Animates the game logo
 */
extern s32 D_8015A7B8;      /* Logo animation phase */

void func_800DDFAC(void) {
    s32 phase;
    f32 scale;
    f32 glow;

    phase = D_8015A7B8;
    phase++;

    /* Pulsing scale effect */
    scale = 1.0f + sinf((f32)phase * 0.05f) * 0.02f;

    /* Glow effect */
    glow = 0.5f + sinf((f32)phase * 0.08f) * 0.3f;

    /* Logo would be drawn here with transforms */
    /* For now just draw a placeholder box */
    {
        s32 glowAlpha = (s32)(glow * 255.0f);
        func_800C6E60(75, 55, 170, 80, (glowAlpha << 24) | 0x404080);
    }

    D_8015A7B8 = phase;
}

/*
 * func_800DE20C (724 bytes)
 * Title button prompt - Shows "PRESS START" with blinking
 */
void func_800DE20C(void) {
    s32 frame;
    s32 blink;
    s32 alpha;

    frame = D_80142AFC;
    blink = (frame / 30) & 1;

    if (blink) {
        alpha = 255;
    } else {
        alpha = 100;
    }

    /* Pulsing alpha */
    alpha = 150 + (s32)(sinf((f32)frame * 0.1f) * 100.0f);
    if (alpha > 255) alpha = 255;
    if (alpha < 50) alpha = 50;

    draw_text(100, 180, "PRESS START", alpha);
}

/*
 * func_800DE4DC (908 bytes)
 * Title background - Renders animated title background
 */
void func_800DE4DC(void) {
    s32 frame;
    s32 i;
    s32 scrollX, scrollY;

    frame = D_80142AFC;

    /* Gradient background */
    func_800C6E60(0, 0, 320, 120, 0xFF000030);
    func_800C6E60(0, 120, 320, 120, 0xFF000050);

    /* Scrolling city silhouette effect */
    scrollX = (frame / 2) % 320;

    for (i = 0; i < 4; i++) {
        s32 x = ((scrollX + i * 80) % 320) - 40;
        s32 height = 30 + (i * 17) % 40;
        func_800C6E60(x, 200 - height, 60, height, 0x80202040);
    }

    /* Stars/particles */
    for (i = 0; i < 8; i++) {
        s32 starX = ((frame * 3 + i * 47) % 320);
        s32 starY = ((i * 31) % 180) + 10;
        s32 twinkle = ((frame + i * 13) / 10) & 1;

        if (twinkle) {
            func_800C6E60(starX, starY, 2, 2, 0xFFFFFFFF);
        }
    }
}

/*
 * func_800DE868 (836 bytes)
 * Main menu screen - Handles main menu logic
 */
extern s32 D_8015A7C0;      /* Menu selection */
extern s32 D_8015A7C4;      /* Menu state */

void func_800DE868(void) {
    s32 input;

    input = func_800CB748(D_80158100);

    func_800DEBAC(input);
    func_800DEC8C();
}

/*
 * func_800DEBAC (224 bytes)
 * Main menu input - Processes main menu input
 */
static const char *mainMenuOptions[] = {
    "RACE",
    "BATTLE",
    "STUNT",
    "OPTIONS",
    "RECORDS"
};
#define MAIN_MENU_COUNT 5

void func_800DEBAC(s32 input) {
    s32 selection = D_8015A7C0;

    if (input == 4) {  /* Up */
        selection--;
        if (selection < 0) selection = MAIN_MENU_COUNT - 1;
        sound_play_menu(12);
    } else if (input == 5) {  /* Down */
        selection++;
        if (selection >= MAIN_MENU_COUNT) selection = 0;
        sound_play_menu(12);
    } else if (input == 1) {  /* A - select */
        sound_play_menu(10);
        switch (selection) {
            case 0:  /* Race */
                D_801146EC = 1;  /* TRKSEL */
                break;
            case 1:  /* Battle */
                D_801146EC = 10;  /* Battle mode */
                break;
            case 2:  /* Stunt */
                D_801146EC = 11;  /* Stunt mode */
                break;
            case 3:  /* Options */
                D_8015A7C4 = 1;  /* Options submenu */
                break;
            case 4:  /* Records */
                D_8015A7C4 = 2;  /* Records submenu */
                break;
        }
    } else if (input == 2) {  /* B - back to title */
        D_801146EC = 0;  /* ATTRACT */
    }

    D_8015A7C0 = selection;
}

/*
 * func_800DEC8C (732 bytes)
 * Main menu render - Draws the main menu
 */
void func_800DEC8C(void) {
    s32 selection = D_8015A7C0;
    s32 i;

    /* Background */
    func_800C6E60(0, 0, 320, 240, 0xFF101030);

    /* Title */
    draw_text(115, 30, "MAIN MENU", 0xFFFFFFFF);

    /* Menu options */
    for (i = 0; i < MAIN_MENU_COUNT; i++) {
        s32 yPos = 80 + i * 30;
        s32 alpha = (i == selection) ? 255 : 150;

        if (i == selection) {
            /* Selection highlight */
            func_800C6E60(80, yPos - 5, 160, 25, 0x80404080);
            draw_text(90, yPos, ">", 255);
        }

        draw_text(100, yPos, mainMenuOptions[i], alpha);
    }

    /* Footer */
    draw_text(90, 210, "A:SELECT  B:BACK", 0xFFFFFF96);
}

/*
 * func_800DEF68 (2976 bytes)
 * Mode select screen - Race/Battle/Stunt mode configuration
 */
extern s32 D_8015A7D0;      /* Mode select selection */
extern s32 D_8015A7D4;      /* Selected mode type */

void func_800DEF68(void) {
    s32 input;
    s32 selection;

    selection = D_8015A7D0;
    input = func_800CB748(D_80158100);

    func_800DFB08(input);

    /* Background */
    func_800C6E60(0, 0, 320, 240, 0xFF101030);

    /* Title based on mode */
    switch (D_8015A7D4) {
        case 0:  /* Race */
            draw_text(115, 30, "RACE MODE", 0xFFFFFFFF);
            draw_text("SINGLE RACE", 110, 80, selection == 0 ? 255 : 150);
            draw_text("CHAMPIONSHIP", 105, 110, selection == 1 ? 255 : 150);
            draw_text("TIME TRIAL", 115, 140, selection == 2 ? 255 : 150);
            break;

        case 1:  /* Battle */
            draw_text(110, 30, "BATTLE MODE", 0xFFFFFFFF);
            draw_text("DEATHMATCH", 110, 80, selection == 0 ? 255 : 150);
            draw_text("TEAM BATTLE", 110, 110, selection == 1 ? 255 : 150);
            draw_text("LAST MAN", 115, 140, selection == 2 ? 255 : 150);
            break;

        case 2:  /* Stunt */
            draw_text(115, 30, "STUNT MODE", 0xFFFFFFFF);
            draw_text("FREESTYLE", 115, 80, selection == 0 ? 255 : 150);
            draw_text("TRICK ATTACK", 105, 110, selection == 1 ? 255 : 150);
            break;
    }

    /* Selection cursor */
    draw_text(">", 90, 80 + selection * 30, 255);
}

/*
 * func_800DFB08 (188 bytes)
 * Mode select input - Handles mode selection input
 */
void func_800DFB08(s32 input) {
    s32 selection = D_8015A7D0;
    s32 maxOptions = (D_8015A7D4 == 2) ? 2 : 3;

    if (input == 4) {  /* Up */
        selection--;
        if (selection < 0) selection = maxOptions - 1;
        sound_play_menu(12);
    } else if (input == 5) {  /* Down */
        selection++;
        if (selection >= maxOptions) selection = 0;
        sound_play_menu(12);
    } else if (input == 1) {  /* A - select */
        sound_play_menu(10);
        /* Proceed to track/arena selection */
        D_801146EC = 1;  /* TRKSEL */
    } else if (input == 2) {  /* B - back */
        D_8015A7D0 = 0;
        D_801146EC = 0;  /* Back to menu */
    }

    D_8015A7D0 = selection;
}

/*

 * func_800DFBC4 (1868 bytes)
 * Profile select screen
 */
void func_800DFBC4(void) {
    /* Profile select - stub */
}

/*

 * func_800EB028 (1640 bytes)
 * World object spawn
 */
void *func_800EB028(s32 objectType, f32 *pos) {
    /* Object spawn - stub */
    return NULL;
}

/*

 * func_800EB690 (396 bytes)
 * World object destroy
 */
void func_800EB690(void *object) {
    /* Object destroy - stub */
}

/*

 * func_800EC2F8 (1584 bytes)
 * World physics tick
 *
 * Based on arcade collision.c - iterates all cars and applies physics
 * Data structures:
 *   D_80152744 - number of active cars
 *   D_8015A250 - car state array base (stride 0x808)
 *   D_80153E88 - car data array (stride 8)
 */
void func_800EC2F8(void) {
    s32 i;
    s32 numCars;

    numCars = D_80152744;
    if (numCars <= 0) {
        return;
    }

    /* Process each car's physics */
    for (i = 0; i < numCars; i++) {
        u8 *carState = &D_8015A250[i * 0x808];

        /* Check if car is active (offset 0x7CC) */
        if (carState[0x7CC] == 0) {
            continue;
        }

        /* Apply gravity */
        func_800ECC18(carState);

        /* Apply friction */
        func_800ED674(carState);

        /* Integrate velocity */
        func_800ED804(carState, 1.0f / 60.0f);
    }
}

/*

 * func_800EC928 (588 bytes)
 * World collision detect
 *
 * Based on arcade collision() - check if two objects' bounding spheres overlap
 * Returns 1 if collision detected, 0 otherwise
 */
s32 func_800EC928(void *a, void *b) {
    f32 *posA, *posB;
    f32 dx, dy, dz, distSq;
    f32 radA, radB, radSum;

    if (a == NULL || b == NULL) {
        return 0;
    }

    /* Get positions (offset 0x24 = position vector) */
    posA = (f32 *)((u8 *)a + 0x24);
    posB = (f32 *)((u8 *)b + 0x24);

    /* Calculate distance squared between centers */
    dx = posA[0] - posB[0];
    dy = posA[1] - posB[1];
    dz = posA[2] - posB[2];
    distSq = dx * dx + dy * dy + dz * dz;

    /* Get collision radii (offset 0x48) */
    radA = *(f32 *)((u8 *)a + 0x48);
    radB = *(f32 *)((u8 *)b + 0x48);
    radSum = radA + radB;

    /* Check if bounding spheres overlap */
    if (distSq < radSum * radSum) {
        return 1;
    }

    return 0;
}

/*

 * func_800ECB74 (164 bytes)
 * World bounds check
 *
 * Check if position is within world bounds
 * Returns 1 if in bounds, 0 if out of bounds
 */
s32 func_800ECB74(f32 *pos) {
    extern f32 D_80124500;  /* World min X */
    extern f32 D_80124504;  /* World max X */
    extern f32 D_80124508;  /* World min Y */
    extern f32 D_8012450C;  /* World max Y */
    extern f32 D_80124510;  /* World min Z */
    extern f32 D_80124514;  /* World max Z */

    if (pos == NULL) {
        return 0;
    }

    /* Check X bounds */
    if (pos[0] < D_80124500 || pos[0] > D_80124504) {
        return 0;
    }

    /* Check Y bounds (height) */
    if (pos[1] < D_80124508 || pos[1] > D_8012450C) {
        return 0;
    }

    /* Check Z bounds */
    if (pos[2] < D_80124510 || pos[2] > D_80124514) {
        return 0;
    }

    return 1;
}

/*

 * func_800ECC18 (2652 bytes)
 * World gravity apply
 *
 * Based on arcade physics - applies gravity acceleration to velocity
 * Gravity constant at D_80124574 (typically -9.8 * scale)
 */
void func_800ECC18(void *object) {
    extern f32 D_80124574;  /* Gravity constant */
    f32 *velocity;
    f32 *accel;
    f32 dt;

    if (object == NULL) {
        return;
    }

    /* Get velocity vector (offset 0x34) */
    velocity = (f32 *)((u8 *)object + 0x34);

    /* Get acceleration vector (offset 0x40) */
    accel = (f32 *)((u8 *)object + 0x40);

    /* Fixed timestep */
    dt = 1.0f / 60.0f;

    /* Apply gravity to Y velocity (vertical) */
    velocity[1] += D_80124574 * dt;

    /* Apply additional acceleration if any */
    velocity[0] += accel[0] * dt;
    velocity[1] += accel[1] * dt;
    velocity[2] += accel[2] * dt;
}

/*

 * func_800ED674 (400 bytes)
 * World friction apply
 *
 * Applies friction/drag to reduce velocity over time
 * Friction coefficient at D_80124578
 */
void func_800ED674(void *object) {
    extern f32 D_80124578;  /* Friction coefficient (0.0 - 1.0) */
    f32 *velocity;
    f32 friction;
    u8 *flags;

    if (object == NULL) {
        return;
    }

    /* Get velocity vector (offset 0x34) */
    velocity = (f32 *)((u8 *)object + 0x34);

    /* Get object flags (offset 0x00) */
    flags = (u8 *)object;

    /* Check if object is grounded (bit 5 of flags) */
    if (flags[0] & 0x20) {
        /* Grounded - apply ground friction */
        friction = D_80124578;
    } else {
        /* Airborne - apply air resistance (less friction) */
        friction = D_80124578 * 0.1f;
    }

    /* Apply friction to horizontal velocities */
    velocity[0] *= (1.0f - friction);
    velocity[2] *= (1.0f - friction);

    /* Apply less friction to vertical (let gravity handle it) */
    if (velocity[1] > 0.0f) {
        velocity[1] *= (1.0f - friction * 0.5f);
    }
}

/*

 * func_800ED804 (712 bytes)
 * World velocity integrate
 *
 * Integrates velocity to update position (Euler integration)
 */
void func_800ED804(void *object, f32 dt) {
    f32 *position;
    f32 *velocity;

    if (object == NULL) {
        return;
    }

    /* Get position (offset 0x24) and velocity (offset 0x34) */
    position = (f32 *)((u8 *)object + 0x24);
    velocity = (f32 *)((u8 *)object + 0x34);

    /* Euler integration: pos += vel * dt */
    position[0] += velocity[0] * dt;
    position[1] += velocity[1] * dt;
    position[2] += velocity[2] * dt;
}

/*

 * func_800EDACC (540 bytes)
 * World collision response
 *
 * Based on arcade setCollisionForce() - applies impulse to separate objects
 * Uses conservation of momentum for elastic collision response
 */
void func_800EDACC(void *a, void *b) {
    f32 *posA, *posB;
    f32 *velA, *velB;
    f32 dx, dy, dz, dist, invDist;
    f32 nx, ny, nz;  /* Collision normal */
    f32 relVelX, relVelY, relVelZ;
    f32 relVelNormal;
    f32 impulse;
    f32 massA, massB, totalMass;
    f32 restitution;

    if (a == NULL || b == NULL || a == b) {
        return;
    }

    /* Get positions (offset 0x24) */
    posA = (f32 *)((u8 *)a + 0x24);
    posB = (f32 *)((u8 *)b + 0x24);

    /* Get velocities (offset 0x34) */
    velA = (f32 *)((u8 *)a + 0x34);
    velB = (f32 *)((u8 *)b + 0x34);

    /* Calculate collision normal (from B to A) */
    dx = posA[0] - posB[0];
    dy = posA[1] - posB[1];
    dz = posA[2] - posB[2];

    dist = sqrtf(dx * dx + dy * dy + dz * dz);
    if (dist < 0.0001f) {
        /* Objects at same position - push apart on Y axis */
        nx = 0.0f;
        ny = 1.0f;
        nz = 0.0f;
    } else {
        invDist = 1.0f / dist;
        nx = dx * invDist;
        ny = dy * invDist;
        nz = dz * invDist;
    }

    /* Calculate relative velocity */
    relVelX = velA[0] - velB[0];
    relVelY = velA[1] - velB[1];
    relVelZ = velA[2] - velB[2];

    /* Project relative velocity onto collision normal */
    relVelNormal = relVelX * nx + relVelY * ny + relVelZ * nz;

    /* If objects are separating, no collision response needed */
    if (relVelNormal > 0.0f) {
        return;
    }

    /* Get masses (offset 0x4C) - default to 1.0 if not set */
    massA = *(f32 *)((u8 *)a + 0x4C);
    massB = *(f32 *)((u8 *)b + 0x4C);
    if (massA <= 0.0f) massA = 1.0f;
    if (massB <= 0.0f) massB = 1.0f;
    totalMass = massA + massB;

    /* Coefficient of restitution (bounciness) */
    restitution = 0.5f;

    /* Calculate impulse magnitude */
    impulse = -(1.0f + restitution) * relVelNormal / totalMass;

    /* Apply impulse to both objects */
    velA[0] += impulse * massB * nx;
    velA[1] += impulse * massB * ny;
    velA[2] += impulse * massB * nz;

    velB[0] -= impulse * massA * nx;
    velB[1] -= impulse * massA * ny;
    velB[2] -= impulse * massA * nz;
}

/*

 * func_800EDCE8 (2292 bytes)
 * World trigger check
 *
 * Checks if player has entered any trigger volumes (checkpoints, pickups, etc.)
 * D_801431C0 - trigger array base
 * D_801431BC - number of triggers
 */
void func_800EDCE8(void *player) {
    extern u8 D_801431C0[];
    extern s16 D_801431BC;
    f32 *playerPos;
    s32 i;
    s32 numTriggers;

    if (player == NULL) {
        return;
    }

    playerPos = (f32 *)((u8 *)player + 0x24);
    numTriggers = D_801431BC;

    for (i = 0; i < numTriggers; i++) {
        u8 *trigger = &D_801431C0[i * 0x40];  /* Trigger stride = 64 bytes */
        f32 *triggerPos = (f32 *)(trigger + 0x04);
        f32 *triggerSize = (f32 *)(trigger + 0x10);
        s32 triggerType = trigger[0];
        s32 triggerActive = trigger[1];

        if (!triggerActive) {
            continue;
        }

        /* AABB check - is player inside trigger volume? */
        if (playerPos[0] >= triggerPos[0] - triggerSize[0] &&
            playerPos[0] <= triggerPos[0] + triggerSize[0] &&
            playerPos[1] >= triggerPos[1] - triggerSize[1] &&
            playerPos[1] <= triggerPos[1] + triggerSize[1] &&
            playerPos[2] >= triggerPos[2] - triggerSize[2] &&
            playerPos[2] <= triggerPos[2] + triggerSize[2]) {

            /* Trigger activated - call handler */
            func_800EE5DC(i);
        }
    }
}

/*

 * func_800EE5DC (580 bytes)
 * World trigger activate
 *
 * Activates a world trigger by ID - used for checkpoints, shortcuts, etc.
 * Based on arcade checkpoint.c trigger handling
 */
void func_800EE5DC(s32 triggerId) {
    extern u8 D_80153D00[];    /* Trigger state array */
    extern s32 D_80153D80;     /* Number of triggers */
    u8 *trigger;
    s32 triggerType;
    f32 *playerPos;

    if (triggerId < 0 || triggerId >= D_80153D80) {
        return;
    }

    trigger = &D_80153D00[triggerId * 0x20];

    /* Check if already activated */
    if (trigger[0x1C] != 0) {
        return;
    }

    /* Mark as activated */
    trigger[0x1C] = 1;

    /* Get trigger type (offset 0x00) */
    triggerType = trigger[0x00];

    playerPos = (f32 *)(&D_80152818[0x24]);

    switch (triggerType) {
        case 0:  /* Checkpoint */
            func_800F6960(triggerId);  /* Record checkpoint */
            sound_play_menu(15);  /* Checkpoint sound */
            break;

        case 1:  /* Shortcut entry */
            D_80152818[0x1E0] = 1;  /* Set shortcut flag */
            break;

        case 2:  /* Boost pad */
            func_800F6584(triggerId);  /* Apply boost */
            sound_play_menu(20);  /* Boost sound */
            break;

        case 3:  /* Jump ramp */
            sound_play_menu(25);  /* Jump sound */
            break;

        case 4:  /* Item pickup */
            func_800EB028(5, playerPos);  /* Spawn pickup effect */
            break;

        case 5:  /* Death trigger */
            func_800F6D10(0);  /* Respawn player */
            break;
    }
}

/*

 * func_800EE820 (148 bytes)
 * World effect spawn
 *
 * Creates a visual effect at the specified position
 * Effect types: 0=smoke, 1=spark, 2=explosion, 3=dust, 4=trail
 */
void *func_800EE820(s32 effectType, f32 *pos) {
    extern u8 D_80154800[];    /* Effect pool */
    extern s32 D_80154C00;     /* Effect pool count */
    extern s32 D_80154C04;     /* Max effects */
    u8 *effect;
    s32 i;

    if (pos == NULL) {
        return NULL;
    }

    /* Find free slot in effect pool */
    for (i = 0; i < D_80154C04; i++) {
        effect = &D_80154800[i * 0x40];
        if (effect[0x00] == 0) {  /* Inactive slot */
            /* Initialize effect */
            effect[0x00] = 1;  /* Active */
            effect[0x04] = (u8)effectType;
            effect[0x08] = 0;  /* Frame counter */

            /* Copy position */
            *(f32 *)(effect + 0x10) = pos[0];
            *(f32 *)(effect + 0x14) = pos[1];
            *(f32 *)(effect + 0x18) = pos[2];

            /* Set lifetime based on type */
            switch (effectType) {
                case 0: effect[0x3C] = 30; break;  /* Smoke - 0.5s */
                case 1: effect[0x3C] = 15; break;  /* Spark - 0.25s */
                case 2: effect[0x3C] = 45; break;  /* Explosion - 0.75s */
                case 3: effect[0x3C] = 20; break;  /* Dust - 0.33s */
                case 4: effect[0x3C] = 60; break;  /* Trail - 1s */
                default: effect[0x3C] = 30; break;
            }

            D_80154C00++;
            return (void *)effect;
        }
    }

    return NULL;  /* No free slots */
}

/*

 * func_800EE8B4 (456 bytes)
 * World effect update
 *
 * Updates a single effect - position, animation, lifetime
 */
void func_800EE8B4(void *effect) {
    u8 *eff = (u8 *)effect;
    s32 effectType;
    s32 frame;
    s32 lifetime;
    f32 *pos;
    f32 *vel;

    if (eff == NULL || eff[0x00] == 0) {
        return;
    }

    effectType = eff[0x04];
    frame = eff[0x08];
    lifetime = eff[0x3C];

    /* Update frame counter */
    eff[0x08] = frame + 1;

    /* Check if effect expired */
    if (frame >= lifetime) {
        eff[0x00] = 0;  /* Deactivate */
        return;
    }

    /* Get position and velocity */
    pos = (f32 *)(eff + 0x10);
    vel = (f32 *)(eff + 0x20);

    /* Update based on type */
    switch (effectType) {
        case 0:  /* Smoke - rise and fade */
            pos[1] += 2.0f;  /* Rise */
            vel[0] *= 0.95f;  /* Slow horizontal */
            vel[2] *= 0.95f;
            eff[0x38] = (u8)(255 * (lifetime - frame) / lifetime);  /* Alpha fade */
            break;

        case 1:  /* Spark - gravity */
            vel[1] -= 0.5f;  /* Gravity */
            pos[0] += vel[0];
            pos[1] += vel[1];
            pos[2] += vel[2];
            break;

        case 2:  /* Explosion - expand and fade */
            *(f32 *)(eff + 0x30) += 5.0f;  /* Expand radius */
            eff[0x38] = (u8)(255 * (lifetime - frame) / lifetime);
            break;

        case 3:  /* Dust - drift and settle */
            pos[1] -= 0.5f;  /* Settle */
            pos[0] += vel[0] * 0.1f;
            pos[2] += vel[2] * 0.1f;
            eff[0x38] = (u8)(200 * (lifetime - frame) / lifetime);
            break;

        case 4:  /* Trail - fade only */
            eff[0x38] = (u8)(255 * (lifetime - frame) / lifetime);
            break;
    }
}

/*

 * func_800EEA7C (820 bytes)
 * Particle emitter create
 *
 * Creates a particle emitter that spawns particles over time
 * Types: 0=smoke trail, 1=spark shower, 2=fire, 3=steam, 4=exhaust
 */
void *func_800EEA7C(s32 type, f32 *pos) {
    extern u8 D_80155000[];    /* Emitter pool */
    extern s32 D_80155400;     /* Emitter count */
    extern s32 D_80155404;     /* Max emitters */
    u8 *emitter;
    s32 i;

    if (pos == NULL) {
        return NULL;
    }

    /* Find free slot */
    for (i = 0; i < D_80155404; i++) {
        emitter = &D_80155000[i * 0x80];
        if (emitter[0x00] == 0) {
            /* Initialize emitter */
            emitter[0x00] = 1;  /* Active */
            emitter[0x04] = (u8)type;
            emitter[0x08] = 0;  /* Frame counter */
            emitter[0x0C] = 0;  /* Particles spawned */

            /* Copy position */
            *(f32 *)(emitter + 0x10) = pos[0];
            *(f32 *)(emitter + 0x14) = pos[1];
            *(f32 *)(emitter + 0x18) = pos[2];

            /* Set spawn rate and particle count based on type */
            switch (type) {
                case 0:  /* Smoke trail */
                    emitter[0x40] = 3;   /* Spawn every 3 frames */
                    emitter[0x44] = 20;  /* Max 20 particles */
                    break;
                case 1:  /* Spark shower */
                    emitter[0x40] = 1;   /* Every frame */
                    emitter[0x44] = 50;  /* Max 50 particles */
                    break;
                case 2:  /* Fire */
                    emitter[0x40] = 2;
                    emitter[0x44] = 30;
                    break;
                case 3:  /* Steam */
                    emitter[0x40] = 4;
                    emitter[0x44] = 15;
                    break;
                case 4:  /* Exhaust */
                    emitter[0x40] = 2;
                    emitter[0x44] = 10;
                    break;
                default:
                    emitter[0x40] = 3;
                    emitter[0x44] = 20;
                    break;
            }

            D_80155400++;
            return (void *)emitter;
        }
    }

    return NULL;
}

/*

 * func_800EEDB0 (1240 bytes)
 * Particle update
 *
 * Updates all particles from an emitter and spawns new ones
 */
void func_800EEDB0(void *emitter) {
    u8 *emit = (u8 *)emitter;
    s32 type;
    s32 frame;
    s32 spawnRate;
    s32 maxParticles;
    s32 currentCount;
    f32 *emitPos;
    f32 spawnPos[3];
    f32 vel[3];
    s32 seed;

    if (emit == NULL || emit[0x00] == 0) {
        return;
    }

    type = emit[0x04];
    frame = emit[0x08];
    spawnRate = emit[0x40];
    maxParticles = emit[0x44];
    currentCount = emit[0x0C];
    emitPos = (f32 *)(emit + 0x10);

    /* Increment frame */
    emit[0x08] = frame + 1;

    /* Check if we should spawn a new particle */
    if (currentCount < maxParticles && (frame % spawnRate) == 0) {
        /* LCG random for position jitter */
        seed = D_80142AFC * 0x41C64E6D + 12345;

        /* Add random offset to spawn position */
        spawnPos[0] = emitPos[0] + ((seed >> 8) & 0xFF) * 0.05f - 6.4f;
        spawnPos[1] = emitPos[1] + ((seed >> 16) & 0xFF) * 0.02f;
        spawnPos[2] = emitPos[2] + ((seed >> 24) & 0xFF) * 0.05f - 6.4f;

        /* Set initial velocity based on type */
        switch (type) {
            case 0:  /* Smoke - rise */
                vel[0] = ((seed >> 4) & 0xFF) * 0.02f - 2.56f;
                vel[1] = 3.0f + ((seed >> 12) & 0xFF) * 0.02f;
                vel[2] = ((seed >> 20) & 0xFF) * 0.02f - 2.56f;
                func_800EF288(spawnPos, vel);
                break;
            case 1:  /* Sparks - random direction */
                vel[0] = ((seed >> 4) & 0xFF) * 0.1f - 12.8f;
                vel[1] = ((seed >> 12) & 0xFF) * 0.1f;
                vel[2] = ((seed >> 20) & 0xFF) * 0.1f - 12.8f;
                func_800EF62C(spawnPos, 1);
                break;
            case 2:  /* Fire - upward with flicker */
                vel[0] = ((seed >> 4) & 0xFF) * 0.03f - 3.84f;
                vel[1] = 5.0f;
                vel[2] = ((seed >> 20) & 0xFF) * 0.03f - 3.84f;
                func_800EF288(spawnPos, vel);
                break;
            case 3:  /* Steam */
                vel[0] = 0.0f;
                vel[1] = 4.0f;
                vel[2] = 0.0f;
                func_800EF288(spawnPos, vel);
                break;
            case 4:  /* Exhaust - backward */
                vel[0] = -5.0f;
                vel[1] = 0.5f;
                vel[2] = 0.0f;
                func_800EF288(spawnPos, vel);
                break;
        }

        emit[0x0C] = currentCount + 1;
    }
}

/*

 * func_800EF288 (932 bytes)
 * Smoke effect
 *
 * Creates a smoke particle with rising motion
 */
void func_800EF288(f32 *pos, f32 *vel) {
    void *effect;
    u8 *eff;

    if (pos == NULL) {
        return;
    }

    effect = func_800EE820(0, pos);  /* Type 0 = smoke */
    if (effect == NULL) {
        return;
    }

    eff = (u8 *)effect;

    /* Set velocity if provided */
    if (vel != NULL) {
        *(f32 *)(eff + 0x20) = vel[0];
        *(f32 *)(eff + 0x24) = vel[1];
        *(f32 *)(eff + 0x28) = vel[2];
    } else {
        /* Default upward drift */
        *(f32 *)(eff + 0x20) = 0.0f;
        *(f32 *)(eff + 0x24) = 2.0f;
        *(f32 *)(eff + 0x28) = 0.0f;
    }

    /* Set initial size and alpha */
    *(f32 *)(eff + 0x30) = 5.0f;   /* Initial radius */
    eff[0x38] = 180;              /* Initial alpha (semi-transparent) */
    eff[0x39] = 128;              /* Gray color R */
    eff[0x3A] = 128;              /* Gray color G */
    eff[0x3B] = 128;              /* Gray color B */
}

/*

 * func_800EF62C (712 bytes)
 * Spark effect
 *
 * Creates multiple spark particles that fly outward with gravity
 */
void func_800EF62C(f32 *pos, s32 count) {
    void *effect;
    u8 *eff;
    s32 i;
    s32 seed;
    f32 angle;
    f32 speed;

    if (pos == NULL || count <= 0) {
        return;
    }

    seed = D_80142AFC;

    for (i = 0; i < count; i++) {
        effect = func_800EE820(1, pos);  /* Type 1 = spark */
        if (effect == NULL) {
            break;
        }

        eff = (u8 *)effect;

        /* Random velocity direction */
        seed = seed * 0x41C64E6D + 12345;
        angle = (seed & 0xFFFF) * 0.0000958738f;  /* 0 to 2*PI */
        speed = 5.0f + ((seed >> 16) & 0xFF) * 0.05f;

        *(f32 *)(eff + 0x20) = speed * cosf(angle);
        *(f32 *)(eff + 0x24) = 3.0f + ((seed >> 8) & 0xFF) * 0.02f;  /* Upward */
        *(f32 *)(eff + 0x28) = speed * sinf(angle);

        /* Set spark appearance - bright yellow/orange */
        *(f32 *)(eff + 0x30) = 1.0f;  /* Small radius */
        eff[0x38] = 255;              /* Full alpha */
        eff[0x39] = 255;              /* Yellow R */
        eff[0x3A] = 200;              /* Yellow G */
        eff[0x3B] = 50;               /* Yellow B */
    }
}

/*

 * func_800EF8F4 (1460 bytes)
 * Explosion effect
 *
 * Creates a large explosion with fireball, smoke, and sparks
 */
void func_800EF8F4(f32 *pos, f32 radius) {
    void *effect;
    u8 *eff;
    s32 seed;
    f32 sparkPos[3];
    s32 i;

    if (pos == NULL) {
        return;
    }

    /* Create main fireball */
    effect = func_800EE820(2, pos);  /* Type 2 = explosion */
    if (effect != NULL) {
        eff = (u8 *)effect;

        /* Set explosion properties */
        *(f32 *)(eff + 0x30) = radius * 0.5f;  /* Initial radius */
        eff[0x38] = 255;                       /* Full alpha */
        eff[0x39] = 255;                       /* Orange R */
        eff[0x3A] = 100;                       /* Orange G */
        eff[0x3B] = 20;                        /* Orange B */
    }

    /* Create smoke ring */
    seed = D_80142AFC;
    for (i = 0; i < 8; i++) {
        seed = seed * 0x41C64E6D + 12345;
        sparkPos[0] = pos[0] + ((seed >> 8) & 0xFF) * 0.1f - 12.8f;
        sparkPos[1] = pos[1] + 2.0f;
        sparkPos[2] = pos[2] + ((seed >> 16) & 0xFF) * 0.1f - 12.8f;

        func_800EF288(sparkPos, NULL);  /* Smoke puff */
    }

    /* Create sparks */
    func_800EF62C(pos, 20);

    /* Create secondary smoke */
    func_800EFEA8(pos);

    /* Play explosion sound */
    sound_play_menu(30);

    /* Screen shake if close to camera */
    func_800D11BC(15);  /* Camera shake */
}

/*

 * func_800EFEA8 (600 bytes)
 * Dust cloud effect
 *
 * Creates a settling dust cloud (from crashes, off-road driving)
 */
void func_800EFEA8(f32 *pos) {
    void *effect;
    u8 *eff;
    s32 seed;
    f32 dustPos[3];
    s32 i;

    if (pos == NULL) {
        return;
    }

    seed = D_80142AFC;

    /* Create multiple dust particles */
    for (i = 0; i < 5; i++) {
        seed = seed * 0x41C64E6D + 12345;
        dustPos[0] = pos[0] + ((seed >> 8) & 0xFF) * 0.08f - 10.24f;
        dustPos[1] = pos[1] + 1.0f;
        dustPos[2] = pos[2] + ((seed >> 16) & 0xFF) * 0.08f - 10.24f;

        effect = func_800EE820(3, dustPos);  /* Type 3 = dust */
        if (effect != NULL) {
            eff = (u8 *)effect;

            /* Random horizontal velocity */
            *(f32 *)(eff + 0x20) = ((seed >> 4) & 0xFF) * 0.02f - 2.56f;
            *(f32 *)(eff + 0x24) = -0.5f;  /* Settle down */
            *(f32 *)(eff + 0x28) = ((seed >> 12) & 0xFF) * 0.02f - 2.56f;

            /* Brown/tan color */
            *(f32 *)(eff + 0x30) = 4.0f + (i * 0.5f);  /* Varying size */
            eff[0x38] = 150;              /* Semi-transparent */
            eff[0x39] = 180;              /* Brown R */
            eff[0x3A] = 150;              /* Brown G */
            eff[0x3B] = 100;              /* Brown B */
        }
    }
}

/*

 * func_800F0100 (1396 bytes)
 * Skid mark render
 *
 * Renders tire skid marks on the track surface
 * Uses decal-style rendering on track geometry
 */
void func_800F0100(void *tire) {
    extern u8 D_80155800[];    /* Skid mark buffer */
    extern s32 D_80155C00;     /* Skid mark count */
    extern s32 D_80155C04;     /* Max skid marks */
    extern Gfx **D_80149438;   /* Display list pointer */
    u8 *tireData = (u8 *)tire;
    u8 *skidMark;
    f32 *tirePos;
    f32 skidIntensity;
    s32 slot;

    if (tireData == NULL) {
        return;
    }

    /* Get tire position (offset 0x00) */
    tirePos = (f32 *)(tireData + 0x00);

    /* Get slip intensity (offset 0x20) - how hard the tire is slipping */
    skidIntensity = *(f32 *)(tireData + 0x20);

    /* Only create skid marks if tire is slipping significantly */
    if (skidIntensity < 0.3f) {
        return;
    }

    /* Find or create skid mark slot */
    if (D_80155C00 >= D_80155C04) {
        /* Buffer full - overwrite oldest */
        slot = 0;
    } else {
        slot = D_80155C00;
        D_80155C00++;
    }

    skidMark = &D_80155800[slot * 0x40];

    /* Store skid mark data */
    *(f32 *)(skidMark + 0x00) = tirePos[0];
    *(f32 *)(skidMark + 0x04) = tirePos[1] + 0.02f;  /* Slightly above ground */
    *(f32 *)(skidMark + 0x08) = tirePos[2];

    /* Copy previous position for line segment */
    *(f32 *)(skidMark + 0x10) = *(f32 *)(tireData + 0x30);
    *(f32 *)(skidMark + 0x14) = *(f32 *)(tireData + 0x34) + 0.02f;
    *(f32 *)(skidMark + 0x18) = *(f32 *)(tireData + 0x38);

    /* Skid mark alpha based on intensity */
    skidMark[0x30] = (u8)(skidIntensity * 200.0f);
    skidMark[0x34] = 180;  /* Lifetime frames */
}

/*

 * func_800F0674 (472 bytes)
 * Trail effect
 *
 * Creates a fading trail behind a moving object (nitro boost, wings)
 */
void func_800F0674(void *object) {
    extern u8 D_80156000[];    /* Trail buffer */
    extern s32 D_80156400;     /* Trail segment count */
    extern s32 D_80156404;     /* Max trail segments */
    u8 *objData = (u8 *)object;
    u8 *trail;
    f32 *objPos;
    s32 slot;
    s32 i;

    if (objData == NULL) {
        return;
    }

    objPos = (f32 *)(objData + 0x24);

    /* Shift existing trail segments */
    for (i = D_80156404 - 1; i > 0; i--) {
        trail = &D_80156000[i * 0x20];
        u8 *prevTrail = &D_80156000[(i - 1) * 0x20];

        /* Copy position from previous */
        *(f32 *)(trail + 0x00) = *(f32 *)(prevTrail + 0x00);
        *(f32 *)(trail + 0x04) = *(f32 *)(prevTrail + 0x04);
        *(f32 *)(trail + 0x08) = *(f32 *)(prevTrail + 0x08);

        /* Fade alpha */
        trail[0x10] = (u8)(255 * (D_80156404 - i) / D_80156404);
    }

    /* Add new segment at head */
    trail = &D_80156000[0];
    *(f32 *)(trail + 0x00) = objPos[0];
    *(f32 *)(trail + 0x04) = objPos[1];
    *(f32 *)(trail + 0x08) = objPos[2];
    trail[0x10] = 255;  /* Full alpha at head */

    if (D_80156400 < D_80156404) {
        D_80156400++;
    }
}

/*

 * func_800F084C (208 bytes)
 * Weather rain
 *
 * Renders falling rain particles
 */
void func_800F084C(void) {
    extern u8 D_80156800[];    /* Rain particle buffer */
    extern s32 D_80156C00;     /* Active rain drops */
    extern f32 D_80158000[];   /* Camera position */
    s32 i;
    s32 seed;
    f32 *drop;

    seed = D_80142AFC;

    /* Update and spawn rain drops around camera */
    for (i = 0; i < 100; i++) {
        drop = (f32 *)&D_80156800[i * 0x10];

        /* Check if drop needs respawn */
        if (drop[1] < 0.0f) {
            /* Respawn at top near camera */
            seed = seed * 0x41C64E6D + 12345;
            drop[0] = D_80158000[0] + ((seed >> 8) & 0xFF) - 128.0f;
            drop[1] = D_80158000[1] + 50.0f;
            drop[2] = D_80158000[2] + ((seed >> 16) & 0xFF) - 128.0f;
            drop[3] = 0.0f;  /* Reset fall distance */
        }

        /* Move drop downward */
        drop[1] -= 8.0f;
        drop[3] += 8.0f;  /* Track fall distance for trail length */
    }
}

/*

 * func_800F091C (564 bytes)
 * Weather snow
 *
 * Renders falling snow particles with wind drift
 */
void func_800F091C(void) {
    extern u8 D_80157000[];    /* Snow particle buffer */
    extern s32 D_80157400;     /* Active snowflakes */
    extern f32 D_80157404;     /* Wind X */
    extern f32 D_80157408;     /* Wind Z */
    s32 i;
    s32 seed;
    f32 *flake;
    f32 drift;

    seed = D_80142AFC;

    /* Update wind with slow sine wave */
    D_80157404 = sinf(D_80142AFC * 0.01f) * 2.0f;
    D_80157408 = cosf(D_80142AFC * 0.015f) * 1.5f;

    /* Update and spawn snowflakes */
    for (i = 0; i < 80; i++) {
        flake = (f32 *)&D_80157000[i * 0x14];

        /* Check if flake needs respawn */
        if (flake[1] < 0.0f) {
            /* Respawn at top near camera */
            seed = seed * 0x41C64E6D + 12345;
            flake[0] = D_80158000[0] + ((seed >> 8) & 0xFF) - 128.0f;
            flake[1] = D_80158000[1] + 40.0f;
            flake[2] = D_80158000[2] + ((seed >> 16) & 0xFF) - 128.0f;
            flake[3] = ((seed >> 4) & 0xFF) * 0.01f;  /* Random phase for wobble */
            flake[4] = 1.0f + ((seed >> 24) & 0x0F) * 0.1f;  /* Size */
        }

        /* Move flake with wind and wobble */
        drift = sinf(D_80142AFC * 0.1f + flake[3]) * 0.5f;
        flake[0] += D_80157404 + drift;
        flake[1] -= 1.5f;  /* Slow fall */
        flake[2] += D_80157408;
    }
}

/*

 * func_800F0F4C (468 bytes)
 * Weather fog
 *
 * Configures RDP fog settings for distance fog effect
 */
void func_800F0F4C(f32 density) {
    extern Gfx **D_80149438;   /* Display list pointer */
    extern u8 D_80157500;      /* Fog R */
    extern u8 D_80157501;      /* Fog G */
    extern u8 D_80157502;      /* Fog B */
    extern f32 D_80157504;     /* Current fog density */
    extern f32 D_80157508;     /* Fog near */
    extern f32 D_8015750C;     /* Fog far */
    Gfx *gfx;
    s32 fogMin, fogMax;

    if (density < 0.0f) {
        density = 0.0f;
    } else if (density > 1.0f) {
        density = 1.0f;
    }

    D_80157504 = density;

    /* Calculate fog range based on density */
    /* Higher density = closer fog start */
    fogMin = (s32)(900.0f - density * 800.0f);  /* Near plane */
    fogMax = (s32)(1000.0f - density * 500.0f); /* Far plane */

    if (fogMin < 100) fogMin = 100;
    if (fogMax < fogMin + 50) fogMax = fogMin + 50;

    /* Apply fog to display list */
    gfx = *D_80149438;

    /* Set fog color */
    gDPSetFogColor(gfx++, D_80157500, D_80157501, D_80157502, 255);

    /* Set fog parameters - simplified */
    gSPFogPosition(gfx++, fogMin, fogMax);

    *D_80149438 = gfx;
}

/*

 * func_800F1120 (252 bytes)
 * Weather update
 *
 * Updates current weather effects each frame
 */
void func_800F1120(void) {
    extern s32 D_80157600;     /* Current weather type: 0=clear, 1=rain, 2=snow, 3=fog */
    extern f32 D_80157604;     /* Weather intensity 0-1 */
    extern f32 D_80157608;     /* Target intensity */
    extern s32 D_8015760C;     /* Weather transition timer */

    /* Smooth transition between intensities */
    if (D_80157604 < D_80157608) {
        D_80157604 += 0.01f;
        if (D_80157604 > D_80157608) {
            D_80157604 = D_80157608;
        }
    } else if (D_80157604 > D_80157608) {
        D_80157604 -= 0.01f;
        if (D_80157604 < D_80157608) {
            D_80157604 = D_80157608;
        }
    }

    /* Update based on weather type */
    switch (D_80157600) {
        case 0:  /* Clear - no weather effects */
            break;

        case 1:  /* Rain */
            func_800F084C();
            func_800F0F4C(D_80157604 * 0.3f);  /* Light fog with rain */
            break;

        case 2:  /* Snow */
            func_800F091C();
            func_800F0F4C(D_80157604 * 0.5f);  /* More fog with snow */
            break;

        case 3:  /* Fog only */
            func_800F0F4C(D_80157604);
            break;
    }
}

/*

 * func_800F121C (1824 bytes)
 * Lighting setup
 *
 * Configures scene lighting for rendering
 */
void func_800F121C(void) {
    extern Gfx **D_80149438;
    extern u8 D_80157800[];    /* Ambient light RGB */
    extern u8 D_80157804[];    /* Directional light RGB */
    extern f32 D_80157808[];   /* Light direction (normalized) */
    extern s32 D_80157814;     /* Time of day (0-2400) */
    Gfx *gfx;
    s32 timeOfDay;
    f32 sunAngle;
    f32 brightness;

    gfx = *D_80149438;
    timeOfDay = D_80157814;

    /* Calculate sun angle based on time of day */
    sunAngle = (timeOfDay / 2400.0f) * 3.14159f;
    brightness = sinf(sunAngle);
    if (brightness < 0.0f) brightness = 0.0f;

    /* Set ambient light based on time */
    D_80157800[0] = (u8)(40 + brightness * 60);   /* R */
    D_80157800[1] = (u8)(40 + brightness * 70);   /* G */
    D_80157800[2] = (u8)(60 + brightness * 80);   /* B */

    /* Set directional light color */
    D_80157804[0] = (u8)(brightness * 255);
    D_80157804[1] = (u8)(brightness * 240);
    D_80157804[2] = (u8)(brightness * 200);

    /* Set light direction (from sun position) */
    D_80157808[0] = cosf(sunAngle);
    D_80157808[1] = sinf(sunAngle);
    D_80157808[2] = 0.3f;

    /* Apply to RSP */
    gSPNumLights(gfx++, 1);

    *D_80149438 = gfx;
}

/*

 * func_800F193C (968 bytes)
 * Shadow render
 *
 * Renders a blob shadow under an object
 */
void func_800F193C(void *object) {
    extern Gfx **D_80149438;
    u8 *objData = (u8 *)object;
    f32 *objPos;
    f32 groundY;
    f32 shadowScale;
    f32 height;

    if (objData == NULL) {
        return;
    }

    objPos = (f32 *)(objData + 0x24);

    /* Get ground height at object position */
    groundY = func_800ED3FC(objPos[0], objPos[2]);

    /* Calculate height above ground */
    height = objPos[1] - groundY;
    if (height < 0.0f) height = 0.0f;
    if (height > 50.0f) {
        return;  /* Too high, no shadow */
    }

    /* Shadow shrinks and fades with height */
    shadowScale = 1.0f - (height / 50.0f);

    /* Get base shadow size from object (offset 0x48) */
    f32 baseSize = *(f32 *)(objData + 0x48);
    f32 shadowSize = baseSize * shadowScale * 0.8f;

    /* Draw shadow decal at ground level */
    func_800C6E60(
        (s32)(objPos[0] - shadowSize),
        (s32)(objPos[2] - shadowSize),
        (s32)(shadowSize * 2.0f),
        (s32)(shadowSize * 2.0f),
        0, 0, 0, (s32)(128 * shadowScale)  /* Black, fading alpha */
    );
}

/*

 * func_800F1D04 (924 bytes)
 * Lens flare
 *
 * Renders lens flare effect when looking toward the sun
 */
void func_800F1D04(f32 *sunPos) {
    extern f32 D_80158010[];   /* Camera forward */
    f32 toSun[3];
    f32 dot;
    f32 dist;
    s32 screenX, screenY;
    s32 flareAlpha;

    if (sunPos == NULL) {
        return;
    }

    /* Calculate vector to sun */
    toSun[0] = sunPos[0] - D_80158000[0];
    toSun[1] = sunPos[1] - D_80158000[1];
    toSun[2] = sunPos[2] - D_80158000[2];

    /* Normalize */
    dist = sqrtf(toSun[0] * toSun[0] + toSun[1] * toSun[1] + toSun[2] * toSun[2]);
    if (dist < 0.001f) return;
    toSun[0] /= dist;
    toSun[1] /= dist;
    toSun[2] /= dist;

    /* Dot product with camera forward = how aligned we are */
    dot = toSun[0] * D_80158010[0] + toSun[1] * D_80158010[1] + toSun[2] * D_80158010[2];

    /* Only show flare when looking toward sun */
    if (dot < 0.5f) {
        return;
    }

    /* Calculate screen position (simplified projection) */
    screenX = 160 + (s32)(toSun[0] * 100.0f);
    screenY = 120 - (s32)(toSun[1] * 100.0f);

    /* Flare intensity based on alignment */
    flareAlpha = (s32)((dot - 0.5f) * 2.0f * 180.0f);
    if (flareAlpha > 180) flareAlpha = 180;

    /* Draw main flare glow */
    func_800C6E60(screenX - 30, screenY - 30, 60, 60, 255, 255, 200, flareAlpha);

    /* Draw secondary flares along line to center */
    func_800C6E60(screenX - 10, screenY - 10, 20, 20, 255, 200, 150, flareAlpha / 2);
    func_800C6E60(160 - 8, 120 - 8, 16, 16, 200, 150, 100, flareAlpha / 3);
}

/*

 * func_800F20A0 (1664 bytes)
 * Environment map
 *
 * Configures RSP for environment mapping on reflective surfaces
 */
void func_800F20A0(void *object) {
    extern Gfx **D_80149438;
    extern u8 D_80158200[];    /* Envmap texture */
    u8 *objData = (u8 *)object;
    Gfx *gfx;
    s32 useEnvmap;

    if (objData == NULL) {
        return;
    }

    /* Check if object uses envmap (offset 0x7C flags) */
    useEnvmap = *(s32 *)(objData + 0x7C) & 0x10;
    if (!useEnvmap) {
        return;
    }

    gfx = *D_80149438;

    /* Set up texture generation for environment mapping */
    gSPTexture(gfx++, 0x8000, 0x8000, 0, G_TX_RENDERTILE, G_ON);

    /* Configure for spherical envmap */
    gDPSetTexturePersp(gfx++, G_TP_PERSP);
    gDPSetCombineMode(gfx++, G_CC_MODULATERGBA, G_CC_MODULATERGBA);

    /* Set envmap texture */
    gDPSetTextureImage(gfx++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 32, D_80158200);

    *D_80149438 = gfx;
}

/*

 * func_800F2720 (376 bytes)
 * Reflection setup
 *
 * Configures planar reflection rendering for wet surfaces
 */
void func_800F2720(void) {
    extern Gfx **D_80149438;
    extern s32 D_80158400;     /* Reflection enabled */
    extern f32 D_80158404;     /* Reflection plane Y */
    extern f32 D_80158408;     /* Reflection intensity */
    Gfx *gfx;

    if (!D_80158400) {
        return;
    }

    gfx = *D_80149438;

    /* Set up reflection blend mode */
    gDPSetRenderMode(gfx++, G_RM_XLU_SURF, G_RM_XLU_SURF2);
    gDPSetCombineMode(gfx++, G_CC_MODULATEIA, G_CC_MODULATEIA);

    /* Set reflection alpha */
    gDPSetPrimColor(gfx++, 0, 0, 255, 255, 255, (s32)(D_80158408 * 128.0f));

    *D_80149438 = gfx;
}

/*

 * func_800F2890 (408 bytes)
 * Water surface
 *
 * Renders animated water surface with wave distortion
 */
void func_800F2890(void) {
    extern Gfx **D_80149438;
    extern f32 D_80158500;     /* Water level Y */
    extern s32 D_80158504;     /* Water tile count X */
    extern s32 D_80158508;     /* Water tile count Z */
    Gfx *gfx;
    f32 waveOffset;
    s32 wavePhase;

    gfx = *D_80149438;

    /* Calculate wave animation offset */
    wavePhase = D_80142AFC & 0x3F;  /* 64 frame cycle */
    waveOffset = sinf(wavePhase * 0.098f) * 0.5f;

    /* Set up water render mode - translucent with texture */
    gDPSetRenderMode(gfx++, G_RM_XLU_SURF, G_RM_XLU_SURF2);
    gDPSetCombineMode(gfx++, G_CC_MODULATEIA, G_CC_MODULATEIA);

    /* Set water color - blue-green tint */
    gDPSetPrimColor(gfx++, 0, 0, 100, 150, 200, 160);

    /* Scroll texture for wave effect */
    gDPSetTileSize(gfx++, G_TX_RENDERTILE,
        (s32)(waveOffset * 32.0f) << 2, 0,
        (31 + (s32)(waveOffset * 32.0f)) << 2, 31 << 2);

    *D_80149438 = gfx;
}

/*

 * func_800F2A28 (2736 bytes)
 * Skybox render
 *
 * Renders the skybox around the camera
 */
void func_800F2A28(void *camera) {
    extern Gfx **D_80149438;
    extern u8 D_80158600[];    /* Skybox texture data */
    extern s32 D_80158604;     /* Skybox type: 0=day, 1=sunset, 2=night */
    u8 *camData = (u8 *)camera;
    Gfx *gfx;
    f32 *camPos;
    f32 *camRot;
    s32 skyType;

    if (camData == NULL) {
        return;
    }

    gfx = *D_80149438;
    camPos = (f32 *)(camData + 0x00);
    camRot = (f32 *)(camData + 0x30);
    skyType = D_80158604;

    /* Disable Z buffer for skybox (always behind) */
    gDPSetRenderMode(gfx++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
    gSPClearGeometryMode(gfx++, G_ZBUFFER);

    /* Set sky color based on type */
    switch (skyType) {
        case 0:  /* Day - blue gradient */
            gDPSetPrimColor(gfx++, 0, 0, 135, 206, 235, 255);
            break;
        case 1:  /* Sunset - orange/pink */
            gDPSetPrimColor(gfx++, 0, 0, 255, 140, 100, 255);
            break;
        case 2:  /* Night - dark blue */
            gDPSetPrimColor(gfx++, 0, 0, 20, 20, 60, 255);
            break;
    }

    /* Draw skybox geometry (would reference display list) */
    gDPSetCombineMode(gfx++, G_CC_SHADE, G_CC_SHADE);

    /* Re-enable Z buffer */
    gSPSetGeometryMode(gfx++, G_ZBUFFER);

    *D_80149438 = gfx;
}

/*

 * func_800F34D8 (3576 bytes)
 * Track render
 *
 * Renders visible track sections based on camera position
 */
void func_800F34D8(void *camera) {
    u8 *camData = (u8 *)camera;
    f32 *camPos;
    s32 i;
    s32 lod;
    f32 dx, dz, dist;

    if (camData == NULL) {
        return;
    }

    camPos = (f32 *)(camData + 0x00);

    /* Iterate through track sections */
    for (i = 0; i < D_80159000; i++) {
        u8 *section = &D_80159010[i * 0x40];
        f32 *sectionPos = (f32 *)(section + 0x00);

        /* Frustum cull check */
        if (!func_800F42D0(i, camera)) {
            continue;
        }

        /* Calculate distance for LOD */
        dx = camPos[0] - sectionPos[0];
        dz = camPos[2] - sectionPos[2];
        dist = sqrtf(dx * dx + dz * dz);

        /* Select LOD based on distance */
        lod = func_800F43D4(dist);

        /* Load textures for this section */
        func_800F5F90(*(s32 *)(section + 0x30));

        /* Render section geometry at selected LOD */
        /* (would call into display list rendering) */
    }
}

/*

 * func_800F42D0 (260 bytes)
 * Track section visible
 *
 * Checks if a track section is within camera frustum
 */
s32 func_800F42D0(s32 sectionId, void *camera) {
    u8 *camData = (u8 *)camera;
    u8 *section;
    f32 *camPos;
    f32 *camFwd;
    f32 *sectionPos;
    f32 toSection[3];
    f32 dot;
    f32 dist;

    if (camData == NULL) {
        return 0;
    }

    section = &D_80159010[sectionId * 0x40];
    camPos = (f32 *)(camData + 0x00);
    camFwd = (f32 *)(camData + 0x30);
    sectionPos = (f32 *)(section + 0x00);

    /* Vector to section center */
    toSection[0] = sectionPos[0] - camPos[0];
    toSection[1] = sectionPos[1] - camPos[1];
    toSection[2] = sectionPos[2] - camPos[2];

    /* Distance check */
    dist = toSection[0] * toSection[0] + toSection[2] * toSection[2];
    if (dist > 90000.0f) {  /* 300 units max distance */
        return 0;
    }

    /* Dot product with camera forward (behind camera check) */
    dot = toSection[0] * camFwd[0] + toSection[2] * camFwd[2];
    if (dot < -50.0f) {
        return 0;  /* Behind camera */
    }

    return 1;
}

/*

 * func_800F43D4 (560 bytes)
 * Track LOD select
 *
 * Selects appropriate LOD level based on distance from camera
 */
s32 func_800F43D4(f32 distance) {
    /* LOD thresholds */
    if (distance < 50.0f) {
        return 0;  /* High detail */
    } else if (distance < 150.0f) {
        return 1;  /* Medium detail */
    } else if (distance < 250.0f) {
        return 2;  /* Low detail */
    }
    return 3;  /* Lowest/billboard */
}

/*

 * func_800F4604 (6540 bytes)
 * Track geometry stream
 *
 * Streams track geometry data from ROM to RSP
 */
void func_800F4604(void) {
    extern Gfx **D_80149438;
    extern s32 D_80159100;     /* Current stream position */
    extern s32 D_80159104;     /* Total geometry size */
    Gfx *gfx;
    s32 chunkSize;

    gfx = *D_80149438;

    /* Calculate chunk to stream this frame */
    chunkSize = 0x1000;  /* 4KB per frame */
    if (D_80159100 + chunkSize > D_80159104) {
        chunkSize = D_80159104 - D_80159100;
    }

    if (chunkSize <= 0) {
        D_80159100 = 0;  /* Reset to beginning */
        return;
    }

    /* Issue DMA for geometry data */
    /* (would normally call osPiStartDma) */

    /* Add geometry display list */
    gSPDisplayList(gfx++, (Gfx*)((u8*)&D_80159200 + D_80159100));

    D_80159100 += chunkSize;

    *D_80149438 = gfx;
}

/*

 * func_800F5F90 (1348 bytes)
 * Track texture load
 *
 * Loads track texture into TMEM
 */
void func_800F5F90(s32 textureId) {
    extern Gfx **D_80149438;
    extern s32 D_80159404;     /* Current loaded texture */
    Gfx *gfx;
    u8 *texData;

    /* Skip if already loaded */
    if (textureId == D_80159404) {
        return;
    }

    if (textureId < 0 || textureId >= 256) {
        return;
    }

    texData = D_80159400[textureId];
    if (texData == NULL) {
        return;
    }

    gfx = *D_80149438;
    D_80159404 = textureId;

    /* Load texture to TMEM */
    gDPSetTextureImage(gfx++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 32, texData);
    gDPLoadSync(gfx++);
    gDPLoadBlock(gfx++, G_TX_LOADTILE, 0, 0, 32 * 32 - 1, 0);

    /* Set tile parameters */
    gDPSetTile(gfx++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 8, 0,
               G_TX_RENDERTILE, 0, G_TX_WRAP, 5, 0, G_TX_WRAP, 5, 0);

    *D_80149438 = gfx;
}

/*

 * func_800F64D4 (1120 bytes)
 * Billboard render
 *
 * Renders a camera-facing billboard sprite
 */
void func_800F64D4(void *billboard) {
    extern Gfx **D_80149438;
    u8 *bbData = (u8 *)billboard;
    Gfx *gfx;
    f32 *bbPos;
    f32 dx, dz;
    f32 angle;
    f32 size;

    if (bbData == NULL) {
        return;
    }

    gfx = *D_80149438;
    bbPos = (f32 *)(bbData + 0x00);
    size = *(f32 *)(bbData + 0x10);

    /* Calculate angle to face camera */
    dx = D_80158000[0] - bbPos[0];
    dz = D_80158000[2] - bbPos[2];

    /* Set up billboard transform matrix */
    /* (would build rotation matrix to face camera) */

    /* Set texture from billboard data */
    gDPSetTextureImage(gfx++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 32,
                       (u8 *)(*(s32 *)(bbData + 0x20)));

    /* Draw quad */
    gSPVertex(gfx++, bbData + 0x40, 4, 0);
    gSP2Triangles(gfx++, 0, 1, 2, 0, 0, 2, 3, 0);

    *D_80149438 = gfx;
}

/*

 * func_800F6934 (388 bytes)
 * Sign render
 *
 * Renders roadside signs (speed limits, directions, etc.)
 */
void func_800F6934(void *sign) {
    u8 *signData = (u8 *)sign;
    f32 *signPos;
    s32 signType;

    if (signData == NULL) {
        return;
    }

    signPos = (f32 *)(signData + 0x00);
    signType = *(s32 *)(signData + 0x0C);

    /* Render as billboard facing camera */
    func_800F64D4(sign);
}

/*

 * func_800F6AB8 (2460 bytes)
 * Props render
 *
 * Renders track props (cones, barriers, trees, etc.)
 */
void func_800F6AB8(void *camera) {
    extern u8 D_80159610[];    /* Prop data array */
    u8 *camData = (u8 *)camera;
    f32 *camPos;
    s32 i;
    f32 dx, dz, distSq;

    if (camData == NULL) {
        return;
    }

    camPos = (f32 *)(camData + 0x00);

    /* Render each visible prop */
    for (i = 0; i < D_80159600; i++) {
        u8 *prop = &D_80159610[i * 0x30];
        f32 *propPos = (f32 *)(prop + 0x00);
        s32 propType = *(s32 *)(prop + 0x10);

        /* Distance cull */
        dx = propPos[0] - camPos[0];
        dz = propPos[2] - camPos[2];
        distSq = dx * dx + dz * dz;

        if (distSq > 40000.0f) {  /* 200 units */
            continue;
        }

        /* Render based on type */
        switch (propType) {
            case 0:  /* Cone */
            case 1:  /* Barrier */
                func_800F64D4(prop);  /* As billboard */
                break;
            case 2:  /* Tree */
            case 3:  /* Building */
                /* Full 3D model render */
                break;
        }
    }
}

/*

 * func_800F7454 (1996 bytes)
 * Crowd render
 *
 * Renders animated crowd sprites along the track
 */
void func_800F7454(void) {
    extern Gfx **D_80149438;
    extern u8 D_80159810[];    /* Crowd section data */
    Gfx *gfx;
    s32 i;
    s32 animFrame;
    f32 dx, dz, distSq;

    gfx = *D_80149438;

    /* Animation frame (4 frames, cycle every 8 game frames) */
    animFrame = (D_80142AFC >> 3) & 0x03;

    /* Render each crowd section */
    for (i = 0; i < D_80159800; i++) {
        u8 *crowd = &D_80159810[i * 0x40];
        f32 *crowdPos = (f32 *)(crowd + 0x00);
        s32 crowdCount = *(s32 *)(crowd + 0x10);

        /* Distance cull */
        dx = crowdPos[0] - D_80158000[0];
        dz = crowdPos[2] - D_80158000[2];
        distSq = dx * dx + dz * dz;

        if (distSq > 22500.0f) {  /* 150 units */
            continue;
        }

        /* Set crowd sprite based on animation frame */
        gDPSetTextureImage(gfx++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 32,
                           (u8 *)(*(s32 *)(crowd + 0x20 + animFrame * 4)));

        /* Draw crowd billboards */
        gSPDisplayList(gfx++, crowd + 0x30);
    }

    *D_80149438 = gfx;
}

/*

 * func_800F7C28 (796 bytes)
 * Car body render
 *
 * Renders the car body mesh with paint/decals
 */
void func_800F7C28(void *car) {
    extern Gfx **D_80149438;
    u8 *carData = (u8 *)car;
    Gfx *gfx;
    s32 carModel;
    s32 paintColor;
    u8 *bodyMesh;

    if (carData == NULL) {
        return;
    }

    gfx = *D_80149438;

    /* Get car model ID (offset 0x00) */
    carModel = *(s32 *)(carData + 0x00);

    /* Get paint color (offset 0x04) */
    paintColor = *(s32 *)(carData + 0x04);

    /* Get body mesh pointer (offset 0x80) */
    bodyMesh = (u8 *)(*(s32 *)(carData + 0x80));

    if (bodyMesh == NULL) {
        *D_80149438 = gfx;
        return;
    }

    /* Set car color as primitive color */
    gDPSetPrimColor(gfx++, 0, 0,
        (paintColor >> 16) & 0xFF,
        (paintColor >> 8) & 0xFF,
        paintColor & 0xFF, 255);

    /* Set up environment mapping for reflective paint */
    func_800F20A0(car);

    /* Draw body mesh display list */
    gSPDisplayList(gfx++, bodyMesh);

    *D_80149438 = gfx;
}

/*

 * func_800F7F44 (1604 bytes)
 * Car wheels render
 *
 * Renders the four wheels with rotation and steering
 */
void func_800F7F44(void *car) {
    extern Gfx **D_80149438;
    u8 *carData = (u8 *)car;
    Gfx *gfx;
    f32 steerAngle;
    f32 wheelRotation;
    s32 i;

    if (carData == NULL) {
        return;
    }

    gfx = *D_80149438;

    /* Get steering angle (offset 0xC0) */
    steerAngle = *(f32 *)(carData + 0xC0);

    /* Get wheel rotation (offset 0xC4) */
    wheelRotation = *(f32 *)(carData + 0xC4);

    /* Render each wheel */
    for (i = 0; i < 4; i++) {
        u8 *wheelData = carData + 0x100 + (i * 0x40);
        f32 *wheelPos = (f32 *)(wheelData + 0x00);
        u8 *wheelMesh = (u8 *)(*(s32 *)(wheelData + 0x30));

        if (wheelMesh == NULL) {
            continue;
        }

        /* Build wheel transform matrix */
        /* Front wheels (0,1) get steering rotation */
        /* All wheels get rotation animation */

        /* Draw wheel mesh */
        gSPDisplayList(gfx++, wheelMesh);

        /* Render skid marks if slipping */
        func_800F0100(wheelData);
    }

    *D_80149438 = gfx;
}

/*

 * func_800F8588 (548 bytes)
 * Car damage render
 *
 * Renders visual damage on car (dents, scratches, missing parts)
 */
void func_800F8588(void *car) {
    extern Gfx **D_80149438;
    u8 *carData = (u8 *)car;
    Gfx *gfx;
    s32 damageLevel;
    u8 *damageMesh;

    if (carData == NULL) {
        return;
    }

    /* Get damage level (offset 0x1B0) */
    damageLevel = *(s32 *)(carData + 0x1B0);

    if (damageLevel <= 0) {
        return;  /* No damage */
    }

    gfx = *D_80149438;

    /* Get damage overlay mesh based on level */
    if (damageLevel < 3) {
        damageMesh = (u8 *)(*(s32 *)(carData + 0x84));  /* Light damage */
    } else if (damageLevel < 6) {
        damageMesh = (u8 *)(*(s32 *)(carData + 0x88));  /* Medium damage */
    } else {
        damageMesh = (u8 *)(*(s32 *)(carData + 0x8C));  /* Heavy damage */
    }

    if (damageMesh != NULL) {
        /* Set damage decal blend mode */
        gDPSetRenderMode(gfx++, G_RM_XLU_SURF, G_RM_XLU_SURF2);
        gSPDisplayList(gfx++, damageMesh);
    }

    *D_80149438 = gfx;
}

/*

 * func_800F87AC (964 bytes)
 * Car lights render
 *
 * Renders car headlights, taillights, and brake lights
 */
void func_800F87AC(void *car) {
    extern Gfx **D_80149438;
    u8 *carData = (u8 *)car;
    Gfx *gfx;
    f32 *carPos;
    s32 isBraking;
    s32 lightsOn;

    if (carData == NULL) {
        return;
    }

    gfx = *D_80149438;
    carPos = (f32 *)(carData + 0x24);

    /* Check if braking (offset 0xCC) */
    isBraking = *(s32 *)(carData + 0xCC) > 0;

    /* Lights on at night or in tunnels */
    lightsOn = (D_80157814 < 600 || D_80157814 > 1800);

    if (lightsOn) {
        /* Headlights - bright white glow */
        gDPSetPrimColor(gfx++, 0, 0, 255, 255, 220, 200);
        /* (would render headlight billboards) */
    }

    /* Taillights always visible */
    if (isBraking) {
        /* Bright red brake lights */
        gDPSetPrimColor(gfx++, 0, 0, 255, 50, 50, 255);
    } else {
        /* Dim red taillights */
        gDPSetPrimColor(gfx++, 0, 0, 200, 30, 30, 150);
    }

    /* (would render taillight billboards) */

    *D_80149438 = gfx;
}

/*

 * func_800F8B70 (556 bytes)
 * Car exhaust render
 *
 * Renders exhaust smoke/flames when accelerating
 */
void func_800F8B70(void *car) {
    u8 *carData = (u8 *)car;
    f32 *exhaustPos;
    f32 throttle;
    f32 speed;

    if (carData == NULL) {
        return;
    }

    /* Get throttle amount (offset 0xC4) */
    throttle = *(f32 *)(carData + 0xC4);

    /* Get speed (offset 0x34 velocity magnitude) */
    speed = *(f32 *)(carData + 0x50);

    /* Only show exhaust when accelerating */
    if (throttle < 0.3f) {
        return;
    }

    /* Get exhaust position (offset 0x200) */
    exhaustPos = (f32 *)(carData + 0x200);

    /* Create smoke particle at exhaust */
    if (speed > 20.0f) {
        /* At high speed, less visible exhaust */
        if ((*(u32 *)&carData[0x08] & 0x07) == 0) {  /* Every 8 frames */
            func_800EF288(exhaustPos, NULL);
        }
    } else {
        /* At low speed, more visible puffs */
        if ((*(u32 *)&carData[0x08] & 0x03) == 0) {  /* Every 4 frames */
            func_800EF288(exhaustPos, NULL);
        }
    }
}

/*

 * func_800F8D9C (300 bytes)
 * Car antenna render
 *
 * Renders flexible car antenna with physics-based wobble
 */
void func_800F8D9C(void *car) {
    extern Gfx **D_80149438;
    u8 *carData = (u8 *)car;
    Gfx *gfx;
    f32 *antennaBase;
    f32 wobbleX, wobbleZ;
    f32 speed;

    if (carData == NULL) {
        return;
    }

    /* Get antenna base position (offset 0x210) */
    antennaBase = (f32 *)(carData + 0x210);

    /* Get car speed for wobble intensity */
    speed = *(f32 *)(carData + 0x50);

    /* Calculate wobble based on velocity and random variation */
    wobbleX = *(f32 *)(carData + 0x34) * 0.02f;  /* Velocity X */
    wobbleZ = *(f32 *)(carData + 0x3C) * 0.02f;  /* Velocity Z */

    /* Clamp wobble */
    if (wobbleX > 0.3f) wobbleX = 0.3f;
    if (wobbleX < -0.3f) wobbleX = -0.3f;
    if (wobbleZ > 0.3f) wobbleZ = 0.3f;
    if (wobbleZ < -0.3f) wobbleZ = -0.3f;

    gfx = *D_80149438;

    /* Draw antenna line segments */
    /* (would build line strip with wobble offset) */

    *D_80149438 = gfx;
}

/*

 * func_800F8EC8 (1240 bytes)
 * Car nitro effect
 *
 * Renders nitro boost flames and trail effect
 */
void func_800F8EC8(void *car) {
    extern Gfx **D_80149438;
    u8 *carData = (u8 *)car;
    Gfx *gfx;
    f32 *exhaustPos;
    f32 nitroAmount;
    s32 flameIntensity;
    f32 vel[3];

    if (carData == NULL) {
        return;
    }

    /* Get nitro amount (offset 0x1C0) */
    nitroAmount = *(f32 *)(carData + 0x1C0);

    if (nitroAmount <= 0.0f) {
        return;  /* No nitro active */
    }

    gfx = *D_80149438;

    /* Get exhaust positions (offset 0x200, 0x20C for dual exhaust) */
    exhaustPos = (f32 *)(carData + 0x200);

    /* Flame intensity based on nitro level */
    flameIntensity = (s32)(nitroAmount * 255.0f);
    if (flameIntensity > 255) flameIntensity = 255;

    /* Set flame color - bright blue core, orange edges */
    gDPSetPrimColor(gfx++, 0, 0, 100, 150, 255, flameIntensity);

    /* Create flame particles */
    vel[0] = -*(f32 *)(carData + 0x34) * 0.5f;  /* Opposite of velocity */
    vel[1] = 1.0f;
    vel[2] = -*(f32 *)(carData + 0x3C) * 0.5f;

    /* Spawn flame particles every frame during nitro */
    func_800EF288(exhaustPos, vel);

    /* Spawn sparks occasionally */
    if ((D_80142AFC & 0x03) == 0) {
        func_800EF62C(exhaustPos, 3);
    }

    /* Update trail effect */
    func_800F0674(car);

    *D_80149438 = gfx;
}

/*

 * func_800F93A0 (5652 bytes)
 * Scene render main
 *
 * Main render function - sets up frame and renders all scene elements
 */
void func_800F93A0(void) {
    extern s32 D_80143A00;    /* Current render mode */
    /* Note: D_80149438 declared globally */

    /* Begin frame */
    func_800FAD58();

    /* Setup Z-buffer */
    func_800FA9B4();

    /* Render skybox */
    func_800F5B44();

    /* Render track geometry */
    func_800F7114();

    /* Render cars */
    func_800F7AA8();

    /* Render particle effects */
    func_800B811C();

    /* Render HUD elements */
    func_800CCFC0();

    /* End frame */
    func_800FADE0();
}

/*

 * func_800FA9B4 (948 bytes)
 * Z-buffer setup
 *
 * Configures RDP Z-buffer for depth testing
 */
void func_800FA9B4(void) {
    extern Gfx **D_80149438;  /* Display list pointer */
    Gfx *dl;

    dl = *D_80149438;

    /* Set Z-buffer mode */
    gDPSetDepthSource(dl++, G_ZS_PIXEL);
    gDPSetRenderMode(dl++, G_RM_ZB_OPA_SURF, G_RM_ZB_OPA_SURF2);
    gDPSetDepthImage(dl++, 0x802C0000);  /* Z-buffer address */

    /* Clear Z-buffer */
    gDPSetColorImage(dl++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 320, 0x802C0000);
    gDPSetFillColor(dl++, 0xFFFCFFFC);  /* Max depth */
    gDPFillRectangle(dl++, 0, 0, 319, 239);
    gDPPipeSync(dl++);

    /* Restore color image */
    gDPSetColorImage(dl++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 320, 0x80200000);

    *D_80149438 = dl;
}

/*

 * func_800FAD58 (136 bytes)
 * Frame start
 *
 * Initializes display list for new frame
 */
void func_800FAD58(void) {
    /* Note: D_80149430, D_80149438 declared globally */
    Gfx *dl;

    D_80142AFC++;

    /* Reset display list to base */
    dl = D_80149430;

    /* Initialize RSP and RDP */
    gSPSegment(dl++, 0, 0x00000000);
    gDPSetCycleType(dl++, G_CYC_1CYCLE);
    gDPSetTexturePersp(dl++, G_TP_PERSP);
    gDPSetTextureLOD(dl++, G_TL_TILE);
    gDPSetTextureLUT(dl++, G_TT_NONE);
    gDPSetTextureDetail(dl++, G_TD_CLAMP);
    gDPSetTextureConvert(dl++, G_TC_FILT);
    gDPSetCombineKey(dl++, G_CK_NONE);
    gDPSetAlphaCompare(dl++, G_AC_NONE);
    gDPPipeSync(dl++);

    *D_80149438 = dl;
}

/*

 * func_800FADE0 (1108 bytes)
 * Frame end
 *
 * Finalizes display list and submits to RDP
 */
void func_800FADE0(void) {
    /* Note: D_80149438, D_80149440 declared globally */
    Gfx *dl;

    dl = *D_80149438;

    /* End display list */
    gDPFullSync(dl++);
    gSPEndDisplayList(dl++);

    *D_80149438 = dl;

    /* Flush display list */
    func_800FB2C8();

    /* Wait for vsync */
    func_800FB234();
}

/*

 * func_800FB234 (148 bytes)
 * Vsync wait
 *
 * Waits for vertical blank period
 */
void func_800FB234(void) {
    extern OSMesgQueue D_80086AC0;  /* VI message queue */
    OSMesg msg;

    osRecvMesg(&D_80086AC0, &msg, OS_MESG_BLOCK);
}

/*

 * func_800FB2C8 (5944 bytes)
 * Display list flush
 *
 * Submits display list to RSP/RDP
 */
void func_800FB2C8(void) {
    extern Gfx **D_80149438;  /* Display list pointer */
    OSTask *task = &D_80149440;

    /* Configure task */
    task->t.type = M_GFXTASK;
    task->t.flags = 0;
    task->t.ucode_boot = (u64 *)rspbootTextStart;
    task->t.ucode_boot_size = (s32)rspbootTextEnd - (s32)rspbootTextStart;
    task->t.ucode = (u64 *)gspF3DEX2_fifoTextStart;
    task->t.ucode_data = (u64 *)gspF3DEX2_fifoDataStart;
    task->t.ucode_data_size = SP_UCODE_DATA_SIZE;
    task->t.dram_stack = NULL;
    task->t.dram_stack_size = 0;
    task->t.output_buff = NULL;
    task->t.output_buff_size = NULL;
    task->t.data_ptr = (u64 *)D_80149430;
    task->t.data_size = ((u8 *)*D_80149438 - (u8 *)D_80149430);
    task->t.yield_data_ptr = NULL;
    task->t.yield_data_size = 0;

    /* Start RSP task */
    osSpTaskStart(task);

    /* Wait for completion */
    osRecvMesg(&D_80086A88, NULL, OS_MESG_BLOCK);
}

/*

 * func_800FCA00 (1016 bytes)
 * Debug overlay
 *
 * Displays debug information overlay
 */
void func_800FCA00(void) {
    extern s32 D_80143B00;  /* FPS counter */
    char buf[32];

    if (!D_80159E00) {
        return;
    }

    /* FPS display */
    buf[0] = 'F'; buf[1] = 'P'; buf[2] = 'S'; buf[3] = ':';
    buf[4] = '0' + (D_80143B00 / 10);
    buf[5] = '0' + (D_80143B00 % 10);
    buf[6] = '\0';
    draw_text(buf, 10, 10, 255);

    /* Frame counter */
    buf[0] = 'F'; buf[1] = ':';
    {
        s32 f = D_80142AFC;
        buf[7] = '0' + (f % 10); f /= 10;
        buf[6] = '0' + (f % 10); f /= 10;
        buf[5] = '0' + (f % 10); f /= 10;
        buf[4] = '0' + (f % 10); f /= 10;
        buf[3] = '0' + (f % 10);
        buf[2] = '0' + (f / 10);
        buf[8] = '\0';
    }
    draw_text(buf, 10, 25, 200);

    /* Memory usage */
    func_800FCDF8();
}

/*

 * func_800FCDF8 (556 bytes)
 * Debug stats
 *
 * Shows memory and performance stats
 */
void func_800FCDF8(void) {
    char buf[32];

    if (!D_80159E00) {
        return;
    }

    /* Audio heap usage */
    {
        u32 used = D_80160400 - 0x80160400;  /* Assuming base */
        buf[0] = 'A'; buf[1] = 'U'; buf[2] = 'D'; buf[3] = ':';
        buf[4] = '0' + ((used / 100000) % 10);
        buf[5] = '0' + ((used / 10000) % 10);
        buf[6] = '0' + ((used / 1000) % 10);
        buf[7] = 'K';
        buf[8] = '\0';
        draw_text(buf, 10, 40, 180);
    }
}

/*

 * func_800FD024 (540 bytes)
 * Debug collision
 *
 * Draws collision debug visualization
 */
void func_800FD024(void) {

    if (!D_80159E04) {
        return;
    }

    /* Would draw collision wireframes */
    /* (Simplified - actual implementation draws collision meshes) */
}

/*

 * func_800FD240 (552 bytes)
 * Debug AI paths
 *
 * Draws AI waypoint paths
 */
void func_800FD240(void) {

    if (!D_80159E08) {
        return;
    }

    /* Would draw AI waypoints and paths */
    /* (Simplified - actual implementation draws debug lines) */
}

/*

 * func_800FD7E8 (244 bytes)
 * Random seed
 *
 * Sets the random number generator seed
 */
void func_800FD7E8(u32 seed) {

    D_80143500 = seed;

    /* Warm up the generator */
    D_80143500 = D_80143500 * 1103515245 + 12345;
    D_80143500 = D_80143500 * 1103515245 + 12345;
    D_80143500 = D_80143500 * 1103515245 + 12345;
}

/*

 * func_800FD8DC (284 bytes)
 * Random int
 *
 * Returns a random 32-bit integer (LCG)
 */
s32 func_800FD8DC(void) {

    D_80143500 = D_80143500 * 1103515245 + 12345;

    return (s32)D_80143500;
}

/*

 * func_800FD9F8 (1436 bytes)
 * Random float
 *
 * Returns a random float in [0.0, 1.0)
 */
f32 func_800FD9F8(void) {

    D_80143500 = D_80143500 * 1103515245 + 12345;

    /* Convert to float 0-1 */
    return (f32)(D_80143500 & 0x7FFFFF) / (f32)0x800000;
}

/*

 * func_800FDF94 (248 bytes)
 * Random range
 *
 * Returns a random integer in [min, max]
 */
s32 func_800FDF94(s32 min, s32 max) {
    s32 range;

    if (max <= min) {
        return min;
    }

    D_80143500 = D_80143500 * 1103515245 + 12345;
    range = max - min + 1;

    return min + (s32)((D_80143500 >> 16) % range);
}

/*

 * func_800FE08C (1072 bytes)
 * Timer start
 *
 * Starts a game timer
 * Timer struct at D_80159B00[id]:
 *   0x00: state (0=stopped, 1=running, 2=paused)
 *   0x04: start time (OS ticks)
 *   0x08: elapsed time
 *   0x0C: lap times[8]
 *   0x2C: lap count
 */
void func_800FE08C(s32 timerId) {
    extern u64 D_80159B00[8][6];  /* Timer data */

    if (timerId < 0 || timerId >= 8) {
        return;
    }

    D_80159B00[timerId][0] = 1;  /* Running */
    D_80159B00[timerId][1] = osGetTime();  /* Start time */
    D_80159B00[timerId][2] = 0;  /* Elapsed */
}

/*

 * func_800FE4BC (100 bytes)
 * Timer stop
 *
 * Stops a game timer
 */
void func_800FE4BC(s32 timerId) {
    extern u64 D_80159B00[8][6];  /* Timer data */

    if (timerId < 0 || timerId >= 8) {
        return;
    }

    if (D_80159B00[timerId][0] == 1) {
        /* Update elapsed before stopping */
        D_80159B00[timerId][2] = osGetTime() - D_80159B00[timerId][1];
    }

    D_80159B00[timerId][0] = 0;  /* Stopped */
}

/*

 * func_800FE520 (144 bytes)
 * Timer reset
 *
 * Resets a game timer
 */
void func_800FE520(s32 timerId) {
    extern u64 D_80159B00[8][6];  /* Timer data */
    s32 i;

    if (timerId < 0 || timerId >= 8) {
        return;
    }

    D_80159B00[timerId][0] = 0;  /* Stopped */
    D_80159B00[timerId][1] = 0;  /* Start time */
    D_80159B00[timerId][2] = 0;  /* Elapsed */

    /* Clear lap times */
    for (i = 3; i < 6; i++) {
        D_80159B00[timerId][i] = 0;
    }
}

/*

 * func_800FE5B0 (412 bytes)
 * Timer get elapsed
 *
 * Returns elapsed time in centiseconds
 */
s32 func_800FE5B0(s32 timerId) {
    extern u64 D_80159B00[8][6];  /* Timer data */
    u64 elapsed;
    s32 centisecs;

    if (timerId < 0 || timerId >= 8) {
        return 0;
    }

    if (D_80159B00[timerId][0] == 1) {
        /* Running - calculate current elapsed */
        elapsed = osGetTime() - D_80159B00[timerId][1];
    } else {
        /* Stopped/paused - return stored elapsed */
        elapsed = D_80159B00[timerId][2];
    }

    /* Convert OS ticks to centiseconds (46.875 MHz counter) */
    centisecs = (s32)(elapsed / 468750);

    return centisecs;
}

/*

 * func_800FE7A4 (164 bytes)
 * Timer pause
 *
 * Pauses a game timer
 */
void func_800FE7A4(s32 timerId) {
    extern u64 D_80159B00[8][6];  /* Timer data */

    if (timerId < 0 || timerId >= 8) {
        return;
    }

    if (D_80159B00[timerId][0] == 1) {
        /* Store elapsed time */
        D_80159B00[timerId][2] = osGetTime() - D_80159B00[timerId][1];
        D_80159B00[timerId][0] = 2;  /* Paused */
    }
}

/*

 * func_800FE848 (220 bytes)
 * Timer resume
 *
 * Resumes a paused timer
 */
void func_800FE848(s32 timerId) {
    extern u64 D_80159B00[8][6];  /* Timer data */

    if (timerId < 0 || timerId >= 8) {
        return;
    }

    if (D_80159B00[timerId][0] == 2) {
        /* Adjust start time to account for pause */
        D_80159B00[timerId][1] = osGetTime() - D_80159B00[timerId][2];
        D_80159B00[timerId][0] = 1;  /* Running */
    }
}

/*

 * func_800FE924 (228 bytes)
 * Timer lap
 *
 * Records a lap time and returns lap number
 */
s32 func_800FE924(s32 timerId) {
    extern u64 D_80159B00[8][6];  /* Timer data */
    s32 lapNum;
    s32 lapTime;

    if (timerId < 0 || timerId >= 8) {
        return 0;
    }

    lapNum = D_80159C00[timerId];
    if (lapNum >= 8) {
        return lapNum;  /* Max laps recorded */
    }

    /* Get current lap time */
    lapTime = func_800FE5B0(timerId);

    /* Store lap time */
    D_80159B00[timerId][3 + (lapNum / 2)] |= ((u64)lapTime << ((lapNum & 1) * 32));

    D_80159C00[timerId]++;

    return lapNum + 1;
}

/*

 * func_800FEA08 (668 bytes)
 * Race timer update
 *
 * Updates race timer display each frame
 */
void func_800FEA08(void) {
    char timeBuf[16];
    s32 m, s, h;

    /* Only update during gameplay */
    if (D_801146EC != 6) {  /* Not PLAYGAME */
        return;
    }

    if (!D_80159A04) {
        return;
    }

    /* Get current race time */
    D_80159A00 = func_800FE5B0(0);  /* Timer 0 = race timer */

    /* Format time display */
    m = D_80159A00 / 6000;
    s = (D_80159A00 / 100) % 60;
    h = D_80159A00 % 100;

    timeBuf[0] = '0' + (m / 10);
    timeBuf[1] = '0' + (m % 10);
    timeBuf[2] = ':';
    timeBuf[3] = '0' + (s / 10);
    timeBuf[4] = '0' + (s % 10);
    timeBuf[5] = '.';
    timeBuf[6] = '0' + (h / 10);
    timeBuf[7] = '0' + (h % 10);
    timeBuf[8] = '\0';

    /* Display timer */
    draw_text(timeBuf, 130, 15, 255);
}

/*

 * func_800FECA4 (352 bytes)
 * Countdown timer
 *
 * Displays pre-race countdown (3, 2, 1, GO!)
 */
void func_800FECA4(void) {
    s32 countdown;
    char numBuf[2];

    if (D_80159A04) {
        return;  /* Race already started */
    }

    D_80159A08++;

    /* 60fps, 1 second per count */
    countdown = 3 - (D_80159A08 / 60);

    if (countdown > 0) {
        numBuf[0] = '0' + countdown;
        numBuf[1] = '\0';
        draw_text(numBuf, 155, 100, 255);
        sound_play_menu(10 + countdown);  /* Countdown sound */
    } else if (countdown == 0 && D_80159A08 < 240) {
        draw_text(140, 100, "GO!", 0xFFFFFFFF);
        if (D_80159A08 == 180) {
            sound_play_menu(13);  /* GO sound */
            D_80159A04 = 1;     /* Start race */
            func_800FE08C(0);   /* Start race timer */
        }
    }
}

/*

 * func_800FEE04 (1172 bytes)
 * Split time display
 *
 * Shows lap split time (+/- vs best)
 */
void func_800FEE04(s32 splitTime) {
    s32 diff;
    s32 absDiff;
    char splitBuf[16];
    s32 m, s, h;
    s32 color;
    s32 i = 0;

    /* Calculate difference from best */
    if (D_80159D10[D_80159A0C] > 0) {
        diff = splitTime - D_80159D10[D_80159A0C];
    } else {
        diff = 0;  /* No best time yet */
    }

    absDiff = (diff < 0) ? -diff : diff;

    /* Format split time */
    if (diff < 0) {
        splitBuf[i++] = '-';
        color = 0xFF00FF00;  /* Green - faster */
    } else {
        splitBuf[i++] = '+';
        color = 0xFFFF0000;  /* Red - slower */
    }

    s = absDiff / 100;
    h = absDiff % 100;

    splitBuf[i++] = '0' + (s / 10);
    splitBuf[i++] = '0' + (s % 10);
    splitBuf[i++] = '.';
    splitBuf[i++] = '0' + (h / 10);
    splitBuf[i++] = '0' + (h % 10);
    splitBuf[i] = '\0';

    /* Display split time */
    draw_text(splitBuf, 135, 35, (color >> 24) & 0xFF);
}

/*

 * func_800FF298 (1164 bytes)
 * Best lap check
 *
 * Checks if lap time is a new best, returns 1 if so
 */
s32 func_800FF298(s32 lapTime) {

    if (lapTime <= 0) {
        return 0;
    }

    if (D_80159D10[D_80159A0C] == 0 || lapTime < D_80159D10[D_80159A0C]) {
        D_80159D10[D_80159A0C] = lapTime;
        return 1;  /* New best! */
    }

    return 0;
}

/*

 * func_800FF724 (1748 bytes)
 * Record save
 *
 * Saves best times and scores to controller pak
 */
void func_800FF724(void) {
    u8 saveData[256];
    s32 i;

    /* Pack times into save data */
    for (i = 0; i < 12; i++) {
        /* Race times */
        saveData[i * 4] = (D_80159A10[i] >> 24) & 0xFF;
        saveData[i * 4 + 1] = (D_80159A10[i] >> 16) & 0xFF;
        saveData[i * 4 + 2] = (D_80159A10[i] >> 8) & 0xFF;
        saveData[i * 4 + 3] = D_80159A10[i] & 0xFF;

        /* Lap times */
        saveData[48 + i * 4] = (D_80159D10[i] >> 24) & 0xFF;
        saveData[48 + i * 4 + 1] = (D_80159D10[i] >> 16) & 0xFF;
        saveData[48 + i * 4 + 2] = (D_80159D10[i] >> 8) & 0xFF;
        saveData[48 + i * 4 + 3] = D_80159D10[i] & 0xFF;
    }

    /* Write to controller pak */
    osPfsReadWriteFile(&D_80159F00, 0, PFS_WRITE, 0, 96, saveData);
}

/*

 * func_800FFDF8 (1900 bytes)
 * High score entry
 *
 * High score name entry screen
 */
void func_800FFDF8(void) {
    extern char D_80159E18[4]; /* Entered name */
    s32 input;
    s32 cursorPos;
    char *alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
    s32 alphabetLen = 37;

    func_800CC040();

    input = func_800CB748(D_80158100);
    cursorPos = D_80159E14;

    /* Handle input */
    if (input == 3) {  /* Left */
        cursorPos--;
        if (cursorPos < 0) cursorPos = alphabetLen - 1;
    } else if (input == 4) {  /* Right */
        cursorPos++;
        if (cursorPos >= alphabetLen) cursorPos = 0;
    } else if (input == 1) {  /* A - select letter */
        if (D_80159E10 < 3) {
            D_80159E18[D_80159E10] = alphabet[cursorPos];
            D_80159E10++;
        }
        if (D_80159E10 >= 3) {
            D_80159E18[3] = '\0';
            /* Save high score */
            func_800FF724();
        }
    } else if (input == 2) {  /* B - backspace */
        if (D_80159E10 > 0) {
            D_80159E10--;
            D_80159E18[D_80159E10] = '_';
        }
    }

    D_80159E14 = cursorPos;

    /* Draw UI */
    draw_text(105, 40, "ENTER NAME", 0xFFFFFFFF);
    draw_text(D_80159E18, 140, 80, 255);
    draw_text(alphabet, 40, 140, 200);
}

/*

 * func_80100564 (1576 bytes)
 * Leaderboard display
 */
void func_80100564(void) {
    /* Leaderboard - stub */
}

/*

 * func_80100B8C (716 bytes)
 * Score calculate
 */
s32 func_80100B8C(void) {
    /* Score calc - stub */
    return 0;
}

/*

 * func_80100E60 (2732 bytes)
 * Stunt score
 */
s32 func_80100E60(s32 trickId) {
    /* Stunt score - stub */
    return 0;
}

/*

 * func_8010190C (1152 bytes)
 * Combo multiplier
 */
s32 func_8010190C(s32 combo) {
    /* Combo - stub */
    return combo;
}

/*

 * func_80101D8C (1168 bytes)
 * Trick detect - Main stunt detection dispatcher
 *
 * Rush 2049's stunt mode allows players to perform aerial tricks.
 * This function detects what trick is being performed based on
 * car orientation changes while airborne.
 *
 * Car structure offsets for stunt tracking:
 *   0x6C: up vector (vec3)
 *   0x60: forward vector (vec3)
 *   0x78: right vector (vec3)
 *   0x84: angular velocity (vec3)
 *   0x118: road code [4] - all AIR means airborne
 *   0x180: stunt state
 *   0x184: stunt start orientation (quat)
 *   0x194: accumulated rotation (vec3)
 *   0x1A0: air time
 *   0x1A4: current trick ID
 *   0x1A8: trick score
 *   0x1AC: combo count
 *
 * Trick IDs:
 *   0 = None
 *   1 = Front flip
 *   2 = Back flip
 *   3 = Barrel roll left
 *   4 = Barrel roll right
 *   5 = Spin left
 *   6 = Spin right
 *   7 = Corkscrew
 *   8 = Super flip
 */
s32 func_80101D8C(void *car) {
    s32 *roadCode;
    s32 *stuntState;
    f32 *accumRot;
    s32 *currentTrick;
    f32 *airTime;
    s32 trick = 0;
    s32 i;
    s32 isAirborne;

    if (car == NULL) {
        return 0;
    }

    roadCode = (s32 *)((u8 *)car + 0x118);
    stuntState = (s32 *)((u8 *)car + 0x180);
    accumRot = (f32 *)((u8 *)car + 0x194);
    currentTrick = (s32 *)((u8 *)car + 0x1A4);
    airTime = (f32 *)((u8 *)car + 0x1A0);

    /* Check if all wheels are in air (road code = AIR = 4) */
    isAirborne = 1;
    for (i = 0; i < 4; i++) {
        if (roadCode[i] != 4) {
            isAirborne = 0;
            break;
        }
    }

    if (!isAirborne) {
        /* Just landed - finalize any active trick */
        if (*stuntState != 0) {
            trick = *currentTrick;
            *stuntState = 0;
            *currentTrick = 0;
            accumRot[0] = 0.0f;
            accumRot[1] = 0.0f;
            accumRot[2] = 0.0f;
            *airTime = 0.0f;
        }
        return trick;
    }

    /* Airborne - update stunt state */
    if (*stuntState == 0) {
        /* Just became airborne - initialize stunt tracking */
        *stuntState = 1;
        accumRot[0] = 0.0f;
        accumRot[1] = 0.0f;
        accumRot[2] = 0.0f;
    }

    /* Check rotation-based tricks */
    trick = func_80102988(car);   /* Front/back flip */
    if (trick != 0) {
        *currentTrick = trick;
        return trick;
    }

    trick = func_80102F30(car);   /* Barrel roll */
    if (trick != 0) {
        *currentTrick = trick;
        return trick;
    }

    trick = func_80103D28(car);   /* Spin */
    if (trick != 0) {
        *currentTrick = trick;
        return trick;
    }

    return 0;
}

/*

 * func_8010221C (564 bytes)
 * Trick register - Records completed trick and awards points
 *
 * Global stunt data addresses:
 *   D_80158000: Stunt score table [16] (points per trick type)
 *   D_80158040: Current stunt score
 *   D_80158044: Combo multiplier
 *   D_80158048: Trick history [8] (for combo detection)
 *   D_80158068: Trick history index
 */
extern s32 D_80158040;       /* Current score */
extern s32 D_80158044;       /* Combo multiplier */
extern s32 D_80158048[8];    /* Trick history */
extern s32 D_80158068;       /* History index */

void func_8010221C(s32 trickId) {
    s32 basePoints;
    s32 finalPoints;
    s32 historyIdx;

    if (trickId <= 0 || trickId > 15) {
        return;
    }

    /* Get base points for this trick type */
    basePoints = D_80158000[trickId];

    /* Apply combo multiplier */
    finalPoints = basePoints * D_80158044;

    /* Add to score */
    D_80158040 += finalPoints;

    /* Record in trick history */
    historyIdx = D_80158068;
    D_80158048[historyIdx] = trickId;
    D_80158068 = (historyIdx + 1) % 8;

    /* Increase combo multiplier (caps at 8x) */
    if (D_80158044 < 8) {
        D_80158044++;
    }
}

/*

 * func_80102450 (1336 bytes)
 * Air time track - Updates air time and accumulated rotation
 *
 * Called every frame while airborne to track total rotation
 * and time spent in the air for bonus calculations.
 */
void func_80102450(void *car) {
    f32 *angVel;
    f32 *accumRot;
    f32 *airTime;
    s32 *stuntState;
    f32 dt = 0.016f;  /* ~60fps */

    if (car == NULL) {
        return;
    }

    stuntState = (s32 *)((u8 *)car + 0x180);
    angVel = (f32 *)((u8 *)car + 0x84);
    accumRot = (f32 *)((u8 *)car + 0x194);
    airTime = (f32 *)((u8 *)car + 0x1A0);

    /* Only track if in stunt state */
    if (*stuntState == 0) {
        return;
    }

    /* Accumulate air time */
    *airTime += dt;

    /* Accumulate rotation from angular velocity */
    /* X = pitch (front/back flip) */
    /* Y = yaw (spin) */
    /* Z = roll (barrel roll) */
    accumRot[0] += angVel[0] * dt;
    accumRot[1] += angVel[1] * dt;
    accumRot[2] += angVel[2] * dt;
}

/*

 * func_80102988 (1448 bytes)
 * Flip detect - Detects front and back flips
 *
 * A flip is rotation around the car's lateral (X) axis.
 * Front flip = nose goes down first (negative pitch rotation)
 * Back flip = nose goes up first (positive pitch rotation)
 *
 * Thresholds:
 *   Single flip = 270-450 degrees
 *   Double flip = 630-810 degrees
 *   Triple flip = 990+ degrees
 *
 * Returns:
 *   0 = No flip
 *   1 = Front flip
 *   2 = Back flip
 *   11 = Double front flip
 *   12 = Double back flip
 *   21 = Triple front flip
 *   22 = Triple back flip
 */
s32 func_80102988(void *car) {
    f32 *accumRot;
    f32 pitchRot;
    f32 absPitch;
    s32 flipCount;
    s32 trickId = 0;

    if (car == NULL) {
        return 0;
    }

    accumRot = (f32 *)((u8 *)car + 0x194);
    pitchRot = accumRot[0];  /* X rotation in radians */
    absPitch = fabsf(pitchRot);

    /* Convert to rotation count (full 360 = 2*PI = 6.283) */
    /* Need at least 3/4 rotation (270 deg = 4.71 rad) to count as flip */
    if (absPitch < 4.71f) {
        return 0;  /* Not enough rotation */
    }

    /* Count complete flips */
    flipCount = (s32)(absPitch / 6.283f);
    if (flipCount < 1) {
        flipCount = 1;  /* At least one flip if threshold met */
    }
    if (flipCount > 3) {
        flipCount = 3;  /* Cap at triple */
    }

    /* Determine flip direction */
    if (pitchRot < 0.0f) {
        /* Negative pitch = front flip */
        trickId = 1 + (flipCount - 1) * 10;
    } else {
        /* Positive pitch = back flip */
        trickId = 2 + (flipCount - 1) * 10;
    }

    return trickId;
}

/*

 * func_80102F30 (3576 bytes)
 * Barrel roll - Detects lateral barrel rolls
 *
 * A barrel roll is rotation around the car's longitudinal (Z) axis.
 * Left roll = counter-clockwise when viewed from behind
 * Right roll = clockwise when viewed from behind
 *
 * Returns:
 *   0 = No barrel roll
 *   3 = Barrel roll left
 *   4 = Barrel roll right
 *   13 = Double barrel roll left
 *   14 = Double barrel roll right
 *   23 = Triple barrel roll left
 *   24 = Triple barrel roll right
 */
s32 func_80102F30(void *car) {
    f32 *accumRot;
    f32 rollRot;
    f32 absRoll;
    s32 rollCount;
    s32 trickId = 0;

    if (car == NULL) {
        return 0;
    }

    accumRot = (f32 *)((u8 *)car + 0x194);
    rollRot = accumRot[2];  /* Z rotation in radians */
    absRoll = fabsf(rollRot);

    /* Need at least 3/4 rotation to count as barrel roll */
    if (absRoll < 4.71f) {
        return 0;
    }

    /* Count complete rolls */
    rollCount = (s32)(absRoll / 6.283f);
    if (rollCount < 1) {
        rollCount = 1;
    }
    if (rollCount > 3) {
        rollCount = 3;
    }

    /* Determine roll direction */
    if (rollRot > 0.0f) {
        /* Positive roll = left barrel roll */
        trickId = 3 + (rollCount - 1) * 10;
    } else {
        /* Negative roll = right barrel roll */
        trickId = 4 + (rollCount - 1) * 10;
    }

    return trickId;
}

/*

 * func_80103D28 (2524 bytes)
 * Spin detect - Detects horizontal spins
 *
 * A spin is rotation around the car's vertical (Y) axis.
 * Spins are counted in 180-degree increments.
 *
 * Returns:
 *   0 = No spin (less than 180)
 *   5 = 180 spin left
 *   6 = 180 spin right
 *   15 = 360 spin left
 *   16 = 360 spin right
 *   25 = 540 spin left
 *   26 = 540 spin right
 *   35 = 720 spin left
 *   36 = 720 spin right
 */
s32 func_80103D28(void *car) {
    f32 *accumRot;
    f32 yawRot;
    f32 absYaw;
    s32 spinCount;
    s32 trickId = 0;

    if (car == NULL) {
        return 0;
    }

    accumRot = (f32 *)((u8 *)car + 0x194);
    yawRot = accumRot[1];  /* Y rotation in radians */
    absYaw = fabsf(yawRot);

    /* Spins are counted in 180-degree (PI) increments */
    /* Need at least 135 degrees (2.36 rad) to count */
    if (absYaw < 2.36f) {
        return 0;
    }

    /* Count 180-degree spins */
    spinCount = (s32)(absYaw / 3.14159f);
    if (spinCount < 1) {
        spinCount = 1;
    }
    if (spinCount > 4) {
        spinCount = 4;  /* Cap at 720 (4 x 180) */
    }

    /* Determine spin direction */
    if (yawRot > 0.0f) {
        /* Positive yaw = left spin */
        trickId = 5 + (spinCount - 1) * 10;
    } else {
        /* Negative yaw = right spin */
        trickId = 6 + (spinCount - 1) * 10;
    }

    return trickId;
}

/*

 * func_80104704 (1040 bytes)
 * Landing bonus - Awards points for clean landings
 *
 * Calculates landing bonus based on:
 *   - Air time (longer = more points)
 *   - Landing angle (all wheels = perfect)
 *   - Speed at landing
 *   - Active combo multiplier
 *
 * Returns landing bonus points (0 if crashed)
 */
s32 func_80104704(void *car) {
    f32 *airTime;
    f32 *upVec;
    s32 *comboMult;
    f32 landingAngle;
    s32 baseBonus;
    s32 angleMult;
    s32 timeMult;
    s32 finalBonus;

    if (car == NULL) {
        return 0;
    }

    airTime = (f32 *)((u8 *)car + 0x1A0);
    upVec = (f32 *)((u8 *)car + 0x6C);
    comboMult = (s32 *)((u8 *)car + 0x1AC);

    /* Check landing angle (up vector Y component) */
    /* Perfect landing: up.y close to 1.0 */
    /* Crashed: up.y < 0 (upside down) */
    landingAngle = upVec[1];

    if (landingAngle < 0.0f) {
        /* Crashed - no bonus, reset combo */
        *comboMult = 1;
        D_80158044 = 1;  /* Reset global combo */
        return 0;
    }

    /* Base bonus from air time (100 pts per second) */
    baseBonus = (s32)(*airTime * 100.0f);
    if (baseBonus > 2000) {
        baseBonus = 2000;  /* Cap at 2000 base */
    }

    /* Angle multiplier (1.0 = perfect, scales down) */
    if (landingAngle > 0.95f) {
        angleMult = 3;  /* Perfect landing - 3x */
    } else if (landingAngle > 0.8f) {
        angleMult = 2;  /* Good landing - 2x */
    } else if (landingAngle > 0.5f) {
        angleMult = 1;  /* OK landing - 1x */
    } else {
        angleMult = 0;  /* Rough landing - no bonus */
        *comboMult = 1;  /* Reset combo on rough landing */
    }

    /* Time bonus (extra for long air time) */
    if (*airTime > 3.0f) {
        timeMult = 2;  /* 3+ seconds = 2x */
    } else if (*airTime > 1.5f) {
        timeMult = 1;  /* 1.5-3 seconds = normal */
    } else {
        timeMult = 1;
    }

    /* Calculate final bonus */
    finalBonus = baseBonus * angleMult * timeMult;

    /* Apply combo multiplier */
    finalBonus *= D_80158044;

    return finalBonus;
}

/*

 * func_80104B14 (2412 bytes)
 * Stunt combo - Manages trick combos during a single air session
 *
 * A combo is built by performing multiple different tricks in one jump.
 * Same trick repeated = no combo bonus
 * Different tricks = increasing combo multiplier
 *
 * Car structure offsets:
 *   0x1AC: combo count
 *   0x1B0: combo tricks [8] (trick IDs in this combo)
 *   0x1D0: combo timer (resets on landing)
 */
void func_80104B14(void *car) {
    s32 *comboCount;
    s32 *comboTricks;
    f32 *comboTimer;
    s32 *currentTrick;
    s32 trick;
    s32 i;
    s32 isDuplicate;

    if (car == NULL) {
        return;
    }

    comboCount = (s32 *)((u8 *)car + 0x1AC);
    comboTricks = (s32 *)((u8 *)car + 0x1B0);
    comboTimer = (f32 *)((u8 *)car + 0x1D0);
    currentTrick = (s32 *)((u8 *)car + 0x1A4);

    trick = *currentTrick;

    /* No trick = nothing to add */
    if (trick == 0) {
        return;
    }

    /* Check if this trick type already in combo */
    isDuplicate = 0;
    for (i = 0; i < *comboCount && i < 8; i++) {
        /* Compare base trick type (mod 10 gives type) */
        if ((comboTricks[i] % 10) == (trick % 10)) {
            isDuplicate = 1;
            break;
        }
    }

    /* Add to combo if new trick type */
    if (!isDuplicate && *comboCount < 8) {
        comboTricks[*comboCount] = trick;
        (*comboCount)++;

        /* Update global combo multiplier */
        D_80158044 = *comboCount + 1;
    }

    /* Reset combo timer */
    *comboTimer = 2.0f;  /* 2 second window for next trick */
}

/*

 * func_80105480 (1780 bytes)
 * Wing deploy - Deploys the car's stunt wings
 *
 * Rush 2049's signature feature - cars have deployable wings
 * that provide air control during jumps.
 *
 * Wing effects:
 *   - Increased air control (pitch/roll influence)
 *   - Reduced fall speed (glide)
 *   - Enables advanced trick combos
 *
 * Car structure offsets:
 *   0x1D4: wing state (0=retracted, 1=deploying, 2=deployed)
 *   0x1D8: wing deploy timer
 *   0x1DC: wing angle (0.0 = retracted, 1.0 = fully deployed)
 *   0x1E0: wing lift coefficient
 *   0x1E4: wing drag coefficient
 */
void func_80105480(void *car) {
    s32 *wingState;
    f32 *deployTimer;
    f32 *wingAngle;
    f32 *liftCoef;
    f32 *dragCoef;
    f32 dt = 0.016f;
    f32 deployRate = 4.0f;  /* Full deploy in 0.25 seconds */

    if (car == NULL) {
        return;
    }

    wingState = (s32 *)((u8 *)car + 0x1D4);
    deployTimer = (f32 *)((u8 *)car + 0x1D8);
    wingAngle = (f32 *)((u8 *)car + 0x1DC);
    liftCoef = (f32 *)((u8 *)car + 0x1E0);
    dragCoef = (f32 *)((u8 *)car + 0x1E4);

    /* Start deploy if not already deploying/deployed */
    if (*wingState == 0) {
        *wingState = 1;  /* Deploying */
        *deployTimer = 0.0f;
    }

    /* Animate wing deployment */
    if (*wingState == 1) {
        *wingAngle += deployRate * dt;
        *deployTimer += dt;

        if (*wingAngle >= 1.0f) {
            *wingAngle = 1.0f;
            *wingState = 2;  /* Fully deployed */
        }
    }

    /* Calculate aerodynamic coefficients based on wing angle */
    /* Lift increases with wing deployment */
    *liftCoef = 0.5f + (*wingAngle * 1.5f);  /* 0.5 base, up to 2.0 */

    /* Drag also increases */
    *dragCoef = 0.1f + (*wingAngle * 0.3f);  /* 0.1 base, up to 0.4 */

    /* Apply wing physics if deployed */
    if (*wingState == 2) {
        func_80105EA8(car);  /* Apply glide physics */
    }
}

/*

 * func_80105B74 (572 bytes)
 * Wing retract - Retracts the car's stunt wings
 *
 * Called when:
 *   - Player releases wing button
 *   - Car lands
 *   - Car crashes
 */
void func_80105B74(void *car) {
    s32 *wingState;
    f32 *wingAngle;
    f32 *liftCoef;
    f32 *dragCoef;
    f32 dt = 0.016f;
    f32 retractRate = 6.0f;  /* Faster retract than deploy */

    if (car == NULL) {
        return;
    }

    wingState = (s32 *)((u8 *)car + 0x1D4);
    wingAngle = (f32 *)((u8 *)car + 0x1DC);
    liftCoef = (f32 *)((u8 *)car + 0x1E0);
    dragCoef = (f32 *)((u8 *)car + 0x1E4);

    /* Skip if already retracted */
    if (*wingState == 0) {
        return;
    }

    /* Animate wing retraction */
    *wingAngle -= retractRate * dt;

    if (*wingAngle <= 0.0f) {
        *wingAngle = 0.0f;
        *wingState = 0;  /* Fully retracted */
        *liftCoef = 0.5f;  /* Reset to base */
        *dragCoef = 0.1f;
    } else {
        /* Update coefficients during retraction */
        *liftCoef = 0.5f + (*wingAngle * 1.5f);
        *dragCoef = 0.1f + (*wingAngle * 0.3f);
    }
}

/*

 * func_80105DB0 (248 bytes)
 * Wing state check - Returns current wing deployment state
 *
 * Returns:
 *   0 = Wings retracted
 *   1 = Wings deploying
 *   2 = Wings fully deployed
 */
s32 func_80105DB0(void *car) {
    if (car == NULL) {
        return 0;
    }
    return *(s32 *)((u8 *)car + 0x1D4);
}

/*

 * func_80105EA8 (2508 bytes)
 * Glide physics - Applies wing aerodynamic forces
 *
 * When wings are deployed, the car experiences:
 *   - Lift force (reduces fall rate)
 *   - Drag force (reduces forward speed)
 *   - Control forces (pitch/roll from player input)
 *
 * This enables the "gliding" behavior unique to Rush 2049.
 */
void func_80105EA8(void *car) {
    f32 *vel;
    f32 *forward, *up, *right;
    f32 *angVel;
    f32 liftCoef, dragCoef;
    f32 wingAngle;
    f32 speed, speedSq;
    f32 liftForce, dragForce;
    f32 pitchControl, rollControl;
    f32 dt = 0.016f;
    f32 airDensity = 0.002377f;  /* Slug/ft^3 */
    f32 wingArea = 20.0f;  /* Square feet */

    if (car == NULL) {
        return;
    }

    vel = (f32 *)((u8 *)car + 0x34);
    forward = (f32 *)((u8 *)car + 0x60);
    up = (f32 *)((u8 *)car + 0x6C);
    right = (f32 *)((u8 *)car + 0x78);
    angVel = (f32 *)((u8 *)car + 0x84);
    wingAngle = *(f32 *)((u8 *)car + 0x1DC);
    liftCoef = *(f32 *)((u8 *)car + 0x1E0);
    dragCoef = *(f32 *)((u8 *)car + 0x1E4);

    /* Calculate speed */
    speedSq = vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2];
    speed = sqrtf(speedSq);

    if (speed < 1.0f) {
        return;  /* Too slow for aerodynamic effects */
    }

    /* Lift force: L = 0.5 * rho * v^2 * S * Cl */
    /* Applied in the up direction */
    liftForce = 0.5f * airDensity * speedSq * wingArea * liftCoef * wingAngle;

    /* Reduce vertical velocity (counteract gravity) */
    vel[1] += liftForce * dt * 0.01f;

    /* Clamp to prevent flying upward */
    if (vel[1] > 0.0f && up[1] > 0.0f) {
        vel[1] *= 0.95f;  /* Dampen upward motion */
    }

    /* Drag force: D = 0.5 * rho * v^2 * S * Cd */
    /* Applied opposite to velocity */
    dragForce = 0.5f * airDensity * speedSq * wingArea * dragCoef * wingAngle;

    /* Reduce speed in direction of motion */
    if (speed > 0.0f) {
        f32 dragScale = 1.0f - (dragForce * dt * 0.001f / speed);
        if (dragScale < 0.9f) dragScale = 0.9f;  /* Cap drag effect */
        vel[0] *= dragScale;
        vel[2] *= dragScale;
    }

    /* Get control inputs from angular velocity requests */
    pitchControl = angVel[0] * wingAngle * 2.0f;
    rollControl = angVel[2] * wingAngle * 2.0f;

    /* Apply pitch moment (nose up/down) */
    angVel[0] += pitchControl * dt;

    /* Apply roll moment (barrel roll) */
    angVel[2] += rollControl * dt;

    /* Dampen angular velocities slightly for stability */
    angVel[0] *= 0.98f;
    angVel[1] *= 0.98f;
    angVel[2] *= 0.98f;
}

/*

 * func_80106874 (712 bytes)
 * Boost activate
 *
 * Activates nitro boost for a car
 */
void func_80106874(void *car) {
    u8 *carData = (u8 *)car;
    f32 *nitroReserve;
    f32 *nitroActive;
    f32 *velocity;

    if (carData == NULL) {
        return;
    }

    nitroReserve = (f32 *)(carData + 0x1BC);  /* Nitro tank */
    nitroActive = (f32 *)(carData + 0x1C0);   /* Active boost amount */
    velocity = (f32 *)(carData + 0x34);

    /* Check if we have nitro */
    if (*nitroReserve <= 0.0f) {
        return;
    }

    /* Already boosting? */
    if (*nitroActive > 0.0f) {
        return;
    }

    /* Consume nitro and activate boost */
    *nitroActive = 1.0f;
    *nitroReserve -= 0.25f;  /* 4 boosts per full tank */

    if (*nitroReserve < 0.0f) {
        *nitroReserve = 0.0f;
    }

    /* Play boost sound */
    sound_play_menu(35);
}

/*

 * func_80106B3C (600 bytes)
 * Boost update
 *
 * Updates active boost each frame - applies acceleration and decays
 */
void func_80106B3C(void *car) {
    u8 *carData = (u8 *)car;
    f32 *nitroActive;
    f32 *velocity;
    f32 *forward;
    f32 boostForce;

    if (carData == NULL) {
        return;
    }

    nitroActive = (f32 *)(carData + 0x1C0);
    velocity = (f32 *)(carData + 0x34);
    forward = (f32 *)(carData + 0x60);

    if (*nitroActive <= 0.0f) {
        return;
    }

    /* Apply boost acceleration in forward direction */
    boostForce = 50.0f * (*nitroActive);

    velocity[0] += forward[0] * boostForce * (1.0f / 60.0f);
    velocity[1] += forward[1] * boostForce * (1.0f / 60.0f);
    velocity[2] += forward[2] * boostForce * (1.0f / 60.0f);

    /* Decay boost amount */
    *nitroActive -= 0.016f;  /* ~1 second boost duration */

    if (*nitroActive < 0.0f) {
        *nitroActive = 0.0f;
    }
}

/*

 * func_80106D94 (1604 bytes)
 * Nitro pickup
 *
 * Handles car collecting a nitro pickup on track
 */
void func_80106D94(void *car, void *pickup) {
    u8 *carData = (u8 *)car;
    u8 *pickupData = (u8 *)pickup;
    f32 *nitroReserve;
    f32 addAmount;

    if (carData == NULL || pickupData == NULL) {
        return;
    }

    nitroReserve = (f32 *)(carData + 0x1BC);

    /* Get pickup amount (offset 0x10 in pickup) */
    addAmount = *(f32 *)(pickupData + 0x10);
    if (addAmount <= 0.0f) {
        addAmount = 0.25f;  /* Default 1/4 tank */
    }

    /* Add to nitro reserve */
    *nitroReserve += addAmount;

    /* Cap at full tank */
    if (*nitroReserve > 1.0f) {
        *nitroReserve = 1.0f;
    }

    /* Mark pickup as collected (offset 0x00 = active flag) */
    pickupData[0x00] = 0;

    /* Play pickup sound */
    sound_play_menu(22);

    /* Spawn collect effect at pickup position */
    func_800EE820(4, (f32 *)(pickupData + 0x04));
}

/*

 * func_801073D8 (580 bytes)
 * Checkpoint hit
 *
 * Records checkpoint passage for lap validation
 */
void func_801073D8(void *car, s32 cpId) {
    u8 *carData = (u8 *)car;
    s32 *lastCp;
    s32 *cpMask;
    s32 expectedCp;

    if (carData == NULL) {
        return;
    }

    lastCp = (s32 *)(carData + 0x1A0);    /* Last checkpoint hit */
    cpMask = (s32 *)(carData + 0x1A4);    /* Checkpoint bitmask */

    /* Check if this is the expected next checkpoint */
    expectedCp = (*lastCp + 1) % 16;  /* Assuming 16 checkpoints max */

    if (cpId == expectedCp || cpId == *lastCp + 1) {
        /* Valid checkpoint sequence */
        *lastCp = cpId;
        *cpMask |= (1 << cpId);

        /* Play checkpoint sound */
        sound_play_menu(15);
    }
}

/*

 * func_8010761C (1240 bytes)
 * Lap complete
 *
 * Handles lap completion - validates checkpoints and updates lap count
 */
void func_8010761C(void *car) {
    u8 *carData = (u8 *)car;
    s32 *cpMask;
    s32 *lapCount;
    s32 *lapTime;
    s32 *bestLap;

    if (carData == NULL) {
        return;
    }

    cpMask = (s32 *)(carData + 0x1A4);
    lapCount = (s32 *)(carData + 0x1A8);
    lapTime = (s32 *)(carData + 0x1AC);
    bestLap = (s32 *)(carData + 0x1B0);

    /* Verify all required checkpoints were hit */
    if ((*cpMask & D_80159A00) != D_80159A00) {
        return;  /* Shortcut detected - invalid lap */
    }

    /* Record lap time */
    s32 currentLapTime = (s32)D_80142AFC - *lapTime;

    /* Check for best lap */
    if (*bestLap == 0 || currentLapTime < *bestLap) {
        *bestLap = currentLapTime;
    }

    /* Increment lap count */
    (*lapCount)++;

    /* Reset for next lap */
    *cpMask = 0;
    *lapTime = (s32)D_80142AFC;
    *(s32 *)(carData + 0x1A0) = -1;  /* Reset last checkpoint */

    /* Check for race finish */
    if (*lapCount >= D_80159A04) {
        func_80107AF4(car);  /* Race finish */
    } else {
        /* Play lap complete sound */
        sound_play_menu(16);
    }
}

/*

 * func_80107AF4 (1000 bytes)
 * Race finish
 *
 * Handles car finishing the race - records time and position
 */
void func_80107AF4(void *car) {
    extern s32 D_80159A34[];   /* Finish positions [8] */
    u8 *carData = (u8 *)car;
    s32 carIdx;
    s32 *raceTime;
    s32 *finishPos;
    s32 *raceState;

    if (carData == NULL) {
        return;
    }

    carIdx = *(s32 *)(carData + 0x08);
    raceTime = (s32 *)(carData + 0x1B4);
    finishPos = (s32 *)(carData + 0x1B8);
    raceState = (s32 *)(carData + 0x1D0);

    /* Check if already finished */
    if (*raceState == 2) {
        return;
    }

    /* Record finish */
    *raceState = 2;  /* Finished state */
    *raceTime = (s32)D_80142AFC;
    *finishPos = D_80159A10;

    /* Record in global arrays */
    if (carIdx >= 0 && carIdx < 8) {
        D_80159A14[carIdx] = *raceTime;
        D_80159A34[carIdx] = D_80159A10;
    }

    D_80159A10[0]++;

    /* Play finish sound based on position */
    if (*finishPos == 0) {
        sound_play_menu(40);  /* First place */
    } else {
        sound_play_menu(41);  /* Other positions */
    }

    /* Check if this is the player */
    if (carIdx == 0) {
        D_801146EC = 7;  /* Transition to ENDGAME state */
    }
}

/*

 * func_80107EDC (632 bytes)
 * Position update
 *
 * Updates race positions for all cars based on progress
 */
void func_80107EDC(void) {
    s32 i, j;
    s32 numCars;
    f32 progress[8];
    s32 positions[8];

    numCars = D_80152744;
    if (numCars <= 0 || numCars > 8) {
        return;
    }

    /* Calculate progress for each car */
    for (i = 0; i < numCars; i++) {
        u8 *car = &D_80152818[i * 0x808];
        s32 lap = *(s32 *)(car + 0x1A8);
        s32 cp = *(s32 *)(car + 0x1A0);
        f32 cpProgress = *(f32 *)(car + 0x1C4);  /* Progress within checkpoint */

        progress[i] = (f32)(lap * 1000 + cp * 10) + cpProgress;
        positions[i] = 0;
    }

    /* Sort to determine positions (higher progress = better position) */
    for (i = 0; i < numCars; i++) {
        for (j = 0; j < numCars; j++) {
            if (i != j && progress[j] > progress[i]) {
                positions[i]++;
            }
        }
    }

    /* Write positions back to cars */
    for (i = 0; i < numCars; i++) {
        u8 *car = &D_80152818[i * 0x808];
        *(s32 *)(car + 0x1CC) = positions[i];  /* Current race position */
    }
}

/*

 * func_80108154 (900 bytes)
 * Race standings
 *
 * Displays current race standings on HUD
 */
void func_80108154(void) {
    s32 i;
    s32 numCars;
    s32 y;

    numCars = D_80152744;
    if (numCars <= 0) {
        return;
    }

    y = 20;

    /* Draw position for each car sorted by position */
    for (i = 0; i < numCars && i < 4; i++) {
        u8 *car = &D_80152818[i * 0x808];
        s32 pos = *(s32 *)(car + 0x1CC);
        s32 carNum = *(s32 *)(car + 0x08);

        /* Draw position indicator */
        s8 posStr[8];
        posStr[0] = '0' + pos + 1;
        posStr[1] = '.';
        posStr[2] = ' ';
        posStr[3] = 'P';
        posStr[4] = '0' + carNum + 1;
        posStr[5] = '\0';

        draw_text(posStr, 260, y, (carNum == 0) ? 255 : 180);
        y += 12;
    }
}

/*

 * func_801084D4 (1500 bytes)
 * Respawn car
 *
 * Respawns car at last valid checkpoint
 */
void func_801084D4(void *car) {
    u8 *carData = (u8 *)car;
    s32 lastCp;
    f32 *carPos;
    f32 *carVel;
    f32 *cpPos;

    if (carData == NULL) {
        return;
    }

    lastCp = *(s32 *)(carData + 0x1A0);
    if (lastCp < 0) {
        lastCp = 0;  /* Start position */
    }

    carPos = (f32 *)(carData + 0x24);
    carVel = (f32 *)(carData + 0x34);

    /* Get checkpoint position */
    cpPos = (f32 *)&D_80159B00[lastCp * 0x20];

    /* Set car position to checkpoint */
    carPos[0] = cpPos[0];
    carPos[1] = cpPos[1] + 2.0f;  /* Slightly above ground */
    carPos[2] = cpPos[2];

    /* Reset velocity */
    carVel[0] = 0.0f;
    carVel[1] = 0.0f;
    carVel[2] = 0.0f;

    /* Reset angular velocity */
    *(f32 *)(carData + 0x84) = 0.0f;
    *(f32 *)(carData + 0x88) = 0.0f;
    *(f32 *)(carData + 0x8C) = 0.0f;

    /* Reset damage */
    *(s32 *)(carData + 0x1B0) = 0;

    /* Clear wreck flag */
    *(s32 *)(carData + 0x1D0) = 1;  /* Racing state */

    /* Play respawn sound */
    sound_play_menu(28);
}

/*

 * func_80108AB0 (760 bytes)
 * Death check
 *
 * Checks if car should be destroyed (out of bounds, excessive damage)
 */
s32 func_80108AB0(void *car) {
    u8 *carData = (u8 *)car;
    f32 *carPos;
    s32 damage;

    if (carData == NULL) {
        return 0;
    }

    carPos = (f32 *)(carData + 0x24);
    damage = *(s32 *)(carData + 0x1B0);

    /* Check if below death plane */
    if (carPos[1] < -100.0f) {
        return 1;
    }

    /* Check for excessive damage */
    if (damage >= 10) {
        return 1;
    }

    /* Check out of bounds */
    if (func_8010A53C(car)) {
        return 1;
    }

    return 0;
}

/*

 * func_80108DA8 (408 bytes)
 * Wreck car
 *
 * Triggers car destruction sequence
 */
void func_80108DA8(void *car) {
    u8 *carData = (u8 *)car;
    f32 *carPos;

    if (carData == NULL) {
        return;
    }

    carPos = (f32 *)(carData + 0x24);

    /* Set wrecked state */
    *(s32 *)(carData + 0x1D0) = 3;  /* Wrecked */

    /* Spawn explosion effect */
    func_800EF8F4(carPos, 10.0f);

    /* Play crash sound */
    sound_play_menu(32);

    /* Start recovery timer */
    *(s32 *)(carData + 0x1D4) = 180;  /* 3 seconds at 60fps */
}

/*

 * func_80108F40 (1320 bytes)
 * Recovery timer
 *
 * Counts down recovery timer and respawns when ready
 */
void func_80108F40(void *car) {
    u8 *carData = (u8 *)car;
    s32 *timer;
    s32 *state;

    if (carData == NULL) {
        return;
    }

    state = (s32 *)(carData + 0x1D0);
    timer = (s32 *)(carData + 0x1D4);

    /* Only update if in wrecked state */
    if (*state != 3) {
        return;
    }

    /* Count down timer */
    if (*timer > 0) {
        (*timer)--;
    }

    /* Respawn when timer expires */
    if (*timer <= 0) {
        func_801084D4(car);
    }
}

/*

 * func_80109468 (1528 bytes)
 * Reset position
 *
 * Manual reset - player requests respawn
 */
void func_80109468(void *car) {
    u8 *carData = (u8 *)car;
    s32 *state;

    if (carData == NULL) {
        return;
    }

    state = (s32 *)(carData + 0x1D0);

    /* Don't reset if already wrecked or finished */
    if (*state == 2 || *state == 3) {
        return;
    }

    /* Respawn at last checkpoint */
    func_801084D4(car);
}

/*

 * func_80109A60 (1276 bytes)
 * Shortcut detect
 *
 * Detects if car is using a valid shortcut path
 */
s32 func_80109A60(void *car) {
    u8 *carData = (u8 *)car;
    f32 *carPos;
    s32 zone;

    if (carData == NULL) {
        return 0;
    }

    carPos = (f32 *)(carData + 0x24);

    /* Get current track zone */
    zone = func_8010A7AC(carPos);

    /* Check if zone is a shortcut zone (types 10-19) */
    if (zone >= 10 && zone < 20) {
        /* Set shortcut flag */
        *(s32 *)(carData + 0x1E0) = 1;
        return 1;
    }

    return 0;
}

/*

 * func_80109F5C (1504 bytes)
 * Wrong way detect
 *
 * Detects if car is driving in wrong direction
 */
s32 func_80109F5C(void *car) {
    u8 *carData = (u8 *)car;
    f32 *carPos;
    f32 *carDir;
    s32 lastCp;
    s32 nextCp;
    f32 *cpPos;
    f32 *nextCpPos;
    f32 toNext[3];
    f32 dot;

    if (carData == NULL) {
        return 0;
    }

    carPos = (f32 *)(carData + 0x24);
    carDir = (f32 *)(carData + 0x60);  /* Forward direction */
    lastCp = *(s32 *)(carData + 0x1A0);

    if (lastCp < 0) {
        return 0;  /* Haven't passed a checkpoint yet */
    }

    nextCp = (lastCp + 1) % 16;

    /* Get checkpoint positions */
    nextCpPos = (f32 *)&D_80159B00[nextCp * 0x20];

    /* Calculate direction to next checkpoint */
    toNext[0] = nextCpPos[0] - carPos[0];
    toNext[2] = nextCpPos[2] - carPos[2];

    /* Normalize */
    f32 len = sqrtf(toNext[0] * toNext[0] + toNext[2] * toNext[2]);
    if (len < 0.001f) {
        return 0;
    }
    toNext[0] /= len;
    toNext[2] /= len;

    /* Dot product with car forward */
    dot = carDir[0] * toNext[0] + carDir[2] * toNext[2];

    /* If facing away from next checkpoint, wrong way */
    if (dot < -0.5f) {
        return 1;
    }

    return 0;
}

/*

 * func_8010A53C (624 bytes)
 * Out of bounds
 *
 * Checks if car is outside track boundaries
 */
s32 func_8010A53C(void *car) {
    u8 *carData = (u8 *)car;
    f32 *carPos;

    if (carData == NULL) {
        return 0;
    }

    carPos = (f32 *)(carData + 0x24);

    /* Check X bounds */
    if (carPos[0] < (f32)D_80159C00[0] || carPos[0] > (f32)D_80159C04) {
        return 1;
    }

    /* Check Z bounds */
    if (carPos[2] < (f32)D_80159C08 || carPos[2] > (f32)D_80159C0C) {
        return 1;
    }

    return 0;
}

/*

 * func_8010A7AC (292 bytes)
 * Track zone get
 *
 * Returns the track zone type at given position
 */
s32 func_8010A7AC(f32 *pos) {
    extern s32 D_80159D08;     /* Grid height */
    extern f32 D_80159D0C;     /* Grid cell size */
    extern f32 D_80159D14;     /* Grid origin Z */
    s32 gridX, gridZ;
    s32 idx;

    if (pos == NULL) {
        return 0;
    }

    /* Convert world position to grid cell */
    gridX = (s32)((pos[0] - (f32)D_80159D10[0]) / D_80159D0C);
    gridZ = (s32)((pos[2] - D_80159D14) / D_80159D0C);

    /* Bounds check */
    if (gridX < 0 || gridX >= D_80159D04 || gridZ < 0 || gridZ >= D_80159D08) {
        return 0;  /* Out of grid = road */
    }

    idx = gridZ * D_80159D04 + gridX;
    return D_80159D00[idx];
}

/*

 * func_8010A8D0 (1500 bytes)
 * Surface type get
 *
 * Returns surface type at position (affects grip/handling)
 * Types: 0=asphalt, 1=concrete, 2=dirt, 3=grass, 4=sand, 5=ice, 6=water
 */
s32 func_8010A8D0(f32 *pos) {
    s32 zone;

    if (pos == NULL) {
        return 0;
    }

    zone = func_8010A7AC(pos);

    /* Map zone to surface type */
    switch (zone) {
        case 0:   /* Road */
        case 1:   /* Start grid */
            return 0;  /* Asphalt */
        case 2:   /* Pit lane */
            return 1;  /* Concrete */
        case 3:   /* Off-road */
            return 2;  /* Dirt */
        case 4:   /* Grass */
            return 3;  /* Grass */
        case 5:   /* Sand */
            return 4;  /* Sand */
        case 6:   /* Ice */
            return 5;  /* Ice */
        case 7:   /* Water */
            return 6;  /* Water */
        default:
            return 0;  /* Default to asphalt */
    }
}

/*

 * func_8010AEAC (1828 bytes)
 * Grip calculate
 *
 * Calculates tire grip based on surface type
 */
f32 func_8010AEAC(void *tire, s32 surface) {
    static const f32 gripTable[7] = {
        1.0f,   /* Asphalt - full grip */
        0.95f,  /* Concrete - slightly less */
        0.6f,   /* Dirt - reduced grip */
        0.4f,   /* Grass - low grip */
        0.3f,   /* Sand - very low grip */
        0.15f,  /* Ice - minimal grip */
        0.1f    /* Water - almost none */
    };

    if (surface < 0 || surface > 6) {
        surface = 0;
    }

    return gripTable[surface];
}

/*

 * func_8010B5D0 (556 bytes)
 * Drag calculate
 *
 * Calculates aerodynamic drag based on speed
 */
f32 func_8010B5D0(void *car) {
    u8 *carData = (u8 *)car;
    f32 *velocity;
    f32 speed;
    f32 dragCoeff;

    if (carData == NULL) {
        return 0.0f;
    }

    velocity = (f32 *)(carData + 0x34);

    /* Calculate speed */
    speed = sqrtf(velocity[0] * velocity[0] +
                  velocity[1] * velocity[1] +
                  velocity[2] * velocity[2]);

    /* Drag coefficient from car stats (offset 0x50) */
    dragCoeff = *(f32 *)(carData + 0x50);
    if (dragCoeff <= 0.0f) {
        dragCoeff = 0.35f;  /* Default */
    }

    /* Drag = 0.5 * Cd * v^2 */
    return 0.5f * dragCoeff * speed * speed;
}

/*

 * func_8010B7FC (460 bytes)
 * Downforce calculate
 *
 * Calculates aerodynamic downforce based on speed
 */
f32 func_8010B7FC(void *car) {
    u8 *carData = (u8 *)car;
    f32 *velocity;
    f32 speed;
    f32 downforceCoeff;

    if (carData == NULL) {
        return 0.0f;
    }

    velocity = (f32 *)(carData + 0x34);

    speed = sqrtf(velocity[0] * velocity[0] + velocity[2] * velocity[2]);

    /* Downforce coefficient from car stats (offset 0x54) */
    downforceCoeff = *(f32 *)(carData + 0x54);
    if (downforceCoeff <= 0.0f) {
        downforceCoeff = 0.5f;
    }

    /* Downforce = Cl * v^2 */
    return downforceCoeff * speed * speed * 0.01f;
}

/*

 * func_8010B9C8 (700 bytes)
 * Engine torque
 *
 * Calculates engine torque based on RPM
 */
f32 func_8010B9C8(void *car, s32 rpm) {
    u8 *carData = (u8 *)car;
    f32 maxTorque;
    f32 peakRpm;
    f32 torque;

    if (carData == NULL || rpm <= 0) {
        return 0.0f;
    }

    /* Get max torque from car stats (offset 0x58) */
    maxTorque = *(f32 *)(carData + 0x58);
    if (maxTorque <= 0.0f) {
        maxTorque = 300.0f;  /* Default Nm */
    }

    /* Peak torque at 5000 RPM */
    peakRpm = 5000.0f;

    /* Simple torque curve - linear up to peak, then drops */
    if (rpm < peakRpm) {
        torque = maxTorque * ((f32)rpm / peakRpm);
    } else {
        /* Linear drop-off after peak */
        f32 overRev = (f32)(rpm - peakRpm) / 3000.0f;
        torque = maxTorque * (1.0f - overRev * 0.5f);
        if (torque < 0.0f) torque = 0.0f;
    }

    return torque;
}

/*

 * func_8010BC84 (932 bytes)
 * Transmission shift
 *
 * Changes gear with shift timing
 */
void func_8010BC84(void *car, s32 gear) {
    u8 *carData = (u8 *)car;
    s32 *currentGear;
    s32 *shiftTimer;

    if (carData == NULL) {
        return;
    }

    currentGear = (s32 *)(carData + 0xD0);
    shiftTimer = (s32 *)(carData + 0xD4);

    /* Validate gear range (1-6 + reverse) */
    if (gear < -1 || gear > 6) {
        return;
    }

    /* Already in this gear? */
    if (*currentGear == gear) {
        return;
    }

    /* Set shift timer (brief power loss during shift) */
    *shiftTimer = 6;  /* 0.1 seconds */
    *currentGear = gear;

    /* Play shift sound */
    sound_play_menu(26);
}

/*

 * func_8010C02C (1060 bytes)
 * Brake apply
 *
 * Applies braking force to slow the car
 */
void func_8010C02C(void *car, f32 force) {
    u8 *carData = (u8 *)car;
    f32 *velocity;
    f32 speed;
    f32 decel;

    if (carData == NULL || force <= 0.0f) {
        return;
    }

    velocity = (f32 *)(carData + 0x34);

    /* Calculate current speed */
    speed = sqrtf(velocity[0] * velocity[0] + velocity[2] * velocity[2]);

    if (speed < 0.1f) {
        velocity[0] = 0.0f;
        velocity[2] = 0.0f;
        return;
    }

    /* Deceleration proportional to brake force */
    decel = force * 30.0f * (1.0f / 60.0f);  /* Max 30 m/s^2 */

    /* Apply deceleration in velocity direction */
    f32 factor = 1.0f - (decel / speed);
    if (factor < 0.0f) factor = 0.0f;

    velocity[0] *= factor;
    velocity[2] *= factor;

    /* Store brake state for lights */
    *(s32 *)(carData + 0xCC) = (s32)(force * 100.0f);
}

/*

 * func_8010C450 (320 bytes)
 * Handbrake apply
 *
 * Applies handbrake - locks rear wheels for drifting
 */
void func_8010C450(void *car) {
    u8 *carData = (u8 *)car;

    if (carData == NULL) {
        return;
    }

    /* Set handbrake flag */
    *(s32 *)(carData + 0xD8) = 1;

    /* Reduce rear wheel grip */
    /* (handled in tire physics) */
}

/*

 * func_8010C590 (320 bytes)
 * Throttle apply
 *
 * Applies throttle input to accelerate car
 */
void func_8010C590(void *car, f32 amount) {
    u8 *carData = (u8 *)car;

    if (carData == NULL) {
        return;
    }

    /* Clamp throttle 0-1 */
    if (amount < 0.0f) amount = 0.0f;
    if (amount > 1.0f) amount = 1.0f;

    /* Store throttle amount */
    *(f32 *)(carData + 0xC4) = amount;
}

/*

 * func_8010C6D0 (292 bytes)
 * Steering apply
 *
 * Applies steering angle to front wheels
 */
void func_8010C6D0(void *car, f32 angle) {
    u8 *carData = (u8 *)car;

    if (carData == NULL) {
        return;
    }

    /* Clamp steering angle */
    if (angle < -1.0f) angle = -1.0f;
    if (angle > 1.0f) angle = 1.0f;

    /* Store steering angle (converted to radians later) */
    *(f32 *)(carData + 0xC0) = angle * 0.5f;  /* Max 0.5 radians (~28 degrees) */
}

/*

 * func_8010C7F4 (384 bytes)
 * Car input process
 *
 * Processes controller input and applies to car controls
 */
void func_8010C7F4(void *car, void *input) {
    u8 *carData = (u8 *)car;
    u8 *inputData = (u8 *)input;
    f32 stickX, stickY;
    s32 buttons;

    if (carData == NULL || inputData == NULL) {
        return;
    }

    /* Read analog stick (-1 to 1) */
    stickX = *(f32 *)(inputData + 0x00);
    stickY = *(f32 *)(inputData + 0x04);

    /* Read button state */
    buttons = *(s32 *)(inputData + 0x08);

    /* Apply steering */
    func_8010C6D0(car, stickX);

    /* Apply throttle (forward on stick or A button) */
    if (stickY > 0.0f || (buttons & 0x01)) {
        f32 throttle = (stickY > 0.0f) ? stickY : 1.0f;
        func_8010C590(car, throttle);
    } else {
        func_8010C590(car, 0.0f);
    }

    /* Apply brake (back on stick or B button) */
    if (stickY < 0.0f || (buttons & 0x02)) {
        f32 brake = (stickY < 0.0f) ? -stickY : 1.0f;
        func_8010C02C(car, brake);
    }

    /* Handbrake (Z or R button) */
    if (buttons & 0x10) {
        func_8010C450(car);
    }

    /* Boost (C-up or L button) */
    if (buttons & 0x20) {
        func_80106874(car);
    }

    /* Reset (Start button) */
    if (buttons & 0x1000) {
        func_80109468(car);
    }
}

/*

 * func_8010C974 (2636 bytes)
 * AI input generate
 *
 * Based on arcade MaxPath() - generates steering, throttle, brake inputs
 * for AI-controlled cars using path following and obstacle avoidance.
 *
 * Car AI state offsets:
 *   0x100: target waypoint index (s32)
 *   0x104: target position (f32[3])
 *   0x110: current path ID (s32)
 *   0x114: steering output (f32)
 *   0x118: throttle output (f32)
 *   0x11C: brake output (f32)
 *   0x120: AI flags (u32)
 */
void func_8010C974(void *car) {
    f32 *carPos, *carVel, *carDir;
    f32 *targetPos, *steer, *throttle, *brake;
    f32 dx, dz, dist, targetDist;
    f32 dotForward, dotRight;
    f32 carSpeed, desiredSpeed;
    s32 *waypointIdx;
    u32 *aiFlags;

    if (car == NULL) {
        return;
    }

    /* Get car state */
    carPos = (f32 *)((u8 *)car + 0x24);
    carVel = (f32 *)((u8 *)car + 0x34);
    carDir = (f32 *)((u8 *)car + 0x60);  /* Forward direction */

    /* Get AI state */
    waypointIdx = (s32 *)((u8 *)car + 0x100);
    targetPos = (f32 *)((u8 *)car + 0x104);
    steer = (f32 *)((u8 *)car + 0x114);
    throttle = (f32 *)((u8 *)car + 0x118);
    brake = (f32 *)((u8 *)car + 0x11C);
    aiFlags = (u32 *)((u8 *)car + 0x120);

    /* Calculate vector to target */
    dx = targetPos[0] - carPos[0];
    dz = targetPos[2] - carPos[2];
    dist = sqrtf(dx * dx + dz * dz);

    /* Calculate current speed */
    carSpeed = sqrtf(carVel[0] * carVel[0] + carVel[2] * carVel[2]);

    /* Check if reached waypoint */
    if (dist < 5.0f) {
        /* Advance to next waypoint */
        func_8010D3C0(car);
        return;
    }

    /* Normalize direction to target */
    if (dist > 0.001f) {
        dx /= dist;
        dz /= dist;
    }

    /* Calculate steering based on angle to target */
    /* Dot product with forward = cos(angle), with right = sin(angle) */
    dotForward = carDir[0] * dx + carDir[2] * dz;
    dotRight = carDir[2] * dx - carDir[0] * dz;  /* Perpendicular */

    /* Set steering (-1 to 1 based on angle) */
    *steer = dotRight * 2.0f;
    if (*steer > 1.0f) *steer = 1.0f;
    if (*steer < -1.0f) *steer = -1.0f;

    /* Calculate desired speed based on upcoming turn angle */
    desiredSpeed = 60.0f;  /* Base speed */
    if (dotForward < 0.7f) {
        /* Sharp turn ahead - slow down */
        desiredSpeed = 30.0f + dotForward * 30.0f;
    }

    /* Set throttle/brake based on speed difference */
    if (carSpeed < desiredSpeed * 0.9f) {
        *throttle = 1.0f;
        *brake = 0.0f;
    } else if (carSpeed > desiredSpeed * 1.1f) {
        *throttle = 0.0f;
        *brake = 0.5f;
    } else {
        *throttle = 0.5f;
        *brake = 0.0f;
    }

    /* Apply obstacle avoidance */
    func_8010D85C(car);

    /* Apply rubber banding */
    func_8010DCFC(car);
}

/*

 * func_8010D3C0 (704 bytes)
 * AI target find
 *
 * Updates AI target waypoint based on path data
 * Path data structure at D_80143000
 */
void func_8010D3C0(void *car) {
    extern u8 D_80143000[];  /* Path data array */
    extern s16 D_80143200;   /* Number of waypoints per path */
    s32 *waypointIdx, *pathId;
    f32 *targetPos;
    f32 *pathData;
    s32 wpIdx, numWaypoints;

    if (car == NULL) {
        return;
    }

    waypointIdx = (s32 *)((u8 *)car + 0x100);
    pathId = (s32 *)((u8 *)car + 0x110);
    targetPos = (f32 *)((u8 *)car + 0x104);

    numWaypoints = D_80143200;
    if (numWaypoints <= 0) {
        numWaypoints = 20;  /* Default */
    }

    /* Advance waypoint */
    (*waypointIdx)++;
    if (*waypointIdx >= numWaypoints) {
        *waypointIdx = 0;  /* Loop back */
    }

    wpIdx = *waypointIdx;

    /* Get waypoint position from path data */
    /* Path format: pathId * stride + wpIdx * 12 (3 floats) */
    pathData = (f32 *)&D_80143000[(*pathId) * numWaypoints * 12 + wpIdx * 12];
    targetPos[0] = pathData[0];
    targetPos[1] = pathData[1];
    targetPos[2] = pathData[2];
}

/*

 * func_8010D680 (476 bytes)
 * AI path follow
 *
 * Main path following update - called from AI input generate
 */
void func_8010D680(void *car) {
    f32 *carPos, *targetPos;
    f32 dx, dy, dz, distSq;

    if (car == NULL) {
        return;
    }

    carPos = (f32 *)((u8 *)car + 0x24);
    targetPos = (f32 *)((u8 *)car + 0x104);

    /* Calculate squared distance to target */
    dx = targetPos[0] - carPos[0];
    dy = targetPos[1] - carPos[1];
    dz = targetPos[2] - carPos[2];
    distSq = dx * dx + dy * dy + dz * dz;

    /* If close enough to waypoint, get next one */
    if (distSq < 25.0f) {  /* 5^2 = 25 */
        func_8010D3C0(car);
    }
}

/*

 * func_8010D85C (372 bytes)
 * AI obstacle avoid
 *
 * Adjusts steering to avoid nearby obstacles and other cars
 */
void func_8010D85C(void *car) {
    f32 *carPos, *steer;
    f32 *otherPos;
    f32 dx, dz, dist;
    s32 i, numCars;

    if (car == NULL) {
        return;
    }

    carPos = (f32 *)((u8 *)car + 0x24);
    steer = (f32 *)((u8 *)car + 0x114);
    numCars = D_80152744;

    /* Check distance to other cars */
    for (i = 0; i < numCars; i++) {
        u8 *otherCar = &D_80152818[i * 0x144];

        if (otherCar == car) {
            continue;  /* Skip self */
        }

        otherPos = (f32 *)(otherCar + 0x24);
        dx = otherPos[0] - carPos[0];
        dz = otherPos[2] - carPos[2];
        dist = sqrtf(dx * dx + dz * dz);

        /* If car is close, adjust steering */
        if (dist < 8.0f && dist > 0.1f) {
            /* Steer away from other car */
            f32 avoidStrength = (8.0f - dist) / 8.0f;
            if (dx > 0) {
                *steer -= avoidStrength * 0.3f;
            } else {
                *steer += avoidStrength * 0.3f;
            }
        }
    }

    /* Clamp steering */
    if (*steer > 1.0f) *steer = 1.0f;
    if (*steer < -1.0f) *steer = -1.0f;
}

/*

 * func_8010D9CC (492 bytes)
 * AI overtake
 *
 * Attempts to overtake car ahead when appropriate
 */
void func_8010D9CC(void *car) {
    f32 *carPos, *carVel, *steer, *throttle;
    f32 *targetPos;
    u32 *aiFlags;

    if (car == NULL) {
        return;
    }

    carPos = (f32 *)((u8 *)car + 0x24);
    carVel = (f32 *)((u8 *)car + 0x34);
    steer = (f32 *)((u8 *)car + 0x114);
    throttle = (f32 *)((u8 *)car + 0x118);
    aiFlags = (u32 *)((u8 *)car + 0x120);

    /* Check if in overtake mode (flag bit 0x01) */
    if (*aiFlags & 0x01) {
        /* Apply more aggressive steering and throttle */
        *throttle = 1.0f;

        /* TODO: Calculate optimal overtake line */
    }
}

/*

 * func_8010DBB8 (324 bytes)
 * AI defend
 *
 * Defensive driving - blocks overtaking attempts
 */
void func_8010DBB8(void *car) {
    u32 *aiFlags;
    f32 *steer;

    if (car == NULL) {
        return;
    }

    aiFlags = (u32 *)((u8 *)car + 0x120);
    steer = (f32 *)((u8 *)car + 0x114);

    /* Check if in defensive mode (flag bit 0x02) */
    if (*aiFlags & 0x02) {
        /* TODO: Block racing line */
    }
}

/*

 * func_8010DCFC (660 bytes)
 * AI rubber band
 *
 * Based on arcade set_catchup() - adjusts AI speed based on position
 * to keep races competitive (slower when ahead, faster when behind)
 */
void func_8010DCFC(void *car) {
    extern f32 D_80143400;  /* Lead car distance */
    extern f32 D_80143404;  /* Player distance */
    f32 *throttle, *maxSpeed;
    f32 distanceGap, speedMod;
    s32 *racePosition;

    if (car == NULL) {
        return;
    }

    throttle = (f32 *)((u8 *)car + 0x118);
    maxSpeed = (f32 *)((u8 *)car + 0x124);  /* Max speed modifier */
    racePosition = (s32 *)((u8 *)car + 0x128);

    /* Calculate gap to player */
    distanceGap = D_80143400 - D_80143404;

    /* Adjust speed based on gap */
    if (distanceGap > 50.0f) {
        /* AI is far ahead - slow down slightly */
        speedMod = 0.9f;
    } else if (distanceGap < -50.0f) {
        /* AI is far behind - speed up */
        speedMod = 1.1f;
    } else {
        /* Close race - normal speed */
        speedMod = 1.0f;
    }

    /* Apply modifier */
    *maxSpeed = speedMod;
    *throttle *= speedMod;
}

/*

 * func_8010DF90 (364 bytes)
 * AI difficulty adjust
 *
 * Adjusts AI parameters based on difficulty setting
 * Difficulty: 0=Easy, 1=Medium, 2=Hard, 3=Expert
 */
void func_8010DF90(void *car, s32 difficulty) {
    f32 *reactionTime, *accuracy, *aggression, *maxSpeed;

    if (car == NULL) {
        return;
    }

    reactionTime = (f32 *)((u8 *)car + 0x12C);
    accuracy = (f32 *)((u8 *)car + 0x130);
    aggression = (f32 *)((u8 *)car + 0x134);
    maxSpeed = (f32 *)((u8 *)car + 0x124);

    switch (difficulty) {
        case 0:  /* Easy */
            *reactionTime = 0.5f;
            *accuracy = 0.7f;
            *aggression = 0.3f;
            *maxSpeed = 0.85f;
            break;

        case 1:  /* Medium */
            *reactionTime = 0.3f;
            *accuracy = 0.85f;
            *aggression = 0.5f;
            *maxSpeed = 0.95f;
            break;

        case 2:  /* Hard */
            *reactionTime = 0.15f;
            *accuracy = 0.95f;
            *aggression = 0.7f;
            *maxSpeed = 1.0f;
            break;

        case 3:  /* Expert */
            *reactionTime = 0.05f;
            *accuracy = 1.0f;
            *aggression = 0.9f;
            *maxSpeed = 1.05f;
            break;

        default:
            break;
    }
}

/*

 * func_8010E0FC (1008 bytes)
 * AI behavior select
 *
 * Selects AI behavior based on race situation
 * Behaviors: 0=Normal, 1=Overtake, 2=Defend, 3=Recover, 4=Catchup
 */
void func_8010E0FC(void *car) {
    u32 *aiFlags;
    s32 *racePosition, *behavior;
    f32 *carSpeed;
    f32 speed;

    if (car == NULL) {
        return;
    }

    aiFlags = (u32 *)((u8 *)car + 0x120);
    racePosition = (s32 *)((u8 *)car + 0x128);
    behavior = (s32 *)((u8 *)car + 0x138);
    carSpeed = (f32 *)((u8 *)car + 0x34);

    speed = sqrtf(carSpeed[0] * carSpeed[0] + carSpeed[2] * carSpeed[2]);

    /* Check if crashed/stuck (very low speed) */
    if (speed < 2.0f) {
        *behavior = 3;  /* Recover */
        *aiFlags |= 0x04;
        return;
    }

    /* Check position for behavior selection */
    if (*racePosition <= 2) {
        /* In lead - defend position */
        *behavior = 2;
        *aiFlags |= 0x02;
        *aiFlags &= ~0x01;
    } else if (*racePosition >= 4) {
        /* In back - try to catch up/overtake */
        *behavior = 1;
        *aiFlags |= 0x01;
        *aiFlags &= ~0x02;
    } else {
        /* Mid-pack - normal racing */
        *behavior = 0;
        *aiFlags &= ~0x03;
    }
}

/*

 * func_8010E4EC (428 bytes)
 * AI aggression
 *
 * Sets AI aggression level (affects overtaking, blocking, etc.)
 */
void func_8010E4EC(void *car, s32 level) {
    f32 *aggression;

    if (car == NULL) {
        return;
    }

    aggression = (f32 *)((u8 *)car + 0x134);

    /* Clamp level to 0-10 */
    if (level < 0) level = 0;
    if (level > 10) level = 10;

    /* Convert to 0.0-1.0 range */
    *aggression = (f32)level / 10.0f;
}

/*

 * func_8010E69C (144 bytes)
 * AI speed limit
 *
 * Sets maximum speed for AI car
 */
void func_8010E69C(void *car, f32 limit) {
    f32 *maxSpeed;

    if (car == NULL) {
        return;
    }

    maxSpeed = (f32 *)((u8 *)car + 0x124);
    *maxSpeed = limit;
}

/*

 * func_8010E72C (392 bytes)
 * AI error inject
 *
 * Injects random errors to make AI more human-like
 * Based on arcade drone "personality" system
 */
void func_8010E72C(void *car) {
    f32 *steer, *throttle;
    f32 *accuracy;
    f32 errorMag;
    u32 rand;

    if (car == NULL) {
        return;
    }

    steer = (f32 *)((u8 *)car + 0x114);
    throttle = (f32 *)((u8 *)car + 0x118);
    accuracy = (f32 *)((u8 *)car + 0x130);

    /* Simple LCG random */
    D_80143500 = D_80143500 * 1103515245 + 12345;
    rand = D_80143500;

    /* Error magnitude based on inverse accuracy */
    errorMag = (1.0f - *accuracy) * 0.2f;

    /* Add random steering error */
    *steer += ((f32)(rand & 0xFF) / 255.0f - 0.5f) * errorMag;

    /* Add random throttle variation */
    *throttle += ((f32)((rand >> 8) & 0xFF) / 255.0f - 0.5f) * errorMag * 0.5f;

    /* Clamp values */
    if (*steer > 1.0f) *steer = 1.0f;
    if (*steer < -1.0f) *steer = -1.0f;
    if (*throttle > 1.0f) *throttle = 1.0f;
    if (*throttle < 0.0f) *throttle = 0.0f;
}

/*

 * func_8010E8B4 (352 bytes)
 * AI catch up
 *
 * More aggressive catch-up logic for AI far behind
 */
void func_8010E8B4(void *car) {
    f32 *carPos;
    f32 *throttle, *maxSpeed;
    f32 distBehind;

    if (car == NULL) {
        return;
    }

    carPos = (f32 *)((u8 *)car + 0x24);
    throttle = (f32 *)((u8 *)car + 0x118);
    maxSpeed = (f32 *)((u8 *)car + 0x124);

    /* Calculate how far behind player */
    /* Simplified: use Z position as proxy for track distance */
    distBehind = D_80143404 - carPos[2];

    if (distBehind > 100.0f) {
        /* Very far behind - maximum boost */
        *maxSpeed = 1.2f;
        *throttle = 1.0f;
    } else if (distBehind > 50.0f) {
        /* Moderately behind - some boost */
        *maxSpeed = 1.1f;
    }
}

/*

 * func_8010EA14 (2052 bytes)
 * Battle mode logic
 *
 * Rush 2049's battle mode - vehicular combat arena gameplay
 * Players collect weapons and attack each other to score points
 *
 * Game modes:
 *   - Deathmatch: Most kills wins
 *   - Team Battle: Team with most kills wins
 *   - Last Man Standing: Survive to win
 *
 * Weapon pickups:
 *   0 = Missile
 *   1 = Machine gun
 *   2 = Mines
 *   3 = Shield
 *   4 = Speed boost
 */
void func_8010EA14(void) {
    extern s32 D_8014B000;    /* Battle mode state */
    extern s32 D_8014B004;    /* Battle timer (frames) */
    extern s32 D_8014B008;    /* Battle mode type */
    extern s32 D_8014B00C[4]; /* Player scores */
    extern s32 D_8014B01C[4]; /* Player lives */
    extern s32 D_8014B02C[4]; /* Player weapons */
    extern s32 D_8014B03C[4]; /* Player ammo */
    s32 i, j;
    void *car;
    f32 *pos, *otherPos;
    f32 dx, dy, dz, dist;
    s32 *health;
    s32 *weapon, *ammo;

    /* Check if battle mode active */
    if (D_8014B000 == 0) {
        return;
    }

    /* Update battle timer */
    D_8014B004++;

    /* Process each player */
    for (i = 0; i < 4; i++) {
        car = (void *)((u8 *)&D_80152818 + i * 0x400);
        if (car == NULL) {
            continue;
        }

        pos = (f32 *)((u8 *)car + 0x24);
        health = (s32 *)((u8 *)car + 0x1F0);
        weapon = &D_8014B02C[i];
        ammo = &D_8014B03C[i];

        /* Skip eliminated players in Last Man Standing */
        if (D_8014B008 == 2 && D_8014B01C[i] <= 0) {
            continue;
        }

        /* Check health */
        if (*health <= 0) {
            /* Player destroyed */
            D_8014B01C[i]--;

            /* Find attacker and award point */
            /* (simplified - award to closest other player) */
            f32 closestDist = 999999.0f;
            s32 closestPlayer = -1;

            for (j = 0; j < 4; j++) {
                if (j == i) continue;
                void *otherCar = (void *)((u8 *)&D_80152818 + j * 0x400);
                if (otherCar == NULL) continue;

                otherPos = (f32 *)((u8 *)otherCar + 0x24);
                dx = pos[0] - otherPos[0];
                dy = pos[1] - otherPos[1];
                dz = pos[2] - otherPos[2];
                dist = dx*dx + dy*dy + dz*dz;

                if (dist < closestDist) {
                    closestDist = dist;
                    closestPlayer = j;
                }
            }

            if (closestPlayer >= 0) {
                D_8014B00C[closestPlayer]++;
            }

            /* Respawn player (if lives remaining or not Last Man Standing) */
            if (D_8014B008 != 2 || D_8014B01C[i] > 0) {
                func_8010F0D0(car, i);  /* Respawn at battle arena spawn point */
                *health = 100;
                *weapon = 0;  /* Reset weapon */
                *ammo = 0;
            }
        }

        /* Check weapon pickup collision */
        func_8010F158(car, i);

        /* Fire weapon if button pressed */
        if (func_80090EBC(i) & 0x8000) {  /* Z button / fire */
            if (*ammo > 0) {
                func_8010F1A0(car, *weapon, i);  /* Fire weapon */
                (*ammo)--;
            }
        }
    }

    /* Check win condition */
    func_8010F1E0();
}

/*

 * func_8010F218 (2524 bytes)
 * Stunt mode logic
 *
 * Rush 2049's signature stunt mode - score points by performing aerial tricks
 * Uses the game's deployable wing system for air control
 *
 * Trick categories:
 *   - Flips (front/back): Rotation around X axis
 *   - Barrel rolls (left/right): Rotation around Z axis
 *   - Spins (left/right): Rotation around Y axis
 *   - Combos: Multiple different tricks in one air session
 *
 * Scoring:
 *   - Base points per trick type
 *   - Multiplier for multiple rotations (double flip = 2x)
 *   - Combo multiplier for variety
 *   - Landing bonus for clean landings
 *   - Crash penalty resets combo
 */
void func_8010F218(void) {
    extern s32 D_8014C000;    /* Stunt mode state */
    extern s32 D_8014C004;    /* Session timer (frames) */
    extern s32 D_8014C008;    /* Session time limit */
    extern s32 D_8014C00C[4]; /* Player stunt scores */
    extern s32 D_8014C01C[4]; /* Player combo multipliers */
    extern s32 D_8014C02C[4]; /* Player best single trick */
    extern s32 D_8014C03C[4]; /* Player best combo */
    s32 i;
    void *car;
    s32 *isAirborne;
    s32 *wasAirborne;
    s32 flipTrick, rollTrick, spinTrick;
    s32 trickScore, landingBonus;
    s32 *comboCount;
    f32 *airTime;

    /* Check if stunt mode active */
    if (D_8014C000 == 0) {
        return;
    }

    /* Update session timer */
    D_8014C004++;

    /* Check time limit */
    if (D_8014C004 >= D_8014C008) {
        /* Session over - determine winner */
        func_8010F5A0();  /* End stunt session */
        return;
    }

    /* Process each player */
    for (i = 0; i < 4; i++) {
        car = (void *)((u8 *)&D_80152818 + i * 0x400);
        if (car == NULL) {
            continue;
        }

        isAirborne = (s32 *)((u8 *)car + 0x190);
        wasAirborne = (s32 *)((u8 *)car + 0x18C);
        comboCount = (s32 *)((u8 *)car + 0x1AC);
        airTime = (f32 *)((u8 *)car + 0x1A0);

        /* Check if in air */
        if (*isAirborne) {
            /* Detect tricks while airborne */
            flipTrick = func_80102988(car);   /* Front/back flip */
            rollTrick = func_80102F30(car);   /* Barrel roll */
            spinTrick = func_80103D28(car);   /* Spin */

            /* Add new tricks to combo */
            if (flipTrick > 0) {
                func_80104B14(car);  /* Add to combo */
            }
            if (rollTrick > 0) {
                func_80104B14(car);
            }
            if (spinTrick > 0) {
                func_80104B14(car);
            }

            /* Track air time */
            *airTime += 0.0166f;  /* ~1/60 second per frame */
        }

        /* Check for landing (was airborne, now grounded) */
        if (*wasAirborne && !(*isAirborne)) {
            /* Calculate trick scores */
            trickScore = 0;

            flipTrick = func_80102988(car);
            rollTrick = func_80102F30(car);
            spinTrick = func_80103D28(car);

            /* Base points per trick */
            if (flipTrick > 0) {
                s32 level = (flipTrick / 10) + 1;  /* 1=single, 2=double, 3=triple */
                trickScore += 100 * level * level;  /* 100, 400, 900 */
            }
            if (rollTrick > 0) {
                s32 level = (rollTrick / 10) + 1;
                trickScore += 150 * level * level;  /* 150, 600, 1350 */
            }
            if (spinTrick > 0) {
                s32 level = (spinTrick / 10) + 1;
                trickScore += 75 * level;  /* 75, 150, 225, 300 per 180 */
            }

            /* Get landing bonus */
            landingBonus = func_80104704(car);

            /* Apply combo multiplier */
            trickScore *= D_8014C01C[i];
            trickScore += landingBonus;

            /* Track best single trick */
            if (trickScore > D_8014C02C[i]) {
                D_8014C02C[i] = trickScore;
            }

            /* Track best combo */
            if (*comboCount > 1 && trickScore > D_8014C03C[i]) {
                D_8014C03C[i] = trickScore;
            }

            /* Add to session score */
            D_8014C00C[i] += trickScore;

            /* Reset for next air session */
            func_80104F48(car);  /* Reset trick accumulators */
            *airTime = 0.0f;
        }

        /* Update was-airborne for next frame */
        *wasAirborne = *isAirborne;
    }
}

/*

 * func_8010FBF4 (440 bytes)
 * Final cleanup game
 *
 * Called when exiting a game session to clean up resources:
 *   - Free allocated memory pools
 *   - Reset audio channels
 *   - Stop any running effects
 *   - Clear display lists
 *   - Reset game state variables
 */
void func_8010FBF4(void) {
    extern s32 D_801461D0;    /* Main game state */
    s32 i;

    /* Stop all audio */
    func_800B2828(0);  /* Stop all sounds */
    func_800B1E24(0);      /* Stop music */

    /* Clear all particle effects */
    for (i = 0; i < 256; i++) {
        func_800B86BC(i);  /* Kill particle */
    }

    /* Reset car states */
    for (i = 0; i < 4; i++) {
        void *car = (void *)((u8 *)&D_80152818 + i * 0x400);
        if (car != NULL) {
            /* Clear car memory */
            u8 *carBytes = (u8 *)car;
            s32 j;
            for (j = 0; j < 0x400; j++) {
                carBytes[j] = 0;
            }
        }
    }

    /* Reset display list to base address */
    D_80149438 = (void *)0x80160000;

    /* Reset game state */
    D_801461D0 = 0;
    D_801146EC = 0;  /* ATTRACT state */
    D_801174B4 = 0;
    D_80142AFC = 0;

    /* Clear any pending messages */
    func_80007A40();  /* Flush message queues */

    /* Invalidate data cache for game data region */
    osInvalDCache((void *)0x80140000, 0x40000);
}

/*

 * Battle mode helper functions
 */

/*
 * func_8010F0D0 (280 bytes)
 * Battle respawn - Respawns player at arena spawn point
 */
void func_8010F0D0(void *car, s32 playerIdx) {
    extern f32 D_8014B100[4][3];  /* Spawn positions */
    extern f32 D_8014B130[4];     /* Spawn rotations */
    f32 *pos;
    f32 *vel;
    f32 *rot;

    if (car == NULL) {
        return;
    }

    pos = (f32 *)((u8 *)car + 0x24);
    vel = (f32 *)((u8 *)car + 0x34);
    rot = (f32 *)((u8 *)car + 0x60);

    /* Set spawn position */
    pos[0] = D_8014B100[playerIdx][0];
    pos[1] = D_8014B100[playerIdx][1];
    pos[2] = D_8014B100[playerIdx][2];

    /* Clear velocity */
    vel[0] = 0.0f;
    vel[1] = 0.0f;
    vel[2] = 0.0f;

    /* Set spawn rotation */
    rot[1] = D_8014B130[playerIdx];

    /* Brief invincibility after spawn */
    *(s32 *)((u8 *)car + 0x1F4) = 180;  /* 3 seconds invincibility */
}

/*

 * func_8010F158 (72 bytes)
 * Battle pickup check - Checks for weapon pickup collision
 */
void func_8010F158(void *car, s32 playerIdx) {
    /* TODO: Check collision with weapon pickups */
    /* Simplified - stub for now */
}

/*

 * func_8010F1A0 (64 bytes)
 * Battle fire weapon - Fires player's equipped weapon
 */
void func_8010F1A0(void *car, s32 weaponType, s32 playerIdx) {
    f32 *pos, *forward;

    if (car == NULL) {
        return;
    }

    pos = (f32 *)((u8 *)car + 0x24);
    forward = (f32 *)((u8 *)car + 0x60);

    switch (weaponType) {
        case 0:  /* Missile */
            func_800B9A68(pos, forward, playerIdx);  /* Spawn missile projectile */
            break;
        case 1:  /* Machine gun */
            func_800B9C40(pos, forward, playerIdx);  /* Spawn bullet */
            break;
        case 2:  /* Mine */
            func_800B9DF8(pos, playerIdx);  /* Drop mine */
            break;
        case 3:  /* Shield */
            *(s32 *)((u8 *)car + 0x1F4) = 300;  /* 5 second shield */
            break;
        case 4:  /* Speed boost */
            *(f32 *)((u8 *)car + 0x200) = 1.5f;  /* Temporary speed boost */
            break;
    }
}

/*

 * func_8010F1E0 (56 bytes)
 * Battle win check - Checks if any player has won
 */
void func_8010F1E0(void) {
    extern s32 D_8014B04C;    /* Score limit */
    s32 i;
    s32 alivePlayers = 0;
    s32 winner = -1;

    /* Check score limit */
    for (i = 0; i < 4; i++) {
        if (D_8014B00C[i] >= D_8014B04C) {
            /* Player reached score limit */
            winner = i;
            D_8014B000 = 2;  /* End battle, show results */
            return;
        }
    }

    /* Check Last Man Standing */
    if (D_8014B008 == 2) {
        for (i = 0; i < 4; i++) {
            if (D_8014B01C[i] > 0) {
                alivePlayers++;
                winner = i;
            }
        }
        if (alivePlayers <= 1) {
            D_8014B000 = 2;  /* End battle */
        }
    }
}

/*

 * Stunt mode helper functions
 */

/*
 * func_8010F5A0 (164 bytes)
 * Stunt end session - Ends stunt mode and shows results
 */
void func_8010F5A0(void) {
    s32 i;
    s32 highScore = 0;
    s32 winner = 0;

    /* Find highest scorer */
    for (i = 0; i < 4; i++) {
        if (D_8014C00C[i] > highScore) {
            highScore = D_8014C00C[i];
            winner = i;
        }
    }

    /* Set winner and end state */
    D_8014C000 = 2;  /* End stunt mode, show results */

    /* Trigger results screen */
    func_800D7DC4();  /* TODO: needs different function for results */
}

/*
*/
