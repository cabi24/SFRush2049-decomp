// Visit https://github.com/ethteck/splat/wiki/Adding-Symbols for documentation about this file
entrypoint = 0x80000400; // type:func clears BSS, sets stack, jumps to main
main = 0x800020F0; // type:func real main function (called from entrypoint)

// libc functions
memchr = 0x80002730; // type:func
memset = 0x80002790; // type:func
strchr = 0x80007C00; // type:func find char in string
strlen = 0x80007C40; // type:func get string length
memcpy = 0x80007C68; // type:func copy memory
bcopy = 0x8000D2B0; // type:func copy memory with overlap handling (memmove)

// libgcc floating point conversion functions (A5F0.s)
__fixdfdi = 0x800099F0; // type:func double to long long
__fixsfdi = 0x80009A0C; // type:func float to long long
__fixunsdfdi = 0x80009A28; // type:func double to unsigned long long
__fixunssfdi = 0x80009AC8; // type:func float to unsigned long long
__floatdidf = 0x80009B64; // type:func long long to double
__floatdisf = 0x80009B7C; // type:func long long to float
__floatundidf = 0x80009B94; // type:func unsigned long long to double
__floatundisf = 0x80009BC8; // type:func unsigned long long to float

// libm functions (34A0.s, 9330.s)
modf = 0x800028A0; // type:func split double into integer and fractional parts
modff = 0x80002A64; // type:func float version of modf
__isinf = 0x80002BF0; // type:func
__isnan = 0x80002C60; // type:func
sinf = 0x80008730; // type:func sine approximation using polynomial arcade:fmath.c:fsin()
cosf = 0x800088F0; // type:func cosine approximation using polynomial arcade:fmath.c:fcos()
fcvt = 0x80002CD0; // type:func convert float to string
__ecvt_internal = 0x80003C3C; // type:func float to string internal helper
__round_helper = 0x80004674; // type:func rounding helper for float conversion

// libm/libgcc floating-point constants (34A0.s, 9330.s)
gSinCoeffs = 0x8002D750; // type:data sine polynomial coefficients array
gTwoOverPi = 0x8002D778; // type:data 2/pi constant (f64)
gPiOver2Hi = 0x8002D780; // type:data pi/2 high part (f64)
gPiOver2Lo = 0x8002D788; // type:data pi/2 low part (f64)
gNaN = 0x8002D790; // type:data NaN value (f64)
gCosCoeffs = 0x8002D7A0; // type:data cosine polynomial coefficients array (f64[5])
gCosAngleScale = 0x8002D7C8; // type:data cosf angle reduction scale (f64)
gCosPiOver2Hi = 0x8002D7D0; // type:data cosf pi/2 high part (f64)
gCosPiOver2Lo = 0x8002D7D8; // type:data cosf pi/2 low part (f64)
gCosOne = 0x8002D7E0; // type:data cosf result 1.0 constant (f32)
gNaNf = 0x8002D880; // type:data NaN value (f32) - returned for invalid trig input
gInfinity = 0x8002D800; // type:data infinity constant (f64)
gNegInfinity = 0x8002D808; // type:data negative infinity (f64)
gFcvtBuffer = 0x8002D4D0; // type:data fcvt output buffer
gFcvtDigits = 0x8002D4E0; // type:data fcvt digit buffer
gFcvtSign = 0x8002D4F0; // type:data fcvt sign flag
gFcvtDecpt = 0x8002D4F4; // type:data fcvt decimal point position
gFcvtTemp1 = 0x8002D4F8; // type:data fcvt temp buffer 1
gFcvtTemp2 = 0x8002D50C; // type:data fcvt temp buffer 2
gFcvtTemp3 = 0x8002D514; // type:data fcvt temp buffer 3
gFcvtTemp4 = 0x8002D528; // type:data fcvt temp buffer 4
gFcvtTemp5 = 0x8002D53C; // type:data fcvt temp buffer 5
gPerspFov = 0x8002D6C0; // type:data perspective FOV constant (f64)
gPerspAspect = 0x8002D6C8; // type:data perspective aspect ratio (f64)
// NOTE: gExceptionMask at 0x8002D6D0 renamed to __osRcpImTable (see Exception handler state section)
gOrthoScale = 0x8002D7F0; // type:data orthographic scale constant (f64)
// NOTE: gExceptionFlag at 0x8002D810 renamed to __osIntOffTable (see Exception handler state section)

// Viewport scale constants (21F0.s)
gViewportFloatA = 0x8002D4C0; // type:data viewport float constant A
gViewportFloatB = 0x8002D4C4; // type:data viewport float constant B
gViewportFloatC = 0x8002D4C8; // type:data viewport float constant C (PAL)
gViewportFloatD = 0x8002D4CC; // type:data viewport float constant D (NTSC)

// libultra OS functions
osCreateMesgQueue = 0x80006A00; // type:func
osSetEventMesg = 0x80006A30; // type:func set event message
osGetCount = 0x8000C970; // type:func read CP0 Count register
osDpIsBusy = 0x8000D740; // type:func check if RDP is busy
osGetActiveQueue = 0x8000C660; // type:func get active thread queue
osSetThreadPri = 0x80006D40; // type:func set thread priority
osSetIntMask = 0x80006DA0; // type:func set interrupt mask
osSetTimer = 0x8000E3D0; // type:func set timer (initializes OSTimer and inserts to queue)
osSetTimerIntr = 0x80006ED0; // type:func set timer interrupt
osCreateThread = 0x80006F30; // type:func create thread
osStartThread = 0x80007080; // type:func start thread
osRecvMesg = 0x80007270; // type:func receive message from queue
osSetGlobalIntMask = 0x800071D0; // type:func set global interrupt mask
osSendMesg = 0x80007440; // type:func send message to queue
osJamMesg = 0x800075E0; // type:func insert message at front of queue
osViSetMode = 0x80007590; // type:func set VI mode
osSpTaskYielded = 0x80007730; // type:func check if SP task yielded
osGetTime = 0x800073B0; // type:func get system time
osViGetFramebuffer = 0x800077D0; // type:func get configured framebuffer from context
osViGetCurrentFramebuffer = 0x80007790; // type:func get current framebuffer
osInvalICache = 0x80007810; // type:func invalidate I-cache
osWritebackDCache = 0x80007CA0; // type:func writeback D-cache
osDpSetNextBuffer = 0x80007B00; // type:func set RDP display list
osDpWait = 0x80007B80; // type:func wait for RDP ready
osDpGetCounters = 0x800099B0; // type:func get RDP performance counters

// Audio interface functions
osAiSetNextBuffer = 0x8000BE70; // type:func set AI DMA buffer
osAiSetFrequency = 0x8000BF00; // type:func set AI sample rate
__osAiDeviceBusy = 0x8000FB60; // type:func check if AI FIFO is full (returns 1 if busy)
__setfpcsr = 0x800049F0; // type:func
osInvalDCache = 0x800084E0; // type:func invalidate D-cache
bzero = 0x80008590; // type:func optimized zero-fill
__osDisableInt = 0x8000C4B0; // type:func disable interrupts, return previous state
__osRestoreInt = 0x8000C520; // type:func restore interrupt state
osViInit = 0x8000C540; // type:func video interface initialization
__osViSwapContext = 0x8000C670; // type:func swap VI context (writes to VI hardware registers)
__osException = 0x8000C980; // type:func CPU exception handler (handwritten asm)
osViSetSpecialFeatures = 0x80007D20; // type:func set VI special features (gamma, dither, etc.)
osCauseGet = 0x8000DBB0; // type:func read CP0 Cause register
osPiReadIo = 0x8000D7A0; // type:func read from physical I/O address
osPiWriteWord = 0x8000D7F0; // type:func write word to cartridge space
osPiRawReadWord = 0x800081D0; // type:func synchronized ROM word read with PI access control
osPiInit = 0x8000DBC0; // type:func peripheral interface initialization
osPiGetAccess = 0x8000DC10; // type:func acquire PI mutex
osPiReleaseAccess = 0x8000DC54; // type:func release PI mutex
osPiReadWord = 0x8000DC80; // type:func read word from cartridge
osPiStartDma = 0x8000DCD0; // type:func start PI DMA transfer
osPiSetDeviceTiming = 0x8000DDA0; // type:func configure PI bus timing registers
__osPiRawStartDma = 0x80008630; // type:func PI raw DMA request via message queue

// PI global state (os_pi.c, os_pi_dma.c)
__osPiInitialized = 0x8002C4A0; // type:data PI initialized flag (s32) - os_pi.c
__osPiMgrState = 0x8002C380; // type:data size:0x1C PI manager state struct (flag+queues+funcs) - osCreatePiManager
__osPiMesgQueue = 0x80037C78; // type:data PI message queue (OSMesgQueue)
__osPiMesg = 0x80037C70; // type:data PI message buffer (OSMesg)
__osPiDmaQueue = 0x80037A80; // type:data size:0x18 PI DMA event message queue (OSMesgQueue) - osCreatePiManager
__osPiDmaMesg = 0x80037A98; // type:data size:0x4 PI DMA message buffer (OSMesg) - capacity 1

__osTlbFlush = 0x8000D840; // type:func flush all TLB entries
__osTlbInit = 0x8000D890; // type:func initialize TLB for 0xC0000000 region
__osTLBLookup = 0x8000FCB0; // type:func TLB lookup for virtual to physical translation
osPhysicalToVirtual = 0x80009C00; // type:func convert physical address to KSEG0 virtual
osVirtualToPhysical = 0x8000D5C0; // type:func convert virtual address to physical
__osPiDeviceBusy = 0x8000FD70; // type:func check if PI device is busy (returns status)
osEPiRawWriteIo = 0x8000FDA0; // type:func raw PI I/O write (no device manager, direct HW access)
osEPiRawStartDma = 0x8000FE00; // type:func raw PI DMA start (no device manager, direct HW access)
osEPiRawReadIo = 0x8000FF60; // type:func raw PI I/O read (no device manager, direct HW access)
__osPiGetCmdQueue = 0x800100C0; // type:func get PI command queue for device manager
__osSpDma = 0x8000D680; // type:func SP DMA transfer (RSP <-> RDRAM)
__osSiRawStartDma = 0x8000E4B0; // type:func SI raw DMA to/from PIF
osSiInit = 0x8000E560; // type:func serial interface initialization
__osSiGetAccess = 0x8000E5B0; // type:func acquire SI mutex
__osSiRelAccess = 0x8000E5F4; // type:func release SI mutex
osContStartReadData = 0x8000E620; // type:func start controller read
__osContBuildRequest = 0x8000E6F0; // type:func build controller request packet
__osContParseResponse = 0x8000E7B4; // type:func parse controller response

// Controller query/read functions (A330.s)
osContStartQuery = 0x80009730; // type:func start controller status query
osContGetQuery = 0x800097AC; // type:func get controller query results (wrapper for __osContGetInitData)
osContStartReadData2 = 0x800097D0; // type:func alternative start controller read
osContGetReadData = 0x80009854; // type:func parse PIF response into OSContPad
__osPackReadData = 0x800098E0; // type:func pack read-buttons command into PIF buffer
__osContRamRead = 0x8000E8D0; // type:func read from controller pak RAM
__osContRamWrite = 0x8000F680; // type:func write to controller pak RAM (PFS page write)
__osContAddressCrc = 0x8000F9F0; // type:func calculate address CRC for controller pak
__osContDataCrc = 0x8000FA4C; // type:func calculate data CRC for controller pak
__osPfsDataChecksum = 0x8000FAC0; // type:func calculate PFS page data checksum (32 bytes)
__osPfsRWInode = 0x8000F3A4; // type:func read/write controller pak inode table
bcmp = 0x8000F8D0; // type:func compare two memory regions (returns 0 if equal, 1 otherwise)

// Controller/PFS global state (os_pfs_rw.c, os_motor.c)
__osContLastChannel = 0x8002C4C0; // type:data last accessed controller channel (u8)
__osPfsRequestType = 0x80037AE0; // type:data controller read in progress flag (u8)
__osPfsRequestType2 = 0x80037AE1; // type:data secondary controller request type (u8)
__osPfsBuffer = 0x80037F60; // type:data PIF command buffer (u8[64])
__osMotorPifBuf = 0x80037B30; // type:data motor PIF command buffer (u8[256])
__osMotorProbe = 0x80037AE0; // type:data motor probe byte (s8) - same as __osPfsRequestType
__osSiDmaBuffer = 0x80037AA0; // type:data SI DMA buffer for controller reads (24 refs)
__osSiDmaRetry = 0x80037ADC; // type:data SI DMA retry counter
__osContQueryMsgQ = 0x80037B08; // type:data controller query message queue (OSMesgQueue)
__osContQueryMesg = 0x80037B20; // type:data controller query message buffer (OSMesg)
__osSiMesgQueue = 0x80037C90; // type:data SI event message queue (OSMesgQueue)
__osSiMesg = 0x80037C98; // type:data SI event message buffer (OSMesg)
__osContPifInode = 0x80037CB0; // type:data controller pak inode buffer

// SI/controller init state (F160.s - osSiInit)
__osSiInitialized = 0x8002C4B0; // type:data SI initialized flag (s32)
__osSiLastChannel = 0x8002C4D0; // type:data last SI channel accessed (s32)
__osSiChannelMask = 0x8002C4D4; // type:data SI channel mask byte (u8) - 0xFA = all channels

__osSetFpcCsr = 0x8000D790; // type:func set FP control/status register
__osSetSR = 0x8000D770; // type:func set CP0 Status register
__osGetSR = 0x8000D780; // type:func get CP0 Status register
__osGetCause = 0x8000DBB0; // type:func get CP0 Cause register
__osSpSetStatus = 0x8000D640; // type:func set RSP status register
__osSpSetPc = 0x8000D650; // type:func set RSP program counter (only if halted)
__osSpDeviceBusy = 0x8000D710; // type:func check if RSP is busy (bits 0x1C)

// VI mode table functions (8440.s)
osViModeTableGet = 0x80007840; // type:func get VI mode from table
osViModeNtscLan1 = 0x8000794C; // type:func get NTSC LAN1 VI mode
osViModeNtscLpn1 = 0x80007AB4; // type:func get NTSC LPN1 VI mode

// OS initialization functions (8A80.s)
__osInitialize_common = 0x80007E80; // type:func OS init: installs exception vectors, sets up PI/AI timing
__osPiReadDeviceType = 0x80008128; // type:func save PI BSD DOM1/DOM2 timing registers to globals

// N64 Exception Vectors (copied from __osException during boot)
// These are the MIPS R4300 exception vector locations in KSEG0
g_tlb_exception_vector = 0x80000000; // type:data size:16 TLB refill exception handler code (16 bytes)
g_tlb_exception_instr1 = 0x80000004; // type:data exception vector instruction word 1
g_tlb_exception_instr2 = 0x80000008; // type:data exception vector instruction word 2
g_tlb_exception_instr3 = 0x8000000C; // type:data exception vector instruction word 3
g_xtlb_exception_vector = 0x80000080; // type:data size:16 XTLB refill exception handler code (16 bytes)
g_cache_exception_vector = 0x80000100; // type:data size:16 Cache error exception handler code (16 bytes)
g_general_exception_vector = 0x80000180; // type:data size:16 General exception handler code (16 bytes)

// N64 OS Boot Parameters (set by IPL, read during osInitialize)
osTvType = 0x80000300; // type:data size:4 TV type (0=PAL, 1=NTSC, 2=MPAL)
osRomType = 0x80000304; // type:data size:4 ROM type
osRomBase = 0x80000308; // type:data size:4 ROM base address
osResetType = 0x8000030C; // type:data size:4 Reset type (0=cold, 1=warm NMI)
osCicId = 0x80000310; // type:data size:4 CIC chip ID
osVersion = 0x80000314; // type:data size:4 OS version
osMemSize = 0x80000318; // type:data size:4 Memory size in bytes
osAppNMIBuffer = 0x8000031C; // type:data size:64 NMI buffer (preserved across warm reset)

// Controller pak (osPfs) functions
osPfsInitPak = 0x80009C10; // type:func initialize controller pak
osPfsChecker = 0x8000B3E0; // type:func check controller pak integrity
osPfsReadWriteFile = 0x8000A970; // type:func read/write controller pak file
osPfsFreeBlocks = 0x8000B240; // type:func get free blocks on controller pak
__osPfsSelectBank = 0x8000E850; // type:func select controller pak bank
__osPfsCheckPages = 0x8000B918; // type:func build inode usage bitmap for integrity check
__osPfsPageCheck = 0x8000BBF0; // type:func validate inode references, detect duplicates
__osPfsDeclearPage = 0x8000ACA4; // type:func page allocation helper for file allocation
__osIdCheckSum = 0x8000EB74; // type:func calculate ID checksum (Adler-like)
__osRepairId = 0x8000EC70; // type:func repair/rewrite ID to 4 redundant pages
__osCheckId = 0x8000EFC0; // type:func check ID consistency across 4 pages
__osGetId = 0x8000F124; // type:func top-level ID retrieval during pak init

// Utility functions (F700.s)
__osSumcalc = 0x8000EB00; // type:func byte-sum checksum helper (used by PFS)

// Timer queue and linked list utilities (CC50.s, D0B0.s)
dll_remove = 0x8000C050; // type:func remove node from singly-linked list
dll_init = 0x8000C090; // type:func initialize timer queue (doubly-linked list)
dll_update = 0x8000C11C; // type:func process expired timers (delta queue maintenance)
dll_reschedule = 0x8000C294; // type:func reschedule timer interrupt (__osSetTimerIntr)
dll_insert = 0x8000C308; // type:func insert timer into delta queue (__osInsertTimer)
dll_get_priority = 0x8000C490; // type:func get thread priority helper
__osSetCompare = 0x8000FB90; // type:func set CP0 Compare register for timer

// Timer queue global state
__osTimerList = 0x8002C3F0; // type:data timer queue head pointer (TimerQueueHead*)
__osTimerCounter = 0x80037C60; // type:data last timer update timestamp (osGetCount value)
gViTimeAccumHi = 0x80037C50; // type:data VI time accumulator high word (64-bit time, hi part)
gViTimeAccumLo = 0x80037C54; // type:data VI time accumulator low word (64-bit time, lo part)
gViLastCount = 0x80037C58; // type:data VI last osGetCount value for delta calculation
gViRetraceCount = 0x80037C5C; // type:data VI retrace tick counter (incremented each retrace)

// Thread state
__osRunningThread = 0x8002C3E0; // type:data current running thread (OSThread*)
__osActiveQueue = 0x8002C3D8; // type:data active thread queue head (OSThread**)
__osRunQueue = 0x8002C3DC; // type:data run queue head (OSThread*) - pending runnable threads
__osGlobalIntMask = 0x8002C370; // type:data global interrupt mask (u32)
__osEmptyMesgQueue = 0x8002C3D0; // type:data empty message queue sentinel (OSMesgQueue)

// PI device manager state (os_pi.c, E9A0.s)
__osPiDevList = 0x8002C3A0; // type:data PI device list array (OSPiHandle*[])
__osContPifBuf = 0x8002C3B0; // type:data controller PIF command buffer pointer

// AI buffer state (CA70.s - osAiSetNextBuffer)
__osAiNeedsAlign = 0x8002C3C0; // type:data AI buffer alignment flag (u8)

// Exception handler state (D580.s) - __osException globals
__osExceptionSaveArea = 0x80037DB0; // type:data size:432 exception preamble temp save area (OSThread-like)
__osFaultedThread = 0x8002C3E4; // type:data faulted thread pointer (OSThread*) - set on CPU fault
__osShutdown = 0x8002C36C; // type:data shutdown/pre-NMI flag (u32) - set when NMI received
__osIntOffTable = 0x8002D810; // type:data size:32 interrupt handler offset table (u8[32])
__osIntTable = 0x8002D830; // type:data size:36 interrupt handler jump table (void*[9])
__osHwIntTable = 0x8002C470; // type:data size:20 hardware interrupt callback table (func_ptr[5])
__osPiIntHandler = 0x8002C498; // type:data size:8 PI interrupt handler entry (callback, stack)
__osRcpImTable = 0x8002D6D0; // type:data size:128 RCP interrupt mask lookup table (u16[64])
__osEventStateTab = 0x80036710; // type:data size:128 event state table array (__OSEventState[16])

// Exception handler code labels (D580.s) - internal entry points within __osException
__osExceptionPreamble = 0x8000C990; // type:func exception preamble - saves context to __osExceptionSaveArea then running thread
__osExceptionPanic = 0x8000D298; // type:func exception panic - called after ERET falls through (should not happen)
__osSendInterrupt = 0x8000CEDC; // type:func send interrupt message to event state table queue (called from exception handler)


// VI manager state (D140.s, D270.s)
__osViMode = 0x8002C400; // type:data VI mode structure (96 bytes)
__osViModeTable = 0x8002C430; // type:data VI mode table pointer
__osViModeInfo = 0x8002C460; // type:data VI mode info pointer (osViGetCurrentFramebuffer)
__osViContext = 0x8002C464; // type:data VI context pointer (current VI settings)
__osViModePending = 0x8002C4E0; // type:data pending VI mode change
__osViModeNext = 0x8002C530; // type:data next VI mode to apply
__osViModeBuffer = 0x8002C580; // type:data VI mode buffer

// VI manager queue structures (7630.s - osSetEventMesg, vi_manager_main)
gViMgrMesgQueue = 0x800366A0; // type:data size:24 VI manager message queue (OSMesgQueue)
gViMgrMesgBuffer = 0x800366B8; // type:data size:20 VI manager message buffer array (5 OSMesg)
gViMgrEventDP = 0x800366D0; // type:data size:8 VI manager DP event message (type=0xD OS_EVENT_DP)
gViMgrEventSP = 0x800366E8; // type:data size:8 VI manager SP event message (type=0xE OS_EVENT_SP)
gViMgrRetraceCounter = 0x80036700; // type:data size:2 VI manager retrace counter (u16, decremented per retrace)
gViModeTempBuffer = 0x80036790; // type:data VI mode temp copy buffer (64 bytes)
gViModePtr0 = 0x800367A0; // type:data VI mode pointer slot 0
gViModePtr1 = 0x800367A8; // type:data VI mode pointer slot 1
gViModePtr2 = 0x800367B0; // type:data VI mode pointer slot 2
gViModePtr3 = 0x800367B8; // type:data VI mode pointer slot 3
gViModePtr4 = 0x800367BC; // type:data VI mode pointer slot 4
gViModePtr5 = 0x800367C0; // type:data VI mode pointer slot 5
gViModePtr6 = 0x800367C8; // type:data VI mode pointer slot 6
gViModeMessage = 0x800368D0; // type:data VI mode message buffer
// NOTE: 0x80036710 is __osEventStateTab (see Exception handler state section), not gViModeIndex

// Thread queue management (D550.s, D580.s)
__osEnqueueThread = 0x8000D0C4; // type:func enqueue thread to priority queue
__osPopThread = 0x8000D10C; // type:func pop highest priority thread
__osDispatchThread = 0x8000D11C; // type:func dispatch next runnable thread
__osDispatchThreadYield = 0x8000D298; // type:func dispatch thread after yield (jump target in exception handler)
__osEnqueueAndYield = 0x8000FBA0; // type:func save thread context, enqueue to queue, yield to scheduler (asm)
osYieldThread = 0x80010110; // type:func yield current thread (calls __osEnqueueAndYield with __osRunQueue)

// DMA/decompression wrappers (3140.s)
dma_queue_init = 0x80002540; // type:func initialize DMA message queue
dma_wait = 0x80002598; // type:func wait for DMA completion
dma_signal = 0x8000262C; // type:func signal DMA complete
lzss_decompress = 0x80002660; // type:func LZSS decompress with DMA
inflate_decompress = 0x800026C0; // type:func inflate decompress with DMA

// DMA global state (dma.c)
gDmaMessageQueue = 0x8002F190; // type:data DMA message queue (OSMesgQueue)
gDmaMessageBuffer = 0x8002F1A8; // type:data DMA message buffer array (OSMesg[])
gDmaInitialized = 0x8002B030; // type:data DMA initialized flag (u8)

// Inflate/decompression (5610.s)
inflate_entry = 0x80006814; // type:func main decompression entry point
inflate_entry_alt = 0x8000697C; // type:func alternative entry (heap alloc)
inflate_loop = 0x80006678; // type:func main inflate decompression loop
inflate_block = 0x800064D4; // type:func decode one deflate block
inflate_stored = 0x8000595C; // type:func handle uncompressed block (type 0)
inflate_fixed = 0x80005B7C; // type:func handle fixed Huffman block (type 1)
inflate_dynamic = 0x80005D44; // type:func handle dynamic Huffman block (type 2)
huft_build = 0x80004D98; // type:func build Huffman decoding tables
huft_alloc = 0x80004D6C; // type:func allocate Huffman table memory
lzss_decode = 0x80004AFC; // type:func LZSS back-reference decoder

// Game initialization (2CF0.s)
game_init = 0x80002238; // type:func main game initialization, creates threads
game_late_init = 0x800EEA7C; // type:func late-stage game init (called after decompression)

// Display/rendering (21F0.s)
display_update = 0x800015F0; // type:func update display list with viewport interpolation
viewport_setup = 0x80001B44; // type:func camera/viewport bounds setup
viewport_scale = 0x800A7508; // type:func scale viewport dimensions (display.c)
get_viewport_pos = 0x80001E84; // type:func get current viewport position
get_viewport_offset = 0x80001ECC; // type:func get viewport offset from base
update_viewport = 0x80001F2C; // type:func update viewport with bounds checking

// Display list globals (gfx.c)
gDisplayListHead = 0x800354C4; // type:data pointer to start of display list buffer
gDisplayListSize = 0x800354C8; // type:data current size/offset in display list
gDisplayListEnd = 0x800354CC; // type:data pointer to end of display list buffer

// Viewport/display globals (21F0.s) - used in display_update
gViewportDataPtr = 0x8002B014; // type:data viewport data buffer pointer (46 refs)
gViewportBuffer = 0x8002EC00; // type:data viewport data buffer base
gViewportX = 0x8002EBF8; // type:data viewport X position (s16)
gViewportY = 0x8002EBFA; // type:data viewport Y position (s16)
gViewportStruct = 0x8002EBFC; // type:data viewport data structure pointer
gViewportScale = 0x8002ECAC; // type:data viewport scale factor (s16)
gViewportScaleX = 0x8002ECB0; // type:data viewport X scale (s16)
gViewportScaleY = 0x8002ECB2; // type:data viewport Y scale (s16)
gViewportOffsetX = 0x8002AFFC; // type:data viewport X offset table (s16[])
gViewportOffsetY = 0x8002AFFE; // type:data viewport Y offset table (s16[])
gScaleTicksPerSecond = 0x8002AFB4; // type:data size:4 ticks-to-seconds scale factor (f32), set by viewport_setup
gScaleSecondsPerTick = 0x8002AFB8; // type:data size:4 seconds-per-tick scale factor (f32), set by viewport_setup
gScTimeEnabled = 0x8002AFB0; // type:data size:4 scheduler time accumulation enabled (0/1)
gViewportPendingFrames = 0x8002B010; // type:data size:2 viewport pending frame countdown (s16)
gViModeTableBase = 0x8002B1B0; // type:data size:0x190 VI mode table (5 entries x 80 bytes each)
gViewportBoundsTable = 0x8002AFC8; // type:data size:32 viewport bounds rect array (16 bytes x 2 entries)
gViewportOffsetXExtra = 0x8002AFF8; // type:data size:2 viewport X offset extra (s16 in 8-byte table)
gViewportOffsetYExtra = 0x8002AFFA; // type:data size:2 viewport Y offset extra (s16 in 8-byte table)

// VI timing state (1050.s) - used by viUpdateTime
gViTickCounter = 0x8002EB64; // type:data VI tick counter (osGetCount value)
gViFrameDelta = 0x8002EB98; // type:data VI frame time delta
gViAccumTime = 0x8002EB9C; // type:data VI accumulated time (secondary)
gViAccumTotal = 0x8002EBA0; // type:data VI accumulated total time
gViLastTick = 0x8002EBA4; // type:data VI last tick snapshot

// Inflate state globals (5610.s)
gInflateInPtr = 0x800354B0; // type:data inflate input pointer
gInflateInEnd = 0x800354B4; // type:data inflate input buffer end
gInflateOutPtr = 0x800354B8; // type:data inflate output write position
gInflateBitBuf = 0x800354BC; // type:data inflate bit accumulator (u32)
gInflateBitCount = 0x800354C0; // type:data valid bits in buffer (u32)
gInflateSrc = 0x800354D0; // type:data compressed source pointer
gInflateToggle = 0x800354D4; // type:data double-buffer toggle
gInflateDmaState = 0x800354D8; // type:data DMA state structure
gInflateMsgQueue = 0x80035428; // type:data inflate message queue
gInflateBufferA = 0x80084A50; // type:data inflate double-buffer A (4KB)
gInflateBufferB = 0x80085A50; // type:data inflate double-buffer B (4KB)

// LZSS decompression state globals (5610.s - lzss_decode)
gLzssSrc = 0x800354A0; // type:data size:4 LZSS compressed source pointer (advances by 4KB per buffer)
gLzssToggle = 0x80035480; // type:data size:4 LZSS double-buffer toggle (0 or 1)
gLzssDmaState = 0x80035488; // type:data size:24 LZSS DMA state structure (passed to __osPiRawStartDma)

// Matrix functions (9DE0.s)
guMtxF2L = 0x800091E0; // type:func convert float matrix to N64 fixed-point
guMtxL2F = 0x800092E0; // type:func convert N64 fixed-point to float matrix
guMtxIdentF = 0x80009394; // type:func create 4x4 identity matrix (float)
guMtxIdent = 0x8000941C; // type:func create N64 identity matrix (fixed-point)

// Graphics utility functions (9660.s, 9820.s, 9AB0.s)
guOrthoF = 0x80008A60; // type:func orthographic projection matrix (float)
guOrtho = 0x80008BB4; // type:func orthographic projection matrix (fixed-point)
guPerspectiveF = 0x80008C20; // type:func perspective projection matrix (float)
guPerspective = 0x80008E50; // type:func perspective projection matrix (fixed-point)
guLookAtF = 0x80008EB0; // type:func look-at view matrix (float)
guLookAt = 0x80009168; // type:func look-at view matrix (fixed-point)
sqrtf = 0x8000E3C0; // type:func square root (float) arcade:fmath.c:fsqrt()

// Communication/data parsing (AB20.s)
osMotorInit = 0x80009F20; // type:func rumble pak motor initialization
__osMotorAccess = 0x8000A088; // type:func build rumble pak PIF command
osMotorStart = 0x8000A194; // type:func start rumble pak motor (writes 0x01 to 0xC000)
osMotorStop = 0x8000A2F0; // type:func stop rumble pak motor (writes 0x00 to 0xC000)

// libgcc 64-bit arithmetic (E4F0.s)
__lshrdi3 = 0x8000D8F0; // type:func logical right shift
__umoddi3 = 0x8000D91C; // type:func unsigned modulo
__udivdi3 = 0x8000D958; // type:func unsigned divide
__ashldi3 = 0x8000D994; // type:func arithmetic left shift
__divdi3 = 0x8000D9FC; // type:func signed divide
__muldi3 = 0x8000DA58; // type:func multiply
__qdivrem = 0x8000DA88; // type:func quotient and remainder
__moddi3 = 0x8000DAE8; // type:func signed modulo
__ashrdi3 = 0x8000DB84; // type:func arithmetic right shift

// Scheduler functions (1050.s) - identified by Codex analysis
osCreateScheduler = 0x80000450; // type:func create OSSc-like scheduler struct, sets up msg queues and events
osScAddClient = 0x800005D4; // type:func link client into scheduler clientList
__scMain = 0x8000063C; // type:func scheduler thread main loop (handles events 0x29A-0x29E)
__scSchedule = 0x80000780; // type:func drain command queue, append tasks to pending lists
__scHandleRetrace = 0x80000880; // type:func VI retrace handler, sends msgs to clients
__scHandleRSP = 0x80000950; // type:func SP interrupt handler, finalizes RSP tasks
__scHandleRDP = 0x80000ACC; // type:func DP interrupt handler, reschedules graphics
__scTaskReady = 0x80000BA4; // type:func validate task timing before scheduling
__scExecTask = 0x80000C54; // type:func process task msgQ, handle watchdog
__scAppendList = 0x80000D6C; // type:func insert task into audio/gfx pending list
__scExec = 0x80000E20; // type:func launch next task to RSP/RDP
__scHandlePreNMI = 0x80000F88; // type:func handle pre-NMI for audio tasks
__scScheduleCore = 0x80000FE8; // type:func main scheduler algorithm

// VI timing functions (1050.s)
viTickStart = 0x80001350; // type:func snapshot counter, compute frame duration
viEnableAccum = 0x800013C0; // type:func enable time accumulation
viDisableAccum = 0x800013DC; // type:func disable time accumulation
viUpdateTime = 0x800013F4; // type:func update frame delta timing
viScheduleTick = 0x800014F0; // type:func schedule next tick deadline
viAddTicks = 0x8000153C; // type:func add ticks to deadline
viGetTimeToDeadline = 0x80001578; // type:func get float time until deadline
viDeadlinePassed = 0x800015BC; // type:func check if deadline passed
viStub = 0x800015DC; // type:func no-op stub

// Display mode functions (21F0.s) - newly identified
display_mode_tick = 0x80001D60; // type:func countdown and apply pending display mode
get_tv_offset = 0x80001DFC; // type:func return TV-type specific offset (0 for PAL=0, 0xE for NTSC, 0x1C for other)
apply_display_mode = 0x80001E58; // type:func apply current display mode settings

// Controller pak PFS functions (F700.s) - newly identified
osPfsReadWriteFile_pages = 0x8000F2D0; // type:func read/write controller pak file pages
osPfsFileState = 0x8000F3A4; // type:func get/verify controller pak file state

// Init/boot functions (2CF0.s) - identified via Codex analysis
idle_thread_entry = 0x800021A4; // type:func boot idle thread: inits PI manager, creates game thread, loops forever
audio_thread_entry = 0x800024FC; // type:func audio thread entry point (priority 5)

// OS thread structures (2CF0.s) - created by boot code
gIdleThread = 0x80034BA0; // type:data idle thread OSThread structure
gGameThread = 0x80034D50; // type:data game thread OSThread structure
gAudioThread = 0x80034690; // type:data audio thread OSThread structure
gSchedulerThread = 0x80034840; // type:data scheduler thread OSThread structure
gStackIdle = 0x8002F660; // type:data idle thread stack base
gStackGame = 0x80030150; // type:data game thread stack base
gStackAudio = 0x8002F7F0; // type:data audio thread stack base

// OS manager init functions (8E10.s)
osCreatePiManager = 0x80008210; // type:func create PI DMA manager thread and queues
osCreateViManager = 0x80008380; // type:func create VI manager thread (handles retrace/prenmi)
osInvalICache_full = 0x80008460; // type:func invalidate instruction cache (cache op 0x00)

// Event/interrupt functions (7A10.s)
osSetEventMesgAlt = 0x80006E10; // type:func alternative event message setter

// VI manager thread (7630.s)
vi_manager_main = 0x80006BB0; // type:func VI manager main loop (handles VI_RETRACE, PRENMI events)

// Inflate/decompression helpers (5610.s)
inflate_read_bits = 0x800066D4; // type:func read compressed bits from buffered DMA stream

// Float-to-string helpers (34A0.s - used by fcvt/ecvt)
__write_exponent = 0x80004878; // type:func write exponent string (e+XX or e-XX)
sprintf = 0x80004990; // type:func sprintf wrapper (calls fcvt)
inflate_io_wait = 0x80004A10; // type:func wait for DMA buffer ready
inflate_flush_window = 0x80004D50; // type:func flush output window to destination
inflate_free_window = 0x80005464; // type:func free huffman decode tables

// Cache operations (9230.s)
osWritebackDCache_full = 0x800086F0; // type:func writeback data cache region
osWritebackDCacheAll = 0x8000870C; // type:func writeback all data cache

// SI controller functions (9930.s)
__osContBuildPacket = 0x80009450; // type:func build controller pak read/write command
__osContGetStatus = 0x800095AC; // type:func get controller status
__osContRamReset = 0x80009658; // type:func reset controller pak RAM

// Timer internal functions (A9E0.s)
__osTimerInterrupt = 0x80009E18; // type:func timer interrupt handler

// Controller pak PFS helpers (AF30.s)
osPfsAllocate = 0x8000A350; // type:func allocate controller pak pages
osPfsDeleteFile = 0x8000A520; // type:func delete controller pak file
osPfsRename = 0x8000A700; // type:func rename controller pak file
osPfsFindFile = 0x8000A8D8; // type:func find file in controller pak

// More PFS functions (B9E0.s)
osPfsGetFileStat = 0x8000ADF0; // type:func get controller pak file status
osPfsGetFileSize = 0x8000AEC4; // type:func get controller pak file size

// PFS checksum/validation (C930.s)
osPfsChecker_full = 0x8000BD90; // type:func validate controller pak filesystem
osPfsReAllocate = 0x8000BE50; // type:func reallocate controller pak file pages

// Exception context save functions (D580.s)
// NOTE: dll_get_data and dll_set_data were misidentified - these are exception handler internal functions
// __osSendInterrupt = 0x8000CEDC already defined in Exception handler code labels section
__osCleanupThread = 0x8000CFC4; // type:func save thread context and check for dispatch (exception cleanup)

// String utility (DE20.s)
bzero_alt = 0x8000D2A0; // type:func alternative bzero (zeroes memory)

// libgcc 64-bit arithmetic (E4F0.s) - duplicate of __umoddi3
__umoddi3_alt = 0x8000D9C0; // type:func unsigned 64-bit modulo (duplicate)

// SP task functions (EB70.s)
osSpTaskLoad_full = 0x8000DF80; // type:func load RSP task microcode and data

// More timer functions (EF80.s)
__osInsertTimer = 0x8000E390; // type:func insert timer into sorted timer queue

// Compressed game code functions (decompressed at 0x80086A50)
// Maps to arcade game/game.c structure

// Main game loop - equivalent to arcade game()
game_loop = 0x800FD464; // type:func main per-frame game state machine (704 bytes)

// Game state handlers called from game_loop
game_mode_handler = 0x800C9AE0; // type:func - in_game_mode handling (arcade: game.c:620)
attract_or_transition = 0x800EDDC0; // type:func attract mode/state transition - attract mode/state transition
process_inputs = 0x800C997C; // type:func ProcessPDUs equivalent or state switch - ProcessPDUs equivalent or state switch


// Large game functions (from analysis 2025-12-07)
// Rendering system (maps to ZOID/visuals in arcade)
render_object = 0x80099BFC; // type:func (10236 bytes) - 3D model rendering, uses G_DL
object_render = 0x80087A08; // type:func (10048 bytes) - 3D object rendering with transforms
render_scene = 0x800A04C4; // type:func (2720 bytes) - scene setup, viewport modes, uses G_SETGEOMETRYMODE

// Gameplay functions (maps to game/game.c)
playgame_state_change = 0x800CA3B4; // type:func walks global mode flags, handles enter/exit gameplay (2544 bytes)
update_active_objects = 0x800F733C; // type:func per-frame scene object dispatcher (accesses 0x80159788 + 0x80159450 arrays)
PhysicsObjectList_Update = 0x800B0868; // type:func per-frame physics/vehicle list updater
effects_update_emitters = 0x800B811C; // type:func particle/trail/FX system updater
state_transition = 0x800FBF88; // type:func conditional state transition

// Audio system
sound_control = 0x800B37E8; // type:func audio/sound (called with -1 as stop signal)
sound_stop = 0x800B358C; // type:func stop sound (called when engine stops)
audio_start = 0x800A48C8; // type:func start audio subsystem (called from init.c)
sound_init = 0x800A4934; // type:func initialize sound system (called from init.c)

// High-frequency utility functions (called 100+ times)
slot_state_setup = 0x800B4200; // type:func player/slot state management (171 calls)
slot_state_init = 0x800B4208; // type:func player slot initialization
dispatch_handler = 0x800B74A0; // type:func event dispatch (152 calls)
state_utility = 0x800B71D4; // type:func state helper (125 calls)
object_utility = 0x800B3FA4; // type:func object management (107 calls)
object_helper = 0x800B3F50; // type:func object helper (77 calls)
math_utility = 0x8008D6B0; // type:func math/vector utility (67 calls) arcade:math.c
render_helper = 0x800B65B4; // type:func rendering helper (65 calls)
// model_utility = 0x8008AE8C; // DUPE: see model_data_load below
input_handler = 0x80094EC8; // type:func input processing (60 calls) - input processing (60 calls)

// Key global variables in game data section (renamed from D_80XXXXXX)
gMainGameStruct = 0x801461D0; // type:data most referenced global (160 refs) - main game state structure
gstate = 0x801174B4; // type:data game state bitmask (110 refs) - uses bit encoding for state machine
gPlayerCarState1 = 0x80152818; // type:data player/car state array 1 (89 refs)
gPlayerCarState2 = 0x80152770; // type:data player/car state array 2 (86 refs)
gRaceControlData = 0x80142728; // type:data race control/timing data (77 refs)
gTrackDataA = 0x8014A110; // type:data track data array A (74 refs) - paired with B
gTrackDataB = 0x8014A250; // type:data track data array B (74 refs) - paired with A
gFrameCounter = 0x80142AFC; // type:data frame counter (incremented each frame in game_loop)

// Arcade source mapping (from Codex analysis 2025-12-07)
// N64 address -> arcade equivalent (confidence level)
// Note: N64 game_init (0x80002238) does NOT map to arcade game_init (game.c:494-601)
// N64 game_init is a low-level OS bootstrap, arcade game_init is gameplay state setup

// ============================================================================
// ARCADE MENU/UI FUNCTION MAPPINGS (from analysis 2025-12-30)
// Reference: rushtherock/game/sselect.c, hiscore.c, attract.c
// ============================================================================

// --- TRACK SELECTION (arcade: sselect.c:TrackSel) ---
// N64 track_select_screen (0x800D000C) maps to arcade TrackSel() [sselect.c:123-1002]
// Arcade TrackSel: Sets gstate=TRKSEL, handles input (SW_EAST/WEST/SELECT/START),
//   updates trackno, calls ShowTrackSelect(true), runs track_negotiation() for link play.
// N64: Uses menu_system_update + state handlers, similar logic adapted for N64 controller.
track_select_handler = 0x800D000C; // type:func arcade:TrackSel() - track selection menu (2264 bytes)
track_preview_handler = 0x800D08E4; // type:func arcade:ShowTrackSelect - renders track thumbnail (692 bytes)
track_info_handler = 0x800D0BA0; // type:func arcade:track stats display (1192 bytes)

// --- CAR SELECTION (arcade: sselect.c:init_car_select, AnimateCarSel) ---
// N64 car_select_screen (0x800D138C) maps to arcade CarSel/init_car_select [sselect.c:1190-1284]
// Arcade init_car_select: gstate=CARSEL, SetCountdownTimer(CAR_SELECT_TIME),
//   ShowCarSelect(true), create_cars() for 3D car models on rotating platform.
// Arcade AnimateCarSel [sselect.c:1373-1504]: Animates car turntable, handles gPickPad selection.
car_select_handler = 0x800D138C; // type:func arcade:CarSel/init_car_select (804 bytes)
car_preview_handler = 0x800D16B0; // type:func arcade:AnimateCarSel - rotating 3D car model (564 bytes)
car_stats_handler = 0x800D18E4; // type:func arcade:car performance stats (152 bytes)
car_unlock_handler = 0x800D197C; // type:func arcade:car unlock check (316 bytes)
car_color_handler = 0x800D1AB8; // type:func arcade:car color selection (552 bytes)

// --- ATTRACT MODE (arcade: attract.c:attract) ---
// N64 attract_mode_start (0x800DC88C) maps to arcade attract() [attract.c:812-1187]
// Arcade attract: Main attract mode loop, cycles through ATR_* screens:
//   ATR_ATARILOGO, ATR_HISCORE1-7, ATR_DEMO, ATR_CREDITS, ATR_JOIN, etc.
// Uses attractFunc state variable, ShowAttract() to display/hide screens,
//   SetCountdownTimer() for screen timing, chk_start() for game start detection.
attract_mode_handler = 0x800DC88C; // type:func arcade:attract() - attract mode state machine (1272 bytes)
attract_demo_handler = 0x800DC99C; // type:func arcade:play_demogame - demo race playback (1016 bytes)
attract_idle_handler = 0x800DCD94; // type:func arcade:TimeOut check (96 bytes)
attract_video_handler = 0x800DCDF4; // type:func arcade:AttractMovie - video playback (732 bytes)
attract_sequence_handler = 0x800DD0D0; // type:func arcade:attract screen sequencing (988 bytes)

// --- TITLE SCREEN (arcade: attract.c:ShowLogo, ShowJoin) ---
// N64 title_screen (0x800DD4AC) maps to arcade ShowLogo/ShowJoin [attract.c:1193-1473]
// Arcade ShowJoin: Creates JoinBlit, shows "INSERT COIN" / "PRESS START".
// Arcade AnimateLogo: Animates game logo with roll/rotation.
title_screen_handler = 0x800DD4AC; // type:func arcade:ShowLogo/ShowJoin (2816 bytes)
title_logo_handler = 0x800DDFAC; // type:func arcade:AnimateLogo (608 bytes)
title_prompt_handler = 0x800DE20C; // type:func arcade:AddJoinNow - PRESS START prompt (724 bytes)
title_background_handler = 0x800DE4DC; // type:func arcade:title background effects (908 bytes)

// --- MAIN MENU (arcade: attract.c after start detected) ---
// N64 main_menu_screen (0x800DE868) handles main menu after title.
// Arcade transitions from attract to TRKSEL via chk_start() in attract().
main_menu_handler = 0x800DE868; // type:func main menu screen (836 bytes)
main_menu_input_handler = 0x800DEBAC; // type:func main menu input processing (224 bytes)
main_menu_render_handler = 0x800DEC8C; // type:func main menu rendering (732 bytes)
mode_select_handler = 0x800DEF68; // type:func race/battle/stunt mode select (2976 bytes)
mode_select_input_handler = 0x800DFB08; // type:func mode selection input (188 bytes)
profile_select_handler = 0x800DFBC4; // type:func profile selection (1868 bytes)

// --- HIGH SCORE (arcade: hiscore.c:hiscore, EnterHighScore) ---
// N64 hiscore_entry (0x800FBF88) maps to arcade hiscore/EnterHighScore [hiscore.c]
// Arcade hiscore(): gstate=HISCORE, displays high score entry screen.
// Arcade EnterHighScore(): Handles character input for name entry,
//   uses keyboard layout, saves score to NVRAM.
hiscore_entry_handler = 0x800FBF88; // type:func arcade:hiscore/EnterHighScore (state_transition)
hiscore_check_handler = 0x800DBFC0; // type:func arcade:CheckHighScore - check if score qualifies
hiscore_display_handler = 0x800DC000; // type:func arcade:ShowHighScores - display high score table
hiscore_insert_handler = 0x800DC100; // type:func arcade:InsertHighScore - insert new entry

// --- COUNTDOWN (arcade: game.c:CountDown) ---
// N64 countdown_start (0x800FBC30) maps to arcade CountDown() [game.c:1000+]
// Arcade CountDown: gstate=COUNTDOWN, displays 3-2-1-GO countdown,
//   plays countdown sounds, transitions to PLAYGAME when complete.
countdown_handler = 0x800FBC30; // type:func arcade:CountDown() - race countdown timer
countdown_display_handler = 0x800FBC60; // type:func countdown number display

// --- GAME OVER (arcade: game.c:gameover) ---
// N64 gameover handling in game_results_* functions.
// Arcade gameover(): gstate=GAMEOVER, shows race results, offers continue.
gameover_handler = 0x800FEE04; // type:func arcade:gameover() - game over screen

// --- OPTIONS MENU ---
// N64 menu_options (0x800D4000) handles game options.
// Arcade uses NVRAM options set in game_init [game.c:494-601].
options_menu_handler = 0x800D4000; // type:func game options menu

// --- PAUSE MENU (N64-specific, arcade has no pause) ---
// N64 pause_menu (0x800FAEF4) - in-race pause screen.
// No direct arcade equivalent (arcade games don't pause).
pause_menu_handler = 0x800FAEF4; // type:func N64-specific pause menu (1808 bytes)
pause_toggle_handler = 0x800FB5F4; // type:func pause state toggle (820 bytes)

// --- LOADING SCREEN ---
// N64 loading_screen (0x800FA9E4) shows loading progress.
// Arcade uses ShowTransit() [attract.c:1479+] for transitions.
loading_screen_handler = 0x800FA9E4; // type:func arcade:ShowTransit (1296 bytes)

// ============================================================================
// ARCADE GAME STATE EQUIVALENTS
// Reference: rushtherock/game/game.h GState enum
// ============================================================================

// Arcade GState enum values (game.h):
//   ATTRACT=0, TRKSEL=1, CARSEL=2, PLAYGAME=3, ENDGAME=4,
//   GAMEOVER=5, HISCORE=6, PREPLAY=7, PREPLAY2=8, COUNTDOWN=9

// N64 uses bitmask state machine at gstate (0x801174B4):
//   0x00040000 = GSTATE_INIT (setup phase)
//   0x00080000 = GSTATE_SETUP (loading phase)
//   0x00100000 = GSTATE_MENU (menu handling) - maps to arcade TRKSEL/CARSEL
//   0x00200000 = GSTATE_CAMERA (camera setup)
//   0x00400000 = GSTATE_READY (race ready) - maps to arcade PREPLAY
//   0x00800000 = GSTATE_PLAY (gameplay) - maps to arcade PLAYGAME
//   0x01000000 = GSTATE_CARS (car iteration)
//   0x02000000 = GSTATE_FINISH (race complete) - maps to arcade ENDGAME

// N64 init sequence -> arcade equivalents:
// 0x800020F0 (main) -> arcade start() (init.c) - Medium confidence
//   Both are reset/entry scaffolds that kick off later stages
// 0x800021A4 (idle_thread_entry) -> arcade start() early video slice - Low confidence
//   Minimal overlap beyond "set video then spawn next thread"
// 0x80002238 (game_init) -> arcade init() (init.c) - Low-Medium confidence
//   Both are deep system bring-up before gameplay, but different subsystems
// 0x800024FC (audio_thread_entry) -> arcade game_loop() - Low-Medium confidence
//   Both are perpetual main loop shells

// Message queue functions in game code (from Codex analysis)
// Note: Some duplicated below with better names
// audio_msg_send = 0x8008A6D0; // DUPE: see sync_release_video below
// audio_task_sync = 0x8008A710; // DUPE: see audio_task_start below
audio_queue_process = 0x8008A77C; // type:func audio queue processing (676 bytes)
// wait_for_msg = 0x8008AA40; // DUPE: see dma_wait_complete below
// task_complete_notify = 0x8008AC74; // DUPE: see task_complete_signal below
scheduler_recv = 0x80091C04; // type:func scheduler message receive
scheduler_jam = 0x80091CA4; // type:func scheduler message send
client_sync = 0x80091E5C; // type:func client synchronization (Jam+Recv)
retrace_sync = 0x80091F34; // type:func retrace synchronization (Jam+Recv)
frame_sync = 0x80092360; // type:func per-frame synchronization
buffer_swap = 0x800924F4; // type:func buffer swap with message
dma_queue_sync = 0x800960D4; // type:func DMA queue synchronization
dma_complete_wait = 0x8009614C; // type:func DMA completion wait
dma_request = 0x800962D4; // type:func DMA request with queue
audio_queue_recv = 0x80097184; // type:func audio queue receive only
audio_buffer_sync = 0x8009731C; // type:func audio buffer synchronization
audio_dma_sync = 0x80097470; // type:func audio DMA synchronization
audio_task_complete = 0x800974EC; // type:func audio task completion
audio_frame_sync = 0x80097798; // type:func audio per-frame sync
engine_sound_sync = 0x80098AE4; // type:func engine/sound synchronization

// Additional Codex analysis findings (2025-12-07)
// Game state machine analysis - uses BITMASK LADDER not jump table
// Note: game_loop defined above at line 322
state_dispatch = 0x800FD238; // type:func state machine bitmask ladder
gstate_requested = 0x801174B8; // type:data requested game state (bitfield)
// State bit mappings in state_dispatch:
//   0x0002 -> handler at 0x8039A2A0 (proposed ATTRACT)
//   0x8000 -> handler at 0x8038A400 (likely service/diag)
//   0x0200 -> handler at 0x800DB1E0
//   0x0400 -> handler at 0x800D91A0
//   0x0800 -> handler at 0x800D7634
//   0x1000 -> handler at 0x800B8C14

// Data structure layouts from Codex analysis
// game_car[] array: stride 0x3B8 (952 bytes per entry)
//   +0x000: handle/pointer
//   +0x008, +0x00C: floats (position/velocity)
//   +0x04C, +0x050, +0x054: vector (3 floats)
//   +0x0EF, +0x359, +0x7E8: flag bytes
// track_data: stride 0x808 (2056 bytes), 6 entries
//   +0x710, +0x714, +0x718: floats for timing
//   +0x71C, +0x720: flags

// Rendering functions (RDP command emitters)
// object_render = 0x80087A08 - defined above at line 470
render_sync_pipeline = 0x8008A474; // type:func sync/pipeline setup (464 bytes)
render_display_list = 0x80099BFC; // type:func large display list builder (10236 bytes)
viewport_perspective = 0x8009F064; // type:func calls guPerspective (5216 bytes)
render_mode_setup = 0x80087118; // type:func RDP render mode setup (1772 bytes)
vi_config_offset = 0x80094C30; // type:func writes VI offsets 0x18/0x1A
vi_retrace_callback = 0x800DE4DC; // type:func retrace video timing config

// Controller input handling (from controls.c analysis)
controller_poll = 0x800C95DC; // type:func per-frame pad poll/state clear (928 bytes)
process_inputs = 0x800C997C; // type:func ProcessPDUs equivalent or state switch - game loop input entry point (356 bytes)
// Input buffer at 0x80140BF0, stride 0x20 per player
//   +0x00, +0x08: button states
//   +0x0A-0x12: 16-bit axes (steering, throttle, brake)
//   +0x18-0x1E: additional analog values
//   +0x1A: "new data" flag
input_analog_write = 0x80094E00; // type:func write primary analog values - write primary analog values
input_status_update = 0x80094DB0; // type:func update status bytes/edge tracking - update status bytes/edge tracking
input_button_adjust = 0x80094D68; // type:func adjust button bits - adjust button bits
input_connected_check = 0x80094D20; // type:func handle pad connection/reset - handle pad connection/reset
input_new_data_wrapper = 0x80094F88; // type:func toggle new data flag - toggle new data flag
input_dispatch = 0x80094FF0; // type:func dispatch from raw pad to input buffer - dispatch from raw pad to input buffer

// Controller Pak functions (BFE0.s analysis)
// Already defined above: osPfsChecker, __osPfsCheckPages, __osPfsPageCheck

// Data structure findings from Codex analysis (2025-12-07)
// game_car[] array: base 0x80152818, stride 0x3B8 (952 bytes)
//   +0x000: handle/pointer
//   +0x008, +0x00C: floats (position/velocity components)
//   +0x04C, +0x050, +0x054: vector3 (3 floats)
//   +0x0EF: flag byte
//   +0x359: flag byte
//   +0x7E8: flag byte
game_car = 0x80152818; // type:data car state array (6 entries, 952 bytes each)

// track_data: base 0x8014A250, stride 0x808 (2056 bytes), 6 entries
//   +0x710, +0x714, +0x718: floats for timing
//   +0x71C, +0x720: flags
track_data = 0x8014A250; // type:data track/race data (6 entries, 2056 bytes each)

// player_slots: base 0x80144030, stride 0x304 (772 bytes)
player_slots = 0x80144030; // type:data player state slots

// input_buffer: base 0x80140BF0, stride 0x20 (32 bytes) per player
//   +0x00, +0x08: button states (current, previous)
//   +0x0A-0x12: 16-bit axes (steering, throttle, brake)
//   +0x18-0x1E: additional analog values
//   +0x1A: "new data" flag
input_buffer = 0x80140BF0; // type:data per-player input state (4 players, 32 bytes each)
sound_state_array = 0x80140BF0; // type:data N64 sound state array (overlaps input_buffer, 0x20 bytes per entry)

// gstate bitmask state machine (from Codex analysis 2025-12-07)
gstate = 0x801174B4; // type:data game state bitmask (110 refs, only playgame_state_change writes)
gstate_prev = 0x801174B8; // type:data previous game state (for transition detection)
gstate_init_flag = 0x801146EC; // type:data byte init flag (set once on first game_loop call)
frame_counter = 0x80142AFC; // type:data frame counter (cleared on init)
race_active = 0x801170FC; // type:data non-zero enables race loop path

// Game state machine handlers (mask 0x03FC0000 in gstate)
// State Value -> Handler
//   0x00040000 -> 0x800FBF90 (GSTATE_INIT: calls 0x800C9BE0, 0x800FAF6C)
//   0x00080000 -> 0x800FBFE4 (GSTATE_SETUP: calls 0x800FB2C8)
//   0x00100000 -> 0x800FC0EC (GSTATE_MENU: UI/input chain)
//   0x00200000 -> 0x800FC038 (GSTATE_CAMERA: camera/race setup)
//   0x00400000 -> 0x800FC228 (GSTATE_READY: copies float to 0x8014401C)
//   0x00800000 -> 0x800FC25C (GSTATE_PLAY: gameplay/menu handling)
//   0x01000000 -> 0x800FC89C (GSTATE_CARS: iterates car list)
//   0x02000000 -> 0x800FC960 (GSTATE_FINISH: calls 0x800F64D4 or 0x800F8B70)

// State handler functions
state_init_handler = 0x800FBF90; // type:func GSTATE_INIT (0x00040000)
state_setup_handler = 0x800FBFE4; // type:func GSTATE_SETUP (0x00080000)
state_menu_handler = 0x800FC0EC; // type:func GSTATE_MENU handler (0x00100000) - GSTATE_MENU (0x00100000)
state_camera_handler = 0x800FC038; // type:func GSTATE_CAMERA (0x00200000)
state_ready_handler = 0x800FC228; // type:func GSTATE_READY (0x00400000)
state_play_handler = 0x800FC25C; // type:func GSTATE_PLAY (0x00800000)
state_cars_handler = 0x800FC89C; // type:func GSTATE_CARS (0x01000000)
state_finish_handler = 0x800FC960; // type:func GSTATE_FINISH (0x02000000)

// Functions called from game_loop
// game_mode_same = 0x800C9AE0; // DUPLICATE - use game_mode_handler // type:func called when state == prev_state
game_mode_changed = 0x800EDDC0; // type:func called on state transition
input_aux_handler = 0x800FD238; // type:func fast-path for bits 0x7C03FFFE - fast-path for bits 0x7C03FFFE
game_mode_post = 0x800FBC30; // type:func post-processing after state match
camera_race_setup = 0x800F8D9C; // type:func camera setup for race
race_init_helper = 0x800EC0DC; // type:func race initialization
race_setup_1 = 0x800BD2C8; // type:func race setup part 1
race_setup_2 = 0x800BEAA0; // type:func race setup part 2
init_state_begin = 0x800C9BE0; // type:func called from GSTATE_INIT
init_state_continue = 0x800FAF6C; // type:func called after init_state_begin
setup_state_main = 0x800FB2C8; // type:func called from GSTATE_SETUP
finish_state_normal = 0x800F64D4; // type:func normal finish handler
finish_state_alt = 0x800F8B70; // type:func alternate finish handler

// Input processing functions (from Codex analysis 2025-12-07)
// Input buffer at 0x80140BF0, stride 0x20 (32 bytes) per controller slot
Input_PollPads = 0x800E73E4; // type:func calls osContGetReadData, reads raw buttons/stick, processes into pad table
Input_ProcessGameplayPad = 0x800A04C4; // type:func per-frame gameplay/menu input (2720 bytes), reads button masks at 0x0E/0x10/0x14
Input_AllocPadSlot = 0x800A7A10; // type:func scans pad buffer for free slot, initializes offsets 0x08-0x1E
Input_SetPadEnabledFlag = 0x80094D20; // type:func set/clear bit 0x80 enable flag at byte 0x15
Input_SetPadSecondaryFlag = 0x80094D68; // type:func set/clear bit 0x04 (rumble/lock) at byte 0x15
Input_ConfigRepeatTimers = 0x80094DB0; // type:func writes repeat/debounce params to pad entry offsets 0x0E/0x14/0x16
Input_SetAnalogBounds = 0x80094E00; // type:func sets analog/deadzone bounds at offsets 0x18-0x1E
Input_InitPadHandlers = 0x80094E8C; // type:func initializes pad entry with handler pointers and timing
Input_ApplyPadConfig = 0x80094EC8; // type:func copies controller config struct into pad buffer slot
Input_RegisterActivePad = 0x800B3590; // type:func marks pad slot active (byte 0x16 = 2), inserts into active controller lists

// Car physics functions (from Codex analysis 2025-12-07)
// game_car[] array: base 0x80152818, stride 0x3B8 (952 bytes)
// Fields: pos_x/y/z at 0x4C/0x50/0x54, vel_x/y at 0x08/0x0C, flags at 0x0EF/0x359
// Motion integration helpers (arcade: drivsym.c velocities/positions)
// Note: Better names provided in later batch - these are duplicates
// physics_velocities_A = 0x8008B69C; // DUPE: see physics_velocity_integrate_a
// physics_velocities_B = 0x8008B964; // DUPE: see physics_velocity_integrate_b
// physics_velocities_C = 0x8008BA84; // DUPE: see physics_velocity_integrate_c
// physics_velocities_D = 0x8008BB8C; // DUPE: see physics_velocity_integrate_d
// physics_velocities_E = 0x8008BC94; // DUPE: see physics_velocity_integrate_e
// physics_velocities_F = 0x8008BD9C; // DUPE: see physics_velocity_integrate_f
// physics_velocities_G = 0x8008C884; // DUPE: see entity_render_setup
// physics_velocities_H = 0x8008D120; // DUPE: see entity_process_main
// physics_velocities_I = 0x8008D93C; // DUPE: see anim_state_update
// physics_accelerations_A = 0x8008E398; // DUPE: see sign_extend_call
// physics_velocities_J = 0x8008EA10; // DUPE: see entity_spawn_init
physics_velocities_K = 0x80090310; // type:func integrate accel to velocity
physics_velocities_L = 0x800908A0; // type:func integrate accel to velocity
physics_forces_handler_A = 0x80090B70; // type:func force accumulation (812 bytes)
physics_forces_handler_B = 0x80090FEC; // type:func force accumulation with flags
physics_velocities_M = 0x80091874; // type:func integrate accel to velocity
physics_velocities_N = 0x800924F4; // type:func integrate accel to velocity
physics_velocities_O = 0x800930A4; // type:func integrate accel to velocity
physics_forces_handler_C = 0x80093B20; // type:func force accumulation with flags
physics_velocities_P = 0x800A2680; // type:func integrate accel to velocity

// ============================================
// Game State Machine (from Codex deep analysis 2025-12-07)
// ============================================
// Main globals for game state:
//   0x801146EC - byte init flag (set once, clears frame counter)
//   0x801174B4 - gstate (current bitmask state)
//   0x801174B8 - gstate_prev (previous/requested state copy)
//   0x801170FC - race_active flag (non-zero enables race loop path)
//   0x80142AFC - frame counter (incremented each frame)
//   0x80111958 - timer global
//   0x801146E8 - heap handle pointer

// game_loop (0x800FD464) internal helpers:
state_change_preprocess = 0x800CA300; // type:func called when gstate != gstate_prev
// sound_control at 0x800B37E8 - also called as heap_object_create (timer check creates/uses heap object)
// sound_stop at 0x800B358C - also called as heap_object_use (if heap object already exists)
// Note: state_dispatch defined above at line 410

// Race loop functions (called when bits 0x00200000 or 0x00400000 set AND race_active):
race_per_frame_update = 0x800F733C; // type:func called in race loop
car_physics_update = 0x800B0868; // type:func car physics update - called in race loop
visual_effects_update = 0x800B811C; // type:func called in race loop

// State machine dispatcher (mask 0x03FC0000 -> handler):
//   0x00040000 -> 0x800FBF90 (calls 0x800C9BE0, 0x800FAF6C, stores 0x00080000 to gstate_prev)
//   0x00080000 -> 0x800FBFE4 (calls 0x800FB2C8, may set 0x00200000 via 0x800B6138)
//   0x00100000 -> 0x800FC0EC (UI/input chain at 0x800FC100)
//   0x00200000 -> 0x800FC038 (camera/race setup: 0x800F8D9C, 0x800EC0DC, 0x800BD2C8, 0x800BEAA0)
//   0x00400000 -> 0x800FC228 (sets state to 0x00400000, copies float to 0x8014401C)
//   0x00800000 -> 0x800FC25C (gameplay/menu handling, ends at 0x800FC88C)
//   0x01000000 -> 0x800FC89C (iterates car list, stores 0x02000000 at 0x800FC950)
//   0x02000000 -> 0x800FC960 (calls 0x800F64D4 or 0x800F8B70)

// Note: state_init_handler defined above at line 501
track_car_selection_setup = 0x800FBFE4; // type:func State_0x80000_Handler - track/car selection setup
ui_input_handler_block = 0x800FC0EC; // type:func State_0x100000_Handler - UI/input handling block
// Note: state_camera_handler and state_ready_handler defined above at lines 504-505
gameplay_menu_handler = 0x800FC25C; // type:func State_0x800000_Handler - gameplay/menu block
// Note: state_cars_handler and state_finish_handler defined above at lines 507-508

// State handler helper functions:
// Note: init_state_begin defined at line 519
// Note: init_state_continue defined at line 520
// Note: setup_state_main defined at line 521
set_race_state = 0x800B6138; // type:func may set 0x00200000 state
// Note: camera_race_setup defined at line 515
// Note: race_init_helper defined at line 516
// Note: race_setup_1 defined at line 517
// Note: race_setup_2 defined at line 518
// Note: finish_state_normal defined at line 522
// Note: finish_state_alt defined at line 523

// Steady-state helpers (called when gstate == gstate_prev):
steady_state_handler = 0x800FBC30; // type:func called when state unchanged

// ============================================
// Large Game Functions (from Codex analysis 2025-12-07)
// ============================================
// Note: 86 functions access gstate (0x801174B4), only playgame_state_change writes to it

// PlayGame_HandleStateChange = 0x800CA3B4; // DUPLICATE - use playgame_state_change // type:func size:2544 - main gameplay state controller, ONLY writer to gstate
UpdateActiveObjects = 0x800F733C; // type:func - loads object count at 0x80159788, iterates array at 0x80159450
PhysicsObjectList_Update = 0x800B0868; // type:func - walks linked list at 0x801491F0, physics update
Effects_UpdateEmitters = 0x800B811C; // type:func - loops over 152-byte effect slots at 0x80150B70
RaceStateMachine_Update = 0x800DB81C; // type:func size:2148 - jump-table state machine on 0x801170FC (cases 0-8)

// Object/Effect data globals (also used by sound system as active_sound_count/active_sound_list):
active_sound_count = 0x80159788; // type:data active object/sound count
active_sound_list = 0x80159450; // type:data active objects/sounds array
gPhysicsObjectListHead = 0x801491F0; // type:data physics object linked list head
gEffectEmittersArray = 0x80150B70; // type:data effect emitters array (152-byte stride)

// ============================================
// Arcade game.c Function Mapping (from Codex analysis 2025-12-07)
// ============================================

// Game code functions (from Ollama analysis - game code at 0x80086A50+)
game_loop = 0x800FD464; // type:func main game state machine (arcade: game/game.c:game)
// game_update = 0x800CA3B4; // DUPLICATE - use playgame_state_change // type:func per-frame gameplay update (arcade: game/game.c:playgame)
attract_mode = 0x800DB81C; // type:func demo/title screen handler (arcade: game/game.c:attract)
countdown = 0x800FBF88; // type:func race countdown handler
preplay_setup = 0x800FBC30; // type:func pre-race setup
render_object = 0x80099BFC; // type:func 3D object rendering (10KB)
// input_handler = 0x800C9AE0; // DUPLICATE - use game_mode_handler // type:func controller/init handler
// Note: collision_check at 0x800B8C14 duplicates physics_sym - now using physics_sym
physics_forces = 0x800BAE24; // type:func force calculation (arcade: forces in drivsym.c:382)
camera_transform = 0x80097CA0; // type:func camera/view transformation
// audio_processing at 0x800974EC - renamed to audio_task_complete above
// vehicle_physics at 0x80097798 - renamed to audio_frame_sync above (dual purpose)

// Cleaned symbols appended from ollama_analysis/cleaned_symbols.txt
// Note: Duplicate entries consolidated - keeping better names from later batches
// load_texture_data = 0x8008A650; // DUPE: see texture_load_start below
audio_call_wrapper = 0x8008A750; // type:func forwards to downstream audio routine
// audio_process = 0x8008AA20; // DUPE: see controller_rumble_thunk below
// audio_chain_dispatch = 0x8008AD48; // DUPE: see pointer_offset_wrapper below
// physics_floats_helper = 0x8008B474; // DUPE: see vector_copy_scale below
// fmath_helper = 0x8008E440; // DUPE: see render_state_process below
physics_forces1 = 0x80095240; // type:func tire/drag forces (arcade: forces1 in drivsym.c:391)
sfx_play = 0x80095360; // type:func play sound effect
poll_input = 0x80095380; // type:func controller/button polling - controller/button polling
draw_sprites = 0x800953A0; // type:func sprite rendering
physics_forces2 = 0x800953C0; // type:func sum all forces (arcade: forces2 in drivsym.c:494)
gfx_setup_e700 = 0x800954A8; // type:func display list setup (E700 clear)
drone_move_update = 0x800954E0; // type:func drone movement/position update (arcade: maxpath.c AI)
hud_update = 0x80095600; // type:func HUD element refresh
anim_frame_update = 0x80095720; // type:func animation frame stepping
physics_torques = 0x80095840; // type:func calculate moments (arcade: torques in drivsym.c:530)
bgm_playback = 0x80095960; // type:func background music handling
ui_render = 0x80095A80; // type:func UI rendering
jump_handler = 0x80095BA0; // type:func jump mechanic logic
npc_interaction = 0x80095CC0; // type:func NPC interaction handler
particles_animate = 0x80095DE0; // type:func particle effect animation
voice_playback = 0x80095F00; // type:func voice line playback
// Note: mp_interval_pos at 0x800979A8 defined below
// Note: MP_TargetSteerPos at 0x80097AFC defined below
camera_update_a = 0x80098574; // type:func nested camera update helper
camera_update_b = 0x80098620; // type:func nested camera update helper
world_collision = 0x80098FC0; // type:func world/environment collision detection
track_render = 0x800992AC; // type:func track generation/rendering
camera_update_c = 0x8009C5BC; // type:func camera update helper
camera_update_d = 0x8009C5E0; // type:func camera update helper
particle_system = 0x8009C8F0; // type:func particle system/effects
track_collision = 0x8009DC50; // type:func track/road surface collision
track_collision_edge = 0x8009DD18; // type:func track edge collision helper
track_collision_wall = 0x8009DD88; // type:func track wall collision helper
track_collision_curb = 0x8009EA70; // type:func track curb/bump collision
gfx_setup_fc = 0x8009EB18; // type:func display list setup (E7/FC)
physics_float_calc = 0x8009EBC0; // type:func float-heavy physics calculation
audio_init_stub = 0x8009FDC4; // type:func audio init stub (LUI)
drone_path_branch = 0x800A0BAC; // type:func drone path branching decision (arcade: maxpath.c branch logic)
gfx_lui_setup = 0x800A12D4; // type:func graphics register setup
physics_step_forces = 0x800A153C; // type:func physics force accumulation step
gfx_store_word = 0x800A1660; // type:func graphics store helper
audio_branch_handler = 0x800A17F4; // type:func audio conditional handler
drone_path_select = 0x800A19E4; // type:func drone path selection logic (arcade: maxpath.c)
gfx_lui = 0x800A1D38; // type:func graphics register load
physics_contact_test = 0x800A214C; // type:func physics contact conditional test
gfx_store = 0x800A2564; // type:func graphics store helper
audio_branch_handler_b = 0x800A27AC; // type:func audio conditional handler
physics_force_limit = 0x800A29A8; // type:func physics force limit conditional
drone_speed_adjust = 0x800A2B30; // type:func adjust drone speed based on target (arcade: maxpath.c:AdjustSpeed)
gfx_store_b = 0x800A2D1C; // type:func graphics store helper
audio_branch_handler_c = 0x800A2E64; // type:func audio conditional handler
gfx_lui_b = 0x800A30AC; // type:func graphics register load
track_logic = 0x800C8A00; // type:func track handling logic
physics_update_all = 0x800F4604; // type:func large physics update routine
graphics_chunk = 0x800F497C; // type:func graphics routine
graphics_chunk_b = 0x800F4B8C; // type:func graphics routine
audio_update_a = 0x800F4D94; // type:func audio update routine
assign_drones = 0x800F4FEC; // type:func assign drone tasks and speed adjustment (arcade: drones.c:assign_drones)
place_cars_in_order = 0x800F54C0; // type:func sort cars by race position (arcade: drones.c:place_cars_in_order)
graphics_chunk_c = 0x800F7344; // type:func graphics routine
audio_update_b = 0x800F73FC; // type:func audio update routine
physics_post_update = 0x800F7454; // type:func physics post-update routine
linear_interp = 0x800F7C28; // type:func linear interpolation for drone speeds (arcade: drones.c:linear_interp)
audio_update_c = 0x800F7E70; // type:func audio update routine
graphics_chunk_d = 0x800F7F44; // type:func graphics routine
update_mpath_index = 0x800F8588; // type:func update maxpath index for car (arcade: maxpath.c:update_mpath_index)
audio_update_d = 0x800F8754; // type:func audio update routine
find_maxpath_intervals = 0x800F87AC; // type:func find closest maxpath intervals (arcade: maxpath.c:find_maxpath_intervals)
save_context_stub = 0x8010FBF4; // type:func stack frame setup helper
call_memcpy = 0x8010FC1C; // type:func helper calling memcpy with size 64
call_osjammsg = 0x8010FC2C; // type:func helper calling osJamMesg with size 1
clear_region = 0x8010FC34; // type:func zeroes region at 0x8003E928

// === Additional 0x80100000+ Functions (from game.c analysis 2025-12-30) ===
callback_init = 0x80100D30; // type:func initialize object callback (44 bytes) - stores callback_ptr, calls texture_load
struct_callback_init = 0x8010B528; // type:func initialize structure with callback (56 bytes) - sets texture_callback_array
state_update_global = 0x8010B560; // type:func update state based on global flag (112 bytes) - checks race_sub_state, updates byte26
sync_acquire_menu = 0x8010FBB4; // type:func acquire menu sync lock (44 bytes) - calls state_get with menu_sync_object
resource_alloc_init = 0x8010FC80; // type:func allocate and initialize resource (64 bytes) - calls resource_lookup_synced then model_set_matrix
synced_model_render = 0x8010FCC0; // type:func render model with sync (92 bytes) - acquires model_sync, calls model_render
struct_init_and_call = 0x8010FD1C; // type:func initialize struct and call sound_start_3d (68 bytes) - sound_3d_struct setup

// === Timer and Scoring Functions (0x80100000+ from game.c comments) ===
timer_reset = 0x80100DF0; // type:func timer reset (244 bytes) - resets race timer to 0
countdown_start = 0x80100EE4; // type:func countdown timer start (776 bytes) - starts 3-2-1 countdown
lap_timer_split = 0x801011DC; // type:func lap timer split (1340 bytes) - records lap completion time
best_time_check = 0x80101700; // type:func best time check (588 bytes) - checks if time beats leaderboard
best_time_record = 0x8010194C; // type:func record new best (812 bytes) - saves new best time to leaderboard
leaderboard_display = 0x80101C78; // type:func leaderboard display (1472 bytes) - shows top 5 times

// === Race Results and End Game UI (0x80102000+) ===
race_results_screen = 0x80102250; // type:func race results screen (2084 bytes) - displays finish times and positions
award_ceremony = 0x80102A74; // type:func award ceremony (1524 bytes) - displays race results and trophies
trophy_animation = 0x8010306C; // type:func trophy animation (876 bytes) - renders animated trophy for winner
continue_prompt = 0x801033D8; // type:func continue prompt (1616 bytes) - ask player to continue or quit
game_over_screen = 0x80103A08; // type:func game over screen (2328 bytes) - displays final stats and options
name_entry_screen = 0x80104320; // type:func name entry screen (1844 bytes) - enter initials for high score
highscore_entry_anim = 0x80104A58; // type:func high score entry animation (1036 bytes) - animates new high score effect
statistics_display = 0x80104E84; // type:func statistics display (2464 bytes) - shows player game statistics
achievements_check = 0x80105858; // type:func achievements check (1692 bytes) - checks and unlocks achievements
achievement_unlock = 0x80105EF4; // type:func achievement unlock (876 bytes) - shows unlock notification popup
achievement_display = 0x80106260; // type:func achievement display (1484 bytes) - renders achievement popup on screen
profile_stats_update = 0x801068F4; // type:func profile stats update (2144 bytes) - updates player profile with race results

// === AI/Difficulty Functions (0x80107000+) ===
difficulty_scaling = 0x80107110; // type:func difficulty scaling (1248 bytes) - scales game difficulty
ai_difficulty_adjust = 0x80107600; // type:func AI difficulty adjust (924 bytes) - adjusts AI based on player skill
rubber_banding = 0x801079AC; // type:func rubber banding (1768 bytes) - adjusts AI speed based on player position
dynamic_difficulty = 0x80108098; // type:func dynamic difficulty (2356 bytes) - adjusts difficulty during race
catchup_logic = 0x801089CC; // type:func catch-up logic (1432 bytes) - implements catch-up mechanics
skill_rating_update = 0x80108F6C; // type:func skill rating update (876 bytes) - updates player skill rating
matchmaking = 0x801092D8; // type:func matchmaking (1984 bytes) - player skill-based matchmaking

// === Multiplayer/Network Functions (0x80109000+) ===
session_host = 0x80109A98; // type:func session host (1124 bytes) - initializes multiplayer session as host
session_join = 0x80109EFC; // type:func session join (1476 bytes) - joins existing multiplayer session
session_leave = 0x8010A4C0; // type:func session leave (892 bytes) - removes player from session
network_sync_full = 0x8010A83C; // type:func network sync full (2648 bytes) - synchronizes game state between players
ping_measurement = 0x8010B284; // type:func ping measurement (676 bytes) - measures input lag/response time
disconnect_handler = 0x8010B874; // type:func disconnection handling (1548 bytes) - handles player disconnect
reconnect_attempt = 0x8010BE7C; // type:func reconnection attempt (1152 bytes) - attempts to reconnect player

// === Overnight1 batch (350 functions from game code) ===
render_init_setup = 0x80087068; // type:func render initialization setup
// render_mode_setup = 0x80087118 - defined above
render_flush_buffer = 0x800878EC; // type:func render buffer flush operation
audio_sync_wait = 0x8008A398; // type:func audio synchronization wait (76 bytes)
// render_sync_pipeline = 0x8008A474 - defined above
texture_load_start = 0x8008A650; // type:func texture loading start
sync_release_video = 0x8008A6D0; // type:func simple sync release wrapper (44 bytes)
audio_task_start = 0x8008A710; // type:func audio task start handler
// audio_queue_process = 0x8008A77C - defined above
controller_rumble_thunk = 0x8008AA20; // type:func thunk to controller_rumble (32 bytes)
dma_wait_complete = 0x8008AA40; // type:func wait for DMA completion
message_send_async = 0x8008ABF4; // type:func asynchronous message send
task_complete_signal = 0x8008AC74; // type:func task completion signal
pointer_offset_wrapper = 0x8008AD48; // type:func adds offset 4 and calls sound_position_set (36 bytes)
model_data_load = 0x8008AE8C; // type:func model/mesh data loading
model_transform_setup = 0x8008B0D8; // type:func model transform matrix setup
model_bounds_calc = 0x8008B26C; // type:func model bounding box calculation
vector_copy_scale = 0x8008B474; // type:func vector copy with scale (80 bytes) arcade:vecmath.c:scalmul()
vector_normalize_length = 0x8008B4C4; // type:func vector normalize and get length arcade:fmath.c:SlowNormalVector()
vector3d_store_transform = 0x8008B660; // type:func vector transform and store arcade:unitvecs.c:bodtorw()
physics_velocity_integrate_a = 0x8008B69C; // type:func physics velocity integration
physics_velocity_integrate_b = 0x8008B964; // type:func physics velocity integration variant
physics_velocity_integrate_c = 0x8008BA84; // type:func physics velocity integration variant
physics_velocity_integrate_d = 0x8008BB8C; // type:func physics velocity integration variant
physics_velocity_integrate_e = 0x8008BC94; // type:func physics velocity integration variant
physics_velocity_integrate_f = 0x8008BD9C; // type:func physics velocity integration variant
audio_channel_update = 0x8008C688; // type:func audio channel state update
audio_buffer_process = 0x8008C724; // type:func audio buffer processing (68 bytes)
audio_param_apply = 0x8008C76C; // type:func apply audio parameters
entity_render_setup = 0x8008C884; // type:func entity rendering setup (736 bytes)
entity_process_main = 0x8008D120; // type:func major entity processing (1524 bytes)
matrix_rotation_build = 0x8008D714; // type:func build rotation matrix arcade:fmath.c:CreateRYPMatrix()
euler_to_matrix = 0x8008D764; // type:func euler angle to rotation matrix (372 bytes) arcade:fmath.c:CreatePYRMatrix()
matrix_scale_apply = 0x8008D8D8; // type:func apply scale to matrix arcade:fmath.c:ScaleUV()
anim_state_update = 0x8008D93C; // type:func entity animation state update (796 bytes)
render_flag_check = 0x8008E0C8; // type:func check render flags
render_mode_select = 0x8008E19C; // type:func select render mode
render_state_init = 0x8008E280; // type:func initialize render state
sign_extend_call = 0x8008E398; // type:func sign extend and call (40 bytes)
render_state_process = 0x8008E440; // type:func major render state processing (1472 bytes)
entity_spawn_init = 0x8008EA10; // type:func entity spawn and initialization (1656 bytes)
entity_spawn_callback = 0x80090088; // type:func entity spawn callback handler
sound_call_simple = 0x80090228; // type:func sign-extends param, calls gfx_flush (44 bytes)
sound_call_minimal = 0x80090254; // type:func sign-extends param, calls gfx_flush (48 bytes)
entity_callback_register = 0x80090310; // type:func entity with callback registration (1036 bytes)
entity_transform_apply = 0x8009079C; // type:func apply entity transformation matrix
entity_physics_update = 0x800908A0; // type:func entity movement/physics update (716 bytes)
entity_collision_detect = 0x80090B70; // type:func entity collision detection (820 bytes)
entity_frame_advance = 0x80090EA4; // type:func entity frame advance processing
entity_callback_invoke = 0x80090F4C; // type:func invoke entity callback function
entity_update_callback = 0x80090FEC; // type:func entity update callback (2184 bytes)
entity_anim_texture = 0x80091874; // type:func entity animation with texture loading (616 bytes)
entity_timer_update = 0x80091C04; // type:func update entity timers
entity_transform_calc = 0x80091CA4; // type:func calculate entity transforms
entity_scale_sync = 0x80091E5C; // type:func entity scale/transform with sync (560 bytes)
entity_hierarchy_update = 0x80091F34; // type:func update entity parent-child hierarchy
entity_state_init = 0x8009229C; // type:func entity state initialization (600 bytes)
entity_flags_apply = 0x80092360; // type:func apply entity flag settings
entity_spawn_full = 0x800924F4; // type:func entity spawn with full initialization (1636 bytes)
entity_name_copy = 0x80092C58; // type:func copy entity name string
string_copy_format = 0x80092E2C; // type:func string/name copy with formatting (720 bytes)
entity_tick_main = 0x800930A4; // type:func major entity processing loop (2684 bytes)
drone_ai_update = 0x80093B20; // type:func entity AI/behavior update for drones (3440 bytes)
audio_channel_setup = 0x80094890; // type:func audio parameter setup (460 bytes)
audio_channel_priority = 0x80094A54; // type:func set audio channel priority
audio_volume_pan = 0x80094C30; // type:func audio volume and pan control (668 bytes)
audio_param_update = 0x80094EC8; // type:func audio parameter update helper
object_byte26_set = 0x80094F88; // type:func sets byte at object offset 26
audio_channel_reset = 0x80094FF0; // type:func audio channel stop and reset (156 bytes)
pointer_compare_thunk = 0x8009508C; // type:func thunk calling sound_position_set (32 bytes)
validate_and_call = 0x80095120; // type:func validates pointers, calls triangle_draw (52 bytes)
sound_volume_helper = 0x8009515C; // type:func sound volume calculation helper (60 bytes)
sound_position_update = 0x800951E0; // type:func 3D sound position update (492 bytes)
audio_fade_control = 0x800953CC; // type:func audio fade control over time (220 bytes)
sound_channel_enable = 0x800954A8; // type:func sound enable/disable channel (128 bytes)
music_track_control = 0x80095528; // type:func music track playback control (484 bytes)
audio_bus_route = 0x8009570C; // type:func audio bus routing (244 bytes)
audio_effect_setup = 0x80095800; // type:func reverb/effect setup (292 bytes)
audio_timing_sync = 0x80095924; // type:func audio timing sync with video (184 bytes)
audio_pitch_adjust = 0x800959DC; // type:func audio pitch adjustment (72 bytes)
sound_priority_set = 0x80095A24; // type:func sound priority management (236 bytes)
audio_stream_control = 0x80095B10; // type:func audio streaming control (236 bytes)
audio_buffer_manage = 0x80095BFC; // type:func audio DMA buffer management (268 bytes)
audio_state_save = 0x80095D04; // type:func audio state save/restore (468 bytes)
audio_reverb_update = 0x80095FD8; // type:func reverb state update
audio_effect_process = 0x800960D4; // type:func audio effect processing
entity_sound_attach = 0x8009614C; // type:func entity sound attachment with sync (216 bytes)
sound_3d_update = 0x80096240; // type:func 3D sound position/volume update
slot_value_get = 0x80096298; // type:func get value from slot array
audio_loop_control = 0x800962D4; // type:func audio loop point control
display_list_alloc = 0x8009638C; // type:func display list memory allocation
display_list_traverse = 0x800963E8; // type:func display list traversal (452 bytes)
entity_render_mode = 0x800965BC; // type:func entity render setup (244 bytes)
entity_lod_select = 0x80096734; // type:func entity LOD selection by distance (716 bytes)
entity_cull_check = 0x80096A00; // type:func entity view frustum culling (348 bytes)
lookup_with_output = 0x80096B5C; // type:func table lookup with output pointer
entity_render_transform = 0x80096CC4; // type:func entity render with transforms (1216 bytes)
entity_collision_response = 0x80097184; // type:func entity collision response (876 bytes)
entity_bounds_update = 0x8009731C; // type:func update entity bounding box
entity_visibility_calc = 0x80097470; // type:func calculate entity visibility state
mp_interval_pos = 0x800979A8; // type:func calc car position relative to maxpath interval (arcade: maxpath.c:mp_interval_pos)
MP_TargetSteerPos = 0x80097AFC; // type:func calc target steering position from maxpath (arcade: maxpath.c:MP_TargetSteerPos)
resource_process_thunk = 0x80098554; // type:func thunk to texture_set
param_reshuffle_wrapper = 0x800985F4; // type:func reorganize params, call matrix_translate (44 bytes)
matrix_push_offset = 0x80098620; // type:func push matrix with offset
pointer_offset8_call = 0x800986B0; // type:func call matrix_identity with offset (36 bytes)
entity_state_check = 0x800987E8; // type:func simple state check (140 bytes)
entity_flag_check = 0x80098874; // type:func entity flag check (108 bytes)
entity_damage_update = 0x800988E0; // type:func entity damage/health update (516 bytes)
entity_physics_step = 0x80098AE4; // type:func entity physics integration step (1244 bytes)
entity_ground_check = 0x80098FC0; // type:func entity ground raycast (708 bytes)
entity_ai_pathfind = 0x800992AC; // type:func entity AI pathfinding (2388 bytes)
lighting_setup = 0x8009C5BC; // type:func lighting setup helper
lighting_calc = 0x8009C5E0; // type:func surface lighting calculation (1560 bytes)
track_geometry_process = 0x8009C8F0; // type:func track geometry processing for rendering (5368 bytes)
track_segment_setup = 0x8009DC50; // type:func track segment initialization
track_texture_setup = 0x8009DD18; // type:func track texture loading and setup
track_segment_render = 0x8009DD88; // type:func render single track segment with display list (3304 bytes)
track_bounds_check = 0x8009EA70; // type:func check position within track boundaries (168 bytes)
track_height_query = 0x8009EB18; // type:func get terrain height at position (168 bytes)
track_surface_type = 0x8009EBC0; // type:func get surface material type at position (1188 bytes)
track_collision_test = 0x8009F064; // type:func raycast against track geometry (8600 bytes)
MP_TargetSpeed = 0x800A0F74; // type:func calc target speed from maxpath (arcade: maxpath.c:MP_TargetSpeed)
NextMaxPath = 0x800A0FDC; // type:func get next maxpath index wrapping at lap end (arcade: maxpath.c:NextMaxPath)
PrevMaxPath = 0x800A11E4; // type:func get previous maxpath index (arcade: maxpath.c:PrevMaxPath)
InitMaxPath = 0x800A1244; // type:func initialize maxpath system for drones (arcade: maxpath.c:InitMaxPath)
assign_default_paths = 0x800A12D4; // type:func assign default paths to drones (arcade: maxpath.c:assign_default_paths)
sync_maxpath_to_checkpoint = 0x800A133C; // type:func sync maxpath index to checkpoint (arcade: maxpath.c)
check_mpath_save = 0x800A13E8; // type:func check if lap faster and save maxpath (arcade: maxpath.c)
track_segment_load = 0x800A1648; // type:func (2256 bytes) load track segment from ROM, GZIP decompression
// RecordMaxPath = 0x800A1A60; // type:func record maxpath during drone training (arcade: maxpath.c)
track_data_decompress = 0x800A1F18; // type:func (644 bytes) decompress GZIP/ZLIB/LZSS track data
track_collision_setup = 0x800A21A4; // type:func (732 bytes) setup 64x64 collision height/surface grids
MaxPathZeroControls = 0x800A2378; // type:func zero out drone controls (arcade: maxpath.c)
slot_state_lookup = 0x800A2504; // type:func accesses player/slot state array (58 calls)
AdjustSteer = 0x800A25C0; // type:func adjust drone steering toward target pos (arcade: maxpath.c:AdjustSteer)
AdjustSpeed = 0x800A2680; // type:func adjust drone throttle/brake to target speed (arcade: maxpath.c:AdjustSpeed)
drone_set_catchup = 0x800A2990; // type:func set catchup speed scaling for drone (arcade: drones.c)
set_catchup = 0x800A2CE4; // type:func set catchup mode for drones (arcade: drones.c:set_catchup)
no_catchup = 0x800A2D0C; // type:func disable catchup for tournament mode (arcade: drones.c:no_catchup)
track_process_main = 0x800A2D4C; // type:func (3116 bytes) per-frame track segment processing
track_spline_interp = 0x800A3654; // type:func (296 bytes) Catmull-Rom spline interpolation
drone_rwtobod = 0x800A373C; // type:func convert real-world to body coords for drone arcade:unitvecs.c:rwtobod()
track_render_process = 0x800A377C; // type:func (3156 bytes) per-frame track rendering
car_lod_select = 0x800A4508; // type:func car model LOD selection (visuals: level-of-detail)
wheel_rotation_update = 0x800A4940; // type:func update wheel rotation and slip (tires: visual rotation)
wheel_setup_initial = 0x800A4AC4; // type:func wheel initial setup
resource_update_global = 0x800A4B48; // type:func update global resource via matrix stack
wheel_params_set = 0x800A4B6C; // type:func set wheel parameters
init_wait_completion = 0x800A4C54; // type:func wait for initialization completion
suspension_update = 0x800A4CC0; // type:func suspension compression update (tires.c: dotireforce)
tire_skid_mark = 0x800A4E60; // type:func tire skid mark generation (visuals: DoSkid)
suspension_setup = 0x800A501C; // type:func suspension spring setup
suspension_params_init = 0x800A511C; // type:func suspension parameters init
suspension_damper_set = 0x800A5160; // type:func suspension damper settings
car_damage_visual = 0x800A51E0; // type:func car damage visual update (visuals: damage deformation)
engine_particle_effect = 0x800A5588; // type:func engine particle effect spawn (visuals: dust/sparks/smoke)
exhaust_smoke_effect = 0x800A5744; // type:func exhaust smoke effect render (visuals: StartSmoke)
arb_rate_set = 0x800A5908; // type:func anti-roll bar rate set
tire_params_load = 0x800A5A74; // type:func tire parameters load
render_state_init = 0x800A5B60; // type:func initialize render state variables
tire_compound_set = 0x800A5BB8; // type:func tire compound type set
car_shadow_render = 0x800A5D34; // type:func car shadow rendering (visuals: shadow)
car_lights_render = 0x800A6094; // type:func headlight/taillight rendering (visuals)
brake_light_update = 0x800A6244; // type:func brake light update (visuals: App_M_BRAKE_LIGHTS)
car_render_full = 0x800A6404; // type:func car full render with effects (visuals: main car render)
wheel_render_full = 0x800A6BE4; // type:func wheel full render
car_setup_physics = 0x800A78C8; // type:func car physics setup
car_mass_set = 0x800A7AE4; // type:func set car mass and inertia
car_gear_shift = 0x800A7C9C; // type:func arcade:drivetra.c:autoshift manual gear shift handler - sets commandgear and triggers shift
car_get_gear = 0x800A7D88; // type:func arcade:drivetra.c return current gear value (-1=R,0=N,1-4=fwd)
object_process_thunk = 0x800A7DF0; // type:func thunk to camera_target_set
tire_force_calc = 0x800A7E00; // type:func (1200 bytes) tire force calculation using friction circle model (tires.c)
car_cg_height_set = 0x800A80D0; // type:func set car center of gravity height
car_collision_init = 0x800A8D9C; // type:func car collision bounds init
car_collision_update = 0x800A8F64; // type:func car collision update
car_crash_detect = 0x800A9390; // type:func car crash detection
car_crash_response = 0x800A99C8; // type:func car crash impulse response
car_reset_position = 0x800AA454; // type:func car reset to track position
car_spawn_at_checkpoint = 0x800AA708; // type:func car spawn at checkpoint
car_velocity_clamp = 0x800AAB44; // type:func car velocity clamping
car_angular_velocity_clamp = 0x800AAE68; // type:func car angular velocity clamp
drivetrain_update = 0x800AB544; // type:func arcade:drivetra.c:drivetrain main drivetrain simulation - engine, trans, clutch, differential
engine_rpm_calc = 0x800AB70C; // type:func arcade:drivetra.c:engine engine torque calculation with gear-specific scaling
object_transform_set = 0x800AB758; // type:func set object transform matrix
engine_torque_calc = 0x800AB7D8; // type:func arcade:drivetra.c:enginetorque bilinear torque curve lookup with RPM/throttle interpolation
clutch_slip_calc = 0x800ABA18; // type:func arcade:drivetra.c:whatslips clutch slip calculation - determines torque transfer engine to driveshaft
autoshift_update = 0x800ABB04; // type:func arcade:drivetra.c:autoshift automatic transmission shift logic - throttle-dependent shift points
transmission_shift = 0x800ABBD0; // type:func arcade:drivetra.c:upshift,downshift gear shift with 1 second timing delay
transmission_ratio_get = 0x800ABCC8; // type:func arcade:drivetra.c:transmission calculate transratio and totalratio from gear array
find_best_gear = 0x800ABD60; // type:func arcade:drivetra.c:find_best_gear find appropriate gear for current speed when shifting out of N/R
drivetrain_interp = 0x800ABDE8; // type:func arcade:drivetra.c:interp linear interpolation helper for torque curve lookup
differential_output = 0x800AC3D8; // type:func arcade:drivetra.c:drivetrain(39-57) magic differential - load-sensitive torque split
wheel_torque_apply = 0x800AC668; // type:func arcade:drivetra.c:drivetrain(41-56) apply dwtorque to drive wheels with differential split
fp_call_wrapper = 0x800AC6F4; // type:func function pointer call wrapper
brake_force_apply = 0x800AC75C; // type:func apply brake force
resource_slot_get = 0x800AC820; // type:func get resource slot value
slot_deactivate = 0x800AC840; // type:func deactivate model slot
player_state_get = 0x800AC898; // type:func get player state value
handbrake_apply = 0x800ACA9C; // type:func apply handbrake
vector_diff_process = 0x800ACB74; // type:func process vector difference
traction_control = 0x800ACC18; // type:func traction control system
abs_brake_control = 0x800AD008; // type:func ABS brake control
steering_angle_calc = 0x800AD0A0; // type:func steering angle calculation
steering_sensitivity = 0x800AD128; // type:func steering sensitivity adjust
input_process_controller = 0x800AD734; // type:func process controller input
input_deadzone_apply = 0x800ADD58; // type:func apply input deadzone
camera_position_update = 0x800AEB54; // type:func camera position update
object_init_cleared = 0x800AED2C; // type:func initialize cleared object
camera_target_track = 0x800AED64; // type:func camera target tracking
camera_collision_check = 0x800AEFE8; // type:func camera collision avoidance
save_write_data = 0x800AF06C; // type:func save game data to buffer
camera_smooth_lerp = 0x800AF51C; // type:func camera smooth interpolation
save_slot_valid = 0x800AF5E0; // type:func check save slot validity
save_load_data = 0x800AF690; // type:func load save from controller pak
save_delete = 0x800AF8CC; // type:func delete save from slot
save_validate = 0x800AFB38; // type:func validate save data integrity
cpak_init = 0x800AFD5C; // type:func controller pak initialization
// ============================================
// Audio System Functions (0x800B0180 - 0x800B3xxx)
// Based on arcade sounds.c and game.c analysis
// ============================================
pool_linked_list_init = 0x800B04D0; // type:func initialize pool as linked list (128 bytes) - sets up element chain in pre-allocated pool
cpak_read = 0x800B0180; // type:func controller pak read - read data from controller pak (868 bytes)
struct_fields_init = 0x800B0550; // type:func initialize structure fields (see game.c comment)
audio_channel_alloc = 0x800B0580; // type:func allocate audio channel
audio_channel_free = 0x800B0618; // type:func free audio channel
audio_voice_set = 0x800B066C; // type:func set audio voice parameters
physics_update_all = 0x800B0870; // type:func physics object linked list update (called when physics_update != 0)
audio_init = 0x800B0904; // type:func audio system initialization - set up channels and hardware (396 bytes)
audio_shutdown = 0x800B0A90; // type:func audio system shutdown - stop all sounds and disable audio (440 bytes)
audio_frame_update = 0x800B0C48; // type:func per-frame audio update - process fades and channel timers (800 bytes)
sound_bank_load = 0x800B0F68; // type:func load sound bank from ROM via DMA (364 bytes)
sound_bank_unload = 0x800B10D4; // type:func unload sound bank and stop dependent sounds (1248 bytes)
music_seq_load = 0x800B15B4; // type:func load music sequence from ROM (1428 bytes)
music_control = 0x800B1B48; // type:func music playback control - stop/play/pause/resume/restart/fade (1020 bytes)
music_volume_set = 0x800B1F44; // type:func set music volume level 0.0-1.0 (200 bytes)
music_tempo_set = 0x800B200C; // type:func set music tempo/playback speed (1612 bytes)
sfx_play = 0x800B24EC; // type:func play sound effect with volume and pan (464 bytes)
sfx_stop = 0x800B2658; // type:func stop sound effect by handle or sound ID (256 bytes)
sfx_volume_set = 0x800B2828; // type:func set sound effect volume (196 bytes)
sfx_position_3d = 0x800B2928; // type:func 3D sound position - calculates attenuation and pan from distance (1016 bytes)
listener_position_set = 0x800B2D20; // type:func set audio listener position and forward vector (216 bytes)
engine_sound_update = 0x800B2DF8; // type:func arcade:carsnd.c:DoEngineSound update engine sound pitch/volume from RPM (1428 bytes)
tire_sound_update = 0x800B338C; // type:func arcade:carsnd.c:DoTireSqueals update tire squeal sounds from slip (900 bytes)
collision_sound_play = 0x800B362C; // type:func arcade:carsnd.c:do_bump_sounds trigger collision/impact sound based on intensity (684 bytes)
// Sound effect management (0x800B3710 - 0x800B3xxx)
wind_sound_update = 0x800B3710; // type:func arcade:carsnd.c:DoCarSounds update wind noise based on car speed (684 bytes)
crowd_cheer_play = 0x800B39BC; // type:func play crowd cheer sound for stunts/checkpoints (396 bytes)
ambient_sound_set = 0x800B3B4C; // type:func set ambient/environment sound volume by ID (468 bytes)
sound_update_channel = 0x800B3D18; // type:func audio sync/update - synchronizes audio state (228 bytes)
voice_play = 0x800B3D20; // type:func play announcer voice clip - start/position/lap announcements (488 bytes)
object_type_byte2_get = 0x800B3F00; // type:func returns byte at offset 2 from current object
object_type_byte3_get = 0x800B3F28; // type:func returns byte at offset 3 from current object
object_bytes_sum_global = 0x800B3F50; // type:func returns sum of mode_byte_2 + current_object offsets
object_manager_update = 0x800B3FA4; // type:func object management update (107 calls)
object_byte9_set = 0x800B41C0; // type:func sets byte at current_object+9
slot_state_init = 0x800B4208; // type:func player slot state initialization
object_create = 0x800B42F0; // type:func allocate and initialize object wrapper
fcvt_wrapper = 0x800B4360; // type:func float to string conversion wrapper (57 calls)
voice_stop = 0x800B438C; // type:func stop currently playing voice and clear queue (224 bytes)
sound_handles_clear = 0x800B45BC; // type:func stops and clears sound handles in object array
format_string_parse = 0x800B466C; // type:func format string parser with jump table (55 calls)
// Text/UI Functions (0x800B4700 - 0x800B5xxx)
voice_stop_2 = 0x800B4738; // type:func text formatting helper function (224 bytes)
audio_bus_mix = 0x800B4818; // type:func set volume levels for audio buses/categories (892 bytes)
reverb_setup = 0x800B4B94; // type:func arcade:carsnd.c:init_reverb configure reverb effect for environment type (536 bytes)
audio_pause = 0x800B4DAC; // type:func pause/resume all game audio
audio_ducking = 0x800B4E70; // type:func audio ducking - reduce lower priority sounds
sound_priority_set = 0x800B4FB0; // type:func set priority for sound handle
ambient_sounds_clear = 0x800B557C; // type:func clear all ambient and environment sound handles
visual_objects_update = 0x800B55FC; // type:func iterates and updates visual objects
sound_priority_mgr = 0x800B5694; // type:func sound priority management (184 bytes)
sound_loop_set = 0x800B574C; // type:func enable/disable looping for playing sound (340 bytes)
sound_pitch_set = 0x800B58A0; // type:func set pitch for playing sound (float to N64 fixed-point)
sound_volume_set = 0x800B5948; // type:func set volume 0.0-1.0 for playing sound (176 bytes)
audio_spatialize = 0x800B59F8; // type:func 3D sound spatialization - pan/attenuation/doppler (1472 bytes)
audio_distance_atten = 0x800B5F4C; // type:func calculate volume attenuation from distance (464 bytes)
audio_doppler = 0x800B5F88; // type:func calculate doppler pitch shift from relative motion
resource_type_select = 0x800B5FC4; // type:func select resource type based on bit flags
audio_occlusion = 0x800B6024; // type:func calculate audio occlusion between listener and source
entity_audio_update = 0x800B6138; // type:func update all audio for game entity (car/drone/object)
resource_alloc_conditional = 0x800B61B0; // type:func conditionally allocate resource or return -1
audio_doppler_full = 0x800B61FC; // type:func full doppler calculation with velocity
render_helper_main = 0x800B65B8; // type:func rendering helper function (65 calls)
audio_doppler_calc = 0x800B6788; // type:func doppler calculation - listener/source velocity (1124 bytes)
menu_input_process = 0x800B6BEC; // type:func process menu controller input
object_bytes23_sum = 0x800B7128; // type:func returns sum of bytes at offsets 2 and 3
sound_pitch_diff_calc = 0x800B7170; // type:func calculate difference with sound_pitch_set result
sound_pitch_diff_halved = 0x800B71A0; // type:func calculate halved difference with sound_pitch_set
sound_state_helper = 0x800B71DC; // type:func sound state helper function (125 calls)
audio_listener_update = 0x800B7440; // type:func update audio listener state from camera
event_dispatch_handler = 0x800B74A0; // type:func event dispatch handler (152 calls)
// Particle/Effect System (0x800B78xx - 0x800B8xxx)
particles_init = 0x800B78F8; // type:func initialize particle system
particles_update = 0x800B7A40; // type:func update all active particles
particles_spawn = 0x800B8000; // type:func spawn new particle emitter
particles_spawn_emitter = 0x800B80C8; // type:func spawn particles for specific emitter index
particle_type_set = 0x800B811C; // type:func set particle type/behavior
particle_position_set = 0x800B821C; // type:func set particle spawn position
particle_velocity_set = 0x800B82C8; // type:func set particle initial velocity
particle_lifetime_set = 0x800B8374; // type:func set particle lifetime in frames
particle_render = 0x800B8650; // type:func render particle sprites
particle_collision = 0x800B8820; // type:func particle collision detection
// Physics Functions (0x800B9xxx)
physics_step = 0x800B9130; // type:func single physics integration step
physics_collision_test = 0x800B9194; // type:func test physics collision between objects
physics_response = 0x800B93A8; // type:func calculate physics collision response
physics_ground_trace = 0x800B9774; // type:func trace ray to ground for terrain contact
physics_velocity_clamp = 0x800B9A0C; // type:func clamp velocity to maximum
physics_friction_apply = 0x800B9D68; // type:func apply friction force to object
// Audio Mixer Functions (0x800BAxxx)
audio_channel_alloc = 0x800BA00C; // type:func allocate audio channel based on priority
audio_channel_free = 0x800BA2E8; // type:func free audio channel
audio_priority_find = 0x800BA46C; // type:func find channel for sound based on priority (472 bytes)
audio_heap_alloc = 0x800BA644; // type:func allocate memory from audio heap (380 bytes)
audio_mixer_main = 0x800BA7C4; // type:func main audio mixer - mix all channels to output (1996 bytes)
audio_effect_apply = 0x800BAAA0; // type:func apply audio effect to output (172 bytes)
audio_effect_remove = 0x800BAD58; // type:func remove audio effect (252 bytes)
audio_dsp_process = 0x800BADE0; // type:func DSP processing - reverb/EQ effects chain (1372 bytes)
mode_flags_clear = 0x800BAF64; // type:func clear audio mode flags
audio_output_setup = 0x800BAF98; // type:func configure audio output mode (408 bytes)
audio_hw_sync = 0x800BB044; // type:func sync audio buffer submission with hardware (392 bytes)
audio_interrupt_handler = 0x800BB140; // type:func audio DMA interrupt handler (756 bytes)
// Camera Functions (0x800BBxxx - 0x800BCxxx)
camera_reset = 0x800BB69C; // type:func reset camera to default state (292 bytes)
camera_lerp_position = 0x800BB834; // type:func lerp camera position toward target (808 bytes)
camera_orbit_delta = 0x800BB9BC; // type:func orbit camera around target by delta angles (548 bytes)
player_flag_clear_process = 0x800BC1E8; // type:func process player flag clear
camera_dolly = 0x800BC2BC; // type:func move camera along view direction/zoom (460 bytes)
camera_follow_target = 0x800BCBB8; // type:func camera follows target with look-ahead (7640 bytes)
camera_collision_avoid = 0x800BCEE4; // type:func prevent camera clipping through geometry (1596 bytes)
camera_smooth_follow = 0x800BD104; // type:func smooth interpolation to follow position (872 bytes)
camera_collision_check = 0x800BD2D0; // type:func raycast collision check from target to camera (1976 bytes)
camera_shake_start = 0x800BDAA8; // type:func initiate camera shake effect (852 bytes)
camera_shake_update = 0x800BDDFC; // type:func update camera shake per frame (192 bytes)
camera_zoom_fov = 0x800BDEBC; // type:func adjust camera FOV for zoom effect (444 bytes)
camera_auto_follow = 0x800BE078; // type:func smooth auto-follow with spring physics (1136 bytes)
// Camera cinematic/cut functions (0x800BExxx - 0x800BFxxx)
camera_cinematic_mode = 0x800BE4B4; // type:func set up camera for cinematic sequences (936 bytes)
camera_cut_to = 0x800BE4F8; // type:func instant camera cut to new position/target
race_position_update = 0x800BE7BC; // type:func update race position
music_fade = 0x800BE9A0; // type:func music fade in/out over duration (388 bytes)
music_tempo_adjust = 0x800BE9E8; // type:func adjust music playback tempo
camera_blend_between = 0x800BEE2C; // type:func blend between two camera states (924 bytes)
results_screen_update = 0x800BF024; // type:func update results screen display
results_time_display = 0x800BF0A4; // type:func display race time on results
leaderboard_update = 0x800BF148; // type:func update leaderboard display
camera_fov_control = 0x800BF1C8; // type:func set camera field of view (236 bytes)
camera_clip_planes = 0x800BF2B8; // type:func set camera near/far clipping planes (220 bytes)
camera_aspect_ratio = 0x800BF394; // type:func set camera aspect ratio (200 bytes)
camera_look_at_point = 0x800BF45C; // type:func orient camera to look at target point (988 bytes)
camera_first_person = 0x800BF838; // type:func first person view from inside vehicle (948 bytes)
camera_third_person = 0x800BFBEC; // type:func third person chase camera behind vehicle (380 bytes)
select_screen_update = 0x800BFD68; // type:func update selection screen state
camera_top_down = 0x800BFD94; // type:func top-down overhead camera view (844 bytes)
camera_free_look = 0x800C00E0; // type:func free camera controlled by player input
camera_replay_mode = 0x800C02A0; // type:func playback camera from recorded replay data
camera_track_spline = 0x800C04CC; // type:func moves camera along a spline path
camera_build_view_matrix = 0x800C085C; // type:func builds view matrix from camera state arcade:fmath.c:MulMat()
camera_update = 0x800C0AC0; // type:func main camera update - calls appropriate mode handler
camera_process_input = 0x800C1604; // type:func processes player input for camera control
camera_check_constraints = 0x800C1B8C; // type:func enforces camera position constraints
camera_debug_display = 0x800C2020; // type:func shows camera debug information
camera_save_state = 0x800C2228; // type:func saves camera state for replay or undo
camera_restore_state = 0x800C244C; // type:func restores camera state from saved data
camera_multi_view_setup = 0x800C26E0; // type:func sets up camera for split screen rendering
camera_split_screen_config = 0x800C2960; // type:func configures split screen mode for multiplayer
camera_scene_manager = 0x800C2BE0; // type:func manages camera state transitions between game states
effect_slot_init = 0x800C3594; // type:func initialize effect slot with index

// Game code functions (extracted from compressed ROM, 0x80086A50 - 0x80124AF0)
// These are in the dynamically loaded game code segment

// Large rendering/display functions
// render_large already defined above
// render_object already defined above

// Audio/sound functions (now renamed - see named definitions earlier in file)
audio_helper = 0x80097384; // type:func audio processing helper
// audio_task_complete at 0x800974EC - see audio system section
// sfx_play at 0x80095360 - defined above
// bgm_playback at 0x80095960 - defined above
// audio_call_wrapper at 0x8008A750 - defined above
// sound_control at 0x800B37E8 - see audio system section

// Vehicle/physics functions (arcade: drivsym.c, tires.c)
// Main physics loop functions (arcade: drivsym.c)
physics_sym = 0x800B8C14; // type:func main per-frame physics update (arcade: sym in drivsym.c:186)
physics_regular = 0x800B9000; // type:func standard physics cycle (arcade: regular in drivsym.c:285)
physics_positions = 0x800B9400; // type:func integrate velocity to position (arcade: positions in drivsym.c:594)
vehicle_physics_sync = 0x80097798; // type:func vehicle physics/collision sync

// Tire model functions (arcade: tires.c)
tire_calc_force = 0x800BA000; // type:func full tire force calculation (arcade: dotireforce in tires.c:120)
tire_suspension_update = 0x800BA800; // type:func suspension compression calc (arcade: suscomp)

// Collision functions (arcade: collision.c)
collision_detect = 0x800BB000; // type:func main collision detection (arcade: collision)
collision_car_car = 0x800BB400; // type:func car-to-car collision (arcade: setFBCollisionForce)
collision_car_wall = 0x800BB800; // type:func car-to-wall collision (arcade: ForceApart)
collision_point_in_body = 0x800BBC00; // type:func point inside collision box test (arcade: PointInBody)

// AI/drone functions (arcade: drones.c, maxpath.c)
// Main drone control functions
DoDrones = 0x800A0000; // type:func main drone housekeeping per frame (arcade: drones.c:DoDrones)
InitDrones = 0x8009FF00; // type:func initialize drone system for race (arcade: drones.c:InitDrones) - calls InitMaxPath
EndDrones = 0x800A0100; // type:func cleanup drone system at race end (arcade: drones.c:EndDrones) - trivial
drone_steering_calc = 0x800A0800; // type:func calculate drone steering angle (arcade: maxpath.c:AdjustSteer)

// Maxpath (drone path following) functions
MaxPath = 0x800A0B00; // type:func main maxpath update per frame (arcade: maxpath.c:MaxPath) - wraps RecordMaxPath
MaxPathControls = 0x800A1000; // type:func drone path following controller (arcade: maxpath.c:MaxPathControls)
MP_FindInterval = 0x800A0C00; // type:func find current maxpath interval (arcade: maxpath.c:MP_FindInterval)
MP_IntervalPos = 0x800A0D00; // type:func calc position relative to maxpath interval (arcade: maxpath.c:MP_IntervalPos)
prev_maxpath = 0x800A1180; // type:func prev maxpath index with loop flag (arcade: maxpath.c:prev_maxpath)
adjust_maxpath_due_to_lap = 0x800A14C0; // type:func adjust maxpath for lap crossing (arcade: maxpath.c:adjust_maxpath_due_to_lap)

// Obstacle avoidance
avoid_areas = 0x800A1800; // type:func obstacle avoidance for drones (arcade: maxpath.c:avoid_areas)
next_maxpath = 0x800A1080; // type:func next maxpath index with loop flag (arcade: maxpath.c:next_maxpath)
// ============================================================================
// Checkpoint functions (arcade: checkpoint.c)
// Cross-referenced with reference/repos/rushtherock/game/checkpoint.c
// Added 2025-12-31 based on arcade-N64 function comparison
// ============================================================================

// Core checkpoint detection (per-frame)
CheckCPs = 0x800C0000; // type:func main checkpoint detection per frame (arcade: checkpoint.c:866 CheckCPs)
checkpoint_check = 0x800C85F0; // type:func checkpoint collision/plane test (arcade: checkpoint.c:866 CheckCPs inner loop)

// Race lap/checkpoint state (0x800E4xxx range)
race_lap_check = 0x800E4000; // type:func check lap completion (arcade: checkpoint.c:1098 PassedCP finish line handling)
race_position_calc = 0x800E4200; // type:func calculate race positions (arcade: checkpoint.c:940-960 CheckCPs position sorting)
race_checkpoint_update = 0x800E4400; // type:func update checkpoint state per frame (arcade: checkpoint.c:check_everyones_checkpoints)
race_finish_check = 0x800E4600; // type:func check race finish condition (arcade: checkpoint.c:CarReportsGameOver trigger)
race_time_update = 0x800E4800; // type:func update race timer (arcade: checkpoint.c:last_checkpoint_time updates)
race_wrong_way_check = 0x800E4A00; // type:func detect wrong way driving (arcade: checkpoint.c:direction check)

// World trigger system (handles checkpoint triggers)
world_trigger_check = 0x800EDCE8; // type:func check player in trigger volumes (2292 bytes) (arcade: checkpoint.c:CheckCPs radius check)
world_trigger_activate = 0x800EE5DC; // type:func activate checkpoint/shortcut/boost trigger (580 bytes) (arcade: checkpoint.c:PassedCP)

// Checkpoint hit/lap functions (0x80107xxx range - in game code segment)
checkpoint_hit = 0x801073D8; // type:func record checkpoint passage, validate sequence (580 bytes) (arcade: checkpoint.c:PassedCP validation)
lap_complete = 0x8010761C; // type:func handle lap completion (1240 bytes) (arcade: checkpoint.c:PassedCP finish line, update_lap_counter)
race_finish = 0x80107AF4; // type:func handle car finishing race (1000 bytes) (arcade: checkpoint.c:CarReportsGameOver)

// Race state machine related to checkpoints
race_state_update = 0x800DB81C; // type:func race progression/checkpoint/finalization controller (2148 bytes) (arcade: checkpoint.c:check_everyones_checkpoints)

// HUD checkpoint display functions
draw_lap_counter = 0x800C7ED4; // type:func display current/total laps (2540 bytes) (arcade: checkpoint.c:update_lap_counter)
split_time_display = 0x800D2CDC; // type:func checkpoint split times (240 bytes) (arcade: checkpoint.c:ShowCheckpointTime)
lap_counter_display = 0x800D2A74; // type:func lap X/Y display (440 bytes) (arcade: checkpoint.c:update_lap_counter Do_it)

// Additional game code functions
read_controllers = 0x800140B0; // type:func controller input reading - controller input reading
// ============================================
// Menu/UI Functions (from game.c analysis 2025-12-29)
// ============================================

// UI Drawing Functions
draw_text = 0x800C734C; // type:func draw text string at x,y with color
draw_ui_element = 0x800C7110; // type:func draw UI sprite element (id, x, y, w, h, alpha)

// HUD Functions
hud_setup = 0x800C8B8C; // type:func HUD initialization with positioning and parameters
hud_speed_display = 0x800C84FC; // type:func render speedometer with speed value
hud_element_render = 0x800C7350; // type:func render HUD element by ID
hud_tachometer_update = 0x800C8DA0; // type:func update tachometer display
hud_full_update = 0x800C8F00; // type:func full HUD refresh
hud_nitro_update = 0x800C8E50; // type:func update nitro gauge
hud_fade_effect = 0x800C8F80; // type:func HUD fade/transition effect

// Menu System Functions
menu_system_update = 0x800CF000; // type:func main menu system update (large, ~12KB)
menu_render = 0x800D0000; // type:func render active menu screen
sound_position_set = 0x800D03DC; // type:func set 3D sound position (72 bytes) - applies Y/X/Z coords to sound system
menu_input_handle = 0x800D1000; // type:func process menu controller input
menu_track_select = 0x800D2000; // type:func track selection screen handler
menu_car_select = 0x800D3000; // type:func car selection screen handler
menu_options = 0x800D4000; // type:func options menu handler
menu_saveload = 0x800D5000; // type:func save/load menu handler
menu_controller_config = 0x800D6000; // type:func controller config menu handler
menu_prev = 0x800D7000; // type:func navigate to previous menu item
menu_confirm = 0x800D7100; // type:func confirm current menu selection
menu_toggle = 0x800D7200; // type:func toggle menu option value
menu_audio_options = 0x800D7300; // type:func audio options sub-menu
menu_credits = 0x800D7400; // type:func credits screen handler
menu_load = 0x800D7500; // type:func load menu data/resources
menu_stub_empty = 0x800D7600; // type:func empty menu stub function
menu_main = 0x800D7700; // type:func main menu entry point
menu_state_dispatch = 0x800D7800; // type:func menu state machine dispatcher

// Display/Visibility Functions
display_enable = 0x800C8FA4; // type:func enable/disable display output
object_render_cleanup = 0x800C7308; // type:func cleanup object render reference
scene_cleanup_slots = 0x800C70BC; // type:func scene slot cleanup

// Player/Mode Functions (UI-related)
player_mode_set = 0x800C84C0; // type:func set player display mode
player_state_set = 0x800C9158; // type:func set player UI state
player_cleanup_slots = 0x800C90E0; // type:func cleanup player mode slots

// Resource Management (menu-related)
speed_set = 0x800C9210; // type:func set menu animation speed
resource_slots_clear_multiple = 0x800C937C; // type:func clear multiple resource slots
resource_type_select = 0x800C9334; // type:func select resource type for menu
speed_mode0_wrapper = 0x800C92DC; // type:func speed mode 0 wrapper
speed_mode1_wrapper = 0x800C93AC; // type:func speed mode 1 wrapper

// Replay UI Functions
replay_ui_draw = 0x800D8000; // type:func draw replay interface elements

// State Handlers (menu-related states)
state_menu_handler = 0x800FC0EC; // type:func GSTATE_MENU handler (UI/input chain)
state_change_preprocess = 0x800CA300; // type:func state change preprocessing (HUD fade)
game_state_check_handler = 0x800FBBFC; // type:func check game state for menu transitions

// Sync/Registration (menu integration)
sync_entry_register = 0x800C9194; // type:func create and register sync entry for menu state

// Camera Functions (0x800C00E0 - 0x800C3000 range)
camera_path_follow = 0x800C0288; // type:func follow predefined camera path with interpolation (2124 bytes)
camera_transition = 0x800C0AC4; // type:func blend between two camera states over time (1736 bytes)
camera_matrix_build = 0x800C1188; // type:func build view matrix from camera state (876 bytes)
camera_frustum_extract = 0x800C14F4; // type:func extract frustum planes from camera (768 bytes)
camera_viewport_setup = 0x800C17F4; // type:func set viewport for camera rendering (1224 bytes)
camera_split_screen_setup = 0x800C1CBC; // type:func configure split-screen for multiplayer (2392 bytes)
camera_trigger_check = 0x800C4200; // type:func check camera trigger zones (1232 bytes)
camera_follow_path = 0x800C46D0; // type:func camera following path logic (3956 bytes)
camera_play_script = 0x800C5644; // type:func execute scripted camera sequence (3520 bytes)
camera_victory = 0x800C6404; // type:func victory lap camera mode (1468 bytes)

// Entity Functions (0x800C6000 range)
entity_iterate = 0x800C69C0; // type:func iterate all entities with callback (224 bytes)
entity_update = 0x800C6AA0; // type:func full entity physics and state update (1564 bytes)

// HUD Drawing Functions (0x800C7000-0x800C9000 range)
draw_number = 0x800C760C; // type:func draw numeric value at position (524 bytes)
draw_speedometer = 0x800C7818; // type:func draw speedometer dial with needle (1724 bytes)
draw_position = 0x800C8864; // type:func show race position (1st, 2nd, etc.) (188 bytes)
draw_timer = 0x800C8920; // type:func show race time MM:SS.ms (228 bytes)
draw_minimap = 0x800C9404; // type:func draw track minimap with car positions (300 bytes)
draw_message = 0x800CA308; // type:func draw centered HUD message (checkpoint, etc.) (172 bytes)
hud_render = 0x800CADA4; // type:func main HUD rendering function (2468 bytes)

// Menu Input Functions (0x800CB000 range)
menu_process_input = 0x800CB400; // type:func handle controller input for menus (628 bytes)
menu_cursor_move = 0x800CB680; // type:func navigate between menu items (516 bytes)
menu_item_select = 0x800CBBD4; // type:func execute selection on menu item (564 bytes)
menu_back = 0x800CBE08; // type:func return to previous menu (132 bytes)
menu_transition = 0x800CBE8C; // type:func switch to new menu with animation (340 bytes)
menu_animation_update = 0x800CC000; // type:func handle menu transitions and element animations (900 bytes)

// Menu Sound Functions
sound_play_menu = 0x800CC3C0; // type:func play menu sound effects (380 bytes)

// Menu Text Functions
menu_text_scroll = 0x800CC540; // type:func scroll long text horizontally (904 bytes)
menu_highlight_set = 0x800CC880; // type:func set highlight state for menu item (316 bytes)
menu_list_render = 0x800CC9AC; // type:func render entire menu with items (1112 bytes)

// Dialog Functions (0x800CD000 range)
menu_confirm_render = 0x800CD300; // type:func render confirmation dialog (580 bytes)
menu_confirm_dialog = 0x800CD544; // type:func show confirmation and handle input (412 bytes)
menu_dialog_close = 0x800CD6E0; // type:func close active dialog with animation (184 bytes)

// Keyboard/Text Input Functions
keyboard_init = 0x800CD738; // type:func initialize on-screen keyboard (340 bytes)
keyboard_input_process = 0x800CD88C; // type:func handle keyboard navigation and selection (500 bytes)
menu_text_input = 0x800CDAE0; // type:func handle full text entry with keyboard (460 bytes)

// Options Functions (0x800CE000 range)
menu_option_toggle = 0x800CDCAC; // type:func toggle game option and apply immediately (576 bytes)
menu_save_options = 0x800CDEEC; // type:func save game options to Controller Pak (764 bytes)
menu_load_options = 0x800CE1EC; // type:func load game options from Controller Pak (364 bytes)
menu_options_screen = 0x800CE358; // type:func main options menu handler (2532 bytes)
menu_audio_settings = 0x800CED3C; // type:func audio options submenu (1364 bytes)
menu_video_settings = 0x800CF290; // type:func video options submenu (228 bytes)
menu_control_settings = 0x800CF374; // type:func controller options submenu (808 bytes)
menu_controller_remap = 0x800CF69C; // type:func controller button remapping screen (1976 bytes)
menu_vibration_test = 0x800CFE74; // type:func test controller rumble feature (404 bytes)

// Additional 0x800C Functions (from game.c analysis 2025-12-29)
input_init_flag_get = 0x800C9528; // type:func load input initialized flag (8 bytes) - prologue for input_callback_process
input_callback_process = 0x800C9530; // type:func process input callback table
resource_slot_clear = 0x800C9334; // type:func clear a resource slot by ID
menu_render_list = 0x800CB9A0; // type:func render menu item list
effect_cleanup = 0x800C55E4; // type:func cleanup effect slots
menu_item_value_get = 0x800CC804; // type:func get menu item value
object_data_allocate = 0x800CD748; // type:func allocate object data
object_type7_create = 0x800C878C; // type:func create object type 7
object_type1_create = 0x800C87F4; // type:func create object type 1
object_byte71_set_sync = 0x800CDA90; // type:func set object byte 71 with sync
effect_system_init = 0x800C3614; // type:func initialize effect system

// ============================================================================
// init.c - Game initialization globals (renamed from D_80XXXXXX placeholders)
// ============================================================================

// Thread structures (OSThread)
gIdleThread = 0x80034BA0; // OSThread for thread 1 (idle thread)
gInitThread = 0x80034D50; // OSThread for thread 6 (init thread)
gAudioThread = 0x80034690; // OSThread for thread 8 (audio thread)
gRenderThread = 0x80034840; // OSThread for thread 5 (render thread)
gGameThread = 0x800344E0; // OSThread for thread 7 (main game thread)

// Thread stacks
gIdleThreadStack = 0x8002F660; // Stack for idle thread (thread 1)
gInitThreadStack = 0x80030150; // Stack for init thread (thread 6)
gAudioThreadStack = 0x8002F7F0; // Stack for audio thread (thread 8)
gRenderThreadStack = 0x80031D70; // Stack for render thread (thread 5)
gGameThreadStack = 0x80030AB0; // Stack for game thread (thread 7)

// Message queues (OSMesgQueue)
gDmaMesgQueue = 0x80035410; // DMA message queue
gInflateMesgQueue = 0x80035428; // Inflate/decompression I/O queue
gRetraceMesgQueue = 0x8002ECF8; // Retrace/VBlank message queue
gEventMesgQueue = 0x8002ECC0; // Event message queue
gSyncMesgQueue = 0x80035440; // Sync signal queue

// Message buffers (OSMesg arrays)
gDmaMesgBuf = 0x8002F140; // 8 messages for gDmaMesgQueue
gInflateMesgBuf = 0x8002F160; // 8 messages for gInflateMesgQueue
gRetraceMesgBuf = 0x8002ED10; // 60 messages for gRetraceMesgQueue
gEventMesgBuf = 0x8002ECD8; // 8 messages for gEventMesgQueue
gSyncMesgBuf = 0x8002F180; // 1 message for gSyncMesgQueue

// Memory regions (used for decompression and BSS)
gDecompressedDataStart = 0x80086A50; // Start of decompressed game code
gDecompressedDataEnd1 = 0x8010FD80; // End of decompressed region 1
gBssStart = 0x801249F0; // Start of BSS region
gBssEnd = 0x8017A640; // End of BSS region

// State variables
gInitFlag = 0x8002B028; // Init mode flag (0 = normal boot)
gSyncMagic = 0x80142D90; // Magic sync value (0x0ABF/0x0ABE handshake)
gGameStateFlag = 0x80035472; // Game state flag

// Scheduler and video structures (from 2CF0.s / init.c analysis)
gScheduler = 0x8002E8E8; // type:data size:0x50 OSSched scheduler structure passed to osScCreateThread and osScStartRetrace
gViModeTable = 0x8002EE08; // type:data size:0x18 video mode table base pointer (passed to osCreateScheduler arg1)
gViModeLan1 = 0x8002EE20; // type:data size:0x50 OSViMode structure for LAN1 mode (passed to osCreateScheduler arg2)
gSchedulerStack = 0x80033EA0; // type:data size:0x640 scheduler thread stack area (used with +0x640 offset)

// Thread entry point functions (from init.c)
render_thread_entry = 0x800E7808; // type:func render thread entry point (thread 5)

// ROM data offsets
gRomCompressedData = 0xB0CB10; // type:data compressed game code in ROM (DEFLATE compressed, decompresses to 0x80086A50)

// ============================================================================
// game.c - Game functions in 0x800D0000-0x800E0000 range
// (Renamed from func_800DXXXX placeholders based on arcade source analysis)
// ============================================================================

// Track/Car Selection (menu screens)
track_select_screen = 0x800D000C; // type:func main track selection menu (2264 bytes)
track_preview_render = 0x800D08E4; // type:func renders track thumbnail/preview image (692 bytes)
track_info_display = 0x800D0BA0; // type:func shows track statistics and info (1192 bytes)
car_select_screen = 0x800D138C; // type:func main car selection menu (804 bytes)
car_preview_render = 0x800D16B0; // type:func renders rotating 3D car model (564 bytes)
car_stats_display = 0x800D18E4; // type:func shows car performance stats (152 bytes)
car_unlock_check = 0x800D197C; // type:func checks if car is unlocked (316 bytes)
car_color_select = 0x800D1AB8; // type:func applies selected color to car preview (552 bytes)

// Race Setup
race_setup_screen = 0x800D1CE0; // type:func configure race options before starting (1960 bytes)
race_mode_select = 0x800D24C8; // type:func configures race mode settings (1120 bytes)
lap_count_select = 0x800D2928; // type:func sets number of laps for race (332 bytes)
difficulty_select = 0x800D2A74; // type:func sets AI difficulty and rubber-banding (440 bytes)
mirror_mode_toggle = 0x800D2C2C; // type:func flips track left-right (176 bytes)
weather_select = 0x800D2CDC; // type:func sets weather conditions (240 bytes)
time_of_day_select = 0x800D2DCC; // type:func sets lighting conditions (200 bytes)
multiplayer_setup = 0x800D2E94; // type:func configures multiplayer game options (1544 bytes)

// Multiplayer and Stunt Setup
player_join_screen = 0x800D349C; // type:func players press start to join (1676 bytes)
stunt_mode_setup = 0x800D3B28; // type:func configure stunt arena and scoring (5068 bytes)
stunt_arena_preview = 0x800D3E50; // type:func render stunt arena preview (384 bytes)
battle_mode_setup = 0x800D4EF4; // type:func configure battle arena and rules (532 bytes)

// Player/Race Management and Menu Screens
players_race_update = 0x800D5050; // type:func update player race progress
ghost_race_setup = 0x800D510C; // type:func race against saved ghosts setup (716 bytes)
object_activate = 0x800D52D4; // type:func activate game object
player_conditional_call = 0x800D54BC; // type:func conditional function call helper
player_conditional_check = 0x800D54E0; // type:func conditional check based on parameter
players_frame_update = 0x800D5798; // type:func per-frame player update
player_state_clear = 0x800D5894; // type:func clear player state
records_screen = 0x800D58CC; // type:func displays best times and high scores (740 bytes)
best_times_display = 0x800D5BB0; // type:func shows best lap and race times (224 bytes)
high_scores_display = 0x800D5C90; // type:func shows stunt high scores (220 bytes)
players_finish_check = 0x800D60B4; // type:func check if players finished race
physics_init_mode0 = 0x800D6290; // type:func physics initialization mode 0
physics_init_mode1 = 0x800D62EC; // type:func physics initialization mode 1 (passes t0=1)
object_action_clear = 0x800D63C4; // type:func clear object action state
achievements_screen = 0x800D63F4; // type:func shows unlocked achievements (676 bytes)

// UI Screens and Menu Functions
credits_screen = 0x800D6698; // type:func displays game credits (296 bytes)
credits_scroll = 0x800D67C0; // type:func scrolls credits text (348 bytes)
loading_screen = 0x800D691C; // type:func displays loading progress bar (1376 bytes)
loading_tips = 0x800D6E7C; // type:func shows random gameplay tip during loading (852 bytes)
pause_menu = 0x800D71D0; // type:func full pause menu with options (3256 bytes)
render_replay_ui = 0x800D7D40; // type:func render replay interface
render_results_screen = 0x800D7DC4; // type:func render race results screen
pause_resume = 0x800D7E88; // type:func resumes game from pause (788 bytes)
pause_restart = 0x800D8184; // type:func restarts current race (2772 bytes)
pause_quit = 0x800D8C58; // type:func quits to main menu (1032 bytes)
results_screen = 0x800D9060; // type:func displays race results (4204 bytes)

// Results Display
position_result_display = 0x800DA0CC; // type:func displays finishing position (168 bytes)
time_result_display = 0x800DA174; // type:func displays race time (348 bytes)
points_award = 0x800DA2D0; // type:func calculates and displays points earned (2316 bytes)
replay_save_prompt = 0x800DABDC; // type:func asks user to save replay (2940 bytes)
continue_prompt = 0x800DB758; // type:func quick continue/quit choice (196 bytes)
object_type7_create_alt = 0x800DB7B4; // type:func create object type 7 alternative

// Championship and Unlock UI
championship_standings = 0x800DC248; // type:func shows championship points (432 bytes)
trophy_award_championship = 0x800DC3F8; // type:func awards championship trophy (924 bytes)
sound_handles_array_clear = 0x800DC720; // type:func clear sound handle array
unlock_notification = 0x800DC794; // type:func shows unlock popup (248 bytes)
attract_mode_start = 0x800DC88C; // type:func initializes attract mode demo (1272 bytes)
attract_demo_play = 0x800DC99C; // type:func plays back recorded demo race (1016 bytes)
mode_enable_flagged = 0x800DCD1C; // type:func enable mode with flag check
attract_idle_check = 0x800DCD94; // type:func returns 1 if no input for idle timeout (96 bytes)
attract_video_play = 0x800DCDF4; // type:func plays FMV or pre-rendered video (732 bytes)

// Attract Mode and Title Screen
attract_sequence_update = 0x800DD0D0; // type:func updates attract mode state machine (988 bytes)
title_screen = 0x800DD4AC; // type:func main title screen display (2816 bytes)
title_logo_animate = 0x800DDFAC; // type:func animates the game logo (608 bytes)
title_button_prompt = 0x800DE20C; // type:func shows PRESS START with blinking (724 bytes)
title_background = 0x800DE4DC; // type:func renders animated title background (908 bytes)
main_menu_screen = 0x800DE868; // type:func handles main menu logic (836 bytes)
main_menu_input = 0x800DEBAC; // type:func processes main menu input (224 bytes)
main_menu_render = 0x800DEC8C; // type:func draws the main menu (732 bytes)
mode_select_screen = 0x800DEF68; // type:func race/battle/stunt mode configuration (2976 bytes)
mode_select_input = 0x800DFB08; // type:func handles mode selection input (188 bytes)
profile_select_screen = 0x800DFBC4; // type:func profile select screen (1868 bytes)

// ============================================================================
// 0x800E* World/Physics/Effects Functions
// (Renamed from func_800EXXXX placeholders based on game.c analysis)
// ============================================================================

// World Physics System
cursor_move = 0x800E051C; // type:func keyboard cursor move (212 bytes)
world_object_destroy = 0x800EB690; // type:func world object destroy (396 bytes)
world_physics_tick = 0x800EC2F8; // type:func world physics tick - iterates cars and applies physics (1584 bytes)
world_collision_detect = 0x800EC928; // type:func world collision detect - bounding sphere check (588 bytes)
world_bounds_check = 0x800ECB74; // type:func world bounds check - position in bounds (164 bytes)
world_gravity_apply = 0x800ECC18; // type:func world gravity apply - applies gravity to velocity (2652 bytes)
world_friction_apply = 0x800ED674; // type:func world friction apply - applies drag to velocity (400 bytes)
world_velocity_integrate = 0x800ED804; // type:func world velocity integrate - Euler integration (712 bytes)
world_collision_response = 0x800EDACC; // type:func world collision response - impulse-based elastic collision (540 bytes)

// Particle/Effects System
world_effect_update = 0x800EE8B4; // type:func world effect update - updates particle position/lifetime (456 bytes)
particle_update = 0x800EEDB0; // type:func particle update - updates emitter particles (1240 bytes)
explosion_effect = 0x800EF8F4; // type:func explosion effect - creates fireball/smoke/sparks (1460 bytes)
dust_cloud_effect = 0x800EFEA8; // type:func dust cloud effect - creates settling dust particles (600 bytes)

// ============================================================================
// 0x800F* Rendering/Track/Timer/Debug Functions
// (Renamed from func_800FXXXX placeholders based on game.c analysis)
// ============================================================================

// Rendering Effects
skid_mark_render = 0x800F0100; // type:func skid mark render - tire skid decals on track (1396 bytes)

// Network/Multiplayer (N64 local multiplayer equivalent to arcade pdu.c)
// NOTE: Arcade used DIS Protocol Data Units (PDUs) for linked cabinet networking.
// N64 uses local controller input sharing and direct memory state sync instead.
// Reference: rushtherock/game/pdu.c - network protocol packet handling
//
// Arcade pdu.c function mapping to N64 equivalents:
//   PutEntityStatePDU    -> net_state_sync (serialize car pos/vel/rot to sync buffer)
//   ParseEntityStatePDU  -> net_message_recv (deserialize car state from buffer)
//   PutEventReportPDU    -> net_game_state_send (checkpoint, lap, score events)
//   ParseEventReportPDU  -> net_message_recv (parse event data from buffer)
//   SendPDU              -> net_packet_send (low-level send)
//   GetTimeStamp         -> gElapsedTime at 0x80142B14 (uses osGetTime)
//   ReportPDUError       -> net_error_handle (error reporting/recovery)
//
net_message_recv = 0x800F0698; // type:func arcade:pdu.c:ParseEntityStatePDU/ParseEventReportPDU - dequeue from buffer (1408 bytes)
net_state_sync = 0x800F0C18; // type:func arcade:pdu.c:PutEntityStatePDU - serialize car state (pos/vel/rot/inputs) to sync buffer (2036 bytes)
net_lobby_update = 0x800F13F0; // type:func network lobby update - handle lobby/player management (1364 bytes)
net_player_update = 0x800F1944; // type:func arcade:pdu.c:EntityStatePDU handling - update remote player state (852 bytes)
net_latency_check = 0x800F1C98; // type:func arcade:pdu.c timing - N64 frame sync (676 bytes)
net_input_sync = 0x800F1F3C; // type:func arcade:pdu.c:EntityStatePDU inputs - input state synchronization (2208 bytes)
net_game_tick = 0x800F20A0; // type:func arcade:pdu.c main loop - per-frame net update (1664 bytes)
net_packet_send = 0x800F2720; // type:func arcade:pdu.c:SendPDU - low-level packet send (376 bytes)
net_packet_recv = 0x800F2890; // type:func arcade:pdu.c:GetPDU - low-level packet receive (408 bytes)
net_connection_update = 0x800F27DC; // type:func network connection update (1632 bytes)
net_state_validate = 0x800F2A28; // type:func arcade:pdu.c:RTEST/LTEST - validate state data bounds (2736 bytes)
net_error_handle = 0x800F2E3C; // type:func arcade:pdu.c:ReportPDUError - error handling (784 bytes)
net_session_init = 0x800F314C; // type:func network session init (1084 bytes)
net_session_update = 0x800F34D8; // type:func network session update (3576 bytes)
net_player_join_handler = 0x800F3588; // type:func arcade:pdu.c:AcknowledgePDU handling - player join (836 bytes)
net_game_state_send = 0x800F38BC; // type:func arcade:pdu.c:PutEventReportPDU - send game events (checkpoint/lap/score) (1912 bytes)
net_race_sync = 0x800F4034; // type:func network race sync (1536 bytes)

// LOD and Track Rendering
lod_select = 0x800F42D0; // type:func LOD level selection based on distance (260 bytes)
lod_object_detail = 0x800F43D4; // type:func LOD object detail level (560 bytes)
track_geometry_stream = 0x800F4604; // type:func track geometry stream - streams from ROM to RSP (6540 bytes)
track_vertex_load = 0x800F4634; // type:func track vertex load (908 bytes)
track_section_render = 0x800F49C0; // type:func track section render (876 bytes)
track_surface_setup = 0x800F4D2C; // type:func track surface setup (752 bytes)
track_render_main = 0x800F5000; // type:func track render main - large rendering (3832 bytes)
track_texture_load = 0x800F5F90; // type:func track texture load - loads texture to TMEM (1348 bytes)
track_lighting_setup = 0x800F5EF8; // type:func track lighting setup (588 bytes)
track_culling_update = 0x800F6144; // type:func track culling update (1888 bytes)

// Billboard/Sign/Prop Rendering
billboard_render = 0x800F64D4; // type:func billboard render - camera-facing sprite (1120 bytes)
sign_render = 0x800F6894; // type:func sign render - roadside signs (580 bytes)
sign_render_main = 0x800F6934; // type:func sign render main (388 bytes)
props_render = 0x800F6AB8; // type:func props render - track props (cones/barriers/trees) (2460 bytes)
prop_instance_render = 0x800F6AD8; // type:func prop instance render (740 bytes)
prop_batch_render = 0x800F6DBC; // type:func prop batch render (1168 bytes)
prop_visibility_check = 0x800F724C; // type:func prop visibility check (252 bytes)

// Render Pipeline
render_pipeline_main = 0x800F7454; // type:func render pipeline main (1996 bytes)
render_large_objects = 0x800F93A0; // type:func render large objects (5652 bytes)
render_car_body = 0x800F9428; // type:func render car body (1604 bytes)
render_car_wheels = 0x800F9A74; // type:func render car wheels (952 bytes)
render_car_shadow = 0x800F9E2C; // type:func render car shadow (684 bytes)
render_scene_setup = 0x800FA0D8; // type:func render scene setup (2356 bytes)
render_viewport_init = 0x800FA9B4; // type:func render viewport init (948 bytes)
render_framebuffer = 0x800FA9E4; // type:func render framebuffer (1296 bytes)
render_display_update = 0x800FAD58; // type:func render display update (136 bytes)
render_post_process = 0x800FADE0; // type:func render post process (1108 bytes)
render_flush = 0x800FAEF4; // type:func render flush (1808 bytes)

// Display/VSync
vsync_wait = 0x800FB234; // type:func vsync wait - waits for vertical blank (148 bytes)
display_list_flush = 0x800FB2C8; // type:func display list flush - submits DL to RSP/RDP (5944 bytes)

// HUD Rendering
hud_render_main = 0x800FB5F4; // type:func HUD render main (820 bytes)
hud_timer_display = 0x800FB928; // type:func HUD timer display (712 bytes)

// State Handlers
state_handler_alt = 0x800FC3D8; // type:func state handler alternate (1516 bytes)
state_transition_check = 0x800FC9B8; // type:func state transition check (1284 bytes)
state_update_loop = 0x800FCEB0; // type:func state update loop (948 bytes)
state_exit_handler = 0x800FD264; // type:func state exit handler (512 bytes)

// Debug Functions
debug_overlay = 0x800FCA00; // type:func debug overlay - FPS/frame counter display (1016 bytes)
debug_stats = 0x800FCDF8; // type:func debug stats - memory/performance stats (556 bytes)
debug_collision = 0x800FD024; // type:func debug collision - collision wireframes (540 bytes)
debug_ai_paths = 0x800FD240; // type:func debug AI paths - waypoint visualization (552 bytes)

// Random Number Generator
random_seed_init = 0x800FD7E8; // type:func random seed init - sets RNG seed (244 bytes)
random_int = 0x800FD8DC; // type:func random int - returns random 32-bit integer (284 bytes)
random_float = 0x800FD9F8; // type:func random float - returns random float [0,1) (1436 bytes)
random_range = 0x800FDF94; // type:func random range - returns random int in [min,max] (248 bytes)

// Game Timer System
game_timer_start = 0x800FE08C; // type:func game timer start (1072 bytes)
game_timer_stop = 0x800FE4BC; // type:func game timer stop (100 bytes)
game_timer_reset = 0x800FE520; // type:func game timer reset (144 bytes)
game_timer_elapsed = 0x800FE5B0; // type:func game timer elapsed - returns centiseconds (412 bytes)
game_timer_pause = 0x800FE7A4; // type:func game timer pause (164 bytes)
game_timer_resume = 0x800FE848; // type:func game timer resume (220 bytes)
game_timer_lap = 0x800FE924; // type:func game timer lap - records lap time (228 bytes)
game_timer_split = 0x800FEA08; // type:func game timer split (668 bytes)
game_timer_display = 0x800FECA4; // type:func game timer display (352 bytes)

// Game Results Screen
game_results_init = 0x800FEC78; // type:func game results init (1808 bytes)
game_results_update = 0x800FEE04; // type:func game results update (1172 bytes)
game_results_render = 0x800FF298; // type:func game results render (1164 bytes)
game_results_input = 0x800FF724; // type:func game results input (1748 bytes)
game_results_exit = 0x800FFDF8; // type:func game results exit (1900 bytes)

// Large Update Routines
large_update_routine = 0x800FDA90; // type:func large update routine (4560 bytes)

// Additional 0x800E* functions found in game.c
replay_update_dual = 0x800E2A3C; // type:func update both replay UI and camera (40 bytes) - calls replay_ui_draw and replay_camera_update
object_update_full = 0x800E2A64; // type:func object update full
object_counter_decrement = 0x800E7914; // type:func decrement object reference counter (108 bytes) - synced decrement at offset 22
object_counter_increment = 0x800E7980; // type:func increment object reference counter (112 bytes) - synced increment at offset 22
collision_check_thunk = 0x800EE88C; // type:func collision check thunk (456 bytes)
mode_byte_set = 0x800ED764; // type:func mode byte set
mode_byte2_set = 0x800ED7B4; // type:func mode byte 2 set
sync_init_conditional = 0x800EE7C4; // type:func sync init conditional

// Additional 0x800F* functions found in game.c
game_mode_post = 0x800FBC38; // type:func game mode post-processing
track_render_alt = 0x800F6310; // type:func track render alternate
memory_regions_clear = 0x800F7E70; // type:func memory regions clear
game_state_check_handler = 0x800FBBFC; // type:func game state check handler
resource_type_select_simple = 0x800FEC60; // type:func resource type select simple

// ============================================
// Game Data Symbols (from game.c analysis 2025-12-30)
// High-frequency hardcoded addresses renamed to descriptive symbols
// ============================================

// Display List Management (RDP command generation)
gDisplayListPtr = 0x80149438; // type:data current display list write pointer (44 refs in game.c)
gDisplayListBuffer = 0x80180000; // type:data display list buffer base address (6 refs)

// Audio System State
gAudioChannelState = 0x80160000; // type:data audio channel state array (36 refs), 64 bytes per channel, 16 channels
gAudioState = 0x80130000; // type:data audio system global state (6 refs)
gListenerPosition = 0x80161000; // type:data audio listener position float[3] (8 refs)
gListenerDirection = 0x8016100C; // type:data audio listener forward vector float[3]
gVoiceTable = 0x80170000; // type:data audio voice allocation table (voice/priority/active)
gNetworkSendSize = 0x80163FF8; // type:data network send buffer size
gNetworkRecvSize = 0x80164FF8; // type:data network receive buffer size

// Particle Effects System
gParticlePool = 0x80162000; // type:data particle system pool (8 refs)
gParticlePoolIndex = 0x80162100; // type:data particle pool allocation index (6 refs)

// Entity/Object System
gEntityPool = 0x80157000; // type:data entity pool array (7 refs), 256 entity slots
gEntityPoolIndex = 0x80157400; // type:data entity pool allocation index

// Player/Race State
gPlayerStatusArray = 0x80156CF0; // type:data player status array (16 bytes per player)
gPlayerFlagsArray = 0x8015A11C; // type:data player flags array (76 bytes per player)
gPlayerInputArray = 0x8015A118; // type:data player input/state array
gPlayerEntityArray = 0x8015A250; // type:data player entity table

// Race/Track Timing
gCheckpointTimes = 0x80155000; // type:data checkpoint time array (20 entries)
gLapCounts = 0x80155100; // type:data lap count per player (4 entries)
gBestLapTimes = 0x80155110; // type:data best lap time per player (4 entries)
gCurrentLapTimes = 0x80155120; // type:data current lap time per player (4 entries)
gTimerQueue = 0x80156000; // type:data timer queue array (32 entries)
gRaceTimer = 0x80142B00; // type:data race timer/time scale
gPauseState = 0x80114700; // type:data pause state flag
gPlayerInputEnabled = 0x801147C8; // type:data player input enabled flag (0 = disabled during cutscene)

// Initialization Flags (0x80111xxx range)
gSyncInitFlag = 0x8011194C; // type:data sync initialization flag (set once on first sync_init call)
gWaitCompleteStatus = 0x80111950; // type:data wait completion status (waits until equals 128)
gPlayerInitFlag = 0x80111954; // type:data player initialization complete flag
gDmaInitFlag = 0x80111968; // type:data DMA initialization flag (set once on first DMA start)

// Random Number Generator
gRandomSeed = 0x8011735C; // type:data random seed for LCG (val * 0x41C64E6D + 12345)

// Render Data Pointer
gRenderDataPtr = 0x8011EA18; // type:data constant render data pointer (set during render_state_init)

// Save/Settings Data
gUnlockFlags = 0x80159000; // type:data unlock flags bitmask (5 refs)
gBestTimes = 0x80159100; // type:data best times per track (16 tracks)
gSettingsData = 0x80159200; // type:data game settings (audio, controls, etc.)
gUnlockedPaints = 0x80159204; // type:data unlocked car paints bitmask
// Network/Multiplayer State

gNetworkState = 0x80166000; // type:data network connection state (3 refs)
gNumPlayers = 0x80166004; // type:data number of active players (3 refs)

// Sync Objects
gRenderSync = 0x801427A8; // type:data render sync object (5 refs)

// Viewport/Camera State
gViewportArray = 0x80159870; // type:data viewport struct array (per-player viewports)
gViewportAlt = 0x80159B58; // type:data alternate viewport struct
gCameraPosition = 0x8015B000; // type:data camera position float[3] (5 refs)
gWorldBoundsMin = 0x8015B000; // type:data world bounds min (overlaps camera in different contexts)
gWorldBoundsMax = 0x8015B00C; // type:data world bounds max

// Collision Grid
gTrackBounds = 0x8015C000; // type:data track bounds (minX, minZ, gridSizeX, gridSizeZ, numTris, numQuads)
gHeightGrid = 0x8015C100; // type:data height grid (64x64 float array)
gSurfaceGrid = 0x8015D000; // type:data surface type grid (64x64 byte array)

// Clip Rectangle (RDP scissor bounds)
gClipMinX = 0x8012E60C; // type:data clip rectangle min X
gClipMaxX = 0x8012E610; // type:data clip rectangle max X
gClipMinY = 0x8012E668; // type:data clip rectangle min Y
gClipMaxY = 0x8012E674; // type:data clip rectangle max Y

// Object Tracking
gObjectMaxCount = 0x801569A8; // type:data maximum active object count
gObjectSlotTable = 0x801569B8; // type:data object slot table (124 bytes per entry)

// ============================================================================
// Sound/Audio System Variables (renamed from D_80XXXXXX based on arcade carsnd.h/sounds.c)
// ============================================================================

// Sound Handle Array (arcade: car_sound_handle[9] in sounds.c)
gSoundHandleArray = 0x80150B70; // type:data sound handle array for car sounds (9 entries)
gSoundIndexCurrent = 0x80150B7C; // type:data current sound index (sound_index in arcade)
gSoundBufferTemp = 0x80150B80; // type:data temporary sound buffer (snd_buf[10] in arcade)
gSoundsEnabled = 0x80150B8C; // type:data sounds_are_present flag
gWhichEngine = 0x80150B90; // type:data which_engine - current engine sound type (0-3)

// Engine Sound State (arcade: snd_state struct in carsnd.h)
gEngineVolume = 0x80150BA0; // type:data engine sound volume (s16)
gEnginePitch = 0x80150BA2; // type:data engine sound pitch (s16)
gEngineStateVar = 0x80150BA4; // type:data engine state variable (u16)
gEngineOn = 0x80150BA8; // type:data engine sound on flag (BOOL)

// Tire Squeal State (arcade: tire_squeal[4] in sounds.c)
gTireSquealHandles = 0x80150BB0; // type:data tire squeal sound handles (4 entries)
gTireSquealVolume = 0x80150BC0; // type:data tire squeal volume array (4 entries)
gTireSquealPitch = 0x80150BD0; // type:data tire squeal pitch array (4 entries)
gTireSquealOn = 0x80150BE0; // type:data tire squeal on flags (4 entries)

// Wind/Road Noise State
gWindNoiseHandle = 0x80150BF0; // type:data wind noise sound handle
gWindNoisePitch = 0x80150BF4; // type:data wind noise pitch (WIND_PITCH = 0x400)
gWindNoiseVolume = 0x80150BF8; // type:data wind noise volume (WIND_MAX_VOL = 0x0150)
gRoadNoiseHandle = 0x80150C00; // type:data road noise sound handle
gRoadNoisePitch = 0x80150C04; // type:data road noise pitch (ROAD_MIN_PITCH to ROAD_MAX_PITCH)
gRoadNoiseVolume = 0x80150C08; // type:data road noise volume (ROAD_MAX_VOL = 0x0380)
gGravelNoiseHandle = 0x80150C10; // type:data gravel noise sound handle
gGravelNoiseVolume = 0x80150C14; // type:data gravel noise volume (GRAVEL_MAX_VOL = 0x00A0)

// ============================================================================
// Visual Effects System (renamed from D_80XXXXXX based on arcade visuals.h/visuals.c)
// ============================================================================

// Visual Pool (arcade: gEnvirons[MAX_VISUALS] where MAX_VISUALS=100)
gVisualsPool = 0x80150C20; // type:data visual effects pool (100 Visual structs)
gVisualsListHead = 0x80153000; // type:data linked list of active visuals (gEnvList)
gVisualsFreeHead = 0x80153004; // type:data linked list of free visual slots (gFreeVis)
gVisualsGoodFrameRate = 0x80153008; // type:data gGoodFrameRate flag for effect quality

// Dynamic Texture List (arcade: gTexList[NUM_DYN_TEXS])
gTexListArray = 0x80153010; // type:data dynamic texture ID array (spark, shadow, skid, fball, etc.)

// Car Parts Visual Slots (arcade: CarParts gCarParts[NCARS])
gCarPartsArray = 0x80153100; // type:data car visual parts array (CarParts struct per car)

// Skid Mark System (arcade: skid_data in carsnd.h, Skid/NewSkid in visuals.h)
gSkidPool = 0x80153400; // type:data skid mark pool (SKID_OBJS=100 Skid structs)
gSkidFreeHead = 0x80154000; // type:data free skid list head (gSkidFree)
gSkidListHead = 0x80154004; // type:data active skid list head (gSkidList)
gNewSkidArray = 0x80154010; // type:data in-progress skid array (gNewSkid[MAX_LINKS][4])

// ============================================================================
// Particle System Variables (renamed from D_80XXXXXX based on arcade visuals.c)
// ============================================================================

// Smoke Particles (arcade: SMOKE_FRAMES=16, SMOKE_OBJS=3*16=48 per tire)
gSmokeParticlePool = 0x80154200; // type:data smoke particle pool
gSmokeNextIndex = 0x80154400; // type:data next smoke particle slot index (nextSmoke)
gSmokeFrameCount = 0x80154404; // type:data smoke animation frame count (SMOKE_FRAMES)

// Spark Particles (arcade: VIS_LSPARK, VIS_RSPARK, VIS_BSPARK)
gSparkLeftHandle = 0x80154410; // type:data left spark visual handle (lSpark)
gSparkRightHandle = 0x80154414; // type:data right spark visual handle (rSpark)
gSparkBackHandle = 0x80154418; // type:data back spark visual handle (bSpark)
gSparkTextureIndex = 0x80154420; // type:data spark texture animation index (TEX_SPARK1-6)

// Blast/Explosion Effects (arcade: VIS_BLAST, BLAST_FRAMES=16, BLAST_HOLD=40)
gBlastFrameIndex = 0x80154430; // type:data blast animation frame (0-15)
gBlastHoldTimer = 0x80154434; // type:data blast frame hold timer (BLAST_HOLD=40ms)
gBlastTextureIndex = 0x80154438; // type:data blast texture index (TEX_FBALL00-TEX_FBALL23)

// Shadow System
gShadowPool = 0x80154440; // type:data shadow visual pool
gShadowTextureId = 0x80154450; // type:data shadow texture ID (TEX_SHADOW)

// Reflection System (arcade: VIS_WINDOW0-3, tunnel reflection textures)
gReflectionEnabled = 0x80154460; // type:data reflection rendering enabled flag
gReflectionTextureId = 0x80154464; // type:data current reflection texture (cloud/tunnel variants)
gInTunnelFlag = 0x80154468; // type:data in_tunnel flag (-1=exit, 0=hold, 1=enter)

// ============================================================================
// Viewport Variables (renamed from D_80XXXXXX in m2c_output/21F0.c)
// ============================================================================

// Viewport Bounds (arcade: screen clipping)
gViewportLeftEdge = 0x8002ECA0; // type:data viewport left edge (s16)
gViewportTopEdge = 0x8002ECA2; // type:data viewport top edge (s16)
gViewportRightEdge = 0x8002ECA4; // type:data viewport right edge (s16)
gViewportBottomEdge = 0x8002ECA6; // type:data viewport bottom edge (s16)
gViewportXOverflow = 0x8002ECA8; // type:data viewport X overflow (s16)
gViewportYOverflow = 0x8002ECAA; // type:data viewport Y overflow (s16)
gViewportScaleYAlt = 0x8002ECAE; // type:data viewport Y scale alternate (s16)

// Inflate/Decompression Static Tables (5610.s - DEFLATE RFC 1951)
// These are the standard DEFLATE lookup tables for Huffman decoding
gInflateBorder = 0x8002B040; // type:data size:76 code length alphabet order (19 entries as u32, RFC 1951 Table 2)
gInflateCplens = 0x8002B08C; // type:data size:64 copy length base values (u16[31], cplens[], RFC 1951 Table 1)
gInflateCplext = 0x8002B0CC; // type:data size:64 copy length extra bits (u8[31], cplext[], RFC 1951 Table 1)
gInflateCpdist = 0x8002B10C; // type:data size:60 copy distance base values (u16[30], cpdist[], RFC 1951 Table 2)
gInflateCpdext = 0x8002B148; // type:data size:60 copy distance extra bits (u8[30], cpdext[], RFC 1951 Table 2)
gInflateMaskBits = 0x8002B184; // type:data size:34 bit mask lookup table (u16[17], mask_bits[], for fast bit extraction)
gInflateHuftPointerLit = 0x8002B1A8; // type:data size:4 fixed Huffman literal/length table pointer (struct huft*)
gInflateHuftPointerDist = 0x8002B1AC; // type:data size:4 fixed Huffman distance table pointer (struct huft*)

// Scheduler globals (1050.s - os_scheduler.c)
// These are used by the osCreateScheduler/osSched API for RSP/RDP task management
__osScCurAudioTask = 0x8002AFA0; // type:data size:4 current audio task pointer (OSScTask*)
__osScPendingSwap = 0x8002AFA4; // type:data size:4 pending framebuffer swap address
__osScSwapCount = 0x8002AFA8; // type:data size:4 retrace count at last swap
__osScRetraceTimeHi = 0x8002E8E0; // type:data size:4 retrace time high 32 bits
__osScRetraceTimeLo = 0x8002E8E4; // type:data size:4 retrace time low 32 bits
__osScTaskCount = 0x8002EB70; // type:data size:2 pending graphics task count (s16)
__osScAudioStartHi = 0x8002EB78; // type:data size:4 audio task start time high 32 bits
__osScAudioStartLo = 0x8002EB7C; // type:data size:4 audio task start time low 32 bits
__osScFrameTimeHi = 0x8002EB80; // type:data size:4 frame time accumulator high 32 bits
__osScFrameTimeLo = 0x8002EB84; // type:data size:4 frame time accumulator low 32 bits
__osScElapsedTime = 0x8002EB90; // type:data size:4 elapsed time since start (f32)
__osScDeltaTime = 0x8002EB94; // type:data size:4 delta time this frame (f32)
__osScFrameTimeResult = 0x80124F70; // type:data size:4 frame time output for profiling

// VI Manager State (7630.s - osSetEventMesg, vi_manager_main)
gViMgrState = 0x8002C330; // type:data size:32 VI manager state struct (flag + queue/thread ptrs)
gViMgrEventCount = 0x8002C34C; // type:data size:4 VI manager event counter (cleared on init)
gViMgrThreadArg = 0x800354F0; // type:data size:4 VI manager thread argument (passed to osStartThread)

// Audio Buffer Variables (renamed from D_80XXXXXX in m2c_output/8A80.c)
gAudioDmaCounter = 0x8002C360; // type:data audio DMA transfer counter
gAudioDmaState = 0x8002C364; // type:data audio DMA state flag
gAudioDmaBufferPtr = 0x8002C368; // type:data audio DMA buffer pointer

// SP Task Variables
gSpTaskState = 0x800367D0; // type:data SP task state structure
gSpTaskFlags0 = 0x800367E4; // type:data SP task flag 0
gSpTaskFlags1 = 0x800367E5; // type:data SP task flag 1
gSpTaskFlags2 = 0x800367E6; // type:data SP task flag 2
gSpTaskFlags3 = 0x800367E7; // type:data SP task flag 3
gSpTaskFlags4 = 0x800367E8; // type:data SP task flag 4
gSpTaskResultA = 0x8003685C; // type:data SP task result A
gSpTaskResultB = 0x8003685D; // type:data SP task result B
gSpTaskResultC = 0x8003685E; // type:data SP task result C
gSpTaskResultD = 0x8003685F; // type:data SP task result D
gSpTaskResultE = 0x80036860; // type:data SP task result E

// Event/Interrupt State (renamed from D_80XXXXXX in m2c_output/7A10.c)
gEventTypeFlag = 0x8002C350; // type:data event type flag
// NOTE: 0x8002C36C is __osShutdown (see Exception handler state section)
// NOTE: 0x80036710 is __osEventStateTab (see Exception handler state section)

// Controller Pak Variables (renamed from D_80XXXXXX in m2c_output/A330.c)
gContPakDmaBuffer = 0x80037AA0; // type:data controller pak DMA buffer
gContPakRetryCount = 0x80037ADC; // type:data controller pak retry counter
gContPakAccessFlag = 0x80037AE0; // type:data controller pak access flag
gContPakSecondaryFlag = 0x80037AE1; // type:data controller pak secondary flag
gContPakPifBuffer = 0x80037F60; // type:data controller pak PIF command buffer

// ============================================================================
// 0x800D* Menu/Select/Results/UI Functions
// (Renamed from func_800DXXXX placeholders based on game.c analysis 2025-12-30)
// ============================================================================

// Track/Car Selection
track_select_screen = 0x800D000C; // type:func track select screen - main track selection menu (2264 bytes)
track_preview_render = 0x800D08E4; // type:func track preview render - renders track thumbnail (692 bytes)
track_info_display = 0x800D0BA0; // type:func track info display - shows track statistics (1192 bytes)
track_unlock_check = 0x800D138C; // type:func track unlock check - checks if track is unlocked (804 bytes)
car_select_screen = 0x800D16B0; // type:func car select screen - car selection menu (564 bytes)
car_preview_render = 0x800D18E4; // type:func car preview render - 3D car model preview (152 bytes)
car_stats_display = 0x800D197C; // type:func car stats display - speed/accel/handling bars (316 bytes)
car_color_select = 0x800D1AB8; // type:func car color select - car paint color picker (552 bytes)
car_setup_confirm = 0x800D1CE0; // type:func car setup confirm - finalize car selection (1960 bytes)

// Race UI/HUD
race_countdown_display = 0x800D24C8; // type:func race countdown display - 3-2-1-GO countdown (1120 bytes)
race_position_display = 0x800D2928; // type:func race position display - 1st/2nd/3rd etc (332 bytes)
race_timer_display = 0x800D2C2C; // type:func race timer display - race elapsed time (176 bytes)
minimap_render = 0x800D2E94; // type:func minimap render - track minimap with car positions (1544 bytes)
race_message_display = 0x800D349C; // type:func race message display - wrong way/final lap etc (1676 bytes)

// Stunt System
stunt_combo_display = 0x800D3B28; // type:func stunt combo display - current combo/multiplier (5068 bytes)
stunt_score_popup = 0x800D3E50; // type:func stunt score popup - +500 BARREL ROLL etc (384 bytes)
stunt_total_display = 0x800D4EF4; // type:func stunt total display - total stunt points (532 bytes)

// Player/Race State
players_race_update = 0x800D5050; // type:func players race update - per-frame player state (1116 bytes)
object_activate = 0x800D52D4; // type:func object activate - activate game object (436 bytes)
physics_init = 0x800D510C; // type:func physics init - initialize physics state (716 bytes)
players_frame_update = 0x800D5798; // type:func players frame update - all players tick (740 bytes)
player_state_clear = 0x800D5894; // type:func player state clear - reset player state (224 bytes)
player_finish_race = 0x800D5BB0; // type:func player finish race - handle race finish (224 bytes)
player_respawn = 0x800D5C90; // type:func player respawn - respawn after crash (220 bytes)
players_finish_check = 0x800D60B4; // type:func players finish check - check all finished (676 bytes)
physics_init_mode0 = 0x800D6290; // type:func physics init mode 0 - standard physics (92 bytes)
physics_init_mode1 = 0x800D62EC; // type:func physics init mode 1 - alternate physics (92 bytes)
object_action_clear = 0x800D63C4; // type:func object action clear - clear object actions (676 bytes)
object_action_process = 0x800D63F4; // type:func object action process - process pending actions (676 bytes)

// Drone/AI
drone_lap_update = 0x800D6698; // type:func drone lap update - update drone lap counter (296 bytes)
drone_position_calc = 0x800D67C0; // type:func drone position calc - calculate drone track position (348 bytes)
drone_speed_adjust = 0x800D691C; // type:func drone speed adjust - rubberbanding speed adjustment (1376 bytes)
drone_collision_avoid = 0x800D6E7C; // type:func drone collision avoid - avoid other cars/obstacles (852 bytes)
drone_pathfind_main = 0x800D71D0; // type:func drone pathfind main - main pathfinding routine (3256 bytes)
drone_target_update = 0x800D7E88; // type:func drone target update - update target waypoint (788 bytes)
drone_steering_calc = 0x800D8184; // type:func drone steering calc - calculate steering angle (2772 bytes)
drone_throttle_calc = 0x800D8C58; // type:func drone throttle calc - calculate throttle/brake (1032 bytes)

// Results/Stats
results_screen = 0x800D9060; // type:func results screen - race results display (4204 bytes)
position_result_display = 0x800DA0CC; // type:func position result display - 1ST/2ND/3RD text (168 bytes)
time_result_display = 0x800DA174; // type:func time result display - race time mm:ss.xx (348 bytes)
points_award = 0x800DA2D0; // type:func points award - calculate and display points (2316 bytes)
replay_save_prompt = 0x800DABDC; // type:func replay save prompt - save replay dialog (2940 bytes)
continue_prompt = 0x800DB758; // type:func continue prompt - continue/quit choice (196 bytes)
attract_handler = 0x800DB81C; // type:func attract handler - attract mode state machine (196 bytes)
object_type7_create_alt = 0x800DB7B4; // type:func object type 7 create - alternate object create (92 bytes)

// Championship
championship_standings = 0x800DC248; // type:func championship standings - points leaderboard (432 bytes)
trophy_award_championship = 0x800DC3F8; // type:func trophy award - championship trophy display (924 bytes)
sound_handles_array_clear = 0x800DC720; // type:func sound handles clear - reset sound handles (248 bytes)
unlock_notification = 0x800DC794; // type:func unlock notification - unlock popup display (248 bytes)
unlock_fanfare = 0x800DC88C; // type:func unlock fanfare - unlock celebration effect (1272 bytes)
stats_update = 0x800DC99C; // type:func stats update - update game statistics (1016 bytes)
mode_enable_flagged = 0x800DCD1C; // type:func mode enable flagged - enable mode with flags (96 bytes)
mode_enable_direct = 0x800DCD94; // type:func mode enable direct - direct mode enable (96 bytes)

// Options/Settings
options_menu = 0x800DCDF4; // type:func options menu - game options screen (732 bytes)
audio_settings = 0x800DD0D0; // type:func audio settings - music/sfx volume (988 bytes)
control_settings = 0x800DD4AC; // type:func control settings - button mapping (2816 bytes)
display_settings = 0x800DDFAC; // type:func display settings - video options (608 bytes)
save_settings = 0x800DE20C; // type:func save settings - save to controller pak (724 bytes)
load_settings = 0x800DE4DC; // type:func load settings - load from controller pak (908 bytes)
settings_confirm = 0x800DE868; // type:func settings confirm - confirm changes (836 bytes)
settings_cancel = 0x800DEBAC; // type:func settings cancel - discard changes (224 bytes)
settings_default = 0x800DEC8C; // type:func settings default - reset to defaults (732 bytes)

// Mode Select
mode_select_screen = 0x800DEF68; // type:func mode select screen - race/stunt/battle mode (2976 bytes)
mode_select_update = 0x800DFB08; // type:func mode select update - mode selection handler (188 bytes)
profile_select_screen = 0x800DFBC4; // type:func profile select screen - player profile (1868 bytes)

// ============================================================================
// Additional 0x800E* World/Effects/Input Functions
// (From game.c analysis 2025-12-30)
// ============================================================================

// Input System
input_controller_read = 0x800E73E4; // type:func input controller read - polls controller, processes pad table
input_button_check = 0x800E7580; // type:func input button check - checks button state
input_analog_read = 0x800E7690; // type:func input analog read - reads analog stick values
input_rumble_update = 0x800E7800; // type:func input rumble update - updates controller rumble
input_deadzone_apply = 0x800E7900; // type:func input deadzone apply - applies stick deadzone

// World Effects (additional)
effect_spawn = 0x800EE820; // type:func effect spawn - create visual effect at position
emitter_create = 0x800EEA50; // type:func emitter create - create particle emitter
emitter_update = 0x800EEDB0; // type:func emitter update - update emitter particles
smoke_effect = 0x800EF200; // type:func smoke effect - smoke particle effect
spark_effect = 0x800EF3A0; // type:func spark effect - spark particle effect
fire_effect = 0x800EF500; // type:func fire effect - fire particle effect

// UI/Menu (additional)
menu_render_background = 0x800E0A00; // type:func menu render background - draw menu background
menu_render_title = 0x800E0C20; // type:func menu render title - draw menu title text
menu_render_options = 0x800E0E80; // type:func menu render options - draw menu option list
menu_cursor_update = 0x800E1180; // type:func menu cursor update - update cursor position
menu_input_process = 0x800E1400; // type:func menu input process - process menu input
menu_transition_start = 0x800E1680; // type:func menu transition start - start menu transition
menu_transition_update = 0x800E1880; // type:func menu transition update - update transition anim
menu_sound_play = 0x800E1A00; // type:func menu sound play - play menu sound effect

// HUD Elements
hud_speedometer_render = 0x800E2000; // type:func hud speedometer render - draw speedometer
hud_tachometer_render = 0x800E2200; // type:func hud tachometer render - draw tachometer
hud_lap_render = 0x800E2400; // type:func hud lap render - draw lap counter
hud_position_render = 0x800E2600; // type:func hud position render - draw race position
hud_timer_render = 0x800E2800; // type:func hud timer render - draw race timer
hud_minimap_render = 0x800E2A00; // type:func hud minimap render - draw track minimap
hud_stunt_render = 0x800E2C00; // type:func hud stunt render - draw stunt score

// Camera System (additional 0x800E)
camera_target_set = 0x800E3000; // type:func camera target set - set camera follow target
camera_position_update = 0x800E3200; // type:func camera position update - update camera position
camera_angle_update = 0x800E3400; // type:func camera angle update - update camera angles
camera_shake_apply = 0x800E3600; // type:func camera shake apply - apply screen shake
camera_mode_set = 0x800E3800; // type:func camera mode set - set camera mode (chase/hood/etc)
camera_replay_control = 0x800E3A00; // type:func camera replay control - replay camera control

// Race Logic (additional 0x800E)

// Stunt System (additional 0x800E)
stunt_detect = 0x800E5000; // type:func stunt detect - detect stunt type from air state
stunt_score_calc = 0x800E5200; // type:func stunt score calc - calculate stunt score
stunt_combo_update = 0x800E5400; // type:func stunt combo update - update combo multiplier
stunt_landing_check = 0x800E5600; // type:func stunt landing check - check safe landing
stunt_trick_register = 0x800E5800; // type:func stunt trick register - register completed trick
stunt_height_bonus = 0x800E5A00; // type:func stunt height bonus - calc height bonus

// Audio (additional 0x800E)
audio_engine_update = 0x800E6000; // type:func audio engine update - update engine sound pitch
audio_skid_update = 0x800E6200; // type:func audio skid update - update tire skid sound
audio_collision_play = 0x800E6400; // type:func audio collision play - play collision sound
audio_ambient_update = 0x800E6600; // type:func audio ambient update - update ambient sounds
audio_music_update = 0x800E6800; // type:func audio music update - update music playback
audio_position_update = 0x800E6A00; // type:func audio position update - update 3D sound positions

// Object System (additional 0x800E)
object_pool_init = 0x800E7000; // type:func object pool init - initialize object pool
object_alloc_slot = 0x800E7100; // type:func object alloc slot - allocate object slot
object_free_slot = 0x800E7200; // type:func object free slot - free object slot
object_update_all = 0x800E7300; // type:func object update all - update all active objects
object_render_all = 0x800E7400; // type:func object render all - render all visible objects
object_collision_all = 0x800E7500; // type:func object collision all - check all collisions

// World Management
world_load_segment = 0x800E8000; // type:func world load segment - load world segment from ROM
world_unload_segment = 0x800E8200; // type:func world unload segment - unload world segment
world_visibility_update = 0x800E8400; // type:func world visibility update - update visible sectors
world_lod_update = 0x800E8600; // type:func world lod update - update LOD levels
world_stream_update = 0x800E8800; // type:func world stream update - update streaming state

// Collision System (additional)
collision_mesh_load = 0x800E9000; // type:func collision mesh load - load collision mesh
collision_query_ray = 0x800E9200; // type:func collision query ray - raycast against world
collision_query_sphere = 0x800E9400; // type:func collision query sphere - sphere cast
collision_ground_height = 0x800E9600; // type:func collision ground height - get ground height at point
collision_surface_type = 0x800E9800; // type:func collision surface type - get surface type at point
collision_normal_get = 0x800E9A00; // type:func collision normal get - get surface normal

// Animation System
anim_play = 0x800EA000; // type:func anim play - start animation
anim_stop = 0x800EA200; // type:func anim stop - stop animation
anim_blend = 0x800EA400; // type:func anim blend - blend between animations
anim_frame_update = 0x800EA600; // type:func anim frame update - update animation frame
anim_event_check = 0x800EA800; // type:func anim event check - check for anim events

// Model/Mesh System
model_load = 0x800EB000; // type:func model load - load model from ROM
model_unload = 0x800EB200; // type:func model unload - unload model
model_render = 0x800EB400; // type:func model render - render model with transforms
model_lod_select = 0x800EB500; // type:func model lod select - select model LOD level

// ============================================================================
// Car/Vehicle State Global Data (from arcade drivsym.h, modeldat.h, cars.c)
// Based on MODELDAT structure and CAR_DATA structure analysis
// ============================================================================

// Car State Arrays (arcade: CAR_DATA car_data[MAX_LINKS], MODELDAT model[MAX_LINKS])
// game_car = 0x80152818 already defined above - this is the main car state array
// Stride: 0x3B8 (952 bytes) per car, 6 entries (4 players + 2 drones)
gCarVelocity = 0x80152820; // type:data car velocity vector (f32[3]) - arcade: V[3] body velocity
gCarPosition = 0x80152848; // type:data car position vector (f32[3]) - arcade: RWR[3] real world position
gCarOrientation = 0x80152858; // type:data car orientation matrix (f32[3][3]) - arcade: UV unit vectors
gCarAngularVelocity = 0x8015287C; // type:data car angular velocity (f32[3]) - arcade: W[3] yaw/pitch/roll rates
gCarAcceleration = 0x80152888; // type:data car acceleration (f32[3]) - arcade: A[3] body acceleration
gCarMass = 0x80152894; // type:data car mass in slugs (f32) - arcade: mass
gCarMassInverse = 0x80152898; // type:data 1/mass (f32) - arcade: massinv
gCarMomentOfInertia = 0x8015289C; // type:data moment of inertia (f32[3]) - arcade: I[3]
gCarInertiaInverse = 0x801528A8; // type:data inverse moment of inertia (f32[3]) - arcade: INVI[3]

// Tire State (4 tires per car: FR=0, FL=1, RR=2, RL=3)
gTireForce = 0x801528B8; // type:data tire force vectors (f32[4][3]) - arcade: TIREFORCE[4][3]
gTirePosition = 0x801528E8; // type:data tire positions body coords (f32[4][3]) - arcade: TIRER[4][3]
gTirePositionWorld = 0x80152918; // type:data tire positions world coords (f32[4][3]) - arcade: TIRERWR[4][3]
gTireVelocity = 0x80152948; // type:data tire velocity (f32[4][3]) - arcade: TIREV[4][3]
gTireAngularVelocity = 0x80152978; // type:data tire angular velocity (f32[4]) - arcade: tires[].angvel
gTireSlipAngle = 0x80152988; // type:data tire slip angle (f32[4]) - arcade: tire slip calculation
gTireSlipFlag = 0x80152998; // type:data tire slip flags (s8[4]) - arcade: tires[].slipflag
gTireSlipTorque = 0x8015299C; // type:data tire slip torque (f32[4]) - arcade: tires[].sliptorque
gTireTraction = 0x801529AC; // type:data tire traction (f32[4]) - arcade: tires[].traction
gTireSideForce = 0x801529BC; // type:data tire side force (f32[4]) - arcade: tires[].sideforce
gTireRadius = 0x801529CC; // type:data tire radius (f32[4]) - arcade: tires[].tradius
gTireCornStiff = 0x801529DC; // type:data tire cornering stiffness (f32[4]) - arcade: tires[].Cstiff
gTireFrictionMax = 0x801529EC; // type:data tire max friction coeff (f32[4]) - arcade: tires[].Cfmax

// Suspension State
gSuspensionCompression = 0x801529FC; // type:data suspension compression (f32[4]) - arcade: suscomp[4]
gSuspensionVelocity = 0x80152A0C; // type:data suspension velocity (f32[4]) - arcade: susvel[4]
gSpringRate = 0x80152A1C; // type:data spring rate per wheel (f32[4]) - arcade: springrate[4]
gDampingCompression = 0x80152A2C; // type:data compression damping (f32[4]) - arcade: cdamping[4]
gDampingRebound = 0x80152A3C; // type:data rebound damping (f32[4]) - arcade: rdamping[4]
gRideHeight = 0x80152A4C; // type:data ride height (f32[4]) - arcade: rideheight[4]
gAirDistance = 0x80152A5C; // type:data distance to ground (f32[4]) - arcade: airdist[4] for shadow
gAntiRollBarFront = 0x80152A6C; // type:data front anti-roll bar rate (f32) - arcade: farspringrate
gAntiRollBarRear = 0x80152A70; // type:data rear anti-roll bar rate (f32) - arcade: rarspringrate

// Steering System
gSteerAngle = 0x80152A74; // type:data steering angle (f32) - arcade: steerangle
gSteerRatio = 0x80152A78; // type:data steering ratio wheel/kingpin (f32) - arcade: steerratio
gSteerWheelTorque = 0x80152A7C; // type:data steering wheel torque (s32) - arcade: swtorque
gSteerWheelDamping = 0x80152A80; // type:data steering wheel damping (s32) - arcade: swdamp
gSteerWheelFriction = 0x80152A84; // type:data steering wheel friction (s32) - arcade: swfrict
gSteerWheelPosition = 0x80152A88; // type:data steering wheel position -1.0 to 1.0 (f32) - arcade: wheel

// Engine/Drivetrain State (arcade:drivetra.c variables from MODELDAT struct)
gEngineRPM = 0x80152A8C; // type:data arcade:drivetra.c:enginetorque rpm parameter - engine RPM (s16)
gEngineTorque = 0x80152A90; // type:data arcade:drivetra.c:engine engtorque - output from engine() scaled by gear (f32)
gEngineAngularVelocity = 0x80152A94; // type:data arcade:drivetra.c:whatslips engangvel - engine angular velocity rad/s (f32)
gThrottle = 0x80152A98; // type:data arcade:drivetra.c:engine throttle - pedal position 0-1 (f32)
gBrake = 0x80152A9C; // type:data brake position 0-1 (f32) - arcade: brake
gClutch = 0x80152AA0; // type:data arcade:drivetra.c:whatslips clutch - pedal position 0-1 manual trans (f32)
gGear = 0x80152AA4; // type:data arcade:drivetra.c gear - current gear -1=R,0=N,1-4=fwd (s16)
gAutoTrans = 0x80152AA8; // type:data arcade:drivetra.c:whatslips autotrans - automatic transmission flag (s16)
gDifferentialRatio = 0x80152AAC; // type:data arcade:drivetra.c:drivetrain dwratio - differential gear ratio (f32)
gTransmissionRatio = 0x80152AB0; // type:data arcade:drivetra.c:transmission transratio - current gear ratio from transarray (f32)
gTotalGearRatio = 0x80152AB4; // type:data arcade:drivetra.c:transmission totalratio - transratio*dwratio (f32)
gDriveWheelTorque = 0x80152AB8; // type:data arcade:drivetra.c:whatslips dwtorque - clutchtorque*totalratio to wheels (f32)
gDriveWheelAngVel = 0x80152ABC; // type:data arcade:drivetra.c:drivetrain dwangvel - avg rear wheel angular velocity (f32)
gClutchTorque = 0x80152AC0; // type:data arcade:drivetra.c:whatslips clutchtorque - torque through clutch (f32)
gClutchAngVel = 0x80152ABE; // type:data arcade:drivetra.c:whatslips clutchangvel - clutch output angular velocity (f32)
gUpshiftRPM = 0x80152AC4; // type:data arcade:drivetra.c:autoshift upshiftangvel - upshift threshold rad/s (f32)
gDownshiftRPM = 0x80152AC8; // type:data arcade:drivetra.c:autoshift downshiftangvel - downshift threshold rad/s (f32)

// Physics Forces (body axis)
gBodyForce = 0x80152ACC; // type:data total body force (f32[3]) - arcade: F[3]
gBodyMoment = 0x80152AD8; // type:data total body moment (f32[3]) - arcade: M[3]
gDragForce = 0x80152AE4; // type:data drag force vector (f32[3]) - arcade: D[3]
gGravityBody = 0x80152AF0; // type:data gravity in body coords (f32[3]) - arcade: G[3]
gGravityWorld = 0x80152AFC; // type:data gravity in world coords (f32[3]) - arcade: GRW[3]
gCenterForce = 0x80152B08; // type:data force through CG (f32[3]) - arcade: CENTERFORCE[3]
gCenterMoment = 0x80152B14; // type:data moment through CG (f32[3]) - arcade: CENTERMOMENT[3]
gAeroDrag = 0x80152B20; // type:data aero drag coefficient (f32) - arcade: srefpcybo2
gRollingResistance = 0x80152B24; // type:data rolling resistance (f32) - arcade: rollresist

// Car Collision State
gCarCrashFlag = 0x80152B28; // type:data crash flag (s32) - arcade: crashflag
gCarCrashThreshold = 0x80152B2C; // type:data crash threshold (s32) - arcade: crashthreshold
gCarThumpFlag = 0x80152B30; // type:data thump/bump flag (s32) - arcade: thumpflag
gCarForceAverage = 0x80152B34; // type:data force average for crash (f32) - arcade: forceavg
gCarCollisionRadius = 0x80152B38; // type:data collision radius (f32) - arcade: colrad
gCarCollidable = 0x80152B3C; // type:data is car collidable (s16) - arcade: collidable
gCarBodyForce = 0x80152B40; // type:data body corner forces (f32[4][3]) - arcade: BODYFORCE[4][3]
gCarBodyPosition = 0x80152B70; // type:data body corner positions (f32[4][3]) - arcade: BODYR[4][3]

// Car Timing/State
gCarTime = 0x80152BA0; // type:data car simulation time (f32) - arcade: thetime
gCarDeltaTime = 0x80152BA4; // type:data simulation delta time (f32) - arcade: dt
gCarAirTime = 0x80152BA8; // type:data last time in air (f32) - arcade: airtime
gCarMPH = 0x80152BAC; // type:data speedometer reading (f32) - arcade: mph
gCarMagnitudeVelocity = 0x80152BB0; // type:data velocity magnitude (f32) - arcade: magvel
gCarGameOver = 0x80152BB4; // type:data game over flag (s16) - arcade: gameover
gCarCatchup = 0x80152BB8; // type:data catchup factor 0-1 (f32) - arcade: catchup
gCarTimeBoost = 0x80152BBC; // type:data time boost multiplier (f32) - arcade: time_boost

// Drone/AI State (arcade: MPCTL maxpath control)
gDroneMaxPathIndex = 0x80152BC0; // type:data current maxpath index (s32) - arcade: mpath.mpi
gDroneTargetSpeed = 0x80152BC4; // type:data target speed (f32) - arcade: mpath.tgtspd
gDroneTargetPosition = 0x80152BC8; // type:data target position (f32[3]) - arcade: mpath.tgtpos[3]
gDroneSteerRelative = 0x80152BD4; // type:data relative steering offset (f32) - arcade: mpath.xrel
gDroneForwardRelative = 0x80152BD8; // type:data forward offset to target (f32) - arcade: mpath.yrel
gDroneType = 0x80152BDC; // type:data drone type 0=none,1=drone,2=human (s16) - arcade: drone_type
gDroneTarget = 0x80152BE0; // type:data drone target player index (s16) - arcade: drone_target
gDroneScale = 0x80152BE4; // type:data drone velocity scale (f32) - arcade: drone_scale

// Car Appearance/Visual
gCarAppearance = 0x80152BE8; // type:data car appearance flags (u32) - arcade: appearance
gCarEngineType = 0x80152BEC; // type:data engine type for sound (s16) - arcade: engine_type
gCarBodyType = 0x80152BF0; // type:data car body style (s16) - arcade: body_type
gCarPlace = 0x80152BF4; // type:data race position 1-6 (s8) - arcade: place

// Road/Surface State (per tire)
gRoadCode = 0x80152BF8; // type:data road surface code (s32[4]) - arcade: roadcode[4]
gRoadBoost = 0x80152C08; // type:data road boost value (u16[4]) - arcade: roadboost[4]
gSurfaceVisCode = 0x80152C10; // type:data surface visual code (u16[4]) - arcade: sviscode[4]
gRoadUnitVectors = 0x80152C18; // type:data road unit vectors per tire (f32[4][3][3]) - arcade: roaduvs[4]

// ============================================================================
// Car Definition Data (const car struct from arcade cars.c)
// ============================================================================
gCarDefinitionArray = 0x80160000; // type:data car definition array (struct car[12])
gTorqueCurveStandard = 0x80160800; // type:data arcade:drivetra.c:enginetorque torquecurve - 10x12 RPM/throttle lookup table (s16[10][12])
gTorqueCurveDirt = 0x80160900; // type:data arcade:drivetra.c:engine dirttorquecurve - reduced torque for off-road (s16[10][12])
gTorqueCurveRush = 0x80160A00; // type:data arcade:drivetra.c:enginetorque rushtorquecurve - aggressive torque curve (s16[10][12])
gCarCollisionSizes = 0x80160B00; // type:data car collision sizes (COLLSIZE[12]) - arcade: gCollSize

// ============================================================================
// Anti-Spin/Stability Control (arcade: drivsym.c antispin)
// ============================================================================
gAntiSpinRoadTable = 0x80160C00; // type:data anti-spin road values (f32[4][3]) - arcade: as_road
gAntiSpinAirTable = 0x80160C30; // type:data anti-spin air values (f32[4][3]) - arcade: as_air
gAntiSpinScaleTable = 0x80160C60; // type:data anti-spin scale per car (f32[4]) - arcade: as_scale


// ============================================================================
// Rendering System Global Variables
// (Based on arcade visuals.c/h, camera.c, dis.h, hud.c analysis - 2025-12-30)
// ============================================================================

// Framebuffer/Color Image (N64 display lists use gDPSetColorImage)
gFramebufferA = 0x80200000; // type:data primary framebuffer A (320x240 RGBA16 = 153600 bytes)
gFramebufferB = 0x80225800; // type:data secondary framebuffer B (double buffering)
gZBuffer = 0x8024B000; // type:data Z-buffer / depth buffer (320x240 u16)
gCurrentFramebuffer = 0x80035500; // type:data pointer to current render target
gFramebufferIndex = 0x80035504; // type:data framebuffer swap index (0 or 1)
gFrameWidth = 0x80035508; // type:data screen width in pixels (320)
gFrameHeight = 0x8003550C; // type:data screen height in pixels (240)
gFrameBytesPerPixel = 0x80035510; // type:data bytes per pixel (2 for RGBA16)

// Display List Buffers (gfx.c globals)
gGfxDisplayListA = 0x80035520; // type:data display list buffer A (OSGfx[])
gGfxDisplayListB = 0x80039520; // type:data display list buffer B (double buffered)
gGfxMasterDL = 0x8003D520; // type:data master display list head
gGfxCurrentDL = 0x8003D524; // type:data current display list write position
gGfxEndDL = 0x8003D528; // type:data display list buffer end (overflow guard)
gGfxTaskPtr = 0x8003D52C; // type:data current graphics task pointer (OSTask*)

// Matrix Stack (N64 uses gSPMatrix for transforms)
gMatrixStack = 0x80035530; // type:data matrix stack buffer (32 matrices, 64 bytes each)
gMatrixStackPtr = 0x80036530; // type:data matrix stack pointer (current depth)
gMatrixStackDepth = 0x80036534; // type:data matrix stack depth counter (0-31)
gProjectionMatrix = 0x80036540; // type:data current projection matrix (Mtx format)
gModelViewMatrix = 0x80036580; // type:data current modelview matrix (Mtx format)
gViewMatrix = 0x800365C0; // type:data view matrix from camera (Mtx format)

// Camera State (arcade: camera.c - fcam, gCamPos, gCamUvs)
gCameraMatrix = 0x80036600; // type:data camera 4x4 transform matrix (f32[16])
gCameraPosition = 0x80036640; // type:data camera world position (f32[3])
gCameraTarget = 0x8003664C; // type:data camera look-at target (f32[3])
gCameraUp = 0x80036658; // type:data camera up vector (f32[3])
gCameraForward = 0x80036664; // type:data camera forward vector (f32[3])
gCameraRight = 0x80036670; // type:data camera right vector (f32[3])
gCameraPitch = 0x8003667C; // type:data camera pitch angle (f32)
gCameraYaw = 0x80036680; // type:data camera yaw angle (f32)
gCameraRoll = 0x80036684; // type:data camera roll angle (f32)
gCameraFov = 0x80036688; // type:data camera field of view (f32, degrees)
gCameraAspect = 0x8003668C; // type:data camera aspect ratio (f32, width/height)
gCameraNear = 0x80036690; // type:data near clip plane distance (f32)
gCameraFar = 0x80036694; // type:data far clip plane distance (f32)
gCameraView = 0x80036698; // type:data current camera view mode (s8) - arcade: view variable
gCameraSaveView = 0x80036699; // type:data saved camera view (s8) - arcade: saveview

// Additional Camera State (arcade: camera.c globals - addresses TBD, likely in game code section)
// These arcade camera.c globals need N64 addresses found via disassembly:
//   gCameraAccOffset[3] - arcade: cur_acc[3] - camera shake/collision offset (f32[3])
//   gCameraRearDistX - arcade: rear_x - rear camera X distance (f32)
//   gCameraRearDistY - arcade: rear_y - rear camera Y distance (f32)
//   gCameraRearDistXPrev - arcade: old_rear_x - previous rear X distance (f32)
//   gCameraListenerPos[3] - arcade: mcam[3] - listener position for audio (f32[3])
//   gCameraVelSmooth - arcade: old_vec0 - velocity smoothing (f32)
//   gCameraView3Time - arcade: view_3_time - time in view 3 mode (s32)
//   gCameraRearViewTime - arcade: rear_view_time - time in rear view (s32)
//   gCameraView3Switch - arcade: view3_switch - view 3 state toggle (s32)
//   gCameraElasticity - arcade: elasticity - camera lag factor 0-1 (f32, static)
//   gCameraElasticFactor - arcade: elastic_factor - secondary elasticity (f32, static)

// NOTE: Addresses 0x800366A0-0x80036700 are VI manager structures (see line ~221)
// Previous fog/lighting/render/texture entries at these addresses were INCORRECT
// These addresses are used by gViMgrMesgQueue, gViMgrMesgBuffer, gViMgrEventDP,
// gViMgrEventSP, and gViMgrRetraceCounter in the VI manager system (7630.s)
gTextureScaleS = 0x80036704; // type:data texture scale S (u16)
gTextureScaleT = 0x80036706; // type:data texture scale T (u16)
gTextureTile = 0x80036708; // type:data current texture tile (s32)
gTextureFormat = 0x8003670C; // type:data texture format (G_IM_FMT_*)
// NOTE: 0x80036710 is __osEventStateTab (see Exception handler state section)
gTextureLodEnabled = 0x80036714; // type:data texture LOD enabled (s32)
gTextureWrapS = 0x80036718; // type:data S wrap mode (clamp/wrap/mirror)
gTextureWrapT = 0x8003671C; // type:data T wrap mode (clamp/wrap/mirror)

// Split Screen / Viewport (for multiplayer)
gSplitScreenMode = 0x80036720; // type:data split screen mode (0=off, 1=vert, 2=horiz, 3=4way)
gSplitScreenCount = 0x80036724; // type:data number of split screen panels (1-4)
gCurrentViewportIdx = 0x80036728; // type:data current viewport index being rendered (0-3)
gViewportRectX = 0x8003672C; // type:data current viewport X offset (s16)
gViewportRectY = 0x80036730; // type:data current viewport Y offset (s16)
gViewportRectW = 0x80036734; // type:data current viewport width (s16)
gViewportRectH = 0x80036738; // type:data current viewport height (s16)

// Object Rendering State (arcade: dis.h DynamicObjName)
gRenderObjectCount = 0x80036740; // type:data number of objects to render (s32)
gRenderObjectList = 0x80036744; // type:data pointer to render object list
gVisibleObjectCount = 0x80036748; // type:data visible objects after culling (s32)
gRenderPassIndex = 0x8003674C; // type:data current render pass (0=opaque, 1=translucent)
gSortedObjectList = 0x80036750; // type:data sorted object list for translucency

// Car Rendering (arcade: visuals.c - CarParts, gCarParts)
gCarPartsSlots = 0x80036760; // type:data car parts slots array (CarParts[12])
gCarBodyModels = 0x80037760; // type:data car body model IDs (s32[12])
gCarWheelModels = 0x80037790; // type:data car wheel model IDs (s32[12])
gWheelRotation = 0x800377C0; // type:data wheel rotation angles (f32[4] per car)
gWheelSteerAngle = 0x80037880; // type:data wheel steer angle (f32 per car)
gSuspensionOffset = 0x800378B0; // type:data suspension compression offset (f32[4] per car)

// HUD Rendering State (arcade: hud.c)
gHudEnabled = 0x80037900; // type:data HUD enabled flag (s32)
gHudBlitList = 0x80037904; // type:data HUD blit element list pointer
gHudBlitCount = 0x80037908; // type:data number of HUD elements (s32)
gSpeedometerValue = 0x8003790C; // type:data current speed display value (s16)
gTachometerValue = 0x80037910; // type:data current RPM display value (s16)
gLapDisplayValue = 0x80037914; // type:data current lap display (s8)
gLapTotalValue = 0x80037918; // type:data total laps display (s8)
gPositionDisplayValue = 0x8003791C; // type:data current race position display (s8)
gTimerDisplayValue = 0x80037920; // type:data race timer in msec (s32)
gWrongWayFlag = 0x80037924; // type:data wrong way indicator flag (s8)
gMinimapEnabled = 0x80037928; // type:data minimap visible flag (s32)
gMinimapCenterX = 0x8003792C; // type:data minimap center X (s16)
gMinimapCenterY = 0x80037930; // type:data minimap center Y (s16)

// Track Visual State
gTrackVisibleSegments = 0x80037940; // type:data visible track segment bitmask
gTrackLodLevel = 0x80037944; // type:data current track LOD level (s32)
gTrackTextureSet = 0x80037948; // type:data track texture set index (s32)
gTrackAmbientColor = 0x8003794C; // type:data track ambient lighting color (u32)
gTrackTimeOfDay = 0x80037950; // type:data time of day setting (0=day, 1=dusk, 2=night)
gTrackWeather = 0x80037954; // type:data weather setting (0=clear, 1=rain)

// Transformation Constants (for fixed-point matrix math)
gScaleFactorX = 0x80037960; // type:data X scale factor for screen (f32)
gScaleFactorY = 0x80037964; // type:data Y scale factor for screen (f32)
gTranslateX = 0x80037968; // type:data X translation offset (f32)
gTranslateY = 0x8003796C; // type:data Y translation offset (f32)
gScreenCenterX = 0x80037970; // type:data screen center X in pixels (s16)
gScreenCenterY = 0x80037974; // type:data screen center Y in pixels (s16)

// Render Statistics (debug)
gTrianglesRendered = 0x80037980; // type:data triangles rendered this frame (s32)
gVerticesTransformed = 0x80037984; // type:data vertices transformed this frame (s32)
gDisplayListCommands = 0x80037988; // type:data display list commands this frame (s32)
gTextureLoads = 0x8003798C; // type:data texture loads this frame (s32)
gCulledObjects = 0x80037990; // type:data objects culled by frustum (s32)

// Visual Effects Pool (arcade: visuals.c - gEnvirons, MAX_VISUALS=100)
gEffectsPoolBase = 0x80150000; // type:data visual effects pool base (Visual[100])
gEffectsPoolEnd = 0x80154000; // type:data visual effects pool end
gActiveEffectList = 0x80037994; // type:data active effects linked list head
gFreeEffectList = 0x80037998; // type:data free effects linked list head
gEffectFrameRate = 0x8003799C; // type:data effect quality (true=good framerate)

// Skid Mark Rendering (arcade: visuals.c - gSkid, SKID_OBJS=100)
gSkidMarkPoolBase = 0x80155000; // type:data skid mark pool base (Skid[100])
gSkidMarkActiveList = 0x800379A0; // type:data active skid list head
gSkidMarkFreeList = 0x800379A4; // type:data free skid list head
gSkidMarkTextureId = 0x800379A8; // type:data skid mark texture ID (TEX_SKID)

// Particle Systems
gParticlePoolBase = 0x80156000; // type:data particle pool base
gParticleActiveCount = 0x800379AC; // type:data active particle count
gSmokeEmitterList = 0x800379B0; // type:data smoke emitter list head
gSparkEmitterList = 0x800379B4; // type:data spark emitter list head
gDustEmitterList = 0x800379B8; // type:data dust emitter list head
gSplashEmitterList = 0x800379BC; // type:data water splash emitter list head

// Shadow System
gShadowEnabled = 0x800379C0; // type:data shadow rendering enabled (s32)
gShadowTextureId = 0x800379C4; // type:data shadow blur texture ID
gShadowIntensity = 0x800379C8; // type:data shadow opacity (0-255)
gShadowOffset = 0x800379CC; // type:data shadow Y offset from ground (f32)

// Reflection System (arcade: visuals.c - reflection textures)
gReflectionMode = 0x800379D0; // type:data reflection mode (0=off, 1=cloud, 2=tunnel)
gReflectionTexCloud = 0x800379D4; // type:data cloud reflection texture ID
gReflectionTexTunnel = 0x800379D8; // type:data tunnel reflection texture ID
gInTunnelState = 0x800379DC; // type:data in tunnel state (-1=exit, 0=hold, 1=enter)

// ============================================================================
// Additional Game State Variables (from game.c hardcoded addresses 2025-12-30)
// ============================================================================

// Object Manager Array (visual_objects_update iteration)
gObjectArrayStart = 0x80144D60; // type:data object manager array start (16-byte entries)
gObjectArrayEnd = 0x80144DA0; // type:data object manager array end

// Player Race State (set in race state machine case 6)
gPlayerRacePositionFlags = 0x8015418C; // type:data player race position flags (u8 per player)

// Race Control Flags
gRaceControlByte = 0x80142699; // type:data race control byte (set in state 7 restart)
gRaceResetFlag = 0x80157244; // type:data race reset flag (triggers race restart)

// ============================================================================
// Race Timing and Lap Tracking Variables (arcade: checkpoint.c, select.c)
// Cross-referenced from arcade source: play_time, start_time, number_checkpoints, etc.
// Added 2025-12-30 based on arcade checkpoint.c and game.c analysis
// ============================================================================

// Core Race Timer (arcade: play_time, start_time in select.c)
gPlayTime = 0x80142B04; // type:data play_time - time remaining to play in msec (u32, arcade: select.c:582)
gStartTime = 0x80142B08; // type:data start_time - IRQTIME when game started (u32, arcade: select.c:581)
gCountdownTimer = 0x80142B0C; // type:data countdown_timer - 3-2-1 countdown in frames (s32)
gCountdownTicks = 0x80142B10; // type:data countdown_ticks - countdown value for display (s32)

// Elapsed Time Functions (arcade: GetElapsedTime, GetCountdownTime)
gElapsedTime = 0x80142B14; // type:data elapsed race time in msec (u32)
gRaceTimeLimit = 0x80142B18; // type:data race_time_limit - max race time in msec (s32)

// Lap Timing (arcade: checkpoint.c - laptime, bestlap tracking)
gCurrentLapTime = 0x80142B1C; // type:data current_lap_time - current lap elapsed time (s32)
gBestLapTime = 0x80142B20; // type:data best_lap_time - best lap this race (s32)
gLastLapTime = 0x80142B24; // type:data last_lap_total - last completed lap time (s32)
gLapStartTime = 0x80142B28; // type:data lap start timestamp in msec (u32)

// Split Times (per-checkpoint timing)
gSplitTimeFrames = 0x80142B30; // type:data split_time_frames[4] - checkpoint split times array (s32[4])
gTimeExpiredFlag = 0x80142B40; // type:data time_expired_flag - race time expired (s32)

// Checkpoint System (arcade: checkpoint.c globals)
gNumberCheckpoints = 0x80142B44; // type:data number_checkpoints - total checkpoints on track (u32, arcade: checkpoint.c:284)
gLastCheckpointTime = 0x80142B48; // type:data last_checkpoint_time - time of last checkpoint hit (u32, arcade: checkpoint.c:284)
gGlobalLaps = 0x80142B4C; // type:data global_laps - global lap counter for time award (s16, arcade: checkpoint.c:301)
gGlobalLastCp = 0x80142B4E; // type:data global_last_cp - last checkpoint passed globally (s16, arcade: checkpoint.c:301)
gGlobalNextCp = 0x80142B50; // type:data global_next_cp - next checkpoint to reach (s16, arcade: checkpoint.c:301)
gLapLoopIndex = 0x80142B52; // type:data lap_loop_index - checkpoint index for lap loop (s16, arcade: checkpoint.c:302)

// Checkpoint Bonus Time (arcade: checkpoint.c - time_to_be_given, total_time_given)
gTimeToBeGiven = 0x80142B54; // type:data time_to_be_given - total bonus time allocated (u32, arcade: checkpoint.c:304)
gTotalTimeGiven = 0x80142B58; // type:data total_time_given - bonus time awarded so far (u32, arcade: checkpoint.c:304)
gTotalTimeBoxTime = 0x80142B5C; // type:data total_time_box_time - time from time boxes (u32, arcade: checkpoint.c:304)

// First Place Tracking (arcade: checkpoint.c)
gFirstPlaceTime = 0x80142B60; // type:data first_place_time - time when entered first (s32, arcade: checkpoint.c:288)
gInFirstPlace = 0x80142B64; // type:data in_first_place - currently in first place flag (s32, arcade: checkpoint.c:289)

// Race Start Frame (for timing sync)
gRaceStartFrame = 0x80142B68; // type:data race_start_frame - frame when race started (s32)

// Race State
gRacePhase = 0x80142B6C; // type:data race_phase - current race phase (s32: 0=pre, 1=countdown, 2=racing, 3=finished)
gRaceNumLaps = 0x80142B70; // type:data race_num_laps - total laps for this race (s32)
gNewBestLapFlag = 0x80142B74; // type:data new_best_lap_flag - set when new best lap achieved (s32)

// Per-Player Timing Arrays (arcade: checkpoint.c per-car tracking)
gPlayerLapCount = 0x80142B78; // type:data player_lap_count[4] - lap count per player (void*[4])
gPlayerCheckpoint = 0x80142B88; // type:data player_checkpoint[4] - current checkpoint per player (void*[4])
gPlayerRaceTime = 0x80142B98; // type:data player_race_time[4] - race time per player (void*[4])

// Game Over / Continue Countdown
gGameoverCountdown = 0x80142BA8; // type:data gameover_countdown - frames until game over screen (s32)
gContinueCountdown = 0x80142BAC; // type:data continue_countdown - continue countdown timer (s32)

// Track Par Times (arcade: track_cp_times_best, track_cp_times_par)
gTrackParTimes = 0x80142BB0; // type:data track_par_times[8] - par times per track (void*[8])
gTrackBestLap = 0x80142BD0; // type:data track_best_lap[8] - best lap times per track (u32[8])

// Finish Time Recording
gPlayerFinishTimes = 0x80142BF0; // type:data player_finish_times[4] - player finish times (s32[4])
gFinishTimeByPlace = 0x80142C00; // type:data finish_time_by_car[8] - finish times by position (u32[8])

// ============================================================================
// Additional Drone/AI Globals (arcade: drones.c, maxpath.c)
// ============================================================================

// Drone System Control
gUseCatchup = 0x80153000; // type:data catchup enabled flag (s32) - arcade: drones.c:gUseCatchup
gNumDrones = 0x80153004; // type:data number of drone cars (s16) - arcade: drones.c:num_drones
gNumHumans = 0x80153006; // type:data number of human players (s16) - arcade: drones.c:num_humans
gDroneDiff = 0x80153008; // type:data drone difficulty level 0-3 (s16) - arcade: drones.c:drone_diff
gDroneAbortTimer = 0x8015300C; // type:data frames since drone stuck (s32) - arcade: mpctl.interval_time
gOldDroneScale = 0x80153020; // type:data size:0x20 old drone scale for smoothing (f32[8]) - arcade: old_drone_scale[MAX_LINKS]
gOldBoost = 0x80153040; // type:data size:0x20 old boost for smoothing (f32[8]) - arcade: old_boost[MAX_LINKS]
gLastWheel = 0x80153060; // type:data size:0x20 last wheel input per car (s32[8]) - arcade: lastwheel[MAX_LINKS]
gLastBrake = 0x80153080; // type:data size:0x20 last brake input per car (s32[8]) - arcade: lastbrake[MAX_LINKS]
gLastThrottle = 0x801530A0; // type:data size:0x20 last throttle input per car (s32[8]) - arcade: lastthrottle[MAX_LINKS]

// Maxpath Path Data (arcade: maxpath.c globals)
gNumMPaths = 0x801530C0; // type:data number of active paths (s16) - arcade: num_mpaths
gMPathRecording = 0x801530C2; // type:data maxpath recording active (s16) - arcade: mprecording
gMPathIndex = 0x801530C4; // type:data current maxpath waypoint index (s16) - arcade: maxpath_index
gDroneDoneCount = 0x801530C6; // type:data drones finished count (s16) - arcade: drone_done_count
gCurrentDrone = 0x801530C8; // type:data current drone being updated (s16) - arcade: current_drone
gBestLoopTime = 0x801530CC; // type:data best lap time for maxpath (s32) - arcade: best_loop_time
gLoopStamp = 0x801530D0; // type:data lap start timestamp (s32) - arcade: loop_stamp
gLastMPathTime = 0x801530D4; // type:data last maxpath update time (s32) - arcade: last_mpath_time

// Maxpath Header/Data Pointers (arcade: maxpath.c)
gMaxPath = 0x801530E0; // type:data main maxpath header pointer (void*) - arcade: gMaxPath
gMPath = 0x801530E4; // type:data main maxpath waypoint array (void*) - arcade: mpath
gMPathNum = 0x801530E8; // type:data pointer to num_points (s32*) - arcade: mpathnum
gMPathHeaderTab = 0x801530F0; // type:data size:0x20 maxpath header table (void*[8]) - arcade: mpheader_tab[MAX_MPATHS]
gMPathTab = 0x80153110; // type:data size:0x20 maxpath waypoint tables (void*[8]) - arcade: mpath_tab[MAX_MPATHS]
gMPathActiveList = 0x80153130; // type:data size:0x10 active path indices (s16[8]) - arcade: mpaths[MAX_MPATHS]

// Maxpath Control State per-car (arcade: MPCTL mpctl[MAX_LINKS])
gMPCtl = 0x80153140; // type:data size:0x200 maxpath control array (MPCTL[8]) - arcade: mpctl[MAX_LINKS]
gWeightTable = 0x80153340; // type:data size:0x180 weight table per track/car (MPWEIGHT[4][8]) - arcade: weight_table[NTRACKS][MAX_LINKS]

// ============================================================================
// Math/Vector Function Mappings (arcade: math.c, fmath.c, vecmath.c)
// ============================================================================
// Reference source files:
//   - reference/repos/rushtherock/game/math.c - Fixed-point trig, rotation matrices, vectors
//   - reference/repos/rushtherock/LIB/fmath.c - Float matrix/vector ops, coordinate transforms
//   - reference/repos/rushtherock/game/vecmath.c - Vector utility functions
//   - reference/repos/rushtherock/game/unitvecs.c - Coordinate transform functions

// --- Fixed-Point Trigonometry (arcade: math.c) ---
// N64 likely uses libm sinf/cosf instead of fixed-point tables
// sinf = 0x80008730; // type:func - already defined, uses polynomial approximation
// cosf = 0x800088F0; // type:func - already defined, uses polynomial approximation
// sqrtf = 0x8000E3C0; // type:func - already defined

// --- Integer/Long Square Root (arcade: math.c:lsqrt) ---
// lsqrt = likely inlined or part of compressed game code
// FastDst = likely inlined, used for quick 2D distance approximation

// --- Vector Math Functions (arcade: math.c, fmath.c) ---
// Summary of arcade to N64 mappings:
//   scalmul() -> vector_copy_scale (0x8008B474)
//   SlowNormalVector() -> vector_normalize_length (0x8008B4C4)
//   bodtorw() -> vector3d_store_transform (0x8008B660)
//   rwtobod() -> drone_rwtobod (0x800A373C)

// --- Matrix Creation/Rotation (arcade: fmath.c) ---
// Summary of arcade to N64 mappings:
//   CreateRYPMatrix() -> matrix_rotation_build (0x8008D714)
//   CreatePYRMatrix() -> euler_to_matrix (0x8008D764)
//   ScaleUV() -> matrix_scale_apply (0x8008D8D8)
//   MulMat() -> camera_build_view_matrix (0x800C085C)

// --- Dot/Cross Products (arcade: math.c:DotProduct*, CrossProduct*) ---
// These are typically inlined in N64 code - see game.c:vec3_dot(), vec3_cross()
// DotProduct14/16/32 -> inlined in physics code
// CrossProduct14/16/32 -> inlined in physics code

// --- Coordinate Transform Constants (arcade: fmath.c) ---
gUnitUVS = 0x8002F680; // type:data unit identity 3x3 matrix (f32[3][3]) arcade:fmath.c:unituvs
gZeroVector = 0x8002F6A4; // type:data zero vector constant (f32[3]) arcade:fmath.c:zerovector
gUpVector = 0x8002F6B0; // type:data Y-up unit vector (f32[3]) arcade:fmath.c:uvector
gForwardVector = 0x8002F6BC; // type:data Z-forward unit vector (f32[3]) arcade:fmath.c:fvector

// --- Trigonometry Lookup Tables (arcade: math.c references trigtab.h) ---
// gSinCoeffs = 0x8002D750 - already defined, polynomial coeffs for sinf
// gCosCoeffs = 0x8002D7A0 - already defined, polynomial coeffs for cosf

// --- Rotation Functions (arcade: math.c:yaw/pitch/roll) ---
// YawUV() -> mtx_yaw in vecmath.c
// PitchUV() -> mtx_pitch in vecmath.c
// RollUV() -> mtx_roll in vecmath.c
// WYawUV/WPitchUV/WRollUV -> mtx_world_* in vecmath.c

// --- Euler Angle Extraction (arcade: math.c:GetEuler, GetEuler32) ---
// GetEuler() -> likely inlined in camera code
// ExtractRYP() -> used in camera_matrix_build

// ============================================================================
// Arcade money.c Function Equivalents
// Reference: rushtherock/game/money.c
// ============================================================================
// NOTE: N64 is a console game - no coin handling needed. The arcade money.c
// functions for credits/coins have no direct equivalent. However, N64 has
// equivalent functionality for:
// - Game session initialization (replaces init_credits)
// - Start button detection (replaces chk_start/EnoughCredit)
// - Continue prompt after game over (replaces ContinueMode/CanContinue)
// - Unlock/achievement system (replaces "free game" rewards)
//
// Arcade money.c functions:
//   init_credits() - Initialize coin/credit state, clear gFreeGame/gPlayingFree
//   get_credits()  - Handle coin drops, play sounds, update credit display
//   chk_start()    - Check if game should start (credits + start button)
//   EnoughCredit() - Return true if enough credits to play
//   ContinueMode() - Return true if in continue mode (continue_flag set)
//   CanContinue()  - Return true if player can continue with discounted credits

// --- N64 Equivalents for money.c ---

// Arcade init_credits() equivalent: N64 initializes game session state
// N64 doesn't need credit variables, but initializes similar session flags.
// See: game_init (0x80002238), attract_reset, session state initialization
session_flags_init = 0x800C9BE0; // type:func arcade:money.c:init_credits N64 session/flags initialization (init_state_begin)

// Arcade chk_start() equivalent: N64 checks Start button in attract mode
// Arcade checks credits + start button; N64 just checks Start button.
// The attract mode handler checks for input to exit attract and start game.
start_button_check = 0x800DCD94; // type:func arcade:money.c:chk_start N64 start/input check (attract_idle_check)

// Arcade EnoughCredit() equivalent: N64 always returns true (console)
// N64 has no credits - any player can always start a game.
// The unlock system gates content instead of credits gating play.
// See: car_unlock_check (0x800D197C), track_unlock_check (0x800D138C)

// Arcade ContinueMode()/CanContinue() equivalent: N64 continue prompt
// Arcade offers continue with discounted credits after game over.
// N64 offers continue/quit choice after race (no credit cost).
// continue_prompt = 0x800DB758 already defined above (line ~1841)
// continue_prompt = 0x801033D8 already defined above (line ~1096)

// Arcade gFreeGame/gPlayingFree equivalent: N64 unlock system
// Arcade awards "free game" for winning. N64 unlocks cars/tracks/modes.
// gUnlockFlags = 0x80159000 already defined above (line ~2068)

// --- Continue/Game Over State Variables ---
// These replace arcade's credit-based continue system
// gGameoverCountdown = 0x80142BA8 already defined above (line ~2834)
// gContinueCountdown = 0x80142BAC already defined above (line ~2835)

// Session start handler - called when transitioning from attract to game
session_start_handler = 0x800EDDC0; // type:func arcade:money.c:chk_start->true game start transition (attract_or_transition)

// Game mode unlock handler - replaces arcade's free game reward
mode_unlock_handler = 0x80105858; // type:func arcade:money.c:gFreeGame reward unlock check (achievements_check)
unlock_reward_show = 0x80105EF4; // type:func arcade:money.c:gFreeGame display unlock notification (achievement_unlock)

// ============================================================================
// Tournament/Championship Mode (arcade: tourney.c mappings)
// ============================================================================
// NOTE: Arcade tourney.c is for linked cabinet tournaments (up to 8 cabinets
// over network). N64 uses local split-screen multiplayer instead.
// The following maps conceptually similar N64 functions to arcade tourney.c.

// Tournament/Championship State Machine
// arcade:tourney.c:InitTourney -> N64 championship init (conceptual)
tournament_init = 0x800DC100; // type:func arcade:tourney.c:InitTourney - init tournament state

// arcade:tourney.c:LoadTourneySettings/SaveTourneySettings -> N64 Controller Pak save/load
// These handle tournament configuration persistence
tournament_save_settings = 0x800DE20C; // type:func arcade:tourney.c:SaveTourneySettings - save tournament config to Controller Pak
tournament_load_settings = 0x800DE4DC; // type:func arcade:tourney.c:LoadTourneySettings - load tournament config from Controller Pak

// arcade:tourney.c:TourneyOn -> N64 check if championship mode active
tournament_is_active = 0x800DC200; // type:func arcade:tourney.c:TourneyOn - check if tournament mode active

// arcade:tourney.c:ParseTourneyFlags -> N64 parse tournament options flags
// Decodes tournament settings from packed flags format
tournament_parse_flags = 0x800DC220; // type:func arcade:tourney.c:ParseTourneyFlags - parse tournament option flags

// Championship Results and Standings (arcade: tourney scoring equivalent)
// arcade:tourney.c:HandleTourneySetup menu equivalent
tournament_standings_display = 0x800DC248; // type:func arcade:tourney.c - championship standings display (432 bytes)
tournament_trophy_award = 0x800DC3F8; // type:func arcade:tourney.c - award championship trophy (924 bytes)
tournament_points_calc = 0x800DA2D0; // type:func arcade:tourney.c - calculate tournament points (2316 bytes)

// Unlock System (tournament progression rewards)
tournament_unlock_check = 0x800DC794; // type:func arcade:tourney.c unlock progression - show unlock notification (248 bytes)

// Tournament Data Globals
gTournamentState = 0x80159300; // type:data tournament state struct (Tourney) - arcade: gTourney
gTournamentActive = 0x80159304; // type:data tournament active flag (s32) - arcade: tourney.cabinets
gTournamentRaces = 0x80159308; // type:data tournament race count (s32)
gTournamentCurrentRace = 0x8015930C; // type:data current race in tournament (s32)
gTournamentPoints = 0x80159310; // type:data size:0x10 tournament points per player (s32[4])
gTournamentStandings = 0x80159320; // type:data size:0x10 tournament standings per player (s32[4])

// Circuit/Championship Definitions (arcade: Tourney struct fields)
gCircuitTrackList = 0x80159340; // type:data size:0x20 circuit track order (s32[8]) - arcade: tourney.track
gCircuitLaps = 0x80159360; // type:data size:0x20 laps per circuit race (s32[8]) - arcade: TourneyLaps
gCircuitDifficulty = 0x80159380; // type:data circuit AI difficulty (s32) - arcade: drone_diff in tourney context

// Points Award Tables (arcade: standard racing points)
gPointsTableStandard = 0x80159390; // type:data size:0x20 standard points table 10,8,6,5,4,3,2,1 (s32[8])
gPointsTableF1 = 0x801593B0; // type:data size:0x28 F1-style points 25,18,15,12,10,8,6,4,2,1 (s32[10])

// Tournament Join/Settings (arcade: ext_start, free play equivalents)
// NOTE: Arcade-specific cabinet linking not applicable to N64
gTournamentFreePlay = 0x801593D8; // type:data free play mode flag (s32) - arcade: tourney.free
gTournamentJoinMode = 0x801593DC; // type:data join mode 0=any, 1=timed (s32) - arcade: tourney.ext_start

// Car/Track Restrictions (arcade: tourney.car, tourney.track, tourney.tranny)
gTournamentCarRestrict = 0x801593E0; // type:data car restriction -1=any (s32) - arcade: tourney.car
gTournamentTrackRestrict = 0x801593E4; // type:data track restriction -1=any (s32) - arcade: tourney.track
gTournamentTransRestrict = 0x801593E8; // type:data transmission -1=any, 0=manual, 1=auto (s32) - arcade: tourney.tranny

// Drone/Catchup Settings (arcade: tourney.drones, tourney.catchup)
gTournamentDronesEnabled = 0x801593EC; // type:data drones enabled -1=normal, 0=off, 1=on (s32) - arcade: tourney.drones
gTournamentCatchupEnabled = 0x801593F0; // type:data catchup enabled -1=normal, 0=off, 1=on (s32) - arcade: tourney.catchup

// ============================================================================
// Arcade-Specific Tournament Functions (No Direct N64 Equivalent)
// ============================================================================
// These arcade functions handle linked cabinet network features:
// - tourney.c:TourneyNode() - check cabinet node status (arcade network)
// - tourney.c:ResetTourneyStatus() - reset cabinet status (arcade network)
// - tourney.c:CheckTourneyBox() - external switch box for tournaments (arcade hardware)
// - tourney.c:ShowTourneySetup() - linked cabinet setup screen (arcade)
// - tourney.c:HandleTourneySetup() - menu navigation for cabinet linking (arcade)
// - tourney.c:HandleLights() - arcade cabinet light control
// - tourney.c:AnimateMenu/AnimateTXxx() - arcade menu UI animations (BLIT system)
// - tourney.c:BadTourneyData() - NVRAM validation (arcade uses BRAM, N64 uses EEPROM/CPak)

// ============================================================================
// Car Sound Functions (arcade: carsnd.c)
// Cross-referenced with reference/repos/rushtherock/game/carsnd.c
// Added 2025-12-31 for Rush 2049 decompilation project
// ============================================================================

// --- Engine Sound Control ---
// arcade: StartEngineSound() [carsnd.c:887-901] - starts engine sound loop
engine_sound_start = 0x800B2D80; // type:func arcade:carsnd.c:StartEngineSound start engine sound for car (120 bytes)
// arcade: DoEngineSound() [carsnd.c:905-962] - updates engine pitch/volume from RPM
// Already mapped: engine_sound_update = 0x800B2DF8 (see Audio System Functions section)
// arcade: StopEngineSound() [carsnd.c:965-968] - stops engine sound
engine_sound_stop = 0x800B3340; // type:func arcade:carsnd.c:StopEngineSound stop engine sound (76 bytes)
// arcade: DoIntCarSounds() [carsnd.c:296-299] - high priority car sounds (calls DoEngineSound)
car_sounds_interrupt = 0x800B2D60; // type:func arcade:carsnd.c:DoIntCarSounds high-priority car sounds wrapper (32 bytes)

// --- Tire Squeal/Skid Sounds ---
// arcade: DoTireSqueals() [carsnd.c:974-1190] - tire squeal based on slip/force
// Already mapped: tire_sound_update = 0x800B338C (see Audio System Functions section)
// arcade: init_skids() [carsnd.c:1196-1217] - initialize/clear skid sound state
skid_sounds_init = 0x800B3700; // type:func arcade:carsnd.c:init_skids initialize skid sounds for car (16 bytes)

// --- Wind/Road Noise ---
// arcade: DoCarSounds() [carsnd.c:303-422] - updates wind, road, gravel, water sounds
// Already mapped: wind_sound_update = 0x800B3710 (see Audio System Functions section)
// arcade: InitCarSnds() [carsnd.c:257-275] - initialize all car sound states for player
car_sounds_init = 0x800B2C40; // type:func arcade:carsnd.c:InitCarSnds initialize car sounds for player (224 bytes)
// arcade: InitSndState() [carsnd.c:248-254] - zero out snd_state struct
sound_state_init = 0x800B2C20; // type:func arcade:carsnd.c:InitSndState initialize sound state struct (32 bytes)

// --- Collision/Bump Sounds ---
// arcade: do_bump_sounds() [carsnd.c:430-638] - collision bump/scrape sounds
// Already mapped: collision_sound_play = 0x800B362C (see Audio System Functions section)
// arcade: init_bump_sounds() [carsnd.c:281-291] - initialize bump sound states
bump_sounds_init = 0x800B35A0; // type:func arcade:carsnd.c:init_bump_sounds initialize bump collision sounds (140 bytes)
// arcade: init_bump() [carsnd.c:720-725] - initialize single bump state slot
bump_state_init = 0x800B3598; // type:func arcade:carsnd.c:init_bump initialize bump state by index (8 bytes)
// arcade: check_forces_on_car() [carsnd.c:646-662] - check collision forces on car corners
collision_force_check = 0x800B34C0; // type:func arcade:carsnd.c:check_forces_on_car check collision forces (204 bytes)
// arcade: get_force_and_peak() [carsnd.c:671-713] - get force vector and peak detection
collision_peak_detect = 0x800B3590; // type:func arcade:carsnd.c:get_force_and_peak force peak detection (8 bytes)
// arcade: kill_scrape_sound() [carsnd.c:731-738] - stop scraping sound
scrape_sound_stop = 0x800B3620; // type:func arcade:carsnd.c:kill_scrape_sound stop scrape sound (12 bytes)

// --- Target/Object Collision Sounds ---
// arcade: target_sound() [carsnd.c:772-872] - play sound when hitting targets (cones, trees, etc)
target_sound_play = 0x800B3A40; // type:func arcade:carsnd.c:target_sound target collision sound (380 bytes)
// arcade: target_inside_box() [carsnd.c:748-762] - check if target inside car bbox
target_in_car_check = 0x800B3A00; // type:func arcade:carsnd.c:target_inside_box target-car collision test (64 bytes)

// --- Reverb/Environment Sounds ---
// arcade: init_reverb() [carsnd.c:1235-1248] - initialize reverb parameters
// Already mapped: reverb_setup = 0x800B4B94 (see Audio System Functions section)
// arcade: handle_reverb() [carsnd.c:1254-1308] - update reverb based on tunnel proximity
reverb_update = 0x800B4C80; // type:func arcade:carsnd.c:handle_reverb update reverb from environment (240 bytes)

// --- Radio/Music Control ---
// arcade: StartRadio() [carsnd.c:1226-1228] - start radio music
radio_start = 0x800B1BC0; // type:func arcade:carsnd.c:StartRadio start radio/music by station (72 bytes)
// arcade: StopRadio() [carsnd.c:1220-1223] - stop radio music
radio_stop = 0x800B1B90; // type:func arcade:carsnd.c:StopRadio stop radio/music (48 bytes)

// ============================================================================
// Car Sound Data Variables (arcade: carsnd.c global variables)
// ============================================================================

// Sound state structures (arcade: snd_state rdnoise_state, wind_state, scrch_state)
gRoadNoiseState = 0x80150C20; // type:data arcade:carsnd.c:rdnoise_state road noise sound state (snd_state 8 bytes)
gWindNoiseState = 0x80150C28; // type:data arcade:carsnd.c:wind_state wind noise sound state (snd_state 8 bytes)
gTireSquealState = 0x80150C30; // type:data arcade:carsnd.c:scrch_state[MAX_LINKS][4] tire squeal states (snd_state[8][4] = 256 bytes)

// Bump collision state (arcade: bump_state car_bump[5])
gCarBumpState = 0x80150D30; // type:data arcade:carsnd.c:car_bump[5] bump collision state array (bump_state 24 bytes * 5 = 120 bytes)
gScrapeState = 0x80150DA8; // type:data arcade:carsnd.c:scrape_state current scrape sound state (s16)
gScrapeTime = 0x80150DAC; // type:data arcade:carsnd.c:scrape_time scrape sound timestamp (s32)
gBumpTime = 0x80150DB0; // type:data arcade:carsnd.c:bump_time bump sound timestamp (s32)

// Skid/smoke intensity (arcade: skid_intensity, smoke_intensity)
gSkidIntensity = 0x80150DC0; // type:data arcade:carsnd.c:skid_intensity[MAX_LINKS][4][2] skid mark intensity (s16[8][4][2] = 128 bytes)
gSmokeIntensity = 0x80150E40; // type:data arcade:carsnd.c:smoke_intensity[MAX_LINKS][4][2] smoke intensity (s16[8][4][2] = 128 bytes)

// Engine sound tuning (arcade: rpm_fix, torque_fix, dbg* variables)
gRpmFix = 0x80150EC0; // type:data arcade:carsnd.c:rpm_fix RPM scaling factor (f32)
gTorqueFix = 0x80150EC4; // type:data arcade:carsnd.c:torque_fix torque scaling factor (f32)

// ============================================================================
// Car Sound Constants (arcade: carsnd.h defines)
// ============================================================================
// WIND_PITCH = 0x400
// WIND_MAX_VOL = 0x0150
// ROAD_MAX_PITCH = 0x03ff
// ROAD_MIN_PITCH = 0x0100
// ROAD_MAX_VOL = 0x0380
// GRAVEL_MAX_VOL = 0x00A0
// MAX_ENG_RPM_SCL = 0x1E00
// VOL_FADE_VAL = 0x0020

// ============================================================================
// Force Feedback / Steering Wheel Mapping (arcade: fswheel.c)
// ============================================================================
// NOTE: Arcade fswheel.c handles force feedback steering wheel.
// N64 uses Rumble Pak (osMotor*) + analog stick for equivalent functionality.
// The arcade wheel force feedback maps to N64 rumble patterns.
//
// Key mappings:
//   fswheel.c:InitSW() -> N64 osMotorInit() + rumble state init
//   fswheel.c:wheelpos() -> N64 Input_GetStickX() (analog stick)
//   fswheel.c:setswforce() -> N64 rumble intensity via osMotorStart/Stop
//   fswheel.c:ModelSteerForce() -> N64 gameplay rumble patterns
//   fswheel.c:OverrideForce() -> N64 menu selection rumble
//   fswheel.c:WheelSection() -> N64 menu selection from stick position

// Steering/Force Feedback State Variables (arcade: fswheel.c globals)
// These map arcade steering wheel state to N64 analog stick + rumble
gSWpos = 0x80140DA0; // type:data steering wheel position (s16) - arcade:fswheel.c:gSWpos N64: analog stick X
gSWforce = 0x80140DA2; // type:data steering wheel force (s16) - arcade:fswheel.c:gSWforce N64: rumble intensity
gSWtorque = 0x80140DA4; // type:data steering wheel torque (s16) - arcade:fswheel.c:gSWtorque N64: collision rumble
gSWfrict = 0x80140DA6; // type:data steering wheel friction (s16) - arcade:fswheel.c:gSWfrict N64: surface rumble
gSWdamp = 0x80140DA8; // type:data steering wheel damping (s16) - arcade:fswheel.c:gSWdamp N64: smoothing
gSWvel = 0x80140DAA; // type:data steering wheel velocity (s16) - arcade:fswheel.c:swvel N64: stick delta

// Force Feedback Rumble State (N64-specific replacements for fswheel.c)
rumble_state = 0x80142A20; // type:data rumble state machine (s32) - arcade:fswheel.c force state
rumble_timer = 0x80142A24; // type:data rumble duration counter (s32) - arcade:fswheel.c force duration
rumble_intensity = 0x80142A28; // type:data rumble intensity 0-127 (s32) - arcade:fswheel.c:last_swforce
rumble_pattern = 0x80142A2C; // type:data rumble pattern index (s32) - arcade:fswheel.c notch patterns
motor_vibe_state = 0x80142A30; // type:data motor vibration state (s32) - arcade:fswheel.c:doing_notch
motor_pak_handles = 0x80142A40; // type:data size:0x10 motor pak handle array (void*[4]) - per-controller rumble pak

// Force Feedback Configuration (arcade: fswheel.c:force_frac table)
gFeedbackLevel = 0x80140DB0; // type:data force feedback level 0-2 (s16) - arcade:fswheel.c:gFeedbackLevel
gForceOffset = 0x80140DB2; // type:data force offset 0-2 (s16) - arcade:fswheel.c:gForceOffset
gFscale = 0x80140DB4; // type:data force scale percent (s16) - arcade:fswheel.c:gFscale
recenter_flag = 0x80140DB6; // type:data wheel recenter active (s16) - arcade:fswheel.c:recenter_flag

// Analog Input Velocity Tracking (arcade: fswheel.c wheel velocity)
rawswvel = 0x80140DC0; // type:data raw steering velocity (s16) - arcade:fswheel.c:rawswvel
avg_sw_vel = 0x80140DC4; // type:data average steering velocity (s32) - arcade:fswheel.c:avg_sw_vel
avg_sw_force = 0x80140DC8; // type:data average steering force (u32) - arcade:fswheel.c:avg_sw_force
playpos = 0x80140DCC; // type:data play-adjusted position (s16) - arcade:fswheel.c:playpos

// Menu Selection State (arcade: fswheel.c:WheelSection/OverrideForce)
prev_notch = 0x80140DD0; // type:data previous menu notch (s32) - arcade:fswheel.c:prev_notch
doing_notch = 0x80140DD4; // type:data notch transition active (s16) - arcade:fswheel.c:doing_notch
last_notch = 0x80140DD8; // type:data last notch position (s32) - arcade:fswheel.c:last_notch

// Functions (N64 equivalents to arcade fswheel.c functions)
// NOTE: N64 replaces arcade force feedback with Rumble Pak patterns

// osMotorInit (0x80009F20) - arcade:fswheel.c:InitSW() equivalent
// Initialize rumble pak, set initial state (already defined above)

// osMotorStart (0x8000A194) - arcade:fswheel.c:setswforce(force>0)
// Turn on rumble motor (already defined above)

// osMotorStop (0x8000A2F0) - arcade:fswheel.c:setswforce(force=0) / freewheel()
// Turn off rumble motor (already defined above)

// N64 rumble pattern functions (equivalents to arcade force feedback)
// input_rumble_update = 0x800E7800 - arcade:fswheel.c:ModelSteerForce - N64 gameplay rumble (defined above)
// menu_vibration_test = 0x800CFE74 - arcade:fswheel.c:OverrideForce - N64 menu rumble test (defined above)
// controller_rumble_thunk = 0x8008AA20 - arcade:fswheel.c:doforcewheel - N64 rumble dispatch (defined above)

// Steering input functions (N64 analog stick replaces arcade wheel)
steering_apply = 0x8010C6D0; // type:func arcade:fswheel.c:wheelpos N64 steering angle from stick (292 bytes)
car_steering_response = 0x800A6100; // type:func arcade:fswheel.c:PotWheelPos N64 car steering response (580 bytes)

// Collision/impact rumble (arcade: crash -> force spike on wheel)
collision_rumble_trigger = 0x800E6450; // type:func arcade:fswheel.c:crash_force N64 collision rumble trigger
landing_rumble_trigger = 0x800E6480; // type:func arcade:fswheel.c:landing_force N64 landing rumble trigger

// High score entry wheel section (arcade: WheelSection for character select)
hiscore_input_analog = 0x800FBB00; // type:func arcade:fswheel.c:WheelSection N64 hiscore analog selection

// ============================================================================
// Arcade PDU (Protocol Data Unit) Mappings (arcade: pdu.c, dis.h)
// ============================================================================
// The arcade Rush The Rock used DIS (Distributed Interactive Simulation) 
// protocol for linked cabinet multiplayer. N64 lacks networking hardware,
// so equivalent functionality uses local memory sharing and OSMessage queues.
//
// PDU Types (arcade dis.h kXXXPDU enum):
//   kEntityStatePDU      - Car state (pos, vel, rot, appearance) - N64: net_state_sync
//   kAcknowledgePDU      - Ack/Nack response - N64: net_player_join_handler  
//   kEventReportPDU      - Events (checkpoint, lap, score) - N64: net_game_state_send
//   kEntityAppearancePDU - Visual/audio appearance - N64: entity_state_dispatch
//   kMessagePDU          - General messages - N64: net_message_recv
//
// EntityStatePDU Fields (arcade pdu.c) -> N64 car state struct:
//   velocity[3]    -> car+0x34 (f32[3])
//   location[3]    -> car+0x24 (f32[3])  
//   accel[3]       -> car+0x44 (f32[3])
//   angularV[3]    -> car+0x54 (f32[3])
//   quat[4]        -> car+0x60 (f32[4]) - quaternion rotation
//   checkpoint     -> car+0x1CC (s16)
//   lap            -> car+0x1CE (s16)
//   tireV[4]       -> car+0x180 (f32[4]) - tire angular velocity
//   suscomp[4]     -> car+0x190 (f32[4]) - suspension compression
//   shadow_h[4]    -> car+0x1A0 (f32[4]) - shadow height per wheel
//   torque         -> car+0x1B0 (f32)
//   rpm            -> car+0x1B4 (f32)
//   steerangle     -> car+0x1B8 (f32)
//   appearance     -> car+0x1BC (u32) - bitfield
//   timeStamp      -> gElapsedTime (0x80142B14)
//
// EventReportItem Fields (arcade pdu.c EventReportItem enum):
//   Report_Node        -> gNodeNumber (player slot)
//   Report_Track       -> gCurrentTrack
//   Report_Channel     -> gNumPlayers
//   Report_CarType     -> gPlayerCarType
//   Report_RaceFlags   -> gRaceFlags
//   Report_Count       -> gCountdownTimer
//   Report_Score       -> gPlayerRaceTime
//   Report_CheckPoint  -> gPlayerCheckpoint
//   Report_Lap         -> gPlayerLapCount
//   Report_Difficulty  -> gDroneDiff
//   Report_NumberLaps  -> gRaceNumLaps

// PDU-equivalent data structures (N64 local multiplayer state)
gPlayerEntityState = 0x80152818; // type:data arcade:pdu.c:EntityStatePDU equivalent - per-player car state array (stride 0x400)
gEntityStateBuffer = 0x80164000; // type:data arcade:pdu.c send buffer - serialized entity state for sync (4KB)
gEntityRecvBuffer = 0x80165000; // type:data arcade:pdu.c recv buffer - received entity state (4KB)
gNetSendHead = 0x80163FF0; // type:data arcade:pdu.c - send buffer head pointer (s32)
gNetSendTail = 0x80163FF4; // type:data arcade:pdu.c - send buffer tail pointer (s32)
gNetSendSize = 0x80163FF8; // type:data arcade:pdu.c - send buffer current size (s32)
gNetRecvHead = 0x80164FF0; // type:data arcade:pdu.c - recv buffer head pointer (s32)
gNetRecvTail = 0x80164FF4; // type:data arcade:pdu.c - recv buffer tail pointer (s32)
gNetRecvSize = 0x80164FF8; // type:data arcade:pdu.c - recv buffer current size (s32)

// PDU Event Report equivalents
gEventReportType = 0x80166010; // type:data arcade:pdu.c:EventTypeID - current event type (s32)
gEventReportItems = 0x80166014; // type:data arcade:pdu.c:PDUDataItem - event data items array
gEventReportCount = 0x80166080; // type:data arcade:pdu.c:numFixedRecs - number of event items (s32)

// PDU timing (arcade: GetTimeStamp, GetElapsedTime)
// gElapsedTime = 0x80142B14 // defined above in timing section
gNetTimeStamp = 0x80166090; // type:data arcade:pdu.c:GetTimeStamp - last sync timestamp (u32)
gNetTimeFudge = 0x80166094; // type:data arcade:pdu.c:timeFudge - dead reckoning time adjustment (f32)

// PDU error tracking (arcade: ReportPDUError, totalErrors)
gPDUErrorCount = 0x801660A0; // type:data arcade:pdu.c:totalErrors - total PDU/sync errors (u32)
gPDULastError = 0x801660A4; // type:data arcade:pdu.c error code - last error type (s16)

// ============================================================================
// Game Statistics System (arcade: stats.c mappings)
// Cross-referenced with reference/repos/rushtherock/game/stats.c
// Added 2025-12-31 based on arcade-N64 function comparison
// Note: N64 console version uses simplified stats vs arcade operator stats
// Arcade stats.c focuses on operator statistics (NVRAM, coins, time-of-day).
// N64 version tracks race times, lap records, and player profile stats.
// ============================================================================

// --- Statistics Functions (arcade: stats.c) ---
// N64 equivalents for race time/lap tracking and record keeping

// Race Time Tracking (arcade: stats.c:stat_playgame, stat_endgame, stat_preplay)
// Arcade stat_preplay(): initializes curstat timing for new race
// Arcade stat_playgame(): updates curstat.play_time each frame
// Arcade stat_endgame(): records final race time, updates track records
// N64 equivalent: game timer system tracks race/lap times
stat_race_start = 0x800FE08C; // type:func arcade:stats.c:stat_preplay race timing init (same as game_timer_start)
stat_race_update = 0x800FE5B0; // type:func arcade:stats.c:stat_playgame per-frame time update (same as game_timer_elapsed)
stat_race_end = 0x800FE4BC; // type:func arcade:stats.c:stat_endgame race completion (same as game_timer_stop)

// Lap Time Recording (arcade: stats.c:update_total_game_time, update_track_time)
// Arcade update_track_time(): checks if lap is new record, updates NVRAM
// N64 equivalent: lap timer system with Controller Pak save
stat_lap_complete = 0x800FE924; // type:func arcade:stats.c:lap_complete lap time recording (same as game_timer_lap)
stat_lap_split = 0x800FEA08; // type:func arcade:stats.c:stat_playgame checkpoint split (same as game_timer_split)
stat_best_lap_check = 0x80101700; // type:func arcade:stats.c:update_track_time check vs best lap (same as best_time_check)
stat_best_lap_save = 0x8010194C; // type:func arcade:stats.c:update_track_time save new best (same as best_time_record)

// Win/Loss and Position Records (arcade: stats.c:stat_endgame)
// Arcade tracks wins in curstat.win_count, total_races in curstat.game_count
// N64 equivalent: profile update saves finish position
stat_finish_position = 0x800DA0CC; // type:func arcade:stats.c:stat_endgame finish position record (same as position_result_display)
stat_results_display = 0x800D9060; // type:func arcade:stats.c:stat_endgame results screen (same as results_screen)
stat_profile_update = 0x801068F4; // type:func arcade:stats.c:update_total_game_time profile stats (same as profile_stats_update)

// Speed Records (arcade: stats.c:update_track_time for time records)
// Arcade compares against track_times[track].best_lap/best_race
// N64 uses similar comparison against gTrackBestLap
stat_speed_record_check = 0x80101700; // type:func arcade:stats.c speed record comparison (reuses best_time_check logic)

// Statistics Display (arcade: stats.c:UpdateStats for operator test menu)
// Arcade UpdateStats(): displays coin counts, time-of-day histograms (operator use)
// N64 equivalent: player-facing statistics screen in profile menu
stat_display_screen = 0x80104E84; // type:func arcade:stats.c:UpdateStats equivalent (same as statistics_display)
stat_records_screen = 0x800D58CC; // type:func arcade:stats.c records display (same as records_screen)
stat_best_times_show = 0x800D5BB0; // type:func arcade:stats.c best times display (same as best_times_display)

// Per-Game Statistics Update (arcade: stats.c curstat structure management)
// Arcade: stat_attract(), stat_trksel(), stat_carsel(), stat_playgame(), stat_endgame()
// These state-specific functions track time spent in each game state.
// N64 uses simpler per-race tracking with single update function
stat_game_update = 0x800DC99C; // type:func arcade:stats.c:stat_* per-state update (same as stats_update)

// --- Statistics Data Globals (arcade: stats.c global variables) ---
// N64 equivalents for race/lap timing globals
// Note: Arcade uses NVRAM for persistence, N64 uses Controller Pak

// Race Timing State (arcade: stats.c:curstat members)
// Arcade curstat: race_time, play_time, lap_time, game_count, win_count
gStatRaceTime = 0x80142B08; // type:data arcade:stats.c:curstat.race_time current race time (s32)
gStatLapTime = 0x80142B24; // type:data arcade:stats.c:curstat.lap_time current lap time (s32)
gStatBestLap = 0x80142BD0; // type:data arcade:stats.c:curstat.best_lap best lap per track (u32[8])
gStatTotalRaces = 0x80159000; // type:data arcade:stats.c:total_games total races played counter
gStatTotalWins = 0x80159004; // type:data arcade:stats.c:total_wins total first place finishes
gStatPlayTime = 0x80142B04; // type:data arcade:stats.c:curstat.play_time total play time (same as gPlayTime)

// Per-Track Best Times (arcade: stats.c:track_times array)
// Arcade: track_times[NUM_TRACKS].best_lap, best_race, race_count
gStatTrackBest = 0x80159100; // type:data arcade:stats.c:track_times best times per track (same as gBestTimes)
